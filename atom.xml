<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ixout&#39;s blog</title>
  
  
  <link href="https://ixout.github.io/atom.xml" rel="self"/>
  
  <link href="https://ixout.github.io/"/>
  <updated>2023-03-18T04:50:40.069Z</updated>
  <id>https://ixout.github.io/</id>
  
  <author>
    <name>ixout</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>堆学习笔记</title>
    <link href="https://ixout.github.io/posts/8932/"/>
    <id>https://ixout.github.io/posts/8932/</id>
    <published>2023-03-02T14:31:03.000Z</published>
    <updated>2023-03-18T04:50:40.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>堆的学习可以说是一道坎了，要掌握的话对源码阅读及理解的能力要求挺高，初学时往往被搞得晕头转向，这里就记录一下我的学习记录，基础的东西到处都有就不记了，主要还是记一些我认为比较重要或者容易被忽略的细节。</p><hr><h1 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>基础的东西网上能搜到的教程(像ctfwiki,狼组安全,ctf-all-in-one等)讲的已经很细了，认真看一定能有一个基础的知识框架.不过还是推荐看一看华庭大佬的<a href="https://pan.baidu.com/s/167Z3CHDEeP1dl3c2Ii0lXg?pwd=1234">glibc内存管理-ptmalloc2源码分析</a>(很细很全很直白),看了之后真的能有很多收获.</p><h2 id="理清从属关系"><a href="#理清从属关系" class="headerlink" title="理清从属关系"></a>理清从属关系</h2><p>初学时,heap,arena,chunk这些东西很容易把人搞糊涂,这里简单梳理一下</p><p>系统中整个堆功能的实现区域都可以被叫做堆(heap),但其实但heap还有一个相对这个整个堆区域要更小的概念,如下:</p><p>glibc的malloc源码中涉及三种最重要数据结构：<strong>Arena、Heap、Chunk</strong> ，分别对应结构体<strong>malloc_state、heap_info、malloc_chunk 。</strong>每个数据结构都有对应的结构体实现,如图:</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-16_095156.png" alt=""></p><ul><li><strong>Thread - Arena</strong> ： 一个Arena对应多个线程Thread。即每个线程都有一个Arena，但是有可能多个线程共用一个Arena(同一时间只能一对一)。每个Arena都包含一个malloc_state结构体，保存bins, top chunk, Last reminder chunk等信息。</li><li><strong>Arena - Heap</strong>：一个Arena可能拥有多个heap。Arena开始的时候只有一个heap，但是当这个heap的空间用尽时，就需要获取新的heap。(也可以理解为subheap子堆)</li><li><strong>Heap - Chunk</strong>：一个Heap根据用户的请求会划分为多个chunk，每个chunk拥有自己的header - malloc_chunk。</li></ul><p>需要注意的是，<em>Main Arena只有一个heap，因此没有heap_info结构</em>。当main arena用尽空间后，会扩展当前的heap空间。此外，Main Arean的Arena header并不是heap segment的一部分，而作为全局变量储存在libc.so的数据段中。</p><p>下图是只有一个heap时，主线程和线程的堆结构示意图，左图是Main Arena，右图是Threa Arena。堆是从低地址向高地址增长的，可以看到每一个malloc_chunk上面都跟着一个chunk。同时Main Arena没有heap_info和malloc_state的结构。 </p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-16_095630.png" alt=""></p><p>下图是存在多个heap的thread Arena的情况。可以看到每一个heap都一个heap header（heap_info），但是只有最初的heap拥有arena header(malloc_state).</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-16_095644.png" alt="graph"></p><p>当线程申请内存时，就创建一个Arena。主线程有自己独立的Arena，叫做main arena，但不是每一个线程都有独立的Arena。</p><p>Arena的个数取决于cpu核的个数</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-17_204838.png" alt=""></p><h2 id="三个重要结构体的定义"><a href="#三个重要结构体的定义" class="headerlink" title="三个重要结构体的定义"></a>三个重要结构体的定义</h2><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="type">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure><h2 id="malloc和free的流程"><a href="#malloc和free的流程" class="headerlink" title="malloc和free的流程"></a>malloc和free的流程</h2><h3 id="malloc流程"><a href="#malloc流程" class="headerlink" title="malloc流程"></a>malloc流程</h3><hr><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/1678786338164.png" alt="malloc"></p><h3 id="free流程"><a href="#free流程" class="headerlink" title="free流程"></a>free流程</h3><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/1678786338155.png" alt="free"></p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="bins数组相关"><a href="#bins数组相关" class="headerlink" title="bins数组相关"></a>bins数组相关</h3><p>bins数组存在于malloc_state结构体中,它被定义为一个长度为254的数组,但我们都知道真正只有126个bin,及有效下标为[0,251] (多的那两个被浪费了)。</p><p>每个bins都是一个指针,在串联bin中起到了重要作用,同一个bin的fd指针和bk指针被存储在相邻位置(例如bins[0]为unsortedbin的fd指针bins[1]为unsortedbin的bk指针)。</p><p>但其实在讲解过程中我们更多提及的是bin的下标,实际上bin数组是一个更抽象的概念，它实际<strong>并不存在</strong>,但使用bin数组下标与对应各个bin的关系更为直接，因此被更多的使用。</p><p>bins下标[X]与bin下标[Y]的关系为:</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-17_203928.png" alt=""></p><p>这也就是为什么许多教程会说bin[0]和bin[127]不存在了,因为如果这样的话对应的bins下标就为-2和252,明显出错了。</p><p><strong>以上所述其实我也不是很确定，各种教程里面的要么语焉不详没头没尾，要么上下矛盾，我也只能根据源码以及一些比较靠谱的博客做出一种比较合理的解释</strong></p><p>我主要以这两个宏为根据,特别是第二个宏与我上面的公式对上了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION) ##这个只是smallbin的索引计算方式,但其他bin大差不差</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure><h2 id="重要宏解释"><a href="#重要宏解释" class="headerlink" title="重要宏解释"></a>重要宏解释</h2><p>看源码最让人头大的无非各种宏了(建议在vscode中阅读源码,能直接找到声明处。)这里记几个重要的宏,顺便做点解释。</p><h3 id="bin-at-m-i"><a href="#bin-at-m-i" class="headerlink" title="bin_at(m,i)"></a>bin_at(m,i)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure><p>其中offsetof (struct malloc_chunk, fd))是常数<strong>值为2</strong>,所需bin的表头与前两个bins数组元素被视为了一个malloc_chunk,也就是说最终的结果就是指向这个chunk的指针。</p><h3 id="first-b-与last-b"><a href="#first-b-与last-b" class="headerlink" title="first(b)与last(b)"></a>first(b)与last(b)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure><p>里面的b一般就是bin_at的返回结果,于是刚好指向所需bin的头和尾。</p><h3 id="unlink-AV-P-BK-FD"><a href="#unlink-AV-P-BK-FD" class="headerlink" title="unlink(AV, P, BK, FD)"></a>unlink(AV, P, BK, FD)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);      \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK;      \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD;      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))      \</span></span><br><span class="line"><span class="meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)      \</span></span><br><span class="line"><span class="meta">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      \</span></span><br><span class="line"><span class="meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                  &#125;      \</span></span><br><span class="line"><span class="meta">              &#125; <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">              &#125;      \</span></span><br><span class="line"><span class="meta">          &#125;      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure><p>这一大串全是根据实际申请大小转换相应bin数组下标的宏</p><h2 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h2><details class="folding-tag" green><summary> bins数组的双向链表是如何实现的[已解决] </summary>              <div class='content'>              <p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-16_231042.png" alt=""></p><p>从上图可以看到，每个small bin使用了bins array中的两个元素，以0、1、2、3四个元素为例，<strong><em>代码中把这部分空间强制转换成malloc_chunk类型</em></strong>，这样根据malloc_chunk数据结构的定义，3、4两个元素就对应了malloc_chunk中的fd、bk指针，它们作为第一个small bin的表头，分别用来指向forward和backward方向的malloc_chunk，如下图所示：</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-16_230420.png" alt=""></p>              </div>            </details><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>最后，堆的学习着实需要耐心，我本人就是中途无数次摆烂，还总是被各种细节困惑，但只要坚持总是能入门的，另外有时遇到不懂又搜不到的知识点，不妨问问chatgpt或newbing之类的ai，虽然基本十个错九个（主要是gpt，bing不懂的它不会瞎答），但总是能给个方向。</p>]]></content>
    
    
    <summary type="html">一个字：就TM让人头大</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="堆" scheme="https://ixout.github.io/tags/%E5%A0%86/"/>
    
    <category term="学习记录" scheme="https://ixout.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
