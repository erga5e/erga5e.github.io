<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ixout&#39;s blog</title>
  
  
  <link href="https://ixout.github.io/atom.xml" rel="self"/>
  
  <link href="https://ixout.github.io/"/>
  <updated>2023-03-16T15:13:56.419Z</updated>
  <id>https://ixout.github.io/</id>
  
  <author>
    <name>ixout</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>堆学习笔记</title>
    <link href="https://ixout.github.io/posts/8932/"/>
    <id>https://ixout.github.io/posts/8932/</id>
    <published>2023-03-02T14:31:03.000Z</published>
    <updated>2023-03-16T15:13:56.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近搭建博客花了不少时间，期间对堆的学习就搁置了，现在既然博客搭建完毕，就要利用起来了，刚好用来记录自己的堆学习过程</p><hr><h1 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>ctfwiki的内容讲的已经很细了，不过还是推荐看一看华庭大佬的<a href="https://pan.baidu.com/s/167Z3CHDEeP1dl3c2Ii0lXg?pwd=1234">glibc内存管理-ptmalloc2源码分析</a>,看了之后真的能有很多收获.</p><h2 id="堆是啥"><a href="#堆是啥" class="headerlink" title="堆是啥"></a>堆是啥</h2><blockquote><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。</p><p>堆管理器处于用户程序与内核中间，主要做以下工作</p><ul><li>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</li><li>管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li></ul><p>引自ctf—wiki</p></blockquote><p>数据结构中也有堆这么个东西，但与这个堆关系不大(大概)</p><h2 id="堆的组成"><a href="#堆的组成" class="headerlink" title="堆的组成"></a>堆的组成</h2><p>在Linux下，glibc的堆是由多个arena组成的，每个arena是一个线程专用的内存池，用于管理内存块的分配和释放。每个arena又由多个subheap组成，每个subheap是一段连续的内存区域，用于存储多个同样大小的内存块。在subheap内部，使用了多种数据结构和技术来管理不同大小的内存块，以提高内存分配和管理的效率。</p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><h3 id="malloc流程"><a href="#malloc流程" class="headerlink" title="malloc流程"></a>malloc流程</h3><hr><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/1678786338164.png" alt="malloc"></p><h3 id="free流程"><a href="#free流程" class="headerlink" title="free流程"></a>free流程</h3><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/1678786338155.png" alt="free"></p><h3 id="易混淆的从属关系"><a href="#易混淆的从属关系" class="headerlink" title="易混淆的从属关系"></a>易混淆的从属关系</h3><p>glibc的malloc源码中涉及三种数据结构：Arena、Heap、Chunk ，分别对应结构体malloc_state、heap_info、malloc_chunk 。</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-16_095156.png" alt="graph"></p><ul><li><strong>Thread - Arena</strong> ： 一个Arena对应多个线程Thread。即每个线程都有一个Arena，但是有可能多个线程共用一个Arena。每个Arena都包含一个malloc_state结构体，保存bins, top chunk, Last reminder chunk等信息。</li><li><strong>Arena - Heap</strong>：一个Arena可能拥有多个heap。Arena开始的时候只有一个heap，但是当这个heap的空间用尽时，就需要获取新的heap。(这里及以下的heap可以理解为subheap子堆)</li><li><strong>Heap - Chunk</strong>：一个Heap根据用户的请求会划分为多个chunk，每个chunk拥有自己的header - malloc_chunk。</li></ul><p>需要注意的是，<em>Main Arena只有一个heap，因此没有heap_info结构</em>。当main arena用尽空间后，会扩展当前的heap空间。此外，Main Arean的Arena header并不是heap segment的一部分，而作为全局变量储存在libc.so的数据段中。</p><p>下图是只有一个heap时，主线程和线程的堆结构示意图，左图是Main Arena，右图是Threa Arena。堆是从低地址向高地址增长的，可以看到每一个malloc_chunk上面都跟着一个chunk。同时Main Arena没有heap_info和malloc_state的结构。 </p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-16_095630.png" alt="graph"></p><p>下图是存在多个heap的thread Arena的情况。可以看到每一个heap都一个heap header（heap_info），但是只有最初的heap拥有arena header.</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-16_095644.png" alt="graph"></p><p>当线程申请内存时，就创建一个Arena。主线程有自己独立的Arena，叫做main arena，但不是每一个线程都有独立的Arena。</p><p>Arena的个数取决于cpu核的个数</p><p>For 32 bit systems:     Number of arena = 2 * number of cores + main arena </p><p>For 64 bit systems:     Number of arena = 8 * number of cores + main arena</p><h1 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h1><ul><li>fastbin的堆块结构与常规的chunk是完全一样，除了使用的是<strong>单链表</strong>。fastbin下chunk不合并.</li><li>bins数组的长度为254个指针，但真正只有126个bin（也就是有2个被浪费了），同一个bin链表的fd指针和bk指针在bins数组中是相邻的，每个bins数组元素都只占<strong>一个指针的长度</strong>，指向对应链表的头节点。每个bin所指向的链表可以被称为是一个freelist。在glibc中，free list是一个通用的术语，用来描述维护空闲块的一组数据结构。每个bin中维护的空闲块链表实际上就是一个free list的具体实现。</li><li>整个堆的实现是通过多个arena，arena可以被看作是堆的一种实现方式或者扩展，arena用于管理多个subheap（子堆，有时也被叫做heap）和对应的内存块，subheap是指从arena中分配出来的一部分内存，用于管理特定的内存分配。可以理解为subheap是arena的一部分，或者说是arena中的一个子分配器。</li><li>在glibc中，每个空闲内存块都是一个结构体。这个结构体在glibc的源码中被称为”mchunk”。堆管理时，指针指向的一般都是<strong>chunk的起始地址(即prev_size字段)</strong>。</li><li>在glibc中，每个arena都有自己的独立的bin数组，用于管理不同大小的内存块，以提高内存分配和回收的效率。</li><li>glibc中的arena加锁解锁操作使用的是pthread_mutex_t类型的互斥锁。每个arena都有自己的互斥锁，用于保护arena的共享资源，例如unsorted bin、small bin、large bin、fastbin等等。</li></ul><h1 id="一些困惑"><a href="#一些困惑" class="headerlink" title="一些困惑"></a>一些困惑</h1><details class="folding-tag" green><summary> bins数组的双向链表是如何实现的[已解决] </summary>              <div class='content'>              <p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-16_231042.png" alt=""></p><p>从上图可以看到，每个small bin使用了bins array中的两个元素，以0、1、2、3四个元素为例，代码中把这部分空间强制转换成malloc_chunk类型，这样根据malloc_chunk数据结构的定义，3、4两个元素就对应了malloc_chunk中的fd、bk指针，它们作为第一个small bin的表头，分别用来指向forward和backward方向的malloc_chunk，如下图所示：</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-16_230420.png" alt=""></p>              </div>            </details><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>最后，不得不说chatgpt确实是神器，许多难以理解的概念都可以问他，特别是一些搜索引擎搜不到的细节，虽然不一定对(<del>其实可以说是%90概率出错:(</del> ),但如果仔细甄别，二次询问之后，的的确确能够解决不少困惑。</p>]]></content>
    
    
    <summary type="html">一个字：就TM让人头大</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="堆" scheme="https://ixout.github.io/tags/%E5%A0%86/"/>
    
    <category term="学习记录" scheme="https://ixout.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
